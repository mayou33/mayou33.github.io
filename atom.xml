<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张天师</title>
  
  
  <link href="http://zhangyu.info/atom.xml" rel="self"/>
  
  <link href="http://zhangyu.info/"/>
  <updated>2022-04-23T14:44:26.103Z</updated>
  <id>http://zhangyu.info/</id>
  
  <author>
    <name>张天师</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为什么互联网大厂一边大规模裁员又一边招聘</title>
    <link href="http://zhangyu.info/2022/04/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E4%B8%80%E8%BE%B9%E5%A4%A7%E8%A7%84%E6%A8%A1%E8%A3%81%E5%91%98%E5%8F%88%E4%B8%80%E8%BE%B9%E6%8B%9B%E8%81%98/"/>
    <id>http://zhangyu.info/2022/04/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E4%B8%80%E8%BE%B9%E5%A4%A7%E8%A7%84%E6%A8%A1%E8%A3%81%E5%91%98%E5%8F%88%E4%B8%80%E8%BE%B9%E6%8B%9B%E8%81%98/</id>
    <published>2022-04-22T16:00:00.000Z</published>
    <updated>2022-04-23T14:44:26.103Z</updated>
    
    <content type="html"><![CDATA[<p>作者：东岳老师</p><p><a href="https://www.zhihu.com/people/tian-tian-quan-75-47">https://www.zhihu.com/people/tian-tian-quan-75-47</a></p><blockquote><p>真实在大厂工作过，十几年的互联网老兵告诉你事实。</p><p>大厂里面有很多的业务线，也有很多的部门，每个部门负责的都不一样，阿里不是只做淘宝，腾讯也不是只做微信，一个大厂有数百条业务线，有的赚钱，有的赔钱。但是通常赔钱的最多。</p><p>通常大厂是这样玩的:</p><p>上层领导看中了一个方向，比如说游戏是赚钱的，于是就大量开始招聘游戏岗位。</p><p>公司往这方面投钱，比如说一年投入1000万，然后制定一个目标，实现三年盈利。通过招聘，你顺利进入了他们的游戏业务线，成为大厂员工。</p><p>光环加顶，有些刚进入大厂的员工觉以为祖坟冒青烟了，但也可能冒黑烟。</p><p>因为公司业务线刚开辟，所以就大量招人，高层来赌这个业务三年后一定盈利。把人力，金钱，物力投入进去。至于高层哪来的那么大自信赌成功，说真的，他们也都是懵逼状态。</p><p><strong>高层之间也内卷，总裁副总裁一大批，负责的业务都不同。</strong></p><p>我在某厂做总监时，经常跟一些总裁开会讨论方案，他们真的啥也不懂。因为这群人年龄太大了，很多都是投资人，根本不懂互联网，都是瞎指挥。</p><p>懂互联网的也是极个别人，总裁眼里只有钱。其他都没有。各种不着调的想法每次和他们开完会恨不能摔门而去。</p><p>但你还得执行他们不靠谱的想法，谁让咱们是打工人。就算方案是屎也得给老板做出臭豆腐的口感。实现不了怎么办，假装很努力的加班啊，得让老板看到咱很努力的干啊。</p><p>高层画大饼不要紧，咱也得吃饭啊。</p><p>高层天天开会，传达给中层的就TM一句话，今年我们要实现十个亿的目标!</p><p>卧槽，毛线都没有呢，那怎么办，上有政策下有对策，中层也有办法，你们知道中层每天都在干什么吗，天天写PPT!天天给高层做实现十个亿目标的汇报，一次一次被打回重改，直到改到高层认为PPT可以真的能实现十个亿目标位置。</p><p>PPT是个好东西，不仅能造车，还能造梦!</p><p>很遗憾的是，高层和中层一本正经的搞了PPT很长时间，大家一致认为从PPT上面已经证明能够实现十个亿的目标。</p><p>但多数业务实际根本不可能像预想的那样盈利，PPT终究是PPT，当不能盈利时，这条业务线就会被砍掉，你经常发现大厂裁员是整条业务线从上到下全部被裁掉就是这个问题。</p><p>老板层总是有各种想法，每年都要想我要做什么，总之都是为了赚钱。</p><p>有的老板都是拍脑门，反正人家有钱，玩得起。瞎折腾怕什么，万一折腾成功了呢。就像有个人说的那样，梦想总是有的，万一实现了呢。</p><p>把钱往里面一投资，找一堆写手，做几篇新闻，搞几个概念，开始忽悠了。全都给我上，产品，技术，运营，招起来!上层要干什么事情呢，上层要拿着PPT去资本市场忽悠钱。</p><p>有一次和某个总裁喝酒，无意之间他说了一句话，我们不这样的话，股票就会跌的，我们只有这样做股票才能涨。</p><p>我忽然恍然大悟，其实他们根本不是做互联网的，他们就是一群在股市圈钱的人。是的，只要折腾起来，股民才会不断的被割韭菜。原来赔掉的钱可以通过股市赚回来!资本市场才是真正赚钱的地方。</p><p>互联网从诞生开始，就是靠资本一轮一轮融资的吹起来的，互联网公司本质就是投资公司，而高层就是投资人，靠着一个一个的故事融钱，用钱赚钱，而至于这个业务，他们并不关心能不能做成。他们只关心手里的股票能不能升值。</p><p>但是问题是，你不可能所有开辟的业务线都赔钱吧，股东也不是傻子啊，靠股市画大饼早晚会被做空。所以他们总得有点赚钱的业务啊。</p><p>十条业务线九条可能都赔钱，但有一条业务线赚钱就成功。公司高层都是赌徒心理，因为他们也没办法判断哪个业务能成功。多生几个孩子，总有一个孩子能成器吧。</p><p>不成器的孩子怎么办，放弃吧。然后继续生孩子，继续招人。大厂靠着自己的招牌不用担心招不到人，反正人人都想进大厂。</p><p>就算全都裁掉，照样能够招到。就算赔掉一个亿对大厂来说只不过是交学费而已。毕竟人家赚一个亿也就是小目标。</p><p>那问题在于，为什么他们不用原有的团队做呢，因为原有团队在高层看来就是败军之将，给你三年时间都没搞成你在高层眼里已经没有价值，不裁你才怪呢。老板看你不顺眼，他们眼中只有一个单词：loser!</p><p><strong>这类新闻屡见不鲜:</strong></p><p>字节跳动方面，本地生活和房产业务受到影响。去年10月，字节跳动本地生活被曝出从22个城市撤退，仅保留了北京、上海等几个城市。</p><p>字节跳动HR相关负责人回应媒体称，裁员信息属实，系公司正常业务调整。</p><p>大部分的公司都是公司业务正常调整，简单来说就是，这孩子不成器，赶出家门。</p><p><strong>那你说，我这条业务线搞成了，那总不会被裁吧。</strong></p><p>呵呵，你想的天真了，一条业务线搞成了照样裁掉一半，这叫<strong>组织人员优化</strong>，本身做这条业务线就需要大量人参与进来，就像你建一座桥，建设时候需要几千人，建完了只需要几十人维护就可以了。</p><p>那你说，我只要努力就不会被裁吧，呵呵，裁掉你和你努力不努力无关系，什么末尾淘汰制只不过是裁你的理由，制定一个规则，让员工内卷，因为员工内卷对企业最有好处。</p><p><strong>只有裁员，才能让员工感到危机。</strong></p><p>你虽然花费了大量时间精力，什么996啊，公司是不会看在眼里的，公司只看你成本太高了。</p><p>三十五岁为什么会被裁，你知道，你在一家公司干十年你的薪资得有多高，不给你加薪资你不满意，给你加薪资老板不满意，反正有的是人干活，这么高薪资不需要你了，就裁掉了。</p><p><strong>与你能力无关系。只和你成本有关系。</strong></p><p>在大厂的业务线，中层压力最大，因为裁员先把中层干掉。中层在公司的定位就是背锅的，中层一般都是总监或者级别副总裁级，负责承上启下，只要业务快玩完了，为了给公司交代，稳定军心，高层首先要把中层拿来祭旗了。</p><p>中层天天要逼着底层加班，也并不是真的很忙，因为他要做给高层看，让高层觉得他很努力，一定能成功。但是中层消息也很灵敏，见势不妙，没等裁员就脚底抹油提前跑路了。</p><p>跑之前中层这群老油条们还得给底层没有经验的职场小白PUA，兄弟们，挺住，困难只是暂时的。只要团结一心，一定可以的！</p><p>你会说中层难道不想要补偿吗？呵呵，你太小看中层了，在业务没有倒闭前另谋其主，还TM能吹牛皮一把说这业务做的很成功。</p><p>你看，离开我就倒闭了吧。真要耗到业务干倒闭了拿那个裁员补偿，对他们来说找工作都不好找。中层早就提前谋划好了出路，重要的人该走的都走光了。</p><p>多说句中层的话题，中层之间也经常在一起喝酒，不同的业务线之间也会互相交流经验，我参加过很多聚餐，喝酒前大家牛皮吹一波，我们做的是十个亿的大项目，这算什么，我们做的是一百亿的大项目。</p><p>你们说的都不是什么，我们定下目标一千亿。酒过三巡，真情流露，大家互相安慰，兄弟，早撤吧，我看透了，这活没希望。</p><p>等你有一天做了中层，就知道中层才是互联网公司最苦逼的，上面领导骂你，底下员工骂你，回家老婆骂你，辞职不敢，没有一边讨好。多少底层想要往上爬到中层，等你爬上去，就知道这哪是人生巅峰，是TM火山口!</p><p>上也上不去，下也下不来。每件事处理起来都是贼烫手。做中层久了就知道，有些事不能硬撑，关键时候跑路才是上上策，孙子兵法得作为案头书天天阅读，不然你怎么在这么复杂的环境中生存下去。</p><p>这就是你看到的类似新闻:</p><p><strong>某某大厂某事业部负责人离职，加入某某公司。</strong></p><p>但你看到这种消息后一般还不到裁员时候，因为裁员需要一个过程。</p><p>三个月后，轮到HR上场了，HR会在一夜之间发个通告，因某某原因，公司无法经营，宣布裁员，底层员工被打的措手不及!</p><p>前一天还在加班到凌晨十二点，这时候你忽然看到HR也在加班，你心里想，嗯，公司又开始招人了。</p><p>公司肯定发展越来越好了。其实人家加班是制定裁员名单呢，今天一上班就被告知裁员。没等你反应过来，整个部门都没有了。</p><p>HR才是互联网公司效率最高的职位!昨天，还许诺你加薪，今天你一脸懵逼的发呆，看着同事一个一个打包离开。</p><p>HR就告诉你一句话，今天必须走。按劳动合同，给你n+1补偿。其实发布裁员公告之前，所有准备都已经提前三个月准备好了。连给你n+1的钱都准备好了。</p><p>有的大厂裁员也很有情怀，临走还发给职场小白一个毕业证，<strong>同学!恭喜你在某厂顺利毕业了!</strong></p><p>呵呵，有的应届生刚入职第一天就毕业了，这速度真TM的快啊!给我的50万年薪呢？这么快就没了?咱好歹号称是大厂啊，别这样糊弄人行不？</p><p>这时候你看到的新闻就是:</p><p>某厂内部员工在某APP传闻裁员，整个事业部都被裁撤，未经官方证实。</p><p>于是一轮从招聘到裁员的过程就结束了，宣布一条不靠谱的业务线彻底消失，老板的大饼没有画成。</p><p>从项目立项，到招人，到投资扩建，到疯狂炒概念，再到负责人离职，内部传出裁员，公司证实属实。</p><p>众位朋友，等你经历互联网十年你就知道这种招聘裁员戏天天上演。只是大部分都没有爆出来而已。因为很多业务线都不起眼，还没有人知道就已经消亡了。</p><p>然后公司继续开辟新业务线，继续靠着大厂这个招牌白嫖打工者的青春，反正你不来是有别人来，我反正是给钱的，你不做还有别人做。真招不到人就开始画大饼，给应届生开高薪。</p><p>一毕业就来个年薪五十万，卧槽，我这工作十几年的都没一个应届生薪资高，你招他来做什么？</p><p>后来我明白，很多人都是凑数的。裁员的时候容易点。要招我这种老油条，连签合同我都得看三遍，敢裁我，分分钟给你讲劳动法。别TM忽悠我，罗翔的刑法讲义我天天看。</p><p>应届生就容易多了，签合同都不看一眼，裁你时候给你一个绩效不合格，他们还觉得自己没有尽全力，对不起公司。也不用n+1补偿，因为连n都没有。看起来薪资那么高，其实用工成本真的很廉价。很多都是做给外界看的。</p><p>其实很多人，不过是陪着高层赌未来，高层赌不对没关系，可以继续赌，毕竟人家不会担心自己被裁掉。本身高层眼里也没有员工，只有利益，员工自己堵不对，只能被裁了。</p><p>老板赌上的是钱，员工陪赌的是未来。老板赌输了钱，大不了再赌一把，员工赌没了未来，就真的啥也没有了。有的员工连命都赔赌进去了。</p><p>所谓某些互联网大厂，也不过是披着一层炫酷的外衣，进去也是996的工作。因为你得陪着老板赌这种不靠谱的未来。</p><p>只是，你人生需要做的是淡定！看庭前花开花落，云卷云舒，莫纠结！很多事情，对打工人来说都很无奈，最后苦的还是打工人。</p><p>你方唱罢我登场，今天他被裁，明天你被裁，也只是打工人的命运。与你能力高低真没关系。如果有关系，那你不过是个背锅侠而已。裁你，也只是杀鸡给猴看。</p><p>领导说，我们给社会每年输送一千人才。呵呵，确实是这样，陪你玩几年，你赚的盆满钵满，我们成了人才。两全其美，何乐不为呢。</p><p>我TM混了互联网十五年不是做人才就是走在做人才的路上!</p><p>青春就那么几年，你从小到大都是很优秀，拿着985的学历拼进大厂，恋爱都不敢谈，每天996的为公司奋斗，养着房东，养着这个城市，养着身体几十万亿的细胞。</p><p>不到三十岁的小伙子头发秃顶，肾虚无力，腰间盘突出，赌上了自己一切，用自己拼搏卷走了无数人，梦想有一天出人头地，你做好了最优秀的自己，无一刻休息，只为了明天更好，最后结局被裁了。最后如梦初醒，才知道自己是小丑。</p><p>真实，上面的话都不敢说，我敢说只因为我不在大厂干了，也不想再进去。就算封杀我也无所谓。我坚决反对拿员工前途做赌注的公司!</p><p>我要说这些话，也希望企业裁员慎重考虑!同时也希望企业不要盲目的招聘，因为真的很多同学因为你们的招聘赌上了未来。我不怕得罪那么多的大厂，我只希望彼此都真诚些，大家都是为了更好的未来。</p><p>我没有针对任何大厂，我只说一种现象，希望我写这些不会被封掉。</p><p>人生苦短，善待自己!</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作者：东岳老师&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/people/tian-tian-quan-75-47&quot;&gt;https://www.zhihu.com/people/tian-tian-quan-75-47&lt;/a&gt;&lt;/p&gt;
&lt;blo</summary>
      
    
    
    
    <category term="我假装讲，你假装看" scheme="http://zhangyu.info/categories/%E6%88%91%E5%81%87%E8%A3%85%E8%AE%B2%EF%BC%8C%E4%BD%A0%E5%81%87%E8%A3%85%E7%9C%8B/"/>
    
    
    <category term="我假装讲，你假装看" scheme="http://zhangyu.info/tags/%E6%88%91%E5%81%87%E8%A3%85%E8%AE%B2%EF%BC%8C%E4%BD%A0%E5%81%87%E8%A3%85%E7%9C%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux的CPU上下文切换深入探讨</title>
    <link href="http://zhangyu.info/2022/04/23/Linux%E7%9A%84CPU%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/"/>
    <id>http://zhangyu.info/2022/04/23/Linux%E7%9A%84CPU%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/</id>
    <published>2022-04-22T16:00:00.000Z</published>
    <updated>2022-04-23T14:19:54.448Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/3fJvAjgPmi6N8XUQ4QII4w">探讨 Linux CPU 的上下文切换</a></p><blockquote><p><em>链接：<a href="https://medium.com/geekculture/linux-cpu-context-switch-deep-dive-764bfdae4f01">https://medium.com/geekculture/linux-cpu-context-switch-deep-dive-764bfdae4f01</a></em></p></blockquote><blockquote><p>我们都知道 Linux 是一个多任务操作系统，它支持的任务同时运行的数量远远大于 CPU 的数量。当然，这些任务实际上并不是同时运行的（Single CPU），而是因为系统在短时间内将 CPU 轮流分配给任务，造成了多个任务同时运行的假象。</p><h2 id="CPU-上下文（CPU-Context）"><a href="#CPU-上下文（CPU-Context）" class="headerlink" title="CPU 上下文（CPU Context）"></a>CPU 上下文（CPU Context）</h2><p>在每个任务运行之前，CPU 需要知道在哪里加载和启动任务。这意味着系统需要提前帮助设置 CPU <strong>寄存器</strong>和<strong>程序计数器</strong>。</p><p>CPU 寄存器是内置于 CPU 中的小型但速度极快的内存。程序计数器用于存储 CPU 正在执行的或下一条要执行指令的位置。</p><p>它们都是 CPU 在运行任何任务之前必须依赖的依赖环境，因此也被称为 “CPU 上下文”。如下图所示：</p><p><img src="https://miro.medium.com/max/438/0*EGtuokcAbzA33aGb.png" alt="图片"></p><p>知道了 CPU 上下文是什么，我想你理解 <strong>CPU 上下文切换</strong>就很容易了。“CPU上下文切换”指的是先保存上一个任务的 CPU 上下文（CPU寄存器和程序计数器），然后将新任务的上下文加载到这些寄存器和程序计数器中，最后跳转到程序计数器。</p><p>这些保存的上下文存储在系统内核中，并在重新安排任务执行时再次加载。这确保了任务的原始状态不受影响，并且任务似乎在持续运行。</p><h2 id="CPU-上下文切换的类型"><a href="#CPU-上下文切换的类型" class="headerlink" title="CPU 上下文切换的类型"></a>CPU 上下文切换的类型</h2><p>你可能会说 CPU 上下文切换无非就是更新 CPU 寄存器和程序计数器值，而这些寄存器是为了快速运行任务而设计的，那为什么会影响 CPU 性能呢？</p><p>在回答这个问题之前，请问，你有没有想过这些“任务”是什么？你可能会说一个任务就是一个<strong>进程</strong>或者一个<strong>线程</strong>。是的，进程和线程正是最常见的任务，但除此之外，还有其他类型的任务。</p><p>别忘了<strong>硬件中断</strong>也是一个常见的任务，硬件触发信号，会引起中断处理程序的调用。</p><p>因此，CPU 上下文切换至少有三种不同的类型：</p><ul><li><p>  进程上下文切换</p></li><li><p>  线程上下文切换</p></li><li><p>  中断上下文切换</p></li></ul><p>让我们一一来看看。</p><h2 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h2><p>Linux 按照特权级别将进程的运行空间划分为内核空间和用户空间，分别对应下图中 <code>Ring 0</code> 和 <code>Ring 3</code> 的 CPU 特权级别的 。</p><ul><li><p>  <strong>内核空间</strong>（<code>Ring 0</code>）拥有最高权限，可以直接访问所有资源</p></li><li><p>  <strong>用户空间</strong>（<code>Ring 3</code>）只能访问受限资源，不能直接访问内存等硬件设备。它必须通过<strong>系统调用</strong>被<strong>陷入（trapped）</strong>内核中才能访问这些特权资源。</p></li></ul><p><img src="https://miro.medium.com/max/600/0*mLfZnFzGvTr3czV5" alt="图片"></p><p>从另一个角度看，一个进程既可以在用户空间也可以在内核空间运行。当一个进程在<strong>用户空间</strong>运行时，称为该进程的<strong>用户态</strong>，当它落入<strong>内核空间</strong>时，称为该进程的<strong>内核态</strong>。</p><p>从<strong>用户态</strong>到<strong>内核态</strong>的转换需要通过<strong>系统调用</strong>来完成。例如，当我们查看一个文件的内容时，我们需要以下系统调用：</p><ul><li><p>  <code>open()</code>：打开文件</p></li><li><p>  <code>read()</code>：读取文件的内容</p></li><li><p>  <code>write()</code>：将文件的内容写入到输出文件（包括标准输出）</p></li><li><p>  <code>close()</code>：关闭文件</p></li></ul><p>那么在上述系统调用过程中是否会发生 CPU 上下文切换呢？当然是的。</p><p>这需要先保存 CPU 寄存器中原来的用户态指令的位置。接下来，为了执行内核态的代码，需要将 CPU 寄存器更新到内核态指令的新位置。最后是跳转到内核态运行内核任务。</p><p>那么系统调用结束后，CPU 寄存器需要<strong>恢复</strong>原来保存的用户状态，然后切换到用户空间继续运行进程。</p><blockquote><p>因此，在一次系统调用的过程中，实际上有两次 CPU 上下文切换。</p></blockquote><p>但需要指出的是，系统调用进程不会涉及进程切换，也不会涉及虚拟内存等系统资源切换。这与我们通常所说的“进程上下文切换”不同。进程上下文切换是指从一个进程切换到另一个进程，而系统调用期间始终运行同一个进程</p><p>系统调用过程通常被称为<strong>特权模式切换</strong>，而不是<strong>上下文切换</strong>。但实际上，在系统调用过程中，CPU 的上下文切换也是不可避免的。</p><h3 id="进程上下文切换-vs-系统调用"><a href="#进程上下文切换-vs-系统调用" class="headerlink" title="进程上下文切换 vs 系统调用"></a>进程上下文切换 vs 系统调用</h3><p>那么进程上下文切换和系统调用有什么区别呢？首先，进程是由内核管理的，进程切换只能发生在内核态。因此，进程上下文不仅包括<strong>虚拟内存</strong>、<strong>栈</strong>和<strong>全局变量</strong>等用户空间资源，还包括<strong>内核栈</strong>和<strong>寄存器</strong>等内核空间的状态。</p><p>所以<strong>进程上下文切换</strong>比<strong>系统调用</strong>要多出一步：</p><blockquote><p>在保存当前进程的内核状态和 CPU 寄存器之前，需要保存进程的虚拟内存、栈等；并加载下一个进程的内核状态。</p></blockquote><p>根据 Tsuna 的测试报告，每次上下文切换需要几十纳秒至微秒的 CPU 时间。这个时间是相当可观的，尤其是在大量进程上下文切换的情况下，很容易导致 CPU 花费大量时间来保存和恢复寄存器、内核栈、虚拟内存等资源。这正是我们在上一篇文章中谈到的，一个导致平均负载上升的重要因素。</p><p>那么，该进程何时会被调度/切换到在 CPU 上运行？其实有很多场景，下面我为大家总结一下：</p><ul><li><p>  当一个进程的 CPU 时间片用完时，它会被系统<strong>挂起</strong>，并切换到其他等待 CPU 运行的进程。</p></li><li><p>  当系统资源不足（如内存不足）时，直到资源充足之前，进程无法运行。此时进程也会被<strong>挂起</strong>，系统会调度其他进程运行。</p></li><li><p>  当一个进程通过 <code>sleep</code> 函数自动<strong>挂起自己</strong>时，自然会被重新调度。</p></li><li><p>  当优先级较高的进程运行时，为了保证高优先级进程的运行，当前进程会被高优先级进程<strong>挂起运行</strong>。</p></li><li><p>  当发生硬件中断时，CPU 上的进程会被<strong>中断挂起</strong>，转而执行内核中的中断服务程序。</p></li></ul><p>了解这些场景是非常有必要的，因为一旦上下文切换出现性能问题，它们就是幕后杀手。</p><h2 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h2><p>线程和进程最大的区别在于，线程是<strong>任务调度</strong>的基本单位，而进程是<strong>资源获取</strong>的基本单位。</p><p>说白了，内核中所谓的任务调度，实际的调度对象是线程；而进程只为线程提供虚拟内存和全局变量等资源。所以，对于线程和进程，我们可以这样理解：</p><ul><li><p>  当一个进程只有一个线程时，可以认为一个进程等于一个线程</p></li><li><p>  当一个进程有多个线程时，这些线程共享相同的资源，例如虚拟内存和全局变量。</p></li><li><p>  此外，线程也有自己的私有数据，比如栈和寄存器，在上下文切换时也需要保存。</p></li></ul><p>这样，线程的上下文切换其实可以分为两种情况：</p><ul><li><p>  首先，前后两个线程属于不同的进程。此时，由于资源不共享，切换过程与进程上下文切换相同。</p></li><li><p>  其次，前后两个线程属于同一个进程。此时，由于虚拟内存是共享的，所以切换时虚拟内存的资源保持不变，只需要切换线程的私有数据、寄存器等未共享的数据。</p></li></ul><p>显然，同一个进程内的线程切换比切换多个进程消耗的资源要少。这也是多线程替代多进程的优势。</p><h2 id="中断上下文切换"><a href="#中断上下文切换" class="headerlink" title="中断上下文切换"></a>中断上下文切换</h2><p>除了前面两种上下文切换之外，还有另外一种场景也输出 CPU 上下文切换的，那就是<strong>中断</strong>。</p><p>为了快速响应事件，硬件中断会中断正常的调度和执行过程，进而调用<strong>中断处理程序</strong>。</p><p>在中断其他进程时，需要保存进程的当前状态，以便中断后进程仍能从原始状态恢复。</p><p>与进程上下文不同，中断上下文切换不涉及进程的用户态。因此，即使中断进程中断了处于用户态的进程，也不需要保存和恢复进程的虚拟内存、全局变量等用户态资源。</p><p>另外，和进程上下文切换一样，中断上下文切换也会消耗 CPU。过多的切换次数会消耗大量的 CPU 资源，甚至严重降低系统的整体性能。因此，当您发现中断过多时，需要注意排查它是否会对您的系统造成严重的性能问题。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>综上所述，无论哪种场景导致上下文切换，你都应该知道：</p><p>CPU 上下文切换是保证 Linux 系统正常运行的核心功能之一，一般不需要我们特别关注。</p><p>但是过多的上下文切换会消耗 CPU 的时间来保存和恢复寄存器、内核栈、虚拟内存等数据，从而缩短进程的实际运行时间，导致系统整体性能显着下降。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/3fJvAjgPmi6N8XUQ4QII4w&quot;&gt;探讨 Linux CPU 的上下文切换&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;链接：&lt;a href=&quot;https://medium.co</summary>
      
    
    
    
    <category term="linux" scheme="http://zhangyu.info/categories/linux/"/>
    
    
    <category term="linux" scheme="http://zhangyu.info/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>微服务架构及设计模式</title>
    <link href="http://zhangyu.info/2022/04/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zhangyu.info/2022/04/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-04-22T16:00:00.000Z</published>
    <updated>2022-04-23T14:12:56.733Z</updated>
    
    <content type="html"><![CDATA[<p> <a href="https://colstuwjx.github.io/2020/01/%E7%BF%BB%E8%AF%91-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">https://colstuwjx.github.io/2020/01/%E7%BF%BB%E8%AF%91-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</a></p><p>原文：<a href="https://medium.com/@madhukaudantha/microservice-architecture-and-design-patterns-for-microservices-e0e5013fd58a">https://medium.com/@madhukaudantha/microservice-architecture-and-design-patterns-for-microservices-e0e5013fd58a</a></p><blockquote><p>本文介绍了主流常见的微服务模式。</p><p>微服务能够对企业产生积极影响。因此，了解如何处理微服务架构（MSA）以及一些微服务设计模式，一个微服务架构的一些通用目标或者设计原则是很有价值的。下面是在微服务架构方案中值得考虑的四个目标[1]。</p><p>1、缩减成本：MSA将会降低设计、实现和维护IT服务的总体成本</p><p>2、加快发布速度：MSA将会加快服务从想法到部署的落地速度</p><p>3、增强弹性：MSA将会提升我们服务网络的弹性</p><p>4、开启可见性：MSA支持为服务和网络提供更好的可见性</p><p>你需要了解建设微服务架构背后的几个设计原则：</p><ul><li>  可扩展性</li><li>  可用性</li><li>  韧性</li><li>  灵活性</li><li>  独立自主性，自治性</li><li>  去中心化治理</li><li>  故障隔离</li><li>  自动装配</li><li>  通过 DevOps 持续交付</li></ul><p>听取上述原则，在你实施的解决方案或系统付诸实践的同时，这也会带来一些挑战和问题。这些问题在许多解决方案中也很常见。使用正确及匹配的设计模式可以克服这些问题。微服务有一些设计模式，这可以大体分为五类。每类都包含许多具体的设计模式。下图展示了这些设计模式。</p><p><img src="https://colstuwjx.github.io/images/2019/Dec/design-patterns.png" alt="Design Patterns for Microservices"></p><p><em>图1 微服务设计模式</em></p><h2 id="分解模式"><a href="#分解模式" class="headerlink" title="分解模式"></a>分解模式</h2><h3 id="按业务功能进行分解"><a href="#按业务功能进行分解" class="headerlink" title="按业务功能进行分解"></a>按业务功能进行分解</h3><p>说白了，微服务就是要应用单一职责原则，把服务改造成松耦合式的。它可以按照业务功能进行分解。定义和业务功能相对应的服务。业务功能是一个来自业务架构建模 [2] 的概念。它是一个企业为了创造价值而要去做的某些事情。一个业务功能往往对应于一个业务对象，比如：</p><ul><li>  订单管理负责订单</li><li>  客户管理则是负责客户</li></ul><h3 id="按问题子域进行分解"><a href="#按问题子域进行分解" class="headerlink" title="按问题子域进行分解"></a>按问题子域进行分解</h3><p>按照业务功能来分解一个应用程序可能会是一个不错的开始，但是你终将会遇到所谓的“神类”，它很难再被分解。这些类将在多个服务之间都是通用的。可以定义一些和领域驱动设计（DDD）里面的子域相对应的服务。DDD 把应用程序的问题空间 —— 也即是业务 —— 称之为域。一个域由多个子域组成。每个子域对应业务的各个不同部分。</p><p>子域可以分为如下几类：</p><ul><li><p>  核心 —— 业务的核心竞争力以及应用程序最有价值的部分</p></li><li><p>  支撑 —— 和业务有关但并不是一个核心竞争力。这些可以在内部实现也可以外包</p></li><li><p>  通用 —— 不特定于业务，而且在理想情况下可以使用现成的软件实现</p></li></ul><p>一个订单管理的子域包括：</p><ul><li><p>  产品目录服务</p></li><li><p>  库存管理服务</p></li><li><p>  订单管理服务</p></li><li><p>  配送管理服务</p></li></ul><h3 id="按事务-两阶段提交（2pc）模式进行分解"><a href="#按事务-两阶段提交（2pc）模式进行分解" class="headerlink" title="按事务/两阶段提交（2pc）模式进行分解"></a>按事务/两阶段提交（2pc）模式进行分解</h3><p>你可以通过事务分解服务。然后，这样一来系统里将会存在多个事务。事务处理协调器[3]是分布式事务处理的重要参与者之一。分布式事务包括两个步骤：</p><ul><li><p>  准备阶段 —— 在这个阶段，事务的所有参与者都准备提交并通知协调员他们已准备好完成事务</p></li><li><p>  提交或回滚阶段 —— 在这个阶段，事务协调器向所有参与者发出提交或回滚命令</p></li></ul><p>2PC 的问题在于，和单个微服务的运行时间相比，它显得相当慢。即便这些微服务跑在相同的网络里，它们之间的事务协调也确实会减慢系统速度，因此这种方法通常不适用于高负载情况。</p><h3 id="绞杀者模式（Strangler-Pattern）"><a href="#绞杀者模式（Strangler-Pattern）" class="headerlink" title="绞杀者模式（Strangler Pattern）"></a>绞杀者模式（Strangler Pattern）</h3><p>上面三种，我们看到的这几个设计模式都是用来分解绿场（Greenfield）的应用程序，但是往往我们所做的工作中有 80％ 是针对灰场（brownfield）应用程序，它们是一些大型的单体应用程序（历史遗留的代码库）。绞杀者模式可以解决这类问题。它会创建两个单独的应用程序，它们并排跑在同一个 URI 空间里。随着时间的流逝，直到最后，新重构的应用程序会“干掉”或替换原有的应用程序，此时就可以关掉那个老的单体应用程序。绞杀应用程序的步骤分别是转换，共存和消除[4]：</p><ul><li><p>  转换（Transform） —— 使用现代方法创建一个并行的全新站点。</p></li><li><p>  共存（Coexist） —— 让现有站点保留一段时间。把针对现有站点的访问重定向到新站点，以便逐步实现所需功能。</p></li><li><p>  消除（Eliminate） —— 从现有站点中删除旧功能。</p></li></ul><h3 id="隔舱模式（Bulkhead-Pattern）"><a href="#隔舱模式（Bulkhead-Pattern）" class="headerlink" title="隔舱模式（Bulkhead Pattern）"></a>隔舱模式（Bulkhead Pattern）</h3><p>让一个应用程序的元素和池子相对隔离，这样一来，其他应用程序将可以继续正常工作。这种模式被称为“隔舱”，因为它类似于船体的分段分区。根据使用者负载和可用性要求，将服务实例分成不同的组。这种设计有助于隔离故障，并允许用户即使在故障期间仍可为某些使用者维持服务。</p><h3 id="边车模式"><a href="#边车模式" class="headerlink" title="边车模式"></a>边车模式</h3><p>该模式将一个应用程序的组件部署到一个单独的处理器容器里以提供隔离和封装。它还允许应用程序由异构的组件和技术组成。这种模式被称为边车模式（Sidecar），因为它类似于连接到摩托车的侧边车。在该模式中，侧边车会附加到父应用程序，并为该应用程序提供功能支持。Sidecar 还与父应用程序共享相同的生命周期，并与父应用程序一起创建和退出。Sidecar 模式有时也称为 sidekick 模式，这是我们在文章中列出的最后一个分解模式。</p><h2 id="集成模式"><a href="#集成模式" class="headerlink" title="集成模式"></a>集成模式</h2><h3 id="API-网关模式"><a href="#API-网关模式" class="headerlink" title="API 网关模式"></a>API 网关模式</h3><p>当一个应用程序被分解成多个较小的微服务时，这里会出现一些需要解决的问题：</p><ul><li><p>  存在不同渠道对多个微服务的多次调用</p></li><li><p>  需要处理不同类型的协议</p></li><li><p>  不同的消费者可能需要不同的响应格式</p></li></ul><p>API 网关有助于解决微服务实现引发的诸多问题，而不仅限于上述提到的这些。</p><ul><li><p>  API 网关是任何微服务调用的单一入口点</p></li><li><p>  它可以用作将请求路由到相关微服务的代理服务</p></li><li><p>  它可以汇总结果并发送回消费者</p></li><li><p>  该解决方案可以为每种特定类型的客户端创建一个细粒度的 API</p></li><li><p>  它还可以转换协议请求并做出响应</p></li><li><p>  它也可以承担微服务的身份验证/授权的责任。</p></li></ul><h3 id="聚合器模式（Aggregator-Pattern）"><a href="#聚合器模式（Aggregator-Pattern）" class="headerlink" title="聚合器模式（Aggregator Pattern）"></a>聚合器模式（Aggregator Pattern）</h3><p>将业务功能分解成几个较小的逻辑代码段后就有必要考虑如何协同每个服务返回的数据。不能把这个职责留给消费者。</p><p>聚合器模式有助于解决这个问题。<strong>它讨论了如何聚合来自不同服务的数据，然后将最终响应发送给消费者。</strong>这里有两种实现方式[6]：</p><p>1、一个组合微服务将调用所有必需的微服务，合并数据，然后在发送回数据之前对其进行转换合成</p><p>2、一个 API 网关还可以将请求划分成多个微服务，然后在将数据发送给使用者之前汇总数据</p><p>如果要应用一些业务逻辑的话，建议选择一个组合式的微服务。除此之外，API 网关作为这个问题的解决方案已经是既定的事实标准。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>针对 API 网关，我们只是借助它来对外公开我们的微服务。引入 API 网关后，我们得以获得一些像安全性和对 API 进行分类这样的 API 层面功能。在这个例子里，API 网关有三个 API 模块：</p><p>1、移动端 API，它实现了 FTGO 移动客户端的 API 2、浏览器端 API，它实现了在浏览器里运行的 JavaScript 应用程序的 API 3、公共API，它实现了一些第三方开发人员需要的 API</p><h3 id="网关路由模式"><a href="#网关路由模式" class="headerlink" title="网关路由模式"></a>网关路由模式</h3><p>API 网关负责路由请求。一个 API 网关通过将请求路由到相应的服务来实现一些 API 操作。当 API 网关接收到请求时，它会查询一个路由映射，该路由映射指定了将请求路由到哪个服务。一个路由映射可以将一个 HTTP 方法和路径映射到服务的 HTTP URL。这种做法和像 NGINX 这样的 Web 服务器提供的反向代理功能一样。</p><h3 id="链式微服务模式（Chained-Microservice-Pattern）"><a href="#链式微服务模式（Chained-Microservice-Pattern）" class="headerlink" title="链式微服务模式（Chained Microservice Pattern）"></a>链式微服务模式（Chained Microservice Pattern）</h3><p>单个服务或者微服务将会有多级依赖，举个例子：Sale 的微服务依赖 Product 微服务和 Order 微服务。链式微服务设计模式将帮助你提供合并后的请求结果。microservice-1 接收到请求后，该请求随后与 microservice-2 进行通信，还有可能正在和 microservice-3 通信。所有这些服务都是同步调用。</p><h3 id="分支模式"><a href="#分支模式" class="headerlink" title="分支模式"></a>分支模式</h3><p>一个微服务可能需要从包括其他微服务在内的多个来源获取数据。分支微服务模式是聚合器和链式设计模式的混合，并允许来自两个或多个微服务的同时请求/响应处理。调用的微服务可以是一个微服务链。分支模式还可用于根据你的业务需求调用不同的微服务链或单个链。</p><h3 id="客户端UI组合模式"><a href="#客户端UI组合模式" class="headerlink" title="客户端UI组合模式"></a>客户端UI组合模式</h3><p>通过分解业务功能/子域来开发服务时，负责用户体验的服务必须从多个微服务中提取数据。在一个单体世界里，过去只有一个从 UI 到后端服务的调用，它会检索所有数据然后刷新/提交 UI 页面。但是，现在不一样了。对于微服务而言，我们必须把 UI 设计成一个具有屏幕/页面的多个板块/区域的框架。每个板块都将调用一个单独的后端微服务以提取数据。诸如 AngularJS 和 ReactJS 之类的框架可以帮助我们轻松地实现这一点。这些屏幕称为单页应用程序（SPA）。每个团队都开发一个客户端 UI 组件，比如一个 AngularJS 指令，该组件实现其服务的页面/屏幕区域。UI 团队负责通过组合多个特定服务的 UI 组件来实现构建页面/屏幕的页面框架。</p><h2 id="数据库模式"><a href="#数据库模式" class="headerlink" title="数据库模式"></a>数据库模式</h2><p>给微服务定义数据库架构时，我们需要考虑以下几点：</p><p>1、服务必须是松耦合的。这样它们可以独立开发，部署和扩展</p><p>2、业务事务可能会强制跨越多个服务的不变量</p><p>3、一些业务事务需要查询多个服务的数据</p><p>4、为了可扩展性考虑，数据库有时候必须是可复制和共享的</p><p>5、不同服务存在不同的数据存储要求</p><h3 id="每个服务一套数据库"><a href="#每个服务一套数据库" class="headerlink" title="每个服务一套数据库"></a>每个服务一套数据库</h3><p>为了解决上述问题，必须为每个微服务设计一个数据库。它必须仅专用于该服务。应当只能通过微服务的 API 访问它。其他服务无法直接访问它。比如，针对关系型数据库，我们可以采用每个服务使用单独的专用表（private-tables-per-service），每个服务单独的数据库模式（schema-per-service）或每个服务单独的数据库服务器（database-server-per-service）。</p><h3 id="服务之间共享数据库"><a href="#服务之间共享数据库" class="headerlink" title="服务之间共享数据库"></a>服务之间共享数据库</h3><p>我们已经说过，在微服务里，为每个服务分配一套单独的数据库是理想方案。采用共享数据库在微服务里属于反模式。但是，如果应用程序是一个单体应用而且试图拆分成微服务，那么反正规化就不那么容易了。在后面的阶段里，我们可以转到每个服务一套数据库的模式，直到我们完全做到了这一点。服务之间共享数据库并不理想，但是对于上述情况，它是一个切实可行的解决方案。大多数人认为这是微服务的反模式，但是对于灰场应用程序，这是将应用程序分解成更小逻辑部分的一个很好的开始。值得一提的是，这不应当应用于绿场应用程序。</p><h3 id="命令和查询职责分离-CQRS"><a href="#命令和查询职责分离-CQRS" class="headerlink" title="命令和查询职责分离 (CQRS)"></a>命令和查询职责分离 (CQRS)</h3><p>一旦实现了每个服务分配单独一套数据库（database-per-service），自然就会产生查询需求，这需要联合来自多个服务的数据。然而这是不可能的。CQRS 建议将应用程序分成两部分 —— 命令端和查询端。</p><ul><li><p>  命令端处理创建，更新和删除请求</p></li><li><p>  查询端通过使用物化视图来处理查询部分</p></li></ul><p>这通常会搭配事件驱动模式（event sourcing pattern）一起使用，一旦有任何数据更改便会创建对应的事件。通过订阅事件流，我们便可以让物化视图保持更新。</p><h3 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h3><p>绝大多数应用程序需要用到数据，典型的做法就是应用程序要维护当前状态。例如，在传统的创建，读取，更新和删除（CRUD）模型中，典型的数据流程是从存储中读取数据。它也包含了经常使用事务导致锁定数据的限制。</p><p>事件驱动模式[7]定义了一种方法，用于处理由一系列事件驱动的数据操作，每个事件都记录在一个 append-only 的存储中。应用程序代码向事件存储发送一系列事件，这些事件命令式的描述了对数据执行的每个操作，它们会被持久化到事件存储。每个事件代表一组数据更改（例如，AddedItemToOrder）。</p><p>这些事件将保留在充当记录系统的一个事件存储里。事件存储发布的事件的典型用途是在应用程序触发的一些动作更改实体时维护这些实体的物化视图，以及与外部系统集成。例如，一个系统可以维护一个用于填充 UI 部分所有客户订单的物化视图。当应用程序添加新订单，添加或删除订单中的项目以及添加运输信息时，描述这些更改的事件将会得到处理并用于更新物化视图。下图展示了该模式的一个概览。</p><p><img src="https://colstuwjx.github.io/images/2019/Dec/event-sourcing.png" alt="Event Sourcing Pattern"></p><p><em>图2 事件驱动模式[8]</em></p><h2 id="Saga模式"><a href="#Saga模式" class="headerlink" title="Saga模式"></a>Saga模式</h2><p>当每个服务都有它们自己的数据库，并且一个业务事务跨越多个服务时，我们该如何确保各个服务之间的数据一致性呢？ 每个请求都有一个补偿请求，它会在请求失败时执行。这可以通过两种方式实现：</p><ul><li>  编舞（Choreography） —— 在没有中央协调的情况下，每个服务都会生成并侦听另一个服务的事件，并决定是否应该采取措施。编舞是一种指定两个或多个参与方的方案。任何一方都无法控制对方的流程，或者对这些流程有任何可见性，无法协调他们的活动和流程以共享信息和值。当需要跨控制/可见性域进行协调时，请使用编舞的方式。参考一个简单场景，你可以把编舞看作和网络协议类似。它规定了各方之间可接受的请求和响应模式。</li></ul><p><img src="https://colstuwjx.github.io/images/2019/Dec/saga-pattern.png" alt="sage pattern"></p><p><em>图3 Saga模式 —— 编舞</em></p><ul><li>  编排（Orchestration） —— 一个编排器（对象）会负责 saga 的决策和业务逻辑排序。此时你可以控制流程中的所有参与者。当它们全部处于一个控制域时，你可以控制该活动的流程。当然，这通常是你被指派到一个拥有控制权的组织里制定业务流程。</li></ul><p><img src="https://colstuwjx.github.io/images/2019/Dec/saga-pattern-orchestration.png" alt="saga-pattern-orchestration"></p><p><em>图4 Saga模式 —— 编排</em></p><h2 id="可观测性模式"><a href="#可观测性模式" class="headerlink" title="可观测性模式"></a>可观测性模式</h2><h3 id="日志聚合"><a href="#日志聚合" class="headerlink" title="日志聚合"></a>日志聚合</h3><p>考虑一个应用程序包含多个服务的用例。请求通常跨越多个服务实例。每个服务实例均采用标准格式生成日志文件。我们需要一个集中式的日志记录服务，该服务可以汇总每个服务实例的日志。用户可以搜索和分析日志。他们可以配置在某些消息出现在日志中时触发告警。例如，PCF 就有日志聚合器，它在应用侧从 PCF 平台的每个组件（router、controller、diego等）收集日志。AWS Cloud Watch 也是这样做的。</p><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><p>当服务组合由于引入了微服务架构而增加时，保持对事务的监控就变得尤为关键了，如此一来就可以监控这些模式，而当有问题发生时便会发送告警。</p><p>此外，需要一个度量服务来收集有关单个操作的统计信息。它应当聚合一个应用服务的指标数据，它会用来报告和告警。这里有两种用于汇总指标的模型：</p><ul><li>  推送 —— 服务将指标推送到指标服务，例如 NewRelic，AppDynamics</li><li>  提取 —— 指标服务从服务中提取指标，例如 Prometheus</li></ul><h3 id="分布式链路追踪"><a href="#分布式链路追踪" class="headerlink" title="分布式链路追踪"></a>分布式链路追踪</h3><p>在微服务架构里，请求通常跨越多个服务。每个服务通过跨越多个服务执行一个或多个操作来处理请求。在排障时，有一个 Trace ID 是很有帮助的，我们可以端对端地跟踪一个请求。</p><p>解决方案便是引入一个事务ID。可以采用如下方式：</p><ul><li>  为每个外部请求分配一个唯一的外部请求ID</li><li>  将外部请求ID传递给处理该请求链路的所有服务</li><li>  在所有日志消息中加入该外部请求ID</li></ul><h3 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h3><p>实施微服务架构后，服务可能会出现启动了但是无法处理事务的情况。每个服务都需要有一个可用于检查应用程序运行状况的 API 端点，例如 /health。该 API 应该检查主机的状态，与其他服务/基础设施的连接以及任何其他特定的逻辑。</p><h2 id="横切关注点模式（Cross-Cutting-Concern-Patterns）"><a href="#横切关注点模式（Cross-Cutting-Concern-Patterns）" class="headerlink" title="横切关注点模式（Cross-Cutting Concern Patterns）"></a>横切关注点模式（Cross-Cutting Concern Patterns）</h2><h3 id="外部配置"><a href="#外部配置" class="headerlink" title="外部配置"></a>外部配置</h3><p>一个服务通常还会调用其他服务和数据库。对于dev，QA，UAT，Prod等每个环境而言，API 端点的 URL 或某些配置属性可能会有所不同。这些属性中的任何一个更改都可能需要重新构建和重新部署服务。</p><p>为避免代码修改，可以使用配置。把所有配置放到外面，包括端点 URL 和证书。应用程序应该在启动时或运行时加载它们。这些可以在启动时由应用程序访问，也可以在不重新启动服务器的情况下进行刷新。</p><h3 id="服务发现模式"><a href="#服务发现模式" class="headerlink" title="服务发现模式"></a>服务发现模式</h3><p>在微服务出现时，我们需要在调用服务方面解决一些问题。</p><p>借助容器技术，IP地址可以动态地分配给服务实例。每次地址更改时，消费端服务都会中断并且需要手动更改。</p><p>对于消费端服务来说，它们必须记住每个上游服务的 URL ，这就变成紧耦合了。</p><p>为此，需要创建一个服务注册中心，该注册表将保留每个生产者服务的元数据和每个服务的配置。服务实例在启动时应当注册到注册中心，而在关闭时应当注销。服务发现有两种类型：</p><ul><li>  客户端：例如：Netflix Eureka</li><li>  服务端：例如：AWS ALB</li></ul><p><img src="https://colstuwjx.github.io/images/2019/Dec/service-discovery.png" alt="service-discovery"></p><p><em>图5 服务发现[9]</em></p><h3 id="熔断器模式"><a href="#熔断器模式" class="headerlink" title="熔断器模式"></a>熔断器模式</h3><p>一个服务通常会通过调用其他服务来检索数据，而这时候下游服务可能已经挂了。这样的话，有两个问题：首先，请求将继续抵达挂了的服务，耗尽网络资源，并且降低性能。其次，用户体验将是糟糕且不可预测的。</p><p>消费端服务应通过代理来调用远程服务，该代理的表现和一个电流断路器类似。当连续的故障数超过阈值时，断路器将跳闸，并且在超时期间内，所有调用远程服务的尝试都会立即失败。超时到期后，断路器将允许有限数量的测试请求通过。如果这些请求成功，断路器则将恢复正常运行。否则，如果发生故障的话，超时时间则将再次重新开始计算。如果某些操作失败概率很高的话，采取此模式有助于防止应用程序在故障发生后仍然不断尝试调用远程服务或访问共享资源。</p><p><img src="https://colstuwjx.github.io/images/2019/Dec/circuit-breaker.png" alt="circuit-breaker"></p><p><em>图6 熔断器模式[10]</em></p><h3 id="蓝绿部署模式"><a href="#蓝绿部署模式" class="headerlink" title="蓝绿部署模式"></a>蓝绿部署模式</h3><p>使用微服务架构时，一个应用可以被拆分成许多个微服务。如果我们采用停止所有服务然后再部署改进版本的方式的话，宕机时间将是非常可观的，并且会影响业务。同样，回滚也将是一场噩梦。 蓝绿部署模式可以避免这种情况。</p><p>实施蓝绿部署策略可以用来减少或消除宕机。它通过运行两个相同的生产环境，Blue 和Green 来实现这一目标。 假设 Green 是现有的活动实例，Blue 是该应用程序的新版本。在任何时候，只有一个环境处于活动状态，该活动环境为所有生产流量提供服务。所有云平台均提供了用于实施蓝绿部署的选项。</p><p><img src="https://colstuwjx.github.io/images/2019/Dec/blue-green-deployment-pattern.png" alt="blue-green-deployment-pattern"></p><p><em>图7 蓝绿部署模式</em></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>[1] “Microservice Architecture: Aligning Principles, Practices, and Culture” Book by Irakli Nadareishvili, Matt McLarty, and Michael Amundsen</p><p>[2] <a href="https://microservices.io/patterns/decomposition/decompose-by-business-capability.html">https://microservices.io/patterns/decomposition/decompose-by-business-capability.html</a></p><p>[3] <a href="https://www.baeldung.com/transactions-across-microservices">https://www.baeldung.com/transactions-across-microservices</a></p><p>[4] <a href="https://developer.ibm.com/articles/cl-strangler-application-pattern-microservices-apps-trs/">https://developer.ibm.com/articles/cl-strangler-application-pattern-microservices-apps-trs/</a></p><p>[5] <a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/bulkhead">https://docs.microsoft.com/en-us/azure/architecture/patterns/bulkhead</a></p><p>[6] <a href="https://dzone.com/articles/design-patterns-for-microservices">https://dzone.com/articles/design-patterns-for-microservices</a></p><p>[7] <a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs#event-sourcing-and-cqrs">https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs#event-sourcing-and-cqrs</a></p><p>[8] <a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing">https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing</a></p><p>[9] <a href="https://www.dineshonjava.com/microservices-with-spring-boot/">https://www.dineshonjava.com/microservices-with-spring-boot/</a></p><p>[10] <a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/circuit-breaker">https://docs.microsoft.com/en-us/azure/architecture/patterns/circuit-breaker</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;a href=&quot;https://colstuwjx.github.io/2020/01/%E7%BF%BB%E8%AF%91-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1</summary>
      
    
    
    
    <category term="架构" scheme="http://zhangyu.info/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="架构" scheme="http://zhangyu.info/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>打造一套客户端功能最全的APM监控系统</title>
    <link href="http://zhangyu.info/2022/04/23/%E6%89%93%E9%80%A0%E4%B8%80%E5%A5%97%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8A%9F%E8%83%BD%E6%9C%80%E5%85%A8%E7%9A%84APM%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/"/>
    <id>http://zhangyu.info/2022/04/23/%E6%89%93%E9%80%A0%E4%B8%80%E5%A5%97%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8A%9F%E8%83%BD%E6%9C%80%E5%85%A8%E7%9A%84APM%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-04-22T16:00:00.000Z</published>
    <updated>2022-04-23T14:24:50.485Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="打造一套客户端功能最全的-APM-监控系统"><a href="#打造一套客户端功能最全的-APM-监控系统" class="headerlink" title="打造一套客户端功能最全的 APM 监控系统"></a><a href="https://segmentfault.com/a/1190000040277799">打造一套客户端功能最全的 APM 监控系统</a></h1><p> <strong>杭城小刘</strong> 发布于 2021-07-02</p><blockquote><p>APM 是 Application Performance Monitoring 的缩写，监视和管理软件应用程序的性能和可用性。应用性能管理对一个应用的持续稳定运行至关重要。所以这篇文章就从一个 iOS App 的性能管理的纬度谈谈如何精确监控以及数据如何上报等技术点</p></blockquote><p>App 的性能问题是影响用户体验的重要因素之一。性能问题主要包含：Crash、网络请求错误或者超时、UI 响应速度慢、主线程卡顿、CPU 和内存使用率高、耗电量大等等。大多数的问题原因在于开发者错误地使用了线程锁、系统函数、编程规范问题、数据结构等等。解决问题的关键在于尽早的发现和定位问题。</p><p>本篇文章着重总结了 APM 的原因以及如何收集数据。APM 数据收集后结合数据上报机制，按照一定策略上传数据到服务端。服务端消费这些信息并产出报告。请结合<a href="https://link.segmentfault.com/?enc=3WWrfendOrHHUYaFUFmEWQ==.gXyR2KjStFj13n8ud2G51sMBu7j/K1MBzaJfRUnJZV1p11+6W2vj1HjCb0fDrYc3Kao0BOufcvbrp+SvLAUkl0nxS4839kyL6sa8Y1fPC9gGbVJXVBqa4xwWlJl+Gmla">姊妹篇</a>， 总结了如何打造一款灵活可配置、功能强大的数据上报组件。</p><h2 id="一、卡顿监控"><a href="#一、卡顿监控" class="headerlink" title="一、卡顿监控"></a>一、卡顿监控</h2><p>卡顿问题，就是在主线程上无法响应用户交互的问题。影响着用户的直接体验，所以针对 App 的卡顿监控是 APM 里面重要的一环。</p><p>FPS（frame per second）每秒钟的帧刷新次数，iPhone 手机以 60 为最佳，iPad 某些型号是 120，也是作为卡顿监控的一项参考参数，为什么说是参考参数？因为它不准确。先说说怎么获取到 FPS。CADisplayLink 是一个系统定时器，会以帧刷新频率一样的速率来刷新视图。 <code>[CADisplayLink displayLinkWithTarget:self selector:@selector(###:)]</code>。至于为什么不准我们来看看下面的示例代码</p><p>_displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(p_displayLinkTick:)];<br>[_displayLink setPaused:YES];<br>[_displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];</p><p>代码所示，CADisplayLink 对象是被添加到指定的 RunLoop 的某个 Mode 下。所以还是 CPU 层面的操作，卡顿的体验是整个图像渲染的结果：CPU + GPU。请继续往下看</p><h3 id="1-屏幕绘制原理"><a href="#1-屏幕绘制原理" class="headerlink" title="1. 屏幕绘制原理"></a>1. 屏幕绘制原理</h3><p><img src="https://segmentfault.com/img/bVbIOee"></p><p>讲讲老式的 CRT 显示器的原理。 CRT 电子枪按照上面方式，从上到下一行行扫描，扫面完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用硬件时钟产生一系列的定时信号。当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 HSync；当一帧画面绘制完成后，电子枪恢复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（Vertical synchronization），简称 VSync。显示器通常以固定的频率进行刷新，这个固定的刷新频率就是 VSync 信号产生的频率。虽然现在的显示器基本都是液晶显示屏，但是原理保持不变。</p><p><img src="https://segmentfault.com/img/bVbIOej"></p><p>通常，屏幕上一张画面的显示是由 CPU、GPU 和显示器是按照上图的方式协同工作的。CPU 根据工程师写的代码计算好需要现实的内容（比如视图创建、布局计算、图片解码、文本绘制等），然后把计算结果提交到 GPU，GPU 负责图层合成、纹理渲染，随后 GPU 将渲染结果提交到帧缓冲区。随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过数模转换传递给显示器显示。</p><p>在帧缓冲区只有一个的情况下，帧缓冲区的读取和刷新都存在效率问题，为了解决效率问题，显示系统会引入2个缓冲区，即双缓冲机制。在这种情况下，GPU 会预先渲染好一帧放入帧缓冲区，让视频控制器来读取，当下一帧渲染好后，GPU 直接把视频控制器的指针指向第二个缓冲区。提升了效率。</p><p>目前来看，双缓冲区提高了效率，但是带来了新的问题：当视频控制器还未读取完成时，即屏幕内容显示了部分，GPU 将新渲染好的一帧提交到另一个帧缓冲区并把视频控制器的指针指向新的帧缓冲区，视频控制器就会把新的一帧数据的下半段显示到屏幕上，造成画面撕裂的情况。</p><p>为了解决这个问题，GPU 通常有一个机制叫垂直同步信号（V-Sync），当开启垂直同步信号后，GPU 会等到视频控制器发送 V-Sync 信号后，才进行新的一帧的渲染和帧缓冲区的更新。这样的几个机制解决了画面撕裂的情况，也增加了画面流畅度。但需要更多的计算资源</p><p><img src="https://segmentfault.com/img/bVbIOes"></p><p>答疑</p><p>可能有些人会看到「当开启垂直同步信号后，GPU 会等到视频控制器发送 V-Sync 信号后，才进行新的一帧的渲染和帧缓冲区的更新」这里会想，GPU 收到 V-Sync 才进行新的一帧渲染和帧缓冲区的更新，那是不是双缓冲区就失去意义了？</p><p>设想一个显示器显示第一帧图像和第二帧图像的过程。首先在双缓冲区的情况下，GPU 首先渲染好一帧图像存入到帧缓冲区，然后让视频控制器的指针直接直接这个缓冲区，显示第一帧图像。第一帧图像的内容显示完成后，视频控制器发送 V-Sync 信号，GPU 收到 V-Sync 信号后渲染第二帧图像并将视频控制器的指针指向第二个帧缓冲区。</p><p><strong>看上去第二帧图像是在等第一帧显示后的视频控制器发送 V-Sync 信号。是吗？真是这样的吗？ 😭 想啥呢，当然不是。 🐷 不然双缓冲区就没有存在的意义了</strong></p><p>揭秘。请看下图</p><p><img src="https://segmentfault.com/img/bVbIOeK"></p><p>当第一次 V-Sync 信号到来时，先渲染好一帧图像放到帧缓冲区，但是不展示，当收到第二个 V-Sync 信号后读取第一次渲染好的结果（视频控制器的指针指向第一个帧缓冲区），并同时渲染新的一帧图像并将结果存入第二个帧缓冲区，等收到第三个 V-Sync 信号后，读取第二个帧缓冲区的内容（视频控制器的指针指向第二个帧缓冲区），并开始第三帧图像的渲染并送入第一个帧缓冲区，依次不断循环往复。</p><p>请查看资料，需要梯子：<a href="https://link.segmentfault.com/?enc=n8yMZ8IDSwKEkHK7UX9mew==.rwyqrHqcabnVtvC7qgQO21Sfn3W4WPZ1Y6CbA1wv6wtXtqZAywcg1uD9Y1SmX4ad3KutIqneRAmcP4CSbb1NbQ==">Multiple buffering</a></p><h3 id="2-卡顿产生的原因"><a href="#2-卡顿产生的原因" class="headerlink" title="2. 卡顿产生的原因"></a>2. 卡顿产生的原因</h3><p><img src="https://segmentfault.com/img/bVbIOeO"></p><p>VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容（视图创建、布局计算、图片解码、文本绘制等）。然后将计算的内容提交到 GPU，GPU 经过图层的变换、合成、渲染，随后 GPU 把渲染结果提交到帧缓冲区，等待下一次 VSync 信号到来再显示之前渲染好的结果。在垂直同步机制的情况下，如果在一个 VSync 时间周期内，CPU 或者 GPU 没有完成内容的提交，就会造成该帧的丢弃，等待下一次机会再显示，这时候屏幕上还是之前渲染的图像，所以这就是 CPU、GPU 层面界面卡顿的原因。</p><p>目前 iOS 设备有双缓存机制，也有三缓冲机制，Android 现在主流是三缓冲机制，在早期是单缓冲机制。<br><a href="https://link.segmentfault.com/?enc=yWtB/pBzC6C53LUBI/MRaA==.dtIZUu+rgO4kc9Kz1OM6fhoRFMNyKY+BUURmK4zHfeQpy9fES4w1t64pP1D3wATKgkkXQunwc71gQBONJgOH45koMcsMRQ5sc8dxbSdg81kFE0AkmutjrwopIhyMnJxE">iOS 三缓冲机制例子</a></p><p>CPU 和 GPU 资源消耗原因很多，比如对象的频繁创建、属性调整、文件读取、视图层级的调整、布局的计算（AutoLayout 视图个数多了就是线性方程求解难度变大）、图片解码（大图的读取优化）、图像绘制、文本渲染、数据库读取（多读还是多写乐观锁、悲观锁的场景）、锁的使用（举例：自旋锁使用不当会浪费 CPU）等方面。开发者根据自身经验寻找最优解（这里不是本文重点）。</p><h3 id="3-APM-如何监控卡顿并上报"><a href="#3-APM-如何监控卡顿并上报" class="headerlink" title="3. APM 如何监控卡顿并上报"></a>3. APM 如何监控卡顿并上报</h3><p>CADisplayLink 肯定不用了，这个 FPS 仅作为参考。一般来讲，卡顿的监测有2种方案：<strong>监听 RunLoop 状态回调、子线程 ping 主线程</strong></p><h4 id="3-1-RunLoop-状态监听的方式"><a href="#3-1-RunLoop-状态监听的方式" class="headerlink" title="3.1 RunLoop 状态监听的方式"></a>3.1 RunLoop 状态监听的方式</h4><p>RunLoop 负责监听输入源进行调度处理。比如网络、输入设备、周期性或者延迟事件、异步回调等。RunLoop 会接收2种类型的输入源：一种是来自另一个线程或者来自不同应用的异步消息（source0事件）、另一种是来自预定或者重复间隔的事件。</p><p>RunLoop 状态如下图<br><img src="https://segmentfault.com/img/bVbIOe3"></p><p>第一步：通知 Observers，RunLoop 要开始进入 loop，紧接着进入 loop</p><p>if (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry )<br>    // 通知 Observers: RunLoop 即将进入 loop<br>    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);<br>// 进入loop<br>result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</p><p>第二步：开启 do while 循环保活线程，通知 Observers，RunLoop 触发 Timer 回调、Source0 回调，接着执行被加入的 block</p><p> if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers)<br>    //  通知 Observers: RunLoop 即将触发 Timer 回调<br>    __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);<br>if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources)<br>    //  通知 Observers: RunLoop 即将触发 Source 回调<br>    __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);<br>// 执行被加入的block<br>__CFRunLoopDoBlocks(rl, rlm);</p><p>第三步：RunLoop 在触发 Source0 回调后，如果 Source1 是 ready 状态，就会跳转到 handle_msg 去处理消息。</p><p>//  如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息<br>if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) {<br>#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI<br>    msg = (mach_msg_header_t *)msg_buffer;</p><pre><code>if (\_\_CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg\_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123;    goto handle\_msg;&#125;</code></pre><p>#elif DEPLOYMENT_TARGET_WINDOWS<br>    if (__CFRunLoopWaitForMultipleObjects(NULL, &amp;dispatchPort, 0, 0, &amp;livePort, NULL)) {<br>        goto handle_msg;<br>    }<br>#endif<br>}</p><p>第四步：回调触发后，通知 Observers 即将进入休眠状态</p><p>Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);<br>// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)<br>if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);<br>    __CFRunLoopSetSleeping(rl);</p><p>第五步：进入休眠后，会等待 mach_port 消息，以便再次唤醒。只有以下4种情况才可以被再次唤醒。</p><ul><li><p>  基于 port 的 source 事件</p></li><li><p>  Timer 时间到</p></li><li><p>  RunLoop 超时</p></li><li><p>被调用者唤醒</p><p>  do {</p><pre><code>if (kCFUseCollectableAllocator) &#123;    // objc\_clear\_stack(0);    // &lt;rdar://problem/16393959&gt;    memset(msg\_buffer, 0, sizeof(msg\_buffer));&#125;msg = (mach\_msg\_header\_t \*)msg\_buffer;\_\_CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg\_buffer), &amp;livePort, poll ? 0 : TIMEOUT\_INFINITY, &amp;voucherState, &amp;voucherCopy);if (modeQueuePort != MACH\_PORT\_NULL &amp;&amp; livePort == modeQueuePort) &#123;    // Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.    while (\_dispatch\_runloop\_root\_queue\_perform\_4CF(rlm-&gt;\_queue));    if (rlm-&gt;\_timerFired) &#123;        // Leave livePort as the queue port, and service timers below        rlm-&gt;\_timerFired = false;        break;    &#125; else &#123;        if (msg &amp;&amp; msg != (mach\_msg\_header\_t \*)msg\_buffer) free(msg);    &#125;&#125; else &#123;    // Go ahead and leave the inner loop.    break;&#125;</code></pre><p>  } while (1);</p></li></ul><p>第六步：唤醒时通知 Observer，RunLoop 的线程刚刚被唤醒了</p><p>// 通知 Observers: RunLoop 的线程刚刚被唤醒了<br>if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);<br>    // 处理消息<br>    handle_msg:;<br>    __CFRunLoopSetIgnoreWakeUps(rl);</p><p>第七步：RunLoop 唤醒后，处理唤醒时收到的消息</p><ul><li><p>  如果是 Timer 时间到，则触发 Timer 的回调</p></li><li><p>  如果是 dispatch，则执行 block</p></li><li><p>如果是 source1 事件，则处理这个事件</p><p>  #if USE_MK_TIMER_TOO</p><pre><code>    // 如果一个 Timer 到时间了，触发这个Timer的回调    else if (rlm-&gt;\_timerPort != MACH\_PORT\_NULL &amp;&amp; livePort == rlm-&gt;\_timerPort) &#123;        CFRUNLOOP\_WAKEUP\_FOR\_TIMER();        // On Windows, we have observed an issue where the timer port is set before the time which we requested it to be set. For example, we set the fire time to be TSR 167646765860, but it is actually observed firing at TSR 167646764145, which is 1715 ticks early. The result is that, when \_\_CFRunLoopDoTimers checks to see if any of the run loop timers should be firing, it appears to be &#39;too early&#39; for the next timer, and no timers are handled.        // In this case, the timer port has been automatically reset (since it was returned from MsgWaitForMultipleObjectsEx), and if we do not re-arm it, then no timers will ever be serviced again unless something adjusts the timer list (e.g. adding or removing timers). The fix for the issue is to reset the timer here if CFRunLoopDoTimers did not handle a timer itself. 9308754        if (!\_\_CFRunLoopDoTimers(rl, rlm, mach\_absolute\_time())) &#123;            // Re-arm the next timer            \_\_CFArmNextTimerInMode(rlm, rl);        &#125;    &#125;</code></pre><p>  #endif</p><pre><code>    //  如果有dispatch到main\_queue的block，执行block    else if (livePort == dispatchPort) &#123;        CFRUNLOOP\_WAKEUP\_FOR\_DISPATCH();        \_\_CFRunLoopModeUnlock(rlm);        \_\_CFRunLoopUnlock(rl);        \_CFSetTSD(\_\_CFTSDKeyIsInGCDMainQ, (void \*)6, NULL);</code></pre><p>  #if DEPLOYMENT_TARGET_WINDOWS</p><pre><code>        void \*msg = 0;</code></pre><p>  #endif</p><pre><code>        \_\_CFRUNLOOP\_IS\_SERVICING\_THE\_MAIN\_DISPATCH\_QUEUE\_\_(msg);        \_CFSetTSD(\_\_CFTSDKeyIsInGCDMainQ, (void \*)0, NULL);        \_\_CFRunLoopLock(rl);        \_\_CFRunLoopModeLock(rlm);        sourceHandledThisLoop = true;        didDispatchPortLastTime = true;    &#125;    // 如果一个 Source1 (基于port) 发出事件了，处理这个事件    else &#123;        CFRUNLOOP\_WAKEUP\_FOR\_SOURCE();        // If we received a voucher from this mach\_msg, then put a copy of the new voucher into TSD. CFMachPortBoost will look in the TSD for the voucher. By using the value in the TSD we tie the CFMachPortBoost to this received mach\_msg explicitly without a chance for anything in between the two pieces of code to set the voucher again.        voucher\_t previousVoucher = \_CFSetTSD(\_\_CFTSDKeyMachMessageHasVoucher, (void \*)voucherCopy, os\_release);        CFRunLoopSourceRef rls = \_\_CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);        if (rls) &#123;</code></pre><p>  #if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</p><pre><code>    mach\_msg\_header\_t \*reply = NULL;    sourceHandledThisLoop = \_\_CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh\_size, &amp;reply) || sourceHandledThisLoop;    if (NULL != reply) &#123;        (void)mach\_msg(reply, MACH\_SEND\_MSG, reply-&gt;msgh\_size, 0, MACH\_PORT\_NULL, 0, MACH\_PORT\_NULL);        CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);    &#125;</code></pre><p>  #elif DEPLOYMENT_TARGET_WINDOWS</p><pre><code>            sourceHandledThisLoop = \_\_CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop;</code></pre><p>  #endif</p></li></ul><p>第八步：根据当前 RunLoop 状态判断是否需要进入下一个 loop。当被外部强制停止或者 loop 超时，就不继续下一个 loop，否则进入下一个 loop</p><p>if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) {<br>    // 进入loop时参数说处理完事件就返回<br>    retVal = kCFRunLoopRunHandledSource;<br>    } else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) {<br>        // 超出传入参数标记的超时时间了<br>        retVal = kCFRunLoopRunTimedOut;<br>} else if (__CFRunLoopIsStopped(rl)) {<br>        __CFRunLoopUnsetStopped(rl);<br>    // 被外部调用者强制停止了<br>    retVal = kCFRunLoopRunStopped;<br>} else if (rlm-&gt;_stopped) {<br>    rlm-&gt;_stopped = false;<br>    retVal = kCFRunLoopRunStopped;<br>} else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) {<br>    // source/timer一个都没有<br>    retVal = kCFRunLoopRunFinished;<br>}</p><p>完整且带有注释的 RunLoop 代码见<a href="https://link.segmentfault.com/?enc=4+ujjBH/lrpIClaiO1sgHw==.4NGPkCBCwzwCUKeUI03OiixGhpRfW7dcVkbAqhHmBXStW2/XOQRmaqukaiDaOHawZC/eLpoax5X2hEwn0gX1hDLwEn+JtBNB6BR5NNWgQt+A+gQ+qPNARMoQOkEZxrc2">此处</a>。 Source1 是 RunLoop 用来处理 Mach port 传来的系统事件的，Source0 是用来处理用户事件的。收到 Source1 的系统事件后本质还是调用 Source0 事件的处理函数。</p><p>RunLoop 6个状态</p><p>typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {<br>    kCFRunLoopEntry ,           // 进入 loop<br>    kCFRunLoopBeforeTimers ,    // 触发 Timer 回调<br>    kCFRunLoopBeforeSources ,   // 触发 Source0 回调<br>    kCFRunLoopBeforeWaiting ,   // 等待 mach_port 消息<br>    kCFRunLoopAfterWaiting ),   // 接收 mach_port 消息<br>    kCFRunLoopExit ,            // 退出 loop<br>    kCFRunLoopAllActivities     // loop 所有状态改变<br>}</p><p>RunLoop 在进入睡眠前的方法执行时间过长而导致无法进入睡眠，或者线程唤醒后接收消息时间过长而无法进入下一步，都会阻塞线程。如果是主线程，则表现为卡顿。</p><p>一旦发现进入睡眠前的 KCFRunLoopBeforeSources 状态，或者唤醒后 KCFRunLoopAfterWaiting，在设置的时间阈值内没有变化，则可判断为卡顿，此时 dump 堆栈信息，还原案发现场，进而解决卡顿问题。</p><p>开启一个子线程，不断进行循环监测是否卡顿了。在 n 次都超过卡顿阈值后则认为卡顿了。卡顿之后进行堆栈 dump 并上报（具有一定的机制，数据处理在下一 part 讲）。</p><p>WatchDog 在不同状态下具有不同的值。</p><ul><li>  启动（Launch）：20s</li><li>  恢复（Resume）：10s</li><li>  挂起（Suspend）：10s</li><li>  退出（Quit）：6s</li><li>  后台（Background）：3min（在 iOS7 之前可以申请 10min；之后改为 3min；可连续申请，最多到 10min）</li></ul><p>卡顿阈值的设置的依据是 WatchDog 的机制。APM 系统里面的阈值需要小于 WatchDog 的值，所以取值范围在 [1, 6] 之间，业界通常选择3秒。</p><p>通过 <code>long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)</code> 方法判断是否阻塞主线程，<code>Returns zero on success, or non-zero if the timeout occurred.</code> 返回非0则代表超时阻塞了主线程。</p><p><img src="https://segmentfault.com/img/bVbIOfh"></p><p>可能很多人纳闷 RunLoop 状态那么多，为什么选择 KCFRunLoopBeforeSources 和 KCFRunLoopAfterWaiting？因为大部分卡顿都是在 KCFRunLoopBeforeSources 和 KCFRunLoopAfterWaiting 之间。比如 Source0 类型的 App 内部事件等</p><p>Runloop 检测卡顿流程图如下：</p><p>关键代码如下：</p><p>// 设置Runloop observer的运行环境<br>CFRunLoopObserverContext context = {0, (__bridge void *)self, NULL, NULL};<br>// 创建Runloop observer对象<br>_observer = CFRunLoopObserverCreate(kCFAllocatorDefault,<br>                                    kCFRunLoopAllActivities,<br>                                    YES,<br>                                    0,<br>                                    &amp;runLoopObserverCallBack,<br>                                    &amp;context);<br>// 将新建的observer加入到当前thread的runloop<br>CFRunLoopAddObserver(CFRunLoopGetMain(), _observer, kCFRunLoopCommonModes);<br>// 创建信号<br>_semaphore = dispatch_semaphore_create(0);</p><p>__weak __typeof(self) weakSelf = self;<br>// 在子线程监控时长<br>dispatch_async(dispatch_get_global_queue(0, 0), ^{<br>    __strong __typeof(weakSelf) strongSelf = weakSelf;<br>    if (!strongSelf) {<br>        return;<br>    }<br>    while (YES) {<br>        if (strongSelf.isCancel) {<br>            return;<br>        }<br>        // N次卡顿超过阈值T记录为一次卡顿<br>        long semaphoreWait = dispatch_semaphore_wait(self-&gt;_semaphore, dispatch_time(DISPATCH_TIME_NOW, strongSelf.limitMillisecond * NSEC_PER_MSEC));<br>        if (semaphoreWait != 0) {<br>            if (self-&gt;_activity == kCFRunLoopBeforeSources || self-&gt;_activity == kCFRunLoopAfterWaiting) {<br>                if (++strongSelf.countTime &lt; strongSelf.standstillCount){<br>                    continue;<br>                }<br>                // 堆栈信息 dump 并结合数据上报机制，按照一定策略上传数据到服务器。堆栈 dump 会在下面讲解。数据上报会在 [打造功能强大、灵活可配置的数据上报组件](<a href="https://github.com/FantasticLBP/knowledge-kit/blob/master/Chapter1%20-%20iOS/1.80.md">https://github.com/FantasticLBP/knowledge-kit/blob/master/Chapter1%20-%20iOS/1.80.md</a>) 讲<br>            }<br>        }<br>        strongSelf.countTime = 0;<br>    }<br>});</p><h4 id="3-2-子线程-ping-主线程监听的方式"><a href="#3-2-子线程-ping-主线程监听的方式" class="headerlink" title="3.2 子线程 ping 主线程监听的方式"></a>3.2 子线程 ping 主线程监听的方式</h4><p>开启一个子线程，创建一个初始值为0的信号量、一个初始值为 YES 的布尔值类型标志位。将设置标志位为 NO 的任务派发到主线程中去，子线程休眠阈值时间，时间到后判断标志位是否被主线程成功（值为 NO），如果没成功则认为主线程发生了卡顿情况，此时 dump 堆栈信息并结合数据上报机制，按照一定策略上传数据到服务器。数据上报会在 <a href="https://link.segmentfault.com/?enc=G+IqmQf5jDS7gdx4HQe5Ew==.OVUGL5Uvtof2GzureH523kZYwMTZz2GbPR81pG19p0mRZXIykiXcGms40cL/DGFT5Omf/h7tJnKxxQjnWD3WYM6I3nn0rGiHbnHLVHJ0CirCtL20e85ritrJms7CsJxL">打造功能强大、灵活可配置的数据上报组件</a> 讲</p><p>while (self.isCancelled == NO) {<br>        @autoreleasepool {<br>            __block BOOL isMainThreadNoRespond = YES;<br>            dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</p><pre><code>        dispatch\_async(dispatch\_get\_main\_queue(), ^&#123;            isMainThreadNoRespond = NO;            dispatch\_semaphore\_signal(semaphore);        &#125;);        \[NSThread sleepForTimeInterval:self.threshold\];        if (isMainThreadNoRespond) &#123;            if (self.handlerBlock) &#123;                self.handlerBlock(); // 外部在 block 内部 dump 堆栈（下面会讲），数据上报            &#125;        &#125;        dispatch\_semaphore\_wait(semaphore, DISPATCH\_TIME\_FOREVER);    &#125;&#125;</code></pre><h3 id="4-堆栈-dump"><a href="#4-堆栈-dump" class="headerlink" title="4. 堆栈 dump"></a>4. 堆栈 dump</h3><p>方法堆栈的获取是一个麻烦事。理一下思路。<code>[NSThread callStackSymbols]</code> 可以获取当前线程的调用栈。但是当监控到卡顿发生，需要拿到主线程的堆栈信息就无能为力了。从任何线程回到主线程这条路走不通。先做个知识回顾。</p><p>在计算机科学中，调用堆栈是一种栈类型的数据结构，用于存储有关计算机程序的线程信息。这种栈也叫做执行堆栈、程序堆栈、控制堆栈、运行时堆栈、机器堆栈等。调用堆栈用于跟踪每个活动的子例程在完成执行后应该返回控制的点。</p><p>维基百科搜索到 “Call Stack” 的一张图和例子，如下<br><img src="https://segmentfault.com/img/bVbIOfu"><br>上图表示为一个栈。分为若干个栈帧（Frame），每个栈帧对应一个函数调用。下面蓝色部分表示 <code>DrawSquare</code> 函数，它在执行的过程中调用了 <code>DrawLine</code> 函数，用绿色部分表示。</p><p>可以看到栈帧由三部分组成：函数参数、返回地址、局部变量。比如在 DrawSquare 内部调用了 DrawLine 函数：第一先把 DrawLine 函数需要的参数入栈；第二把返回地址(控制信息。举例：函数 A 内调用函数 B，调用函数B 的下一行代码的地址就是返回地址)入栈；第三函数内部的局部变量也在该栈中存储。</p><p>栈指针 Stack Pointer 表示当前栈的顶部，大多部分操作系统都是栈向下生长，所以栈指针是最小值。帧指针 Frame Pointer 指向的地址中，存储了上一次 Stack Pointer 的值，也就是返回地址。</p><p>大多数操作系统中，每个栈帧还保存了上一个栈帧的帧指针。因此知道当前栈帧的 Stack Pointer 和 Frame Pointer 就可以不断回溯，递归获取栈底的帧。</p><p>接下来的步骤就是拿到所有线程的 Stack Pointer 和 Frame Pointer。然后不断回溯，还原案发现场。</p><h3 id="5-Mach-Task-知识"><a href="#5-Mach-Task-知识" class="headerlink" title="5. Mach Task 知识"></a>5. Mach Task 知识</h3><p><strong>Mach task:</strong></p><p>App 在运行的时候，会对应一个 Mach Task，而 Task 下可能有多条线程同时执行任务。《OS X and iOS Kernel Programming》 中描述 Mach Task 为：任务（Task）是一种容器对象，虚拟内存空间和其他资源都是通过这个容器对象管理的，这些资源包括设备和其他句柄。简单概括为：Mack task 是一个机器无关的 thread 的执行环境抽象。</p><p>作用： task 可以理解为一个进程，包含它的线程列表。</p><p>结构体：task_threads，将 target_task 任务下的所有线程保存在 act_list 数组中，数组个数为 act_listCnt</p><p>kern_return_t task_threads<br>(<br>  task_t traget_task,<br>  thread_act_array_t *act_list,                     //线程指针列表<br>  mach_msg_type_number_t *act_listCnt  //线程个数<br>)</p><p>thread_info:</p><p>kern_return_t thread_info<br>(<br>  thread_act_t target_act,<br>  thread_flavor_t flavor,<br>  thread_info_t thread_info_out,<br>  mach_msg_type_number_t *thread_info_outCnt<br>);</p><p>如何获取线程的堆栈数据：</p><p>系统方法 <code>kern_return_t task_threads(task_inspect_t target_task, thread_act_array_t *act_list, mach_msg_type_number_t *act_listCnt);</code> 可以获取到所有的线程，不过这种方法获取到的线程信息是最底层的 <strong>mach 线程</strong>。</p><p>对于每个线程，可以用 <code>kern_return_t thread_get_state(thread_act_t target_act, thread_state_flavor_t flavor, thread_state_t old_state, mach_msg_type_number_t *old_stateCnt);</code> 方法获取它的所有信息，信息填充在 <code>_STRUCT_MCONTEXT</code> 类型的参数中，这个方法中有2个参数随着 CPU 架构不同而不同。所以需要定义宏屏蔽不同 CPU 之间的区别。</p><p><code>_STRUCT_MCONTEXT</code> 结构体中，存储了当前线程的 Stack Pointer 和最顶部栈帧的 Frame pointer，进而回溯整个线程调用堆栈。</p><p>但是上述方法拿到的是内核线程，我们需要的信息是 NSThread，所以需要将内核线程转换为 NSThread。</p><p>pthread 的 p 是 <strong>POSIX</strong> 的缩写，表示「可移植操作系统接口」（Portable Operating System Interface）。设计初衷是每个系统都有自己独特的线程模型，且不同系统对于线程操作的 API 都不一样。所以 POSIX 的目的就是提供抽象的 pthread 以及相关 API。这些 API 在不同的操作系统中有不同的实现，但是完成的功能一致。</p><p>Unix 系统提供的 <code>task_threads</code> 和 <code>thread_get_state</code> 操作的都是内核系统，每个内核线程由 thread_t 类型的 id 唯一标识。pthread 的唯一标识是 pthread_t 类型。其中内核线程和 pthread 的转换（即 thread_t 和 pthread_t）很容易，因为 pthread 设计初衷就是「抽象内核线程」。</p><p><code>memorystatus_action_neededpthread_create</code> 方法创建线程的回调函数为 <strong>nsthreadLauncher</strong>。</p><p>static void *nsthreadLauncher(void* thread)<br>{<br>    NSThread *t = (NSThread*)thread;<br>    [nc postNotificationName: NSThreadDidStartNotification object:t userInfo: nil];<br>    [t _setName: [t name]];<br>    [t main];<br>    [NSThread exit];<br>    return NULL;<br>}</p><p>NSThreadDidStartNotification 其实就是字符串 @”_NSThreadDidStartNotification”。</p><p>&lt;NSThread: 0x…&gt;{number = 1, name = main}  </p><p>为了 NSThread 和内核线程对应起来，只能通过 name 一一对应。 pthread 的 API <code>pthread_getname_np</code> 也可获取内核线程名字。np 代表 not POSIX，所以不能跨平台使用。</p><p>思路概括为：将 NSThread 的原始名字存储起来，再将名字改为某个随机数（时间戳），然后遍历内核线程 pthread 的名字，名字匹配则 NSThread 和内核线程对应了起来。找到后将线程的名字还原成原本的名字。对于主线程，由于不能使用 <code>pthread_getname_np</code>，所以在当前代码的 load 方法中获取到 thread_t，然后匹配名字。</p><p>static mach_port_t main_thread_id;  </p><ul><li>(void)load {<br>  main_thread_id = mach_thread_self();<br>}</li></ul><h2 id="二、-App-启动时间监控"><a href="#二、-App-启动时间监控" class="headerlink" title="二、 App 启动时间监控"></a>二、 App 启动时间监控</h2><h3 id="1-App-启动时间的监控"><a href="#1-App-启动时间的监控" class="headerlink" title="1. App 启动时间的监控"></a>1. App 启动时间的监控</h3><p>应用启动时间是影响用户体验的重要因素之一，所以我们需要量化去衡量一个 App 的启动速度到底有多快。启动分为冷启动和热启动。<br><img src="https://segmentfault.com/img/bVbIOfD"></p><p>冷启动：App 尚未运行，必须加载并构建整个应用。完成应用的初始化。冷启动存在较大优化空间。冷启动时间从 <code>application: didFinishLaunchingWithOptions:</code> 方法开始计算，App 一般在这里进行各种 SDK 和 App 的基础初始化工作。</p><p>热启动：应用已经在后台运行（常见场景：比如用户使用 App 过程中点击 Home 键，再打开 App），由于某些事件将应用唤醒到前台，App 会在 <code>applicationWillEnterForeground:</code> 方法接受应用进入前台的事件</p><p>思路比较简单。如下</p><ul><li>  在监控类的 <code>load</code> 方法中先拿到当前的时间值</li><li>  监听 App 启动完成后的通知 <code>UIApplicationDidFinishLaunchingNotification</code></li><li>  收到通知后拿到当前的时间</li><li>  步骤1和3的时间差就是 App 启动时间。</li></ul><p><code>mach_absolute_time</code> 是一个 CPU/总线依赖函数，返回一个 CPU 时钟周期数。系统休眠时不会增加。是一个纳秒级别的数字。获取前后2个纳秒后需要转换到秒。需要基于系统时间的基准，通过 <code>mach_timebase_info</code> 获得。</p><p>mach_timebase_info_data_t g_apmmStartupMonitorTimebaseInfoData = 0;<br>mach_timebase_info(&amp;g_apmmStartupMonitorTimebaseInfoData);<br>uint64_t timelapse = mach_absolute_time() - g_apmmLoadTime;<br>double timeSpan = (timelapse * g_apmmStartupMonitorTimebaseInfoData.numer) / (g_apmmStartupMonitorTimebaseInfoData.denom * 1e9);</p><h3 id="2-线上监控启动时间就好，但是在开发阶段需要对启动时间做优化。"><a href="#2-线上监控启动时间就好，但是在开发阶段需要对启动时间做优化。" class="headerlink" title="2. 线上监控启动时间就好，但是在开发阶段需要对启动时间做优化。"></a>2. 线上监控启动时间就好，但是在开发阶段需要对启动时间做优化。</h3><p>要优化启动时间，就先得知道在启动阶段到底做了什么事情，针对现状作出方案。</p><p>pre-main 阶段定义为 App 开始启动到系统调用 main 函数这个阶段；main 阶段定义为 main 函数入口到主 UI 框架的 viewDidAppear。</p><p>App 启动过程：</p><ul><li>  解析 Info.plist：加载相关信息例如闪屏；沙盒建立、权限检查；</li><li>  Mach-O 加载：如果是胖二进制文件，寻找合适当前 CPU 架构的部分；加载所有依赖的 Mach-O 文件（递归调用 Mach-O 加载的方法）；定义内部、外部指针引用，例如字符串、函数等；加载分类中的方法；c++ 静态对象加载、调用 Objc 的 <code>+load()</code> 函数；执行声明为 __attribute_((constructor)) 的 c 函数；</li><li>  程序执行：调用 main()；调用 UIApplicationMain()；调用 applicationWillFinishLaunching()；</li></ul><p>Pre-Main 阶段<br><img src="https://segmentfault.com/img/bVbIOfI"></p><p>Main 阶段<br><img src="https://segmentfault.com/img/bVbIOfP"></p><h4 id="2-1-加载-Dylib"><a href="#2-1-加载-Dylib" class="headerlink" title="2.1 加载 Dylib"></a>2.1 加载 Dylib</h4><p>每个动态库的加载，dyld 需要</p><ul><li>  分析所依赖的动态库</li><li>  找到动态库的 Mach-O 文件</li><li>  打开文件</li><li>  验证文件</li><li>  在系统核心注册文件签名</li><li>  对动态库的每一个 segment 调用 mmap（）</li></ul><p>优化：</p><ul><li>  减少非系统库的依赖</li><li>  使用静态库而不是动态库</li><li>  合并非系统动态库为一个动态库</li></ul><h4 id="2-2-Rebase-amp-amp-Binding"><a href="#2-2-Rebase-amp-amp-Binding" class="headerlink" title="2.2 Rebase &amp;&amp; Binding"></a>2.2 Rebase &amp;&amp; Binding</h4><p>优化：</p><ul><li>  减少 Objc 类数量，减少 selector 数量，把未使用的类和函数都可以删掉</li><li>  减少 c++ 虚函数数量</li><li>  转而使用 Swift struct（本质就是减少符号的数量）</li></ul><h4 id="2-3-Initializers"><a href="#2-3-Initializers" class="headerlink" title="2.3 Initializers"></a>2.3 Initializers</h4><p>优化：</p><ul><li>  使用 <code>+initialize</code> 代替 <code>+load</code></li><li>  不要使用过 attribute*((constructor)) 将方法显示标记为初始化器，而是让初始化方法调用时才执行。比如使用 dispatch_one、pthread_once() 或 std::once()。也就是第一次使用时才初始化，推迟了一部分工作耗时也尽量不要使用 c++ 的静态对象</li></ul><h4 id="2-4-pre-main-阶段影响因素"><a href="#2-4-pre-main-阶段影响因素" class="headerlink" title="2.4 pre-main 阶段影响因素"></a>2.4 pre-main 阶段影响因素</h4><ul><li>  动态库加载越多，启动越慢。</li><li>  ObjC 类越多，函数越多，启动越慢。</li><li>  可执行文件越大启动越慢。</li><li>  C 的 constructor 函数越多，启动越慢。</li><li>  C++ 静态对象越多，启动越慢。</li><li>  ObjC 的 +load 越多，启动越慢。</li></ul><p>优化手段：</p><ul><li>  减少依赖不必要的库，不管是动态库还是静态库；如果可以的话，把动态库改造成静态库；如果必须依赖动态库，则把多个非系统的动态库合并成一个动态库</li><li>  检查下 framework应当设为optional和required，如果该framework在当前App支持的所有iOS系统版本都存在，那么就设为required，否则就设为optional，因为optional会有些额外的检查</li><li>合并或者删减一些OC类和函数。关于清理项目中没用到的类，使用工具AppCode代码检查功能，查到当前项目中没有用到的类（也可以用根据linkmap文件来分析，但是准确度不算很高）<br>  有一个叫做<a href="https://link.segmentfault.com/?enc=+M8NWNM6ZOB/M1EERBDGkA==.4WCLtil1YWB+tkjAZgL3jaHwEVhfygyzT0Rq6xbaGoM=">FUI</a>的开源项目能很好的分析出不再使用的类，准确率非常高，唯一的问题是它处理不了动态库和静态库里提供的类，也处理不了C++的类模板</li><li>  删减一些无用的静态变量</li><li>  删减没有被调用到或者已经废弃的方法</li><li>  将不必须在 +load 方法中做的事情延迟到 +initialize中，尽量不要用 C++ 虚函数(创建虚函数表有开销)</li><li>类和方法名不要太长：iOS每个类和方法名都在 __cstring 段里都存了相应的字符串值，所以类和方法名的长短也是对可执行文件大小是有影响的<br>  因还是 Object-c 的动态特性，因为需要通过类/方法名反射找到这个类/方法进行调用，Object-c 对象模型会把类/方法名字符串都保存下来；</li><li>  用 dispatch_once() 代替所有的 attribute((constructor)) 函数、C++ 静态对象初始化、ObjC 的 +load 函数；</li><li>在设计师可接受的范围内压缩图片的大小，会有意外收获。<br>  压缩图片为什么能加快启动速度呢？因为启动的时候大大小小的图片加载个十来二十个是很正常的，<br>  图片小了，IO操作量就小了，启动当然就会快了，比较靠谱的压缩算法是 TinyPNG。</li></ul><h4 id="2-5-main-阶段优化"><a href="#2-5-main-阶段优化" class="headerlink" title="2.5 main 阶段优化"></a>2.5 main 阶段优化</h4><ul><li>  减少启动初始化的流程。能懒加载就懒加载，能放后台初始化就放后台初始化，能延迟初始化的就延迟初始化，不要卡主线程的启动时间，已经下线的业务代码直接删除</li><li>  优化代码逻辑。去除一些非必要的逻辑和代码，减小每个流程所消耗的时间</li><li>  启动阶段使用多线程来进行初始化，把 CPU 性能发挥最大</li><li>  使用纯代码而不是 xib 或者 storyboard 来描述 UI，尤其是主 UI 框架，比如 TabBarController。因为 xib 和 storyboard 还是需要解析成代码来渲染页面，多了一步。</li></ul><h3 id="3-启动时间加速"><a href="#3-启动时间加速" class="headerlink" title="3. 启动时间加速"></a>3. 启动时间加速</h3><p>内存缺页异常？在使用中，访问虚拟内存的一个 page 而对应的物理内存缺不存在（没有被加载到物理内存中），则发生缺页异常。影响耗时，在几毫秒之内。</p><p>什么时候发生大量的缺页异常？一个应用程序刚启动的时候。</p><p>启动时所需要的代码分布在 VM 的第一页、第二页、第三页…，这样的情况下启动时间会影响较大，所以解决思路就是将应用程序启动刻所需要的代码（二进制优化一下），统一放到某几页，这样就可以避免内存缺页异常，则优化了 App 启动时间。</p><p>二进制重排提升 App 启动速度是通过「解决内存缺页异常」（内存缺页会有几毫秒的耗时）来提速的。</p><p>一个 App 发生大量「内存缺页」的时机就是 App 刚启动的时候。所以优化手段就是「将影响 App 启动的方法集中处理，放到某一页或者某几页」（虚拟内存中的页）。Xcode 工程允许开发者指定 「Order File」，可以「按照文件中的方法顺序去加载」，可以查看 linkMap 文件（需要在 Xcode 中的 「Buiild Settings」中设置 Order File、Write Link Map Files 参数）。</p><p>其实难点是如何拿到启动时刻所调用的所用方法？代码可能是 Swift、block、c、OC，所以hook 肯定不行、fishhook 也不行，用 clang 插桩可以满足需求。</p><h2 id="三、-CPU-使用率监控"><a href="#三、-CPU-使用率监控" class="headerlink" title="三、 CPU 使用率监控"></a>三、 CPU 使用率监控</h2><h3 id="1-CPU-架构"><a href="#1-CPU-架构" class="headerlink" title="1. CPU 架构"></a>1. CPU 架构</h3><p>CPU（Central Processing Unit）中央处理器，市场上主流的架构有 ARM（arm64）、Intel（x86）、AMD 等。其中 Intel 使用 CISC（Complex Instruction Set Computer），ARM 使用 RISC（Reduced Instruction Set Computer）。区别在于<strong>不同的 CPU 设计理念和方法</strong>。</p><p>早期 CPU 全部是 CISC 架构，设计目的是<strong>用最少的机器语言指令来完成所需的计算任务</strong>。比如对于乘法运算，在 CISC 架构的 CPU 上。一条指令 <code>MUL ADDRA, ADDRB</code> 就可以将内存 ADDRA 和内存 ADDRB 中的数香乘，并将结果存储在 ADDRA 中。做的事情就是：将 ADDRA、ADDRB 中的数据读入到寄存器，相乘的结果写入到内存的操作依赖于 CPU 设计，所以 <strong>CISC 架构会增加 CPU 的复杂性和对 CPU 工艺的要求。</strong></p><p>RISC 架构要求软件来指定各个操作步骤。比如上面的乘法，指令实现为 <code>MOVE A, ADDRA; MOVE B, ADDRB; MUL A, B; STR ADDRA, A;</code>。这种架构可以降低 CPU 的复杂性以及允许在同样的工艺水平下生产出功能更加强大的 CPU，但是对于编译器的设计要求更高。</p><p>目前市场是大部分的 iPhone 都是基于 arm64 架构的。且 arm 架构能耗低。</p><h3 id="2-获取线程信息"><a href="#2-获取线程信息" class="headerlink" title="2. 获取线程信息"></a>2. 获取线程信息</h3><p>讲完了区别来讲下如何做 CPU 使用率的监控</p><ul><li>  开启定时器，按照设定的周期不断执行下面的逻辑</li><li>  获取当前任务 task。从当前 task 中获取所有的线程信息（线程个数、线程数组）</li><li>  遍历所有的线程信息，判断是否有线程的 CPU 使用率超过设置的阈值</li><li>  假如有线程使用率超过阈值，则 dump 堆栈</li><li>  组装数据，上报数据</li></ul><p>线程信息结构体</p><p>struct thread_basic_info {<br>    time_value_t    user_time;      /* user run time（用户运行时长） */<br>    time_value_t    system_time;    /* system run time（系统运行时长） */<br>    integer_t       cpu_usage;      /* scaled cpu usage percentage（CPU使用率，上限1000） */<br>    policy_t        policy;         /* scheduling policy in effect（有效调度策略） */<br>    integer_t       run_state;      /* run state (运行状态，见下) */<br>    integer_t       flags;          /* various flags (各种各样的标记) */<br>    integer_t       suspend_count;  /* suspend count for thread（线程挂起次数） */<br>    integer_t       sleep_time;     /* number of seconds that thread<br>                                     *  has been sleeping（休眠时间） */<br>};</p><p>代码在讲堆栈还原的时候讲过，忘记的看一下上面的分析</p><p>thread_act_array_t threads;<br>mach_msg_type_number_t threadCount = 0;<br>const task_t thisTask = mach_task_self();<br>kern_return_t kr = task_threads(thisTask, &amp;threads, &amp;threadCount);<br>if (kr != KERN_SUCCESS) {<br>    return ;<br>}<br>for (int i = 0; i &lt; threadCount; i++) {<br>    thread_info_data_t threadInfo;<br>    thread_basic_info_t threadBaseInfo;<br>    mach_msg_type_number_t threadInfoCount;</p><pre><code>kern\_return\_t kr = thread\_info((thread\_inspect\_t)threads\[i\], THREAD\_BASIC\_INFO, (thread\_info\_t)threadInfo, &amp;threadInfoCount);if (kr == KERN\_SUCCESS) &#123;    threadBaseInfo = (thread\_basic\_info\_t)threadInfo;    // todo：条件判断，看不明白    if (!(threadBaseInfo-&gt;flags &amp; TH\_FLAGS\_IDLE)) &#123;        integer\_t cpuUsage = threadBaseInfo-&gt;cpu\_usage / 10;        if (cpuUsage &gt; CPUMONITORRATE) &#123;            NSMutableDictionary \*CPUMetaDictionary = \[NSMutableDictionary dictionary\];            NSData \*CPUPayloadData = \[NSData data\];            NSString \*backtraceOfAllThread = \[BacktraceLogger backtraceOfAllThread\];            // 1. 组装卡顿的 Meta 信息            CPUMetaDictionary\[@&quot;MONITOR\_TYPE&quot;\] = APMMonitorCPUType;            // 2. 组装卡顿的 Payload 信息（一个JSON对象，对象的 Key 为约定好的 STACK\_TRACE， value 为 base64 后的堆栈信息）            NSData \*CPUData = \[SAFE\_STRING(backtraceOfAllThread) dataUsingEncoding:NSUTF8StringEncoding\];            NSString \*CPUDataBase64String = \[CPUData base64EncodedStringWithOptions:0\];            NSDictionary \*CPUPayloadDictionary = @&#123;@&quot;STACK\_TRACE&quot;: SAFE\_STRING(CPUDataBase64String)&#125;;            NSError \*error;            // NSJSONWritingOptions 参数一定要传0，因为服务端需要根据 \\n 处理逻辑，传递 0 则生成的 json 串不带 \\n            NSData \*parsedData = \[NSJSONSerialization dataWithJSONObject:CPUPayloadDictionary options:0 error:&amp;error\];            if (error) &#123;                APMMLog(@&quot;%@&quot;, error);                return;            &#125;            CPUPayloadData = \[parsedData copy\];            // 3. 数据上报会在 \[打造功能强大、灵活可配置的数据上报组件\](https://github.com/FantasticLBP/knowledge-kit/blob/master/Chapter1%20-%20iOS/1.80.md) 讲            \[\[HermesClient sharedInstance\] sendWithType:APMMonitorCPUType meta:CPUMetaDictionary payload:CPUPayloadData\];         &#125;    &#125;&#125;</code></pre><p>}</p><h2 id="四、-OOM-问题"><a href="#四、-OOM-问题" class="headerlink" title="四、 OOM 问题"></a>四、 OOM 问题</h2><h3 id="1-基础知识准备"><a href="#1-基础知识准备" class="headerlink" title="1. 基础知识准备"></a>1. 基础知识准备</h3><p>硬盘：也叫做磁盘，用于存储数据。你存储的歌曲、图片、视频都是在硬盘里。</p><p>内存：由于硬盘读取速度较慢，如果 CPU 运行程序期间，所有的数据都直接从硬盘中读取，则非常影响效率。所以 CPU 会将程序运行所需要的数据从硬盘中读取到内存中。然后 CPU 与内存中的数据进行计算、交换。内存是易失性存储器（断电后，数据消失）。内存条区是计算机内部（在主板上）的一些存储器，用来保存 CPU 运算的中间数据和结果。内存是程序与 CPU 之间的桥梁。从硬盘读取出数据或者运行程序提供给 CPU。</p><p><strong>虚拟内存</strong> 是计算机系统内存管理的一种技术。它使得程序认为它拥有连续的可用内存，而实际上，它通常被分割成多个物理内存碎片，可能部分暂时存储在外部磁盘（硬盘）存储器上（当需要使用时则用硬盘中数据交换到内存中）。Windows 系统中称为 “虚拟内存”，Linux/Unix 系统中称为 ”交换空间“。</p><p>iOS 不支持交换空间？不只是 iOS 不支持交换空间，大多数手机系统都不支持。因为移动设备的大量存储器是<strong>闪存</strong>，它的读写速度远远小电脑所使用的硬盘，也就是说手机即使使用了<strong>交换空间</strong>技术，也因为闪存慢的问题，不能提升性能，所以索性就没有交换空间技术。</p><h3 id="2-iOS-内存知识"><a href="#2-iOS-内存知识" class="headerlink" title="2. iOS 内存知识"></a>2. iOS 内存知识</h3><p>内存（RAM）与 CPU 一样都是系统中最稀少的资源，也很容易发生竞争，应用内存与性能直接相关。iOS 没有交换空间作为备选资源，所以内存资源尤为重要。</p><p>什么是 OOM？是 out-of-memory 的缩写，字面意思是超过了内存限制。分为 FOOM（Foreground Out Of Memory，应用在前台运行的过程中崩溃。用户在使用的过程中产生的，这样的崩溃会使得活跃用户流失，业务上是非常不愿意看到的）和 BOOM（Background Out Of Memory，应用在后台运行的过程崩溃）。它是由 iOS 的 <code>Jetsam</code> 机制造成的一种非主流 Crash，它不能通过 Signal 这种监控方案所捕获。</p><p>什么是 Jetsam 机制？Jetsam 机制可以理解为系统为了控制内存资源过度使用而采用的一种管理机制。Jetsam 机制是运行在一个独立的进程中，每个进程都有一个内存阈值，一旦超过这个内存阈值，Jetsam 会立即杀掉这个进程。</p><p>为什么设计 Jetsam 机制？因为设备的内存是有限的，所以内存资源非常重要。系统进程以及其他使用的 App 都会抢占这个资源。由于 iOS 不支持交换空间，一旦触发低内存事件，Jetsam 就会尽可能多的释放 App 所在内存，这样 iOS 系统上出现内存不足时，App 就会被系统杀掉，变现为 crash。</p><p>2种情况触发 OOM：系统由于整体内存使用过高，会基于优先级策略杀死优先级较低的 App；当前 App 达到了 “<strong>highg water mark</strong>“ ，系统也会强杀当前 App（超过系统对当前单个 App 的内存限制值）。</p><p>读了源码（xnu/bsd/kern/kern_memorystatus.c）会发现内存被杀也有2种机制，如下</p><p>highwater 处理 -&gt; 我们的 App 占用内存不能超过单个限制</p><ol><li> 从优先级列表里循环寻找线程</li><li> 判断是否满足 p_memstat_memlimit 的限制条件</li><li> DiagonoseActive、FREEZE 过滤</li><li> 杀进程，成功则 exit，否则循环</li></ol><p>memorystatus_act_aggressive 处理 -&gt; 内存占用高，按照优先级杀死</p><ol><li> 根据 policy 家在 jld_bucket_count，用来判断是否被杀</li><li> 从 JETSAM_PRIORITY_ELEVATED_INACTIVE 开始杀</li><li> Old_bucket_count 和 memorystatus_jld_eval_period_msecs 判断是否开杀</li><li> 根据优先级从低到高开始杀，直到 memorystatus_avail_pages_below_pressure</li></ol><p>内存过大的几种情况</p><ul><li>  App 内存消耗较低，同时其他 App 内存管理也很棒，那么即使切换到其他 App，我们自己的 App 依旧是“活着”的，保留了用户状态。体验好</li><li>  App 内存消耗较低，但其他 App 内存消耗太大（可能是内存管理糟糕，也可能是本身就耗费资源，比如游戏），那么除了在前台的线程，其他 App 都会被系统杀死，回收内存资源，用来给活跃的进程提供内存。</li><li>  App 内存消耗较大，切换到其他 App 后，即使其他 App 向系统申请的内存不大，系统也会因为内存资源紧张，优先把内存消耗大的 App 杀死。表现为用户将 App 退出到后台，过会儿再次打开会发现 App 重新加载启动。</li><li>  App 内存消耗非常大，在前台运行时就被系统杀死，造成闪退。</li></ul><p>App 内存不足时，系统会按照一定策略来腾出更多的空间供使用。比较常见的做法是将一部分优先级低的数据挪到磁盘上，该操作为称为 <strong>page out</strong>。之后再次访问这块数据的时候，系统会负责将它重新搬回到内存中，该操作被称为 <strong>page in</strong>。</p><p>Memory page** 是内存管理中的最小单位，是系统分配的，可能一个 page 持有多个对象，也可能一个大的对象跨越多个 page。通常它是 16KB 大小，且有3种类型的 page。</p><p><img src="https://segmentfault.com/img/bVbIOf9"></p><ul><li><p>Clean Memory<br>  Clean memory 包括3类：可以 <code>page out</code> 的内存、内存映射文件、App 使用到的 framework（每个 framework 都有 _DATA_CONST 段，通常都是 clean 状态，但使用 runtime swizling，那么变为 dirty）。</p><p>  一开始分配的 page 都是干净的（堆里面的对象分配除外），我们 App 数据写入时候变为 dirty。从硬盘读进内存的文件，也是只读的、clean page。<br>  <img src="https://segmentfault.com/img/bVbIOn9"></p></li><li><p>Dirty Memory</p><p>  Dirty memory 包括4类：被 App 写入过数据的内存、所有堆区分配的对象、图像解码缓冲区、framework（framework 都有 _DATA 段和 _DATA_DIRTY 段，它们的内存都是 dirty）。</p><p>  在使用 framework 的过程中会产生 Dirty memory，使用单例或者全局初始化方法有助于帮助减少 Dirty memory（因为单例一旦创建就不销毁，一直在内存中，系统不认为是 Dirty memory）。</p><p>  <img src="https://segmentfault.com/img/bVbIOoc"></p></li><li><p>Compressed Memory</p><p>  由于闪存容量和读写限制，iOS 没有交换空间机制，而是在 iOS7 引入了 <strong>memory compressor</strong>。它是在内存紧张时候能够将最近一段时间未使用过的内存对象，内存压缩器会把对象压缩，释放出更多的 page。在需要时内存压缩器对其解压复用。在节省内存的同时提高了响应速度。</p><p>  比如 App 使用某 Framework，内部有个 NSDictionary 属性存储数据，使用了 3 pages 内存，在近期未被访问的时候 memory compressor 将其压缩为 1 page，再次使用的时候还原为 3 pages。</p></li></ul><p>App 运行内存 = pageNumbers * pageSize。因为 Compressed Memory 属于 Dirty memory。所以 Memory footprint = dirtySize + CompressedSize</p><p>设备不同，内存占用上限不同，App 上限较高，extension 上限较低，超过上限 crash 到 <code>EXC_RESOURCE_EXCEPTION</code>。<br><img src="https://segmentfault.com/img/bVbIOgi"></p><p>接下来谈一下如何获取内存上限，以及如何监控 App 因为占用内存过大而被强杀。</p><h3 id="3-获取内存信息"><a href="#3-获取内存信息" class="headerlink" title="3. 获取内存信息"></a>3. 获取内存信息</h3><h4 id="3-1-通过-JetsamEvent-日志计算内存限制值"><a href="#3-1-通过-JetsamEvent-日志计算内存限制值" class="headerlink" title="3.1 通过 JetsamEvent 日志计算内存限制值"></a>3.1 通过 JetsamEvent 日志计算内存限制值</h4><p>当 App 被 Jetsam 机制杀死时，手机会生成系统日志。查看路径：Settings-Privacy-Analytics &amp; Improvements- Analytics Data（设置-隐私- 分析与改进-分析数据），可以看到 <code>JetsamEvent-2020-03-14-161828.ips</code> 形式的日志，以 JetsamEvent 开头。这些 JetsamEvent 日志都是 iOS 系统内核强杀掉那些优先级不高（idle、frontmost、suspended）且占用内存超过系统内存限制的 App 留下的。</p><p>日志包含了 App 的内存信息。可以查看到 日志最顶部有 <code>pageSize</code> 字段，查找到 per-process-limit，该节点所在结构里的 <code>rpages</code> ，将 rpages * pageSize 即可得到 OOM 的阈值。</p><p>日志中 largestProcess 字段代表 App 名称；reason 字段代表内存原因；states 字段代表奔溃时 App 的状态（ idle、suspended、frontmost…）。</p><p>为了测试数据的准确性，我将测试2台设备（iPhone 6s plus/13.3.1，iPhone 11 Pro/13.3.1）的所有 App 彻底退出，只跑了一个为了测试内存临界值的 Demo App。 循环申请内存，ViewController 代码如下</p><p>- (void)viewDidLoad {<br>    [super viewDidLoad];<br>    NSMutableArray *array = [NSMutableArray array];<br>    for (NSInteger index = 0; index &lt; 10000000; index++) {<br>        UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];<br>        UIImage *image = [UIImage imageNamed:@”AppIcon”];<br>        imageView.image = image;<br>        [array addObject:imageView];<br>    }<br>}</p><p>iPhone 6s plus/13.3.1 数据如下：</p><p>{“bug_type”:”298”,”timestamp”:”2020-03-19 17:23:45.94 +0800”,”os_version”:”iPhone OS 13.3.1 (17D50)”,”incident_id”:”DA8AF66D-24E8-458C-8734-981866942168”}<br>{<br>  “crashReporterKey” : “fc9b659ce486df1ed1b8062d5c7c977a7eb8c851”,<br>  “kernel” : “Darwin Kernel Version 19.3.0: Thu Jan  9 21:10:44 PST 2020; root:xnu-6153.82.3~1\/RELEASE_ARM64_S8000”,<br>  “product” : “iPhone8,2”,<br>  “incident” : “DA8AF66D-24E8-458C-8734-981866942168”,<br>  “date” : “2020-03-19 17:23:45.93 +0800”,<br>  “build” : “iPhone OS 13.3.1 (17D50)”,<br>  “timeDelta” : 332,<br>  “memoryStatus” : {<br>  “compressorSize” : 48499,<br>  “compressions” : 7458651,<br>  “decompressions” : 5190200,<br>  “zoneMapCap” : 744407040,<br>  “largestZone” : “APFS_4K_OBJS”,<br>  “largestZoneSize” : 41402368,<br>  “pageSize” : 16384,<br>  “uncompressed” : 104065,<br>  “zoneMapSize” : 141606912,<br>  “memoryPages” : {<br>    “active” : 26214,<br>    “throttled” : 0,<br>    “fileBacked” : 14903,<br>    “wired” : 20019,<br>    “anonymous” : 37140,<br>    “purgeable” : 142,<br>    “inactive” : 23669,<br>    “free” : 2967,<br>    “speculative” : 2160<br>  }<br>},<br>  “largestProcess” : “Test”,<br>  “genCounter” : 0,<br>  “processes” : [<br>  {<br>    “uuid” : “39c5738b-b321-3865-a731-68064c4f7a6f”,<br>    “states” : [<br>      “daemon”,<br>      “idle”<br>    ],<br>    “lifetimeMax” : 188,<br>    “age” : 948223699030,<br>    “purgeable” : 0,<br>    “fds” : 25,<br>    “coalition” : 422,<br>    “rpages” : 177,<br>    “pid” : 282,<br>    “idleDelta” : 824711280,<br>    “name” : “com.apple.Safari.SafeBrowsing.Se”,<br>    “cpuTime” : 10.275422000000001<br>  },<br>  // …<br>  {<br>    “uuid” : “83dbf121-7c0c-3ab5-9b66-77ee926e1561”,<br>    “states” : [<br>      “frontmost”<br>    ],<br>    “killDelta” : 2592,<br>    “genCount” : 0,<br>    “age” : 1531004794,<br>    “purgeable” : 0,<br>    “fds” : 50,<br>    “coalition” : 1047,<br>    “rpages” : 92806,<br>    “reason” : “per-process-limit”,<br>    “pid” : 2384,<br>    “cpuTime” : 59.464373999999999,<br>    “name” : “Test”,<br>    “lifetimeMax” : 92806<br>  },<br>  // …<br> ]<br>}</p><p>iPhone 6s plus/13.3.1 手机 OOM 临界值为：(16384*92806)/(1024*1024)=1450.09375M</p><p>iPhone 11 Pro/13.3.1 数据如下：</p><p>{“bug_type”:”298”,”timestamp”:”2020-03-19 17:30:28.39 +0800”,”os_version”:”iPhone OS 13.3.1 (17D50)”,”incident_id”:”7F111601-BC7A-4BD7-A468-CE3370053057”}<br>{<br>  “crashReporterKey” : “bc2445adc164c399b330f812a48248e029e26276”,<br>  “kernel” : “Darwin Kernel Version 19.3.0: Thu Jan  9 21:11:10 PST 2020; root:xnu-6153.82.3~1\/RELEASE_ARM64_T8030”,<br>  “product” : “iPhone12,3”,<br>  “incident” : “7F111601-BC7A-4BD7-A468-CE3370053057”,<br>  “date” : “2020-03-19 17:30:28.39 +0800”,<br>  “build” : “iPhone OS 13.3.1 (17D50)”,<br>  “timeDelta” : 189,<br>  “memoryStatus” : {<br>  “compressorSize” : 66443,<br>  “compressions” : 25498129,<br>  “decompressions” : 15532621,<br>  “zoneMapCap” : 1395015680,<br>  “largestZone” : “APFS_4K_OBJS”,<br>  “largestZoneSize” : 41222144,<br>  “pageSize” : 16384,<br>  “uncompressed” : 127027,<br>  “zoneMapSize” : 169639936,<br>  “memoryPages” : {<br>    “active” : 58652,<br>    “throttled” : 0,<br>    “fileBacked” : 20291,<br>    “wired” : 45838,<br>    “anonymous” : 96445,<br>    “purgeable” : 4,<br>    “inactive” : 54368,<br>    “free” : 5461,<br>    “speculative” : 3716<br>  }<br>},<br>  “largestProcess” : “杭城小刘”,<br>  “genCounter” : 0,<br>  “processes” : [<br>  {<br>    “uuid” : “2dd5eb1e-fd31-36c2-99d9-bcbff44efbb7”,<br>    “states” : [<br>      “daemon”,<br>      “idle”<br>    ],<br>    “lifetimeMax” : 171,<br>    “age” : 5151034269954,<br>    “purgeable” : 0,<br>    “fds” : 50,<br>    “coalition” : 66,<br>    “rpages” : 164,<br>    “pid” : 11276,<br>    “idleDelta” : 3801132318,<br>    “name” : “wcd”,<br>    “cpuTime” : 3.430787<br>  },<br>  // …<br>  {<br>    “uuid” : “63158edc-915f-3a2b-975c-0e0ac4ed44c0”,<br>    “states” : [<br>      “frontmost”<br>    ],<br>    “killDelta” : 4345,<br>    “genCount” : 0,<br>    “age” : 654480778,<br>    “purgeable” : 0,<br>    “fds” : 50,<br>    “coalition” : 1718,<br>    “rpages” : 134278,<br>    “reason” : “per-process-limit”,<br>    “pid” : 14206,<br>    “cpuTime” : 23.955463999999999,<br>    “name” : “杭城小刘”,<br>    “lifetimeMax” : 134278<br>  },<br>  // …<br> ]<br>}</p><p>iPhone 11 Pro/13.3.1 手机 OOM 临界值为：(16384*134278)/(1024*1024)=2098.09375M</p><p><strong>iOS 系统如何发现 Jetsam ？</strong></p><p>MacOS/iOS 是一个 BSD 衍生而来的系统，其内核是 Mach，但是对于上层暴露的接口一般是基于 BSD 层对 Mach 的包装后的。Mach 是一个微内核的架构，真正的虚拟内存管理也是在其中进行的，BSD 对内存管理提供了上层接口。Jetsam 事件也是由 BSD 产生的。<code>bsd_init</code> 函数是入口，其中基本都是在初始化各个子系统，比如虚拟内存管理等。</p><p>// 1. Initialize the kernel memory allocator, 初始化 BSD 内存 Zone，这个 Zone 是基于 Mach 内核的zone 构建<br>kmeminit();</p><p>// 2. Initialise background freezing, iOS 上独有的特性，内存和进程的休眠的常驻监控线程<br>#if CONFIG_FREEZE<br>#ifndef CONFIG_MEMORYSTATUS<br>    #error “CONFIG_FREEZE defined without matching CONFIG_MEMORYSTATUS”<br>#endif<br>    /* Initialise background freezing */<br>    bsd_init_kprintf(“calling memorystatus_freeze_init\n”);<br>    memorystatus_freeze_init();<br>#endif&gt;</p><p>// 3. iOS 独有，JetSAM（即低内存事件的常驻监控线程）<br>#if CONFIG_MEMORYSTATUS<br>    /* Initialize kernel memory status notifications */<br>    bsd_init_kprintf(“calling memorystatus_init\n”);<br>    memorystatus_init();<br>#endif /* CONFIG_MEMORYSTATUS */</p><p><strong>主要作用就是开启了2个优先级最高的线程，来监控整个系统的内存情况。</strong></p><p>CONFIG_FREEZE 开启时，内核对进程进行冷冻而不是杀死。冷冻功能是由内核中启动一个 <code>memorystatus_freeze_thread</code> 进行，这个进程在收到信号后调用 <code>memorystatus_freeze_top_process</code> 进行冷冻。</p><p>iOS 系统会开启优先级最高的线程 <code>vm_pressure_monitor</code> 来监控系统的内存压力情况，并通过一个堆栈来维护所有 App 进程。iOS 系统还会维护一个内存快照表，用于保存每个进程内存页的消耗情况。有关 Jetsam 也就是 memorystatus 相关的逻辑，可以在 XNU 项目中的 <strong>kern_memorystatus.h</strong> 和 <strong>kern_memorystatus.c</strong> 源码中查看。</p><p>iOS 系统因内存占用过高会强杀 App 前，至少有 6秒钟可以用来做优先级判断，JetsamEvent 日志也是在这6秒内生成的。</p><p>上文提到了 iOS 系统没有交换空间，于是引入了 <strong>MemoryStatus 机制（也称为 Jetsam）</strong>。也就是说在 iOS 系统上释放尽可能多的内存供当前 App 使用。这个机制表现在优先级上，就是先强杀后台应用；如果内存还是不够多，就强杀掉当前应用。在 MacOS 中，MemoryStatus 只会强杀掉标记为空闲退出的进程。</p><p>MemoryStatus 机制会开启一个 memorystatus_jetsam_thread 的线程，它负责强杀 App 和记录日志，不会发送消息，所以内存压力检测线程无法获取到强杀 App 的消息。</p><p>当监控线程发现某 App 有内存压力时，就发出通知，此时有内存的 App 就去执行 <code>didReceiveMemoryWarning</code> 代理方法。在这个时机，我们还有机会做一些内存资源释放的逻辑，也许会避免 App 被系统杀死。</p><p><strong>源码角度查看问题</strong></p><p>iOS 系统内核有一个数组，专门维护线程的优先级。数组的每一项是一个包含进程链表的结构体。结构体如下：</p><p>#define MEMSTAT_BUCKET_COUNT (JETSAM_PRIORITY_MAX + 1)</p><p>typedef struct memstat_bucket {<br>    TAILQ_HEAD(, proc) list;<br>    int count;<br>} memstat_bucket_t;</p><p>memstat_bucket_t memstat_bucket[MEMSTAT_BUCKET_COUNT];</p><p>在 kern_memorystatus.h 中可以看到进行优先级信息</p><p>#define JETSAM_PRIORITY_IDLE_HEAD                -2<br>/* The value -1 is an alias to JETSAM_PRIORITY_DEFAULT */<br>#define JETSAM_PRIORITY_IDLE                      0<br>#define JETSAM_PRIORITY_IDLE_DEFERRED          1 /* Keeping this around till all xnu_quick_tests can be moved away from it.*/<br>#define JETSAM_PRIORITY_AGING_BAND1          JETSAM_PRIORITY_IDLE_DEFERRED<br>#define JETSAM_PRIORITY_BACKGROUND_OPPORTUNISTIC  2<br>#define JETSAM_PRIORITY_AGING_BAND2          JETSAM_PRIORITY_BACKGROUND_OPPORTUNISTIC<br>#define JETSAM_PRIORITY_BACKGROUND                3<br>#define JETSAM_PRIORITY_ELEVATED_INACTIVE      JETSAM_PRIORITY_BACKGROUND<br>#define JETSAM_PRIORITY_MAIL                      4<br>#define JETSAM_PRIORITY_PHONE                     5<br>#define JETSAM_PRIORITY_UI_SUPPORT                8<br>#define JETSAM_PRIORITY_FOREGROUND_SUPPORT        9<br>#define JETSAM_PRIORITY_FOREGROUND               10<br>#define JETSAM_PRIORITY_AUDIO_AND_ACCESSORY      12<br>#define JETSAM_PRIORITY_CONDUCTOR                13<br>#define JETSAM_PRIORITY_HOME                     16<br>#define JETSAM_PRIORITY_EXECUTIVE                17<br>#define JETSAM_PRIORITY_IMPORTANT                18<br>#define JETSAM_PRIORITY_CRITICAL                 19</p><p>#define JETSAM_PRIORITY_MAX                      21</p><p>可以明显的看到，后台 App 优先级 JETSAM_PRIORITY_BACKGROUND 为3，前台 App 优先级 JETSAM_PRIORITY_FOREGROUND 为10。</p><p>优先级规则是：内核线程优先级 &gt; 操作系统优先级 &gt; App 优先级。且前台 App 优先级高于后台运行的 App；当线程的优先级相同时， CPU 占用多的线程的优先级会被降低。</p><p>在 kern_memorystatus.c 中可以看到 OOM 可能的原因：</p><p>/* For logging clarity */<br>static const char *memorystatus_kill_cause_name[] = {<br>    “”                                ,        /* kMemorystatusInvalid                            */<br>    “jettisoned”                    ,        /* kMemorystatusKilled                            */<br>    “highwater”                        ,        /* kMemorystatusKilledHiwat                        */<br>    “vnode-limit”                    ,        /* kMemorystatusKilledVnodes                    */<br>    “vm-pageshortage”                ,        /* kMemorystatusKilledVMPageShortage            */<br>    “proc-thrashing”                ,        /* kMemorystatusKilledProcThrashing                */<br>    “fc-thrashing”                    ,        /* kMemorystatusKilledFCThrashing                */<br>    “per-process-limit”                ,        /* kMemorystatusKilledPerProcessLimit            */<br>    “disk-space-shortage”            ,        /* kMemorystatusKilledDiskSpaceShortage            */<br>    “idle-exit”                        ,        /* kMemorystatusKilledIdleExit                    */<br>    “zone-map-exhaustion”            ,        /* kMemorystatusKilledZoneMapExhaustion            */<br>    “vm-compressor-thrashing”        ,        /* kMemorystatusKilledVMCompressorThrashing        */<br>    “vm-compressor-space-shortage”    ,        /* kMemorystatusKilledVMCompressorSpaceShortage    */<br>};</p><p>查看 memorystatus_init 这个函数中初始化 Jetsam 线程的关键代码</p><p>__private_extern__ void<br>memorystatus_init(void) {<br>    // …<br>  /* Initialize the jetsam_threads state array */<br>    jetsam_threads = kalloc(sizeof(struct jetsam_thread_state) * max_jetsam_threads);</p><pre><code>/\* Initialize all the jetsam threads \*/for (i = 0; i &lt; max\_jetsam\_threads; i++) &#123;    result = kernel\_thread\_start\_priority(memorystatus\_thread, NULL, 95 /\* MAXPRI\_KERNEL \*/, &amp;jetsam\_threads\[i\].thread);    if (result == KERN\_SUCCESS) &#123;        jetsam\_threads\[i\].inited = FALSE;        jetsam\_threads\[i\].index = i;        thread\_deallocate(jetsam\_threads\[i\].thread);    &#125; else &#123;        panic(&quot;Could not create memorystatus\_thread %d&quot;, i);    &#125;&#125;</code></pre><p>}</p><p>/*<br> *    High-level priority assignments<br> *<br> *************************************************************************<br> * 127        Reserved (real-time)<br> *                A<br> *                +<br> *            (32 levels)<br> *                +<br> *                V<br> * 96        Reserved (real-time)<br> * 95        Kernel mode only<br> *                A<br> *                +<br> *            (16 levels)<br> *                +<br> *                V<br> * 80        Kernel mode only<br> * 79        System high priority<br> *                A<br> *                +<br> *            (16 levels)<br> *                +<br> *                V<br> * 64        System high priority<br> * 63        Elevated priorities<br> *                A<br> *                +<br> *            (12 levels)<br> *                +<br> *                V<br> * 52        Elevated priorities<br> * 51        Elevated priorities (incl. BSD +nice)<br> *                A<br> *                +<br> *            (20 levels)<br> *                +<br> *                V<br> * 32        Elevated priorities (incl. BSD +nice)<br> * 31        Default (default base for threads)<br> * 30        Lowered priorities (incl. BSD -nice)<br> *                A<br> *                +<br> *            (20 levels)<br> *                +<br> *                V<br> * 11        Lowered priorities (incl. BSD -nice)<br> * 10        Lowered priorities (aged pri’s)<br> *                A<br> *                +<br> *            (11 levels)<br> *                +<br> *                V<br> * 0        Lowered priorities (aged pri’s / idle)<br> *************************************************************************<br> */</p><p>可以看出：用户态的应用程序的线程不可能高于操作系统和内核。而且，用户态的应用程序间的线程优先级分配也有区别，比如处于前台的应用程序优先级高于处于后台的应用程序优先级。iOS 上应用程序优先级最高的是 SpringBoard；此外线程的优先级不是一成不变的。Mach 会根据线程的利用率和系统整体负载动态调整线程优先级。如果耗费 CPU 太多就降低线程优先级，如果线程过度挨饿，则会提升线程优先级。但是无论怎么变，程序都不能超过其所在线程的优先级区间范围。</p><p>可以看出，系统会根据内核启动参数和设备性能，开启 max_jetsam_threads 个（一般情况为1，特殊情况下可能为3）jetsam 线程，且这些线程的优先级为 95，也就是 MAXPRI_KERNEL（注意这里的 95 是线程的优先级，XNU 的线程优先级区间为：0～127。上文的宏定义是进程优先级，区间为：-2~19）。</p><p>紧接着，分析下 memorystatus_thread 函数，主要负责线程启动的初始化</p><p>static void<br>memorystatus_thread(void *param __unused, wait_result_t wr __unused) {<br>  //…<br>  while (memorystatus_action_needed()) {<br>        boolean_t killed;<br>        int32_t priority;<br>        uint32_t cause;<br>        uint64_t jetsam_reason_code = JETSAM_REASON_INVALID;<br>        os_reason_t jetsam_reason = OS_REASON_NULL;</p><pre><code>    cause = kill\_under\_pressure\_cause;    switch (cause) &#123;        case kMemorystatusKilledFCThrashing:            jetsam\_reason\_code = JETSAM\_REASON\_MEMORY\_FCTHRASHING;            break;        case kMemorystatusKilledVMCompressorThrashing:            jetsam\_reason\_code = JETSAM\_REASON\_MEMORY\_VMCOMPRESSOR\_THRASHING;            break;        case kMemorystatusKilledVMCompressorSpaceShortage:            jetsam\_reason\_code = JETSAM\_REASON\_MEMORY\_VMCOMPRESSOR\_SPACE\_SHORTAGE;            break;        case kMemorystatusKilledZoneMapExhaustion:            jetsam\_reason\_code = JETSAM\_REASON\_ZONE\_MAP\_EXHAUSTION;            break;        case kMemorystatusKilledVMPageShortage:            /\* falls through \*/        default:            jetsam\_reason\_code = JETSAM\_REASON\_MEMORY\_VMPAGESHORTAGE;            cause = kMemorystatusKilledVMPageShortage;            break;    &#125;    /\* Highwater \*/    boolean\_t is\_critical = TRUE;    if (memorystatus\_act\_on\_hiwat\_processes(&amp;errors, &amp;hwm\_kill, &amp;post\_snapshot, &amp;is\_critical)) &#123;        if (is\_critical == FALSE) &#123;            /\*             \* For now, don&#39;t kill any other processes.             \*/            break;        &#125; else &#123;            goto done;        &#125;    &#125;    jetsam\_reason = os\_reason\_create(OS\_REASON\_JETSAM, jetsam\_reason\_code);    if (jetsam\_reason == OS\_REASON\_NULL) &#123;        printf(&quot;memorystatus\_thread: failed to allocate jetsam reason\\n&quot;);    &#125;    if (memorystatus\_act\_aggressive(cause, jetsam\_reason, &amp;jld\_idle\_kills, &amp;corpse\_list\_purged, &amp;post\_snapshot)) &#123;        goto done;    &#125;    /\*     \* memorystatus\_kill\_top\_process() drops a reference,     \* so take another one so we can continue to use this exit reason     \* even after it returns     \*/    os\_reason\_ref(jetsam\_reason);    /\* LRU \*/    killed = memorystatus\_kill\_top\_process(TRUE, sort\_flag, cause, jetsam\_reason, &amp;priority, &amp;errors);    sort\_flag = FALSE;    if (killed) &#123;        if (memorystatus\_post\_snapshot(priority, cause) == TRUE) &#123;                post\_snapshot = TRUE;        &#125;        /\* Jetsam Loop Detection \*/        if (memorystatus\_jld\_enabled == TRUE) &#123;            if ((priority == JETSAM\_PRIORITY\_IDLE) || (priority == system\_procs\_aging\_band) || (priority == applications\_aging\_band)) &#123;                jld\_idle\_kills++;            &#125; else &#123;                /\*                 \* We&#39;ve reached into bands beyond idle deferred.                 \* We make no attempt to monitor them                 \*/            &#125;        &#125;        if ((priority &gt;= JETSAM\_PRIORITY\_UI\_SUPPORT) &amp;&amp; (total\_corpses\_count() &gt; 0) &amp;&amp; (corpse\_list\_purged == FALSE)) &#123;            /\*             \* If we have jetsammed a process in or above JETSAM\_PRIORITY\_UI\_SUPPORT             \* then we attempt to relieve pressure by purging corpse memory.             \*/            task\_purge\_all\_corpses();            corpse\_list\_purged = TRUE;        &#125;        goto done;    &#125;    if (memorystatus\_avail\_pages\_below\_critical()) &#123;        /\*         \* Still under pressure and unable to kill a process - purge corpse memory         \*/        if (total\_corpses\_count() &gt; 0) &#123;            task\_purge\_all\_corpses();            corpse\_list\_purged = TRUE;        &#125;        if (memorystatus\_avail\_pages\_below\_critical()) &#123;            /\*             \* Still under pressure and unable to kill a process - panic             \*/            panic(&quot;memorystatus\_jetsam\_thread: no victim! available pages:%llu\\n&quot;, (uint64\_t)memorystatus\_available\_pages);        &#125;    &#125;</code></pre><p>done:    </p><p>}</p><p>可以看到它开启了一个 循环，memorystatus_action_needed() 来作为循环条件，持续释放内存。</p><p>static boolean_t<br>memorystatus_action_needed(void) {<br>#if CONFIG_EMBEDDED<br>    return (is_reason_thrashing(kill_under_pressure_cause) ||<br>            is_reason_zone_map_exhaustion(kill_under_pressure_cause) ||<br>           memorystatus_available_pages &lt;= memorystatus_available_pages_pressure);<br>#else /* CONFIG_EMBEDDED */<br>    return (is_reason_thrashing(kill_under_pressure_cause) ||<br>            is_reason_zone_map_exhaustion(kill_under_pressure_cause));<br>#endif /* CONFIG_EMBEDDED */<br>}</p><p>它通过 vm_pagepout 发送的内存压力来判断当前内存资源是否紧张。几种情况：频繁的页面换出换进 is_reason_thrashing, Mach Zone 耗尽了 is_reason_zone_map_exhaustion、以及可用的页低于了 memory status_available_pages 这个门槛。</p><p>继续看 memorystatus_thread，会发现内存紧张时，将先触发 High-water 类型的 OOM，也就是说假如某个进程使用过程中超过了其使用内存的最高限制 hight water mark 时会发生 OOM。在 memorystatus_act_on_hiwat_processes() 中，通过 memorystatus_kill_hiwat_proc() 在优先级数组 memstat_bucket 中查找优先级最低的进程，如果进程的内存小于阈值（footprint_in_bytes &lt;= memlimit_in_bytes）则继续寻找次优先级较低的进程，直到找到占用内存超过阈值的进程并杀死。</p><p>通常来说单个 App 很难触碰到 high water mark，如果不能结束任何进程，最终走到 memorystatus_act_aggressive，也就是大多数 OOM 发生的地方。</p><p>static boolean_t<br>memorystatus_act_aggressive(uint32_t cause, os_reason_t jetsam_reason, int *jld_idle_kills, boolean_t *corpse_list_purged, boolean_t *post_snapshot) {<br>    // …<br>  if ( (jld_bucket_count == 0) ||<br>             (jld_now_msecs &gt; (jld_timestamp_msecs + memorystatus_jld_eval_period_msecs))) {</p><pre><code>        /\*          \* Refresh evaluation parameters          \*/        jld\_timestamp\_msecs     = jld\_now\_msecs;        jld\_idle\_kill\_candidates = jld\_bucket\_count;        \*jld\_idle\_kills         = 0;        jld\_eval\_aggressive\_count = 0;        jld\_priority\_band\_max    = JETSAM\_PRIORITY\_UI\_SUPPORT;    &#125;</code></pre><p>  //…<br>}</p><p>上述代码看到，判断要不要真正执行 kill 是根据一定的时间间判断的，条件是 <code>jld_now_msecs &gt; (jld_timestamp_msecs + memorystatus_jld_eval_period_msecs</code>。 也就是在 memorystatus_jld_eval_period_msecs 后才发生条件里面的 kill。</p><p>/* Jetsam Loop Detection */<br>if (max_mem &lt;= (512 * 1024 * 1024)) {<br>    /* 512 MB devices */<br>memorystatus_jld_eval_period_msecs = 8000;    /* 8000 msecs == 8 second window */<br>} else {<br>    /* 1GB and larger devices */<br>memorystatus_jld_eval_period_msecs = 6000;    /* 6000 msecs == 6 second window */<br>}</p><p>其中 memorystatus_jld_eval_period_msecs 取值最小6秒。所以我们可以在6秒内做些处理。</p><h4 id="3-2-开发者们整理所得"><a href="#3-2-开发者们整理所得" class="headerlink" title="3.2 开发者们整理所得"></a>3.2 开发者们整理所得</h4><p><a href="https://link.segmentfault.com/?enc=jXqAlw4S4FOsD7u5160uFA==.Ap2qdKjaM0Mrxz+exry6MgJXIb+6daIX0Uf70MPabekPiXVP9YTyapT4vtBNYne6LbUktczVdsrs9D8E/M5QzaYa1fLm/DrkWOTFgNx1OySq+DkvKpj6QxzOJBIyhLmx">stackoverflow</a> 上有一份数据，整理了各种设备的 OOM 临界值</p><p>device</p><p>crash amount:MB</p><p>total amount:MB</p><p>percentage of total</p><p>iPad1</p><p>127</p><p>256</p><p>49%</p><p>iPad2</p><p>275</p><p>512</p><p>53%</p><p>iPad3</p><p>645</p><p>1024</p><p>62%</p><p>iPad4(iOS 8.1)</p><p>585</p><p>1024</p><p>57%</p><p>Pad Mini 1st Generation</p><p>297</p><p>512</p><p>58%</p><p>iPad Mini retina(iOS 7.1)</p><p>696</p><p>1024</p><p>68%</p><p>iPad Air</p><p>697</p><p>1024</p><p>68%</p><p>iPad Air 2(iOS 10.2.1)</p><p>1383</p><p>2048</p><p>68%</p><p>iPad Pro 9.7”(iOS 10.0.2 (14A456))</p><p>1395</p><p>1971</p><p>71%</p><p>iPad Pro 10.5”(iOS 11 beta4)</p><p>3057</p><p>4000</p><p>76%</p><p>iPad Pro 12.9” (2015)(iOS 11.2.1)</p><p>3058</p><p>3999</p><p>76%</p><p>iPad 10.2(iOS 13.2.3)</p><p>1844</p><p>2998</p><p>62%</p><p>iPod touch 4th gen(iOS 6.1.1)</p><p>130</p><p>256</p><p>51%</p><p>iPod touch 5th gen</p><p>286</p><p>512</p><p>56%</p><p>iPhone4</p><p>325</p><p>512</p><p>63%</p><p>iPhone4s</p><p>286</p><p>512</p><p>56%</p><p>iPhone5</p><p>645</p><p>1024</p><p>62%</p><p>iPhone5s</p><p>646</p><p>1024</p><p>63%</p><p>iPhone6(iOS 8.x)</p><p>645</p><p>1024</p><p>62%</p><p>iPhone6 Plus(iOS 8.x)</p><p>645</p><p>1024</p><p>62%</p><p>iPhone6s(iOS 9.2)</p><p>1396</p><p>2048</p><p>68%</p><p>iPhone6s Plus(iOS 10.2.1)</p><p>1396</p><p>2048</p><p>68%</p><p>iPhoneSE(iOS 9.3)</p><p>1395</p><p>2048</p><p>68%</p><p>iPhone7(iOS 10.2)</p><p>1395</p><p>2048</p><p>68%</p><p>iPhone7 Plus(iOS 10.2.1)</p><p>2040</p><p>3072</p><p>66%</p><p>iPhone8(iOS 12.1)</p><p>1364</p><p>1990</p><p>70%</p><p>iPhoneX(iOS 11.2.1)</p><p>1392</p><p>2785</p><p>50%</p><p>iPhoneXS(iOS 12.1)</p><p>2040</p><p>3754</p><p>54%</p><p>iPhoneXS Max(iOS 12.1)</p><p>2039</p><p>3735</p><p>55%</p><p>iPhoneXR(iOS 12.1)</p><p>1792</p><p>2813</p><p>63%</p><p>iPhone11(iOS 13.1.3)</p><p>2068</p><p>3844</p><p>54%</p><p>iPhone11 Pro Max(iOS 13.2.3)</p><p>2067</p><p>3740</p><p>55%</p><h4 id="3-3-触发当前-App-的-high-water-mark"><a href="#3-3-触发当前-App-的-high-water-mark" class="headerlink" title="3.3 触发当前 App 的 high water mark"></a>3.3 触发当前 App 的 high water mark</h4><p>我们可以写定时器，不断的申请内存，之后再通过 <code>phys_footprint</code> 打印当前占用内存，按道理来说不断申请内存即可触发 Jetsam 机制，强杀 App，那么<strong>最后一次打印的内存占用也就是当前设备的内存上限值</strong>。</p><p>timer = [NSTimer scheduledTimerWithTimeInterval:0.01 target:self selector:@selector(allocateMemory) userInfo:nil repeats:YES];</p><ul><li><p>(void)allocateMemory {<br>  UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];<br>  UIImage *image = [UIImage imageNamed:@”AppIcon”];<br>  imageView.image = image;<br>  [array addObject:imageView];</p><p>  memoryLimitSizeMB = [self usedSizeOfMemory];<br>  if (memoryWarningSizeMB &amp;&amp; memoryLimitSizeMB) {</p><pre><code>  NSLog(@&quot;----- memory warnning:%dMB, memory limit:%dMB&quot;, memoryWarningSizeMB, memoryLimitSizeMB);</code></pre><p>  }<br>}</p></li><li><p>(int)usedSizeOfMemory {<br>  task_vm_info_data_t taskInfo;<br>  mach_msg_type_number_t infoCount = TASK_VM_INFO_COUNT;<br>  kern_return_t kernReturn = task_info(mach_task_self(), TASK_VM_INFO, (task_info_t)&amp;taskInfo, &amp;infoCount);</p><p>  if (kernReturn != KERN_SUCCESS) {</p><pre><code>  return 0;</code></pre><p>  }<br>  return (int)(taskInfo.phys_footprint/1024.0/1024.0);<br>}</p></li></ul><h4 id="3-4-适用于-iOS13-系统的获取方式"><a href="#3-4-适用于-iOS13-系统的获取方式" class="headerlink" title="3.4 适用于 iOS13 系统的获取方式"></a>3.4 适用于 iOS13 系统的获取方式</h4><p>iOS13 开始 &lt;os/proc.h&gt; 中 <code>size_t os_proc_available_memory(void);</code> 可以查看当前可用内存。</p><blockquote><p>Return Value</p><p>The number of bytes that the app may allocate before it hits its memory limit. If the calling process isn’t an app, or if the process has already exceeded its memory limit, this function returns <code>0</code>.</p><p>Discussion</p><p>Call this function to determine the amount of memory available to your app. The returned value corresponds to the current memory limit minus the memory footprint of your app at the time of the function call. Your app’s memory footprint consists of the data that you allocated in RAM, and that must stay in RAM (or the equivalent) at all times. Memory limits can change during the app life cycle and don’t necessarily correspond to the amount of physical memory available on the device.</p><p>Use the returned value as advisory information only and don’t cache it. The precise value changes when your app does any work that affects memory, which can happen frequently.</p><p>Although this function lets you determine the amount of memory your app may safely consume, don’t use it to maximize your app’s memory usage. Significant memory use, even when under the current memory limit, affects system performance. For example, when your app consumes all of its available memory, the system may need to terminate other apps and system processes to accommodate your app’s requests. Instead, always consume the smallest amount of memory you need to be responsive to the user’s needs.</p><p>If you need more detailed information about the available memory resources, you can call <code>task_info</code>. However, be aware that <code>task_info</code> is an expensive call, whereas this function is much more efficient.</p></blockquote><p>if (@available(iOS 13.0, *)) {<br>    return os_proc_available_memory() / 1024.0 / 1024.0;<br>}</p><p>App 内存信息的 API 可以在 Mach 层找到，<code>mach_task_basic_info</code> 结构体存储了 Mach task 的内存使用信息，其中 phys_footprint 就是应用使用的物理内存大小，virtual_size 是虚拟内存大小。</p><p>#define MACH_TASK_BASIC_INFO     20         /* always 64-bit basic info */<br>struct mach_task_basic_info {<br>    mach_vm_size_t  virtual_size;       /* virtual memory size (bytes) */<br>    mach_vm_size_t  resident_size;      /* resident memory size (bytes) */<br>    mach_vm_size_t  resident_size_max;  /* maximum resident memory size (bytes) */<br>    time_value_t    user_time;          /* total user run time for<br>                                            terminated threads */<br>    time_value_t    system_time;        /* total system run time for<br>                                            terminated threads */<br>    policy_t        policy;             /* default policy for new threads */<br>    integer_t       suspend_count;      /* suspend count for task */<br>};</p><p>所以获取代码为</p><p>task_vm_info_data_t vmInfo;<br>mach_msg_type_number_t count = TASK_VM_INFO_COUNT;<br>kern_return_t kr = task_info(mach_task_self(), TASK_VM_INFO, (task_info_t)&amp;vmInfo, &amp;count);</p><p>if (kr != KERN_SUCCESS) {<br>    return ;<br>}<br>CGFloat memoryUsed = (CGFloat)(vmInfo.phys_footprint/1024.0/1024.0);</p><p>可能有人好奇不应该是 <code>resident_size</code> 这个字段获取内存的使用情况吗？一开始测试后发现 resident_size 和 Xcode 测量结果差距较大。而使用 phys_footprint 则接近于 Xcode 给出的结果。且可以从 <a href="https://link.segmentfault.com/?enc=JnwZOCCjfSuM+5Ot/DLidg==.cYB5AHuFJs5/6Be4sEnT/CDIRxgf1D0geQbZ5W2vvtXQxvYEPRKMVYgeJt8rGaYhaU+rrfaezYhQI3h+pGMETDhUijv+K1JrciXQb9ArAJQfyT545MlJlPC6OLcyu6GtxVj+tlQVIxC1wNk9sbg6C5Dynbwf7TCURqKmnF39nIk=">WebKit 源码</a>中得到印证。</p><p>所以在 iOS13 上，我们可以通过 <code>os_proc_available_memory</code> 获取到当前可以用内存，通过 <code>phys_footprint</code> 获取到当前 App 占用内存，2者的和也就是当前设备的内存上限，超过即触发 Jetsam 机制。</p><p>- (CGFloat)limitSizeOfMemory {<br>    if (@available(iOS 13.0, *)) {<br>        task_vm_info_data_t taskInfo;<br>        mach_msg_type_number_t infoCount = TASK_VM_INFO_COUNT;<br>        kern_return_t kernReturn = task_info(mach_task_self(), TASK_VM_INFO, (task_info_t)&amp;taskInfo, &amp;infoCount);</p><pre><code>    if (kernReturn != KERN\_SUCCESS) &#123;        return 0;    &#125;    return (CGFloat)((taskInfo.phys\_footprint + os\_proc\_available\_memory()) / (1024.0 \* 1024.0);&#125;return 0;</code></pre><p>}</p><p>当前可以使用内存：1435.936752MB；当前 App 已占用内存：14.5MB，临界值：1435.936752MB + 14.5MB= 1450.436MB， 和 3.1 方法中获取到的内存临界值一样「iPhone 6s plus/13.3.1 手机 OOM 临界值为：(16384*92806)/(1024*1024)=1450.09375M」。</p><h4 id="3-5-通过-XNU-获取内存限制值"><a href="#3-5-通过-XNU-获取内存限制值" class="headerlink" title="3.5 通过 XNU 获取内存限制值"></a>3.5 通过 XNU 获取内存限制值</h4><p>在 XNU 中，有专门用于获取内存上限值的函数和宏，可以通过 <code>memorystatus_priority_entry</code> 这个结构体得到所有进程的优先级和内存限制值。</p><p>typedef struct memorystatus_priority_entry {<br>  pid_t pid;<br>  int32_t priority;<br>  uint64_t user_data;<br>  int32_t limit;<br>  uint32_t state;<br>} memorystatus_priority_entry_t;</p><p>其中，priority 代表进程优先级，limit 代表进程的内存限制值。但是这种方式需要 root 权限，由于没有越狱设备，我没有尝试过。</p><p>相关代码可查阅 <code>kern_memorystatus.h</code> 文件。需要用到函数 <code>int memorystatus_control(uint32_t command, int32_t pid, uint32_t flags, void *buffer, size_t buffersize);</code></p><p>/* Commands */<br>#define MEMORYSTATUS_CMD_GET_PRIORITY_LIST            1<br>#define MEMORYSTATUS_CMD_SET_PRIORITY_PROPERTIES      2<br>#define MEMORYSTATUS_CMD_GET_JETSAM_SNAPSHOT          3<br>#define MEMORYSTATUS_CMD_GET_PRESSURE_STATUS          4<br>#define MEMORYSTATUS_CMD_SET_JETSAM_HIGH_WATER_MARK   5    /* Set active memory limit = inactive memory limit, both non-fatal    */<br>#define MEMORYSTATUS_CMD_SET_JETSAM_TASK_LIMIT          6    /* Set active memory limit = inactive memory limit, both fatal    */<br>#define MEMORYSTATUS_CMD_SET_MEMLIMIT_PROPERTIES      7    /* Set memory limits plus attributes independently            */<br>#define MEMORYSTATUS_CMD_GET_MEMLIMIT_PROPERTIES      8    /* Get memory limits plus attributes                    */<br>#define MEMORYSTATUS_CMD_PRIVILEGED_LISTENER_ENABLE   9    /* Set the task’s status as a privileged listener w.r.t memory notifications  */<br>#define MEMORYSTATUS_CMD_PRIVILEGED_LISTENER_DISABLE  10   /* Reset the task’s status as a privileged listener w.r.t memory notifications  */<br>#define MEMORYSTATUS_CMD_AGGRESSIVE_JETSAM_LENIENT_MODE_ENABLE  11   /* Enable the ‘lenient’ mode for aggressive jetsam. See comments in kern_memorystatus.c near the top. */<br>#define MEMORYSTATUS_CMD_AGGRESSIVE_JETSAM_LENIENT_MODE_DISABLE 12   /* Disable the ‘lenient’ mode for aggressive jetsam. */<br>#define MEMORYSTATUS_CMD_GET_MEMLIMIT_EXCESS          13   /* Compute how much a process’s phys_footprint exceeds inactive memory limit */<br>#define MEMORYSTATUS_CMD_ELEVATED_INACTIVEJETSAMPRIORITY_ENABLE     14 /* Set the inactive jetsam band for a process to JETSAM_PRIORITY_ELEVATED_INACTIVE */<br>#define MEMORYSTATUS_CMD_ELEVATED_INACTIVEJETSAMPRIORITY_DISABLE     15 /* Reset the inactive jetsam band for a process to the default band (0)*/<br>#define MEMORYSTATUS_CMD_SET_PROCESS_IS_MANAGED       16   /* (Re-)Set state on a process that marks it as (un-)managed by a system entity e.g. assertiond */<br>#define MEMORYSTATUS_CMD_GET_PROCESS_IS_MANAGED       17   /* Return the ‘managed’ status of a process */<br>#define MEMORYSTATUS_CMD_SET_PROCESS_IS_FREEZABLE     18   /* Is the process eligible for freezing? Apps and extensions can pass in FALSE to opt out of freezing, i.e.,</p><p>伪代码</p><p>struct memorystatus_priority_entry memStatus[NUM_ENTRIES];<br>size_t count = sizeof(struct memorystatus_priority_entry) * NUM_ENTRIES;<br>int kernResult = memorystatus_control(MEMORYSTATUS_CMD_GET_PRIORITY_LIST, 0, 0, memStatus, count);<br>if (rc &lt; 0) {<br>  NSLog(@”memorystatus_control”);<br>    return ;<br>}</p><p>int entry = 0;<br>for (; rc &gt; 0; rc -= sizeof(struct memorystatus_priority_entry)){<br>  printf (“PID: %5d\tPriority:%2d\tUser Data: %llx\tLimit:%2d\tState:%s\n”,<br>          memstatus[entry].pid,<br>          memstatus[entry].priority,<br>          memstatus[entry].user_data,<br>          memstatus[entry].limit,<br>          state_to_text(memstatus[entry].state));<br>  entry++;<br>}</p><p>for 循环打印出每个进程（也就是 App）的 pid、Priority、User Data、Limit、State 信息。从 log 中找出优先级为10的进程，即我们前台运行的 App。为什么是10？ 因为 <code>#define JETSAM_PRIORITY_FOREGROUND 10</code> 我们的目的就是获取前台 App 的内存上限值。</p><h3 id="4-如何判定发生了-OOM"><a href="#4-如何判定发生了-OOM" class="headerlink" title="4. 如何判定发生了 OOM"></a>4. 如何判定发生了 OOM</h3><p>OOM 导致 crash 前，app 一定会收到低内存警告吗？</p><p>做2组对比实验：</p><p>// 实验1<br>NSMutableArray *array = [NSMutableArray array];<br>for (NSInteger index = 0; index &lt; 10000000; index++) {<br>  NSString *filePath = [[NSBundle mainBundle] pathForResource:@”Info” ofType:@”plist”];<br>  NSData *data = [NSData dataWithContentsOfFile:filePath];<br>  [array addObject:data];<br>}</p><p>// 实验2<br>// ViewController.m</p><ul><li>(void)viewDidLoad {<br>  [super viewDidLoad];<br>  dispatch_async(dispatch_get_global_queue(0, 0), ^{<pre><code>  NSMutableArray \*array = \[NSMutableArray array\];  for (NSInteger index = 0; index &lt; 10000000; index++) &#123;      NSString \*filePath = \[\[NSBundle mainBundle\] pathForResource:@&quot;Info&quot; ofType:@&quot;plist&quot;\];      NSData \*data = \[NSData dataWithContentsOfFile:filePath\];      \[array addObject:data\];  &#125;</code></pre>  });<br>}</li><li>(void)didReceiveMemoryWarning<br>{<br>  NSLog(@”2”);<br>}</li></ul><p>// AppDelegate.m</p><ul><li>(void)applicationDidReceiveMemoryWarning:(UIApplication *)application<br>{<br>  NSLog(@”1”);<br>}</li></ul><p>现象：</p><ol><li> 在 viewDidLoad 也就是主线程中内存消耗过大，系统并不会发出低内存警告，直接 Crash。因为内存增长过快，主线程很忙。</li><li> 多线程的情况下，App 因内存增长过快，会收到低内存警告，AppDelegate 中的<code>applicationDidReceiveMemoryWarning</code> 先执行，随后是当前 VC 的 <code>didReceiveMemoryWarning</code>。</li></ol><p>结论：</p><p><strong>收到低内存警告不一定会 Crash，因为有6秒钟的系统判断时间，6秒内内存下降了则不会 crash。发生 OOM 也不一定会收到低内存警告。</strong></p><h3 id="5-内存信息收集"><a href="#5-内存信息收集" class="headerlink" title="5. 内存信息收集"></a>5. 内存信息收集</h3><p>要想精确的定位问题，就需要 dump 所有对象及其内存信息。当内存接近系统内存上限的时候，收集并记录所需信息，结合一定的数据上报机制，上传到服务器，分析并修复。</p><p>还需要知道每个对象具体是在哪个函数里创建出来的，以便还原“案发现场”。</p><p>源代码（libmalloc/malloc），内存分配函数 malloc 和 calloc 等默认使用 nano_zone，nano_zone 是小于 256B 以下的内存分配，大于 256B 则使用 scalable_zone 来分配。</p><p>主要针对大内存的分配监控。malloc 函数用的是 malloc_zone_malloc, calloc 用的是 malloc_zone_calloc。</p><p>使用 scalable_zone 分配内存的函数都会调用 malloc_logger 函数，因为系统为了有个地方专门统计并管理内存分配情况。这样的设计也满足「收口原则」。</p><p>void *<br>malloc(size_t size) {<br>    void *retval;<br>    retval = malloc_zone_malloc(default_zone, size);<br>    if (retval == NULL) {<br>        errno = ENOMEM;<br>    }<br>    return retval;<br>}</p><p>void *<br>calloc(size_t num_items, size_t size) {<br>    void *retval;<br>    retval = malloc_zone_calloc(default_zone, num_items, size);<br>    if (retval == NULL) {<br>        errno = ENOMEM;<br>    }<br>    return retval;<br>}</p><p>首先来看看这个 <code>default_zone</code> 是什么东西, 代码如下</p><p>typedef struct {<br>    malloc_zone_t malloc_zone;<br>    uint8_t pad[PAGE_MAX_SIZE - sizeof(malloc_zone_t)];<br>} virtual_default_zone_t;</p><p>static virtual_default_zone_t virtual_default_zone<br>__attribute__((section(“__DATA,__v_zone”)))<br>__attribute__((aligned(PAGE_MAX_SIZE))) = {<br>    NULL,<br>    NULL,<br>    default_zone_size,<br>    default_zone_malloc,<br>    default_zone_calloc,<br>    default_zone_valloc,<br>    default_zone_free,<br>    default_zone_realloc,<br>    default_zone_destroy,<br>    DEFAULT_MALLOC_ZONE_STRING,<br>    default_zone_batch_malloc,<br>    default_zone_batch_free,<br>    &amp;default_zone_introspect,<br>    10,<br>    default_zone_memalign,<br>    default_zone_free_definite_size,<br>    default_zone_pressure_relief,<br>    default_zone_malloc_claimed_address,<br>};</p><p>static malloc_zone_t *default_zone = &amp;virtual_default_zone.malloc_zone;</p><p>static void *<br>default_zone_malloc(malloc_zone_t *zone, size_t size) {<br>    zone = runtime_default_zone();</p><pre><code>return zone-&gt;malloc(zone, size);</code></pre><p>}</p><p>MALLOC_ALWAYS_INLINE<br>static inline malloc_zone_t *<br>runtime_default_zone() {<br>    return (lite_zone) ? lite_zone : inline_malloc_default_zone();<br>}</p><p>可以看到 <code>default_zone</code> 通过这种方式来初始化</p><p>static inline malloc_zone_t *<br>inline_malloc_default_zone(void) {<br>    _malloc_initialize_once();<br>    // malloc_report(ASL_LEVEL_INFO, “In inline_malloc_default_zone with %d %d\n”, malloc_num_zones, malloc_has_debug_zone);<br>    return malloc_zones[0];<br>}</p><p><strong>随后的调用如下</strong><br><code>_malloc_initialize</code> -&gt; <code>create_scalable_zone</code> -&gt; <code>create_scalable_szone</code> 最终我们创建了 szone_t 类型的对象，通过类型转换，得到了我们的 default_zone。</p><p>malloc_zone_t *<br>create_scalable_zone(size_t initial_size, unsigned debug_flags) {<br>    return (malloc_zone_t *) create_scalable_szone(initial_size, debug_flags);<br>}</p><p>void *malloc_zone_malloc(malloc_zone_t *zone, size_t size) {<br>  MALLOC_TRACE(TRACE_malloc | DBG_FUNC_START, (uintptr_t)zone, size, 0, 0);<br>  void *ptr;<br>  if (malloc_check_start &amp;&amp; (malloc_check_counter++ &gt;= malloc_check_start)) {<br>    internal_check();<br>  }<br>  if (size &gt; MALLOC_ABSOLUTE_MAX_SIZE) {<br>    return NULL;<br>  }<br>  ptr = zone-&gt;malloc(zone, size);<br>  // 在 zone 分配完内存后就开始使用 malloc_logger 进行进行记录<br>  if (malloc_logger) {<br>    malloc_logger(MALLOC_LOG_TYPE_ALLOCATE | MALLOC_LOG_TYPE_HAS_ZONE, (uintptr_t)zone, (uintptr_t)size, 0, (uintptr_t)ptr, 0);<br>  }<br>  MALLOC_TRACE(TRACE_malloc | DBG_FUNC_END, (uintptr_t)zone, size, (uintptr_t)ptr, 0);<br>  return ptr;<br>}</p><p>其分配实现是 <code>zone-&gt;malloc</code> 根据之前的分析，就是szone_t结构体对象中对应的malloc实现。</p><p>在创建szone之后，做了一系列如下的初始化操作。</p><p>// Initialize the security token.<br>szone-&gt;cookie = (uintptr_t)malloc_entropy[0];</p><p>szone-&gt;basic_zone.version = 12;<br>szone-&gt;basic_zone.size = (void *)szone_size;<br>szone-&gt;basic_zone.malloc = (void *)szone_malloc;<br>szone-&gt;basic_zone.calloc = (void *)szone_calloc;<br>szone-&gt;basic_zone.valloc = (void *)szone_valloc;<br>szone-&gt;basic_zone.free = (void *)szone_free;<br>szone-&gt;basic_zone.realloc = (void *)szone_realloc;<br>szone-&gt;basic_zone.destroy = (void *)szone_destroy;<br>szone-&gt;basic_zone.batch_malloc = (void *)szone_batch_malloc;<br>szone-&gt;basic_zone.batch_free = (void *)szone_batch_free;<br>szone-&gt;basic_zone.introspect = (struct malloc_introspection_t *)&amp;szone_introspect;<br>szone-&gt;basic_zone.memalign = (void *)szone_memalign;<br>szone-&gt;basic_zone.free_definite_size = (void *)szone_free_definite_size;<br>szone-&gt;basic_zone.pressure_relief = (void *)szone_pressure_relief;<br>szone-&gt;basic_zone.claimed_address = (void *)szone_claimed_address;</p><p>其他使用 scalable_zone 分配内存的函数的方法也类似，所以大内存的分配，不管外部函数如何封装，最终都会调用到 malloc_logger 函数。所以我们可以用 fishhook 去 hook 这个函数，然后记录内存分配情况，结合一定的数据上报机制，上传到服务器，分析并修复。</p><p>// For logging VM allocation and deallocation, arg1 here<br>// is the mach_port_name_t of the target task in which the<br>// alloc or dealloc is occurring. For example, for mmap()<br>// that would be mach_task_self(), but for a cross-task-capable<br>// call such as mach_vm_map(), it is the target task.</p><p>typedef void (malloc_logger_t)(uint32_t type, uintptr_t arg1, uintptr_t arg2, uintptr_t arg3, uintptr_t result, uint32_t num_hot_frames_to_skip);</p><p>extern malloc_logger_t *__syscall_logger;</p><p>当 malloc_logger 和 __syscall_logger 函数指针不为空时，malloc/free、vm_allocate/vm_deallocate 等内存分配/释放通过这两个指针通知上层，这也是内存调试工具 malloc stack 的实现原理。有了这两个函数指针，我们很容易记录当前存活对象的内存分配信息（包括分配大小和分配堆栈）。分配堆栈可以用 backtrace 函数捕获，但捕获到的地址是虚拟内存地址，不能从符号表 DSYM 解析符号。所以还要记录每个 image 加载时的偏移 slide，这样 <strong>符号表地址 = 堆栈地址 - slide。</strong></p><p>小 tips：</p><p>ASLR（Address space layout randomization）：常见称呼为位址空间随机载入、位址空间配置随机化、位址空间布局随机化，是一种防止内存损坏漏洞被利用的计算机安全技术，通过随机放置进程关键数据区域的定址空间来放置攻击者能可靠地跳转到内存的特定位置来操作函数。现代作业系统一般都具备该机制。</p><p>函数地址 add: 函数真实的实现地址;</p><p>函数虚拟地址：<code>vm_add</code>;</p><p>ASLR: <code>slide</code> 函数虚拟地址加载到进程内存的随机偏移量，每个 mach-o 的 slide 各不相同。<code>vm_add + slide = add</code>。也就是：<code>*(base +offset)= imp</code>。</p><p>由于腾讯也开源了自己的 OOM 定位方案- <a href="https://link.segmentfault.com/?enc=yKbHc3af98aQlln5PiMykQ==.TLNJTvH5g0hkQIcULZcKaEhuB4PrGx64mTZELylFElD2YaHmAbY9Klysfkjwk8a/">OOMDetector</a> ，有了现成的轮子，那么用好就可以了，所以对于内存的监控思路就是找到系统给 App 的内存上限，然后当接近内存上限值的时候，dump 内存情况，组装基础数据信息成一个合格的上报数据，经过一定的数据上报策略到服务端，服务端消费数据，分析产生报表，客户端工程师根据报表分析问题。不同工程的数据以邮件、短信、企业微信等形式通知到该项目的 owner、开发者。（情况严重的会直接电话给开发者，并给主管跟进每一步的处理结果）。<br>问题分析处理后要么发布新版本，要么 hot fix。</p><h3 id="6-开发阶段针对内存我们能做些什么"><a href="#6-开发阶段针对内存我们能做些什么" class="headerlink" title="6. 开发阶段针对内存我们能做些什么"></a>6. 开发阶段针对内存我们能做些什么</h3><ol><li><p>图片缩放</p><p> WWDC 2018 Session 416 - iOS Memory Deep Dive，处理图片缩放的时候直接使用 UIImage 会在解码时读取文件而占用一部分内存，还会生成中间位图 bitmap 消耗大量内存。而 <strong>ImageIO</strong> 不存在上述2种弊端，只会占用最终图片大小的内存</p><p> 做了2组对比实验：给 App 显示一张图片</p><p> // 方法1: 19.6M<br> UIImage *imageResult = [self scaleImage:[UIImage imageNamed:@”test”]                                                  newSize:CGSizeMake(self.view.frame.size.width, self.view.frame.size.height)];<br> self.imageView.image = imageResult;</p><p> // 方法2: 14M<br> NSData *data = UIImagePNGRepresentation([UIImage imageNamed:@”test”]);<br> UIImage *imageResult = [self scaledImageWithData:data                     withSize:CGSizeMake(self.view.frame.size.width, self.view.frame.size.height) scale:3 orientation:UIImageOrientationUp];<br> self.imageView.image = imageResult;</p><ul><li><p>(UIImage *)scaleImage:(UIImage *)image newSize:(CGSize)newSize<br>{<br>  UIGraphicsBeginImageContextWithOptions(newSize, NO, 0);<br>  [image drawInRect:CGRectMake(0, 0, newSize.width, newSize.height)];<br>  UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();<br>  UIGraphicsEndImageContext();<br>  return newImage;<br>}</p></li><li><p>(UIImage *)scaledImageWithData:(NSData *)data withSize:(CGSize)size scale:(CGFloat)scale orientation:(UIImageOrientation)orientation<br>{<br>  CGFloat maxPixelSize = MAX(size.width, size.height);<br>  CGImageSourceRef sourceRef = CGImageSourceCreateWithData((__bridge CFDataRef)data, nil);<br>  NSDictionary *options = @{(__bridge id)kCGImageSourceCreateThumbnailFromImageAlways : (__bridge id)kCFBooleanTrue,</p><pre><code>                        (\_\_bridge id)kCGImageSourceThumbnailMaxPixelSize : \[NSNumber numberWithFloat:maxPixelSize\]&#125;;</code></pre><p>  CGImageRef imageRef = CGImageSourceCreateThumbnailAtIndex(sourceRef, 0, (__bridge CFDictionaryRef)options);<br>  UIImage *resultImage = [UIImage imageWithCGImage:imageRef scale:scale orientation:orientation];<br>  CGImageRelease(imageRef);<br>  CFRelease(sourceRef);<br>  return resultImage;<br>}</p></li></ul></li></ol><p>可以看出使用 ImageIO 比使用 UIImage 直接缩放占用内存更低。</p><ol start="2"><li><p>合理使用 autoreleasepool</p><p> 我们知道 autoreleasepool 对象是在 RunLoop 结束时才释放。在 ARC 下，我们如果在不断申请内存，比如各种循环，那么我们就需要手动添加 autoreleasepool，避免短时间内内存猛涨发生 OOM。</p><p> 对比实验</p><p> // 实验1<br> NSMutableArray *array = [NSMutableArray array];<br> for (NSInteger index = 0; index &lt; 10000000; index++) {<br>  NSString *indexStrng = [NSString stringWithFormat:@”%zd”, index];<br>  NSString *resultString = [NSString stringWithFormat:@”%zd-%@”, index, indexStrng];<br>  [array addObject:resultString];<br> }</p><p> // 实验2<br> NSMutableArray *array = [NSMutableArray array];<br> for (NSInteger index = 0; index &lt; 10000000; index++) {<br>  @autoreleasepool {<br>  NSString *indexStrng = [NSString stringWithFormat:@”%zd”, index];<br>  NSString *resultString = [NSString stringWithFormat:@”%zd-%@”, index, indexStrng];<br>  [array addObject:resultString];<br>  }<br> }</p></li></ol><p>实验1消耗内存 739.6M，实验2消耗内存 587M。</p><ol start="3"><li><p> UIGraphicsBeginImageContext 和 UIGraphicsEndImageContext 必须成双出现，不然会造成 context 泄漏。另外 XCode 的 Analyze 也能扫出这类问题。</p></li><li><p> 不管是打开网页，还是执行 js，都应该使用 WKWebView。UIWebView 会占用大量内存，从而导致 App 发生 OOM 的几率增加，而 WKWebView 是一个多进程组件，Network Loading 以及 UI Rendering 在其它进程中执行，比 UIWebView 占用更低的内存开销。</p></li><li><p>在做 SDK 或者 App，如果场景是缓存相关，尽量使用 NSCache 而不是 NSMutableDictionary。它是系统提供的专门处理缓存的类，NSCache 分配的内存是 <code>Purgeable Memory</code>，可以由系统自动释放。NSCache 与 NSPureableData 的结合使用可以让系统根据情况回收内存，也可以在内存清理时移除对象。</p><p> 其他的开发习惯就不一一描述了，良好的开发习惯和代码意识是需要平时注意修炼的。</p></li></ol><h3 id="7-现状及其改进"><a href="#7-现状及其改进" class="headerlink" title="7. 现状及其改进"></a>7. 现状及其改进</h3><p>在使用了一波业界优秀的的内存监控工具后发现了一些问题，比如 <code>MLeaksFinder</code>、<code>OOMDetector</code>、<code>FBRetainCycleDetector</code>等都有一些问题。比如 <code>MLeaksFinder</code> 因为单纯通过 VC 的 push、pop 等检测内存泄露的情况，会存在误报的情况。<code>FBRetainCycleDetector</code> 则因为对象深度优先遍历，会有一些性能问题，影响 App 性能。<code>OOMDetector</code> 因为没有合适的触发时机。</p><p>思路有2种：</p><ul><li>  <code>MLeaksFinder</code> + <code>FBRetainCycleDetector</code> 结合提高准确性</li><li>  借鉴头条的实现方案：基于内存快照技术的线上方案，我们称之为——线上 Memory Graph。（引用如下）</li></ul><blockquote><ul><li>  基于 Objective-C 对象引用关系找循环引用的方案，适用范围比较小，只能处理部分循环引用问题，而内存问题通常是复杂的，类似于内存堆积，Root Leak，C/C++层问题都无法解决。</li><li>  基于分配堆栈信息聚类的方案需要常驻运行，对内存、CPU 等资源存在较大消耗，无法针对有内存问题的用户进行监控，只能广撒网，用户体验影响较大。同时，通过某些比较通用的堆栈分配的内存无法定位出实际的内存使用场景，对于循环引用等常见泄漏也无法分析。</li></ul></blockquote><p>核心原理是： 扫描进程中所有的 Dirty 内存，通过内存节点中保存的其他内存节点的地址值，建立起内存节点之间的引用关系的有向图。</p><p>全部的讲解可以看这里)。对于 Memory Graph 的实现细节感兴趣的可以看这篇<a href="https://link.segmentfault.com/?enc=JCBA55CJcQityylTd2V54w==.YaCpcpVk5R35as3/ROYixsLzKFlCP2yFYxf4IsraLh/EQjp7u9kioXChaJGQzACX">文章</a></p><h2 id="五、-App-网络监控"><a href="#五、-App-网络监控" class="headerlink" title="五、 App 网络监控"></a>五、 App 网络监控</h2><p>移动网络环境一直很复杂，WIFI、2G、3G、4G、5G 等，用户使用 App 的过程中可能在这几种类型之间切换，这也是移动网络和传统网络间的一个区别，被称为「Connection Migration」。此外还存在 DNS 解析缓慢、失败率高、运营商劫持等问题。用户在使用 App 时因为某些原因导致体验很差，要想针对网络情况进行改善，必须有清晰的监控手段。</p><h3 id="1-App-网络请求过程"><a href="#1-App-网络请求过程" class="headerlink" title="1. App 网络请求过程"></a>1. App 网络请求过程</h3><p><img src="https://segmentfault.com/img/bVbIOhA"></p><p>App 发送一次网络请求一般会经历下面几个关键步骤：</p><ul><li><p>DNS 解析</p><p>  Domain Name system，网络域名名称系统，本质上就是将<code>域名</code>和<code>IP 地址</code> 相互映射的一个分布式数据库，使人们更方便的访问互联网。首先会查询本地的 DNS 缓存，查找失败就去 DNS 服务器查询，这其中可能会经过非常多的节点，涉及到<strong>递归查询和迭代查询</strong>的过程。运营商可能不干人事：一种情况就是出现运营商劫持的现象，表现为你在 App 内访问某个网页的时候会看到和内容不相关的广告；另一种可能的情况就是把你的请求丢给非常远的基站去做 DNS 解析，导致我们 App 的 DNS 解析时间较长，App 网络效率低。一般做 HTTPDNS 方案去自行解决 DNS 的问题。</p></li><li><p>TCP 3次握手</p><p>  关于 TCP 握手过程中为什么是3次握手而不是2次、4次，可以查看这篇<a href="https://link.segmentfault.com/?enc=4bf4fIci5+2SfwGhscbC8A==.JejU/qg7VrCdv+zxcQmevbCzhRa1Cmx81mmRYmh1XkWKMZhUAMuy+3VW42U2OI1iy1tkPAqSWzWeVDDOI15+9g==">文章</a>。</p></li><li><p>TLS 握手</p><p>  对于 HTTPS 请求还需要做 TLS 握手，也就是密钥协商的过程。</p></li><li><p>发送请求</p><p>  连接建立好之后就可以发送 request，此时可以记录下 request start 时间</p></li><li><p>等待回应</p><p>  等待服务器返回响应。这个时间主要取决于资源大小，也是网络请求过程中最为耗时的一个阶段。</p></li><li><p>返回响应</p><p>  服务端返回响应给客户端，根据 HTTP header 信息中的状态码判断本次请求是否成功、是否走缓存、是否需要重定向。</p></li></ul><h3 id="2-监控原理"><a href="#2-监控原理" class="headerlink" title="2. 监控原理"></a>2. 监控原理</h3><p>名称</p><p>说明</p><p>NSURLConnection</p><p>已经被废弃。用法简单</p><p>NSURLSession</p><p>iOS7.0 推出，功能更强大</p><p>CFNetwork</p><p>NSURL 的底层，纯 C 实现</p><p>iOS 网络框架层级关系如下：</p><p><img src="https://segmentfault.com/img/bVbIOhF"></p><p>iOS 网络现状是由4层组成的：最底层的 BSD Sockets、SecureTransport；次级底层是 CFNetwork、NSURLSession、NSURLConnection、WebView 是用 Objective-C 实现的，且调用 CFNetwork；应用层框架 AFNetworking 基于 NSURLSession、NSURLConnection 实现。</p><p>目前业界对于网络监控主要有2种：一种是通过 NSURLProtocol 监控、一种是通过 Hook 来监控。下面介绍几种办法来监控网络请求，各有优缺点。</p><h4 id="2-1-方案一：NSURLProtocol-监控-App-网络请求"><a href="#2-1-方案一：NSURLProtocol-监控-App-网络请求" class="headerlink" title="2.1 方案一：NSURLProtocol 监控 App 网络请求"></a>2.1 方案一：NSURLProtocol 监控 App 网络请求</h4><p>NSURLProtocol 作为上层接口，使用较为简单，但 NSURLProtocol 属于 URL Loading System 体系中。应用协议的支持程度有限，支持 FTP、HTTP、HTTPS 等几个应用层协议，对于其他的协议则无法监控，存在一定的局限性。如果监控底层网络库 CFNetwork 则没有这个限制。</p><p>对于 NSURLProtocol 的具体做法在<a href="https://link.segmentfault.com/?enc=32MAqCv5rRh1xG9swBrweQ==.waVikw52hdsc0HH/KXTAhq1AbWxJWzODd9KmUKRpFe0ys3u+yRMdMdKnPLFVrtinIpYrvdbyeC33qKZqTeuJx8TDkWj/hIeStA+z7zej8a/ZVIlwwrLHg+MKzIhLU5BM">这篇文章</a>中讲过，继承抽象类并实现相应的方法，自定义去发起网络请求来实现监控的目的。</p><p>iOS 10 之后，NSURLSessionTaskDelegate 中增加了一个新的代理方法：</p><p>/*<br> * Sent when complete statistics information has been collected for the task.<br> */</p><ul><li>(void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didFinishCollectingMetrics:(NSURLSessionTaskMetrics *)metrics API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));</li></ul><p>可以从 <code>NSURLSessionTaskMetrics</code> 中获取到网络情况的各项指标。各项参数如下</p><p>@interface NSURLSessionTaskMetrics : NSObject</p><p>/*<br> * transactionMetrics array contains the metrics collected for every request/response transaction created during the task execution.<br> */<br>@property (copy, readonly) NSArray&lt;NSURLSessionTaskTransactionMetrics *&gt; *transactionMetrics;</p><p>/*<br> * Interval from the task creation time to the task completion time.<br> * Task creation time is the time when the task was instantiated.<br> * Task completion time is the time when the task is about to change its internal state to completed.<br> */<br>@property (copy, readonly) NSDateInterval *taskInterval;</p><p>/*<br> * redirectCount is the number of redirects that were recorded.<br> */<br>@property (assign, readonly) NSUInteger redirectCount;</p><ul><li>(instancetype)init API_DEPRECATED(“Not supported”, macos(10.12,10.15), ios(10.0,13.0), watchos(3.0,6.0), tvos(10.0,13.0));</li></ul><ul><li>(instancetype)new API_DEPRECATED(“Not supported”, macos(10.12,10.15), ios(10.0,13.0), watchos(3.0,6.0), tvos(10.0,13.0));</li></ul><p>@end</p><p>其中：<code>taskInterval</code> 表示任务从创建到完成话费的总时间，任务的创建时间是任务被实例化时的时间，任务完成时间是任务的内部状态将要变为完成的时间；<code>redirectCount</code> 表示被重定向的次数；<code>transactionMetrics</code> 数组包含了任务执行过程中每个请求/响应事务中收集的指标，各项参数如下：</p><pre><code>/* * This class defines the performance metrics collected for a request/response transaction during the task execution. */API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0))@interface NSURLSessionTaskTransactionMetrics : NSObject/* * Represents the transaction request. 请求事务 */@property (copy, readonly) NSURLRequest *request;/* * Represents the transaction response. Can be nil if error occurred and no response was generated. 响应事务 */@property (nullable, copy, readonly) NSURLResponse *response;/* * For all NSDate metrics below, if that aspect of the task could not be completed, then the corresponding “EndDate” metric will be nil. * For example, if a name lookup was started but the name lookup timed out, failed, or the client canceled the task before the name could be resolved -- then while domainLookupStartDate may be set, domainLookupEndDate will be nil along with all later metrics. *//* * 客户端开始请求的时间，无论是从服务器还是从本地缓存中获取 * fetchStartDate returns the time when the user agent started fetching the resource, whether or not the resource was retrieved from the server or local resources. * * The following metrics will be set to nil, if a persistent connection was used or the resource was retrieved from local resources: * *   domainLookupStartDate *   domainLookupEndDate *   connectStartDate *   connectEndDate *   secureConnectionStartDate *   secureConnectionEndDate */@property (nullable, copy, readonly) NSDate *fetchStartDate;/* * domainLookupStartDate returns the time immediately before the user agent started the name lookup for the resource. DNS 开始解析的时间 */@property (nullable, copy, readonly) NSDate *domainLookupStartDate;/* * domainLookupEndDate returns the time after the name lookup was completed. DNS 解析完成的时间 */@property (nullable, copy, readonly) NSDate *domainLookupEndDate;/* * connectStartDate is the time immediately before the user agent started establishing the connection to the server. * * For example, this would correspond to the time immediately before the user agent started trying to establish the TCP connection. 客户端与服务端开始建立 TCP 连接的时间 */@property (nullable, copy, readonly) NSDate *connectStartDate;/* * If an encrypted connection was used, secureConnectionStartDate is the time immediately before the user agent started the security handshake to secure the current connection. HTTPS 的 TLS 握手开始的时间 * * For example, this would correspond to the time immediately before the user agent started the TLS handshake.  * * If an encrypted connection was not used, this attribute is set to nil. */@property (nullable, copy, readonly) NSDate *secureConnectionStartDate;/* * If an encrypted connection was used, secureConnectionEndDate is the time immediately after the security handshake completed. HTTPS 的 TLS 握手结束的时间 * * If an encrypted connection was not used, this attribute is set to nil. */@property (nullable, copy, readonly) NSDate *secureConnectionEndDate;/* * connectEndDate is the time immediately after the user agent finished establishing the connection to the server, including completion of security-related and other handshakes. 客户端与服务器建立 TCP 连接完成的时间，包括 TLS 握手时间 */@property (nullable, copy, readonly) NSDate *connectEndDate;/* * requestStartDate is the time immediately before the user agent started requesting the source, regardless of whether the resource was retrieved from the server or local resources. 客户端请求开始的时间，可以理解为开始传输 HTTP 请求的 header 的第一个字节时间 * * For example, this would correspond to the time immediately before the user agent sent an HTTP GET request. */@property (nullable, copy, readonly) NSDate *requestStartDate;/* * requestEndDate is the time immediately after the user agent finished requesting the source, regardless of whether the resource was retrieved from the server or local resources. 客户端请求结束的时间，可以理解为 HTTP 请求的最后一个字节传输完成的时间 * * For example, this would correspond to the time immediately after the user agent finished sending the last byte of the request. */@property (nullable, copy, readonly) NSDate *requestEndDate;/* * responseStartDate is the time immediately after the user agent received the first byte of the response from the server or from local resources. 客户端从服务端接收响应的第一个字节的时间 * * For example, this would correspond to the time immediately after the user agent received the first byte of an HTTP response. */@property (nullable, copy, readonly) NSDate *responseStartDate;/* * responseEndDate is the time immediately after the user agent received the last byte of the resource. 客户端从服务端接收到最后一个请求的时间 */@property (nullable, copy, readonly) NSDate *responseEndDate;/* * The network protocol used to fetch the resource, as identified by the ALPN Protocol ID Identification Sequence [RFC7301]. * E.g., h2, http/1.1, spdy/3.1. 网络协议名，比如 http/1.1, spdy/3.1 * * When a proxy is configured AND a tunnel connection is established, then this attribute returns the value for the tunneled protocol. * * For example: * If no proxy were used, and HTTP/2 was negotiated, then h2 would be returned. * If HTTP/1.1 were used to the proxy, and the tunneled connection was HTTP/2, then h2 would be returned. * If HTTP/1.1 were used to the proxy, and there were no tunnel, then http/1.1 would be returned. * */@property (nullable, copy, readonly) NSString *networkProtocolName;/* * This property is set to YES if a proxy connection was used to fetch the resource.    该连接是否使用了代理 */@property (assign, readonly, getter=isProxyConnection) BOOL proxyConnection;/* * This property is set to YES if a persistent connection was used to fetch the resource. 是否复用了现有连接 */@property (assign, readonly, getter=isReusedConnection) BOOL reusedConnection;/* * Indicates whether the resource was loaded, pushed or retrieved from the local cache. 获取资源来源 */@property (assign, readonly) NSURLSessionTaskMetricsResourceFetchType resourceFetchType;/* * countOfRequestHeaderBytesSent is the number of bytes transferred for request header. 请求头的字节数 */@property (readonly) int64_t countOfRequestHeaderBytesSent API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));/* * countOfRequestBodyBytesSent is the number of bytes transferred for request body. 请求体的字节数 * It includes protocol-specific framing, transfer encoding, and content encoding. */@property (readonly) int64_t countOfRequestBodyBytesSent API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));/* * countOfRequestBodyBytesBeforeEncoding is the size of upload body data, file, or stream. 上传体数据、文件、流的大小 */@property (readonly) int64_t countOfRequestBodyBytesBeforeEncoding API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));/* * countOfResponseHeaderBytesReceived is the number of bytes transferred for response header. 响应头的字节数 */@property (readonly) int64_t countOfResponseHeaderBytesReceived API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));/* * countOfResponseBodyBytesReceived is the number of bytes transferred for response body. 响应体的字节数 * It includes protocol-specific framing, transfer encoding, and content encoding. */@property (readonly) int64_t countOfResponseBodyBytesReceived API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));/* * countOfResponseBodyBytesAfterDecoding is the size of data delivered to your delegate or completion handler.给代理方法或者完成后处理的回调的数据大小 */@property (readonly) int64_t countOfResponseBodyBytesAfterDecoding API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));/* * localAddress is the IP address string of the local interface for the connection.  当前连接下的本地接口 IP 地址 * * For multipath protocols, this is the local address of the initial flow. * * If a connection was not used, this attribute is set to nil. */@property (nullable, copy, readonly) NSString *localAddress API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));/* * localPort is the port number of the local interface for the connection. 当前连接下的本地端口号 * * For multipath protocols, this is the local port of the initial flow. * * If a connection was not used, this attribute is set to nil. */@property (nullable, copy, readonly) NSNumber *localPort API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));/* * remoteAddress is the IP address string of the remote interface for the connection. 当前连接下的远端 IP 地址 * * For multipath protocols, this is the remote address of the initial flow. * * If a connection was not used, this attribute is set to nil. */@property (nullable, copy, readonly) NSString *remoteAddress API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));/* * remotePort is the port number of the remote interface for the connection.  当前连接下的远端端口号 * * For multipath protocols, this is the remote port of the initial flow. * * If a connection was not used, this attribute is set to nil. */@property (nullable, copy, readonly) NSNumber *remotePort API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));/* * negotiatedTLSProtocolVersion is the TLS protocol version negotiated for the connection.  连接协商用的 TLS 协议版本号 * It is a 2-byte sequence in host byte order. * * Please refer to tls_protocol_version_t enum in Security/SecProtocolTypes.h * * If an encrypted connection was not used, this attribute is set to nil. */@property (nullable, copy, readonly) NSNumber *negotiatedTLSProtocolVersion API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));/* * negotiatedTLSCipherSuite is the TLS cipher suite negotiated for the connection. 连接协商用的 TLS 密码套件 * It is a 2-byte sequence in host byte order. * * Please refer to tls_ciphersuite_t enum in Security/SecProtocolTypes.h * * If an encrypted connection was not used, this attribute is set to nil. */@property (nullable, copy, readonly) NSNumber *negotiatedTLSCipherSuite API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));/* * Whether the connection is established over a cellular interface. 是否是通过蜂窝网络建立的连接 */@property (readonly, getter=isCellular) BOOL cellular API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));/* * Whether the connection is established over an expensive interface. 是否通过昂贵的接口建立的连接 */@property (readonly, getter=isExpensive) BOOL expensive API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));/* * Whether the connection is established over a constrained interface. 是否通过受限接口建立的连接 */@property (readonly, getter=isConstrained) BOOL constrained API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));/* * Whether a multipath protocol is successfully negotiated for the connection. 是否为了连接成功协商了多路径协议 */@property (readonly, getter=isMultipath) BOOL multipath API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));- (instancetype)init API_DEPRECATED(&quot;Not supported&quot;, macos(10.12,10.15), ios(10.0,13.0), watchos(3.0,6.0), tvos(10.0,13.0));+ (instancetype)new API_DEPRECATED(&quot;Not supported&quot;, macos(10.12,10.15), ios(10.0,13.0), watchos(3.0,6.0), tvos(10.0,13.0));@end</code></pre><p>网络监控简单代码</p><p>// 监控基础信息<br>@interface  NetworkMonitorBaseDataModel : NSObject<br>// 请求的 URL 地址<br>@property (nonatomic, strong) NSString *requestUrl;<br>//请求头<br>@property (nonatomic, strong) NSArray *requestHeaders;<br>//响应头<br>@property (nonatomic, strong) NSArray *responseHeaders;<br>//GET方法 的请求参数<br>@property (nonatomic, strong) NSString *getRequestParams;<br>//HTTP 方法, 比如 POST<br>@property (nonatomic, strong) NSString *httpMethod;<br>//协议名，如http1.0 / http1.1 / http2.0<br>@property (nonatomic, strong) NSString *httpProtocol;<br>//是否使用代理<br>@property (nonatomic, assign) BOOL useProxy;<br>//DNS解析后的 IP 地址<br>@property (nonatomic, strong) NSString *ip;<br>@end</p><p>// 监控信息模型<br>@interface  NetworkMonitorDataModel : NetworkMonitorBaseDataModel<br>//客户端发起请求的时间<br>@property (nonatomic, assign) UInt64 requestDate;<br>//客户端开始请求到开始dns解析的等待时间,单位ms<br>@property (nonatomic, assign) int waitDNSTime;<br>//DNS 解析耗时<br>@property (nonatomic, assign) int dnsLookupTime;<br>//tcp 三次握手耗时,单位ms<br>@property (nonatomic, assign) int tcpTime;<br>//ssl 握手耗时<br>@property (nonatomic, assign) int sslTime;<br>//一个完整请求的耗时,单位ms<br>@property (nonatomic, assign) int requestTime;<br>//http 响应码<br>@property (nonatomic, assign) NSUInteger httpCode;<br>//发送的字节数<br>@property (nonatomic, assign) UInt64 sendBytes;<br>//接收的字节数<br>@property (nonatomic, assign) UInt64 receiveBytes;</p><p>// 错误信息模型<br>@interface  NetworkMonitorErrorModel : NetworkMonitorBaseDataModel<br>//错误码<br>@property (nonatomic, assign) NSInteger errorCode;<br>//错误次数<br>@property (nonatomic, assign) NSUInteger errCount;<br>//异常名<br>@property (nonatomic, strong) NSString *exceptionName;<br>//异常详情<br>@property (nonatomic, strong) NSString *exceptionDetail;<br>//异常堆栈<br>@property (nonatomic, strong) NSString *stackTrace;<br>@end</p><p>// 继承自 NSURLProtocol 抽象类，实现响应方法，代理网络请求<br>@interface CustomURLProtocol () &lt;NSURLSessionTaskDelegate&gt;</p><p>@property (nonatomic, strong) NSURLSessionDataTask *dataTask;<br>@property (nonatomic, strong) NSOperationQueue *sessionDelegateQueue;<br>@property (nonatomic, strong) NetworkMonitorDataModel *dataModel;<br>@property (nonatomic, strong) NetworkMonitorErrorModel *errModel;</p><p>@end</p><p>//使用NSURLSessionDataTask请求网络</p><ul><li>(void)startLoading {<br>  NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];<pre><code>NSURLSession \*session = \[NSURLSession sessionWithConfiguration:configuration                                                    delegate:self                                               delegateQueue:nil\];</code></pre>  NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration delegate:self delegateQueue:nil];<pre><code>self.sessionDelegateQueue = \[\[NSOperationQueue alloc\] init\];</code></pre>  self.sessionDelegateQueue.maxConcurrentOperationCount = 1;<br>  self.sessionDelegateQueue.name = @”com.networkMonitor.session.queue”;<br>  self.dataTask = [session dataTaskWithRequest:self.request];<br>  [self.dataTask resume];<br>}</li></ul><p>#pragma mark - NSURLSessionTaskDelegate</p><ul><li>(void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error {<br>  if (error) {<pre><code>  \[self.client URLProtocol:self didFailWithError:error\];</code></pre>  } else {<pre><code>  \[self.client URLProtocolDidFinishLoading:self\];</code></pre>  }<br>  if (error) {<pre><code>  NSURLRequest \*request = task.currentRequest;  if (request) &#123;      self.errModel.requestUrl  = request.URL.absoluteString;              self.errModel.httpMethod = request.HTTPMethod;      self.errModel.requestParams = request.URL.query;  &#125;  self.errModel.errorCode = error.code;  self.errModel.exceptionName = error.domain;  self.errModel.exceptionDetail = error.description;// 上传 Network 数据到数据上报组件，数据上报会在 \[打造功能强大、灵活可配置的数据上报组件\](https://github.com/FantasticLBP/knowledge-kit/blob/master/Chapter1%20-%20iOS/1.80.md) 讲</code></pre>  }<br>  self.dataTask = nil;<br>}</li></ul><ul><li><p>(void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didFinishCollectingMetrics:(NSURLSessionTaskMetrics *)metrics {</p><pre><code> if (@available(iOS 10.0, \*) &amp;&amp; \[metrics.transactionMetrics count\] &gt; 0) &#123;  \[metrics.transactionMetrics enumerateObjectsUsingBlock:^(NSURLSessionTaskTransactionMetrics \*\_Nonnull obj, NSUInteger idx, BOOL \*\_Nonnull stop) &#123;      if (obj.resourceFetchType == NSURLSessionTaskMetricsResourceFetchTypeNetworkLoad) &#123;          if (obj.fetchStartDate) &#123;              self.dataModel.requestDate = \[obj.fetchStartDate timeIntervalSince1970\] \* 1000;          &#125;          if (obj.domainLookupStartDate &amp;&amp; obj.domainLookupEndDate) &#123;              self.dataModel. waitDNSTime = ceil(\[obj.domainLookupStartDate timeIntervalSinceDate:obj.fetchStartDate\] \* 1000);              self.dataModel. dnsLookupTime = ceil(\[obj.domainLookupEndDate timeIntervalSinceDate:obj.domainLookupStartDate\] \* 1000);          &#125;          if (obj.connectStartDate) &#123;              if (obj.secureConnectionStartDate) &#123;                  self.dataModel. waitDNSTime = ceil(\[obj.secureConnectionStartDate timeIntervalSinceDate:obj.connectStartDate\] \* 1000);              &#125; else if (obj.connectEndDate) &#123;                  self.dataModel.tcpTime = ceil(\[obj.connectEndDate timeIntervalSinceDate:obj.connectStartDate\] \* 1000);              &#125;          &#125;          if (obj.secureConnectionEndDate &amp;&amp; obj.secureConnectionStartDate) &#123;              self.dataModel.sslTime = ceil(\[obj.secureConnectionEndDate timeIntervalSinceDate:obj.secureConnectionStartDate\] \* 1000);          &#125;          if (obj.fetchStartDate &amp;&amp; obj.responseEndDate) &#123;              self.dataModel.requestTime = ceil(\[obj.responseEndDate timeIntervalSinceDate:obj.fetchStartDate\] \* 1000);          &#125;          self.dataModel.httpProtocol = obj.networkProtocolName;          NSHTTPURLResponse \*response = (NSHTTPURLResponse \*)obj.response;          if (\[response isKindOfClass:NSHTTPURLResponse.class\]) &#123;              self.dataModel.receiveBytes = response.expectedContentLength;          &#125;          if (\[obj respondsToSelector:@selector(\_remoteAddressAndPort)\]) &#123;              self.dataModel.ip = \[obj valueForKey:@&quot;\_remoteAddressAndPort&quot;\];          &#125;          if (\[obj respondsToSelector:@selector(\_requestHeaderBytesSent)\]) &#123;              self.dataModel.sendBytes = \[\[obj valueForKey:@&quot;\_requestHeaderBytesSent&quot;\] unsignedIntegerValue\];          &#125;          if (\[obj respondsToSelector:@selector(\_responseHeaderBytesReceived)\]) &#123;              self.dataModel.receiveBytes = \[\[obj valueForKey:@&quot;\_responseHeaderBytesReceived&quot;\] unsignedIntegerValue\];          &#125;         self.dataModel.requestUrl = \[obj.request.URL absoluteString\];          self.dataModel.httpMethod = obj.request.HTTPMethod;          self.dataModel.useProxy = obj.isProxyConnection;      &#125;  &#125;\];          // 上传 Network 数据到数据上报组件，数据上报会在 \[打造功能强大、灵活可配置的数据上报组件\](https://github.com/FantasticLBP/knowledge-kit/blob/master/Chapter1%20-%20iOS/1.80.md) 讲</code></pre><p>  }<br>}</p></li></ul><h4 id="2-2-方案二：NSURLProtocol-监控-App-网络请求之黑魔法篇"><a href="#2-2-方案二：NSURLProtocol-监控-App-网络请求之黑魔法篇" class="headerlink" title="2.2 方案二：NSURLProtocol 监控 App 网络请求之黑魔法篇"></a>2.2 方案二：NSURLProtocol 监控 App 网络请求之黑魔法篇</h4><p>文章上面 <a href="https://segmentfault.com/a/1190000040277799#network-2.1">2.1</a> 分析到了 NSURLSessionTaskMetrics 由于兼容性问题，对于网络监控来说似乎不太完美，但是自后在搜资料的时候看到了一篇<a href="https://link.segmentfault.com/?enc=lyjF2l1sjWlNLh2nKf0mXw==.2JdFSv7uYQ9qWxE26VJkv7dXHcec4rUBP6BpC/FCKNN/5qdXhE9jLJ3RU0x8KzGA">文章</a>。文章在分析 WebView 的网络监控的时候分析 Webkit 源码的时候发现了下面代码</p><p>#if !HAVE(TIMINGDATAOPTIONS)<br>void setCollectsTimingData()<br>{<br>    static dispatch_once_t onceToken;<br>    dispatch_once(&amp;onceToken, ^{<br>        [NSURLConnection _setCollectsTimingData:YES];<br>        …<br>    });<br>}<br>#endif</p><p>也就是说明 NSURLConnection 本身有一套 <code>TimingData</code> 的收集 API，只是没有暴露给开发者，苹果自己在用而已。在 runtime header 中找到了 NSURLConnection 的 <code>_setCollectsTimingData:</code> 、<code>_timingData</code> 2个 api（iOS8 以后可以使用）。</p><p>NSURLSession 在 iOS9 之前使用 <code>_setCollectsTimingData:</code> 就可以使用 TimingData 了。</p><p>注意：</p><ul><li>  因为是私有 API，所以在使用的时候注意混淆。比如 <code>[[@&quot;_setC&quot; stringByAppendingString:@&quot;ollectsT&quot;] stringByAppendingString:@&quot;imingData:&quot;]</code>。</li><li>  不推荐私有 API，一般做 APM 的属于公共团队，你想想看虽然你做的 SDK 达到网络监控的目的了，但是万一给业务线的 App 上架造成了问题，那就得不偿失了。一般这种投机取巧，不是百分百确定的事情可以在玩具阶段使用。</li></ul><p>@interface _NSURLConnectionProxy : DelegateProxy</p><p>@end</p><p>@implementation _NSURLConnectionProxy</p><ul><li><p>(BOOL)respondsToSelector:(SEL)aSelector<br>{<br>  if ([NSStringFromSelector(aSelector) isEqualToString:@”connectionDidFinishLoading:”]) {</p><pre><code>  return YES;</code></pre><p>  }<br>  return [self.target respondsToSelector:aSelector];<br>}</p></li><li><p>(void)forwardInvocation:(NSInvocation *)invocation<br>{<br>  [super forwardInvocation:invocation];<br>  if ([NSStringFromSelector(invocation.selector) isEqualToString:@”connectionDidFinishLoading:”]) {</p><pre><code>  \_\_unsafe\_unretained NSURLConnection \*conn;  \[invocation getArgument:&amp;conn atIndex:2\];  SEL selector = NSSelectorFromString(\[@&quot;\_timin&quot; stringByAppendingString:@&quot;gData&quot;\]);  NSDictionary \*timingData = \[conn performSelector:selector\];  \[\[NTDataKeeper shareInstance\] trackTimingData:timingData request:conn.currentRequest\];</code></pre><p>  }<br>}</p></li></ul><p>@end</p><p>@implementation NSURLConnection(tracker)</p><ul><li><p>(void)load<br>{<br>  static dispatch_once_t onceToken;<br>  dispatch_once(&amp;onceToken, ^{</p><pre><code>  Class class = \[self class\];  SEL originalSelector = @selector(initWithRequest:delegate:);  SEL swizzledSelector = @selector(swizzledInitWithRequest:delegate:);  Method originalMethod = class\_getInstanceMethod(class, originalSelector);  Method swizzledMethod = class\_getInstanceMethod(class, swizzledSelector);  method\_exchangeImplementations(originalMethod, swizzledMethod);  NSString \*selectorName = \[\[@&quot;\_setC&quot; stringByAppendingString:@&quot;ollectsT&quot;\] stringByAppendingString:@&quot;imingData:&quot;\];  SEL selector = NSSelectorFromString(selectorName);  \[NSURLConnection performSelector:selector withObject:@(YES)\];</code></pre><p>  });<br>}</p></li></ul><ul><li>(instancetype)swizzledInitWithRequest:(NSURLRequest *)request delegate:(id&lt;NSURLConnectionDelegate&gt;)delegate<br>{<br>  if (delegate) {<pre><code>  \_NSURLConnectionProxy \*proxy = \[\[\_NSURLConnectionProxy alloc\] initWithTarget:delegate\];  objc\_setAssociatedObject(delegate ,@&quot;\_NSURLConnectionProxy&quot; ,proxy, OBJC\_ASSOCIATION\_RETAIN\_NONATOMIC);  return \[self swizzledInitWithRequest:request delegate:(id&lt;NSURLConnectionDelegate\&gt;)proxy\];</code></pre>  }else{<pre><code>  return \[self swizzledInitWithRequest:request delegate:delegate\];</code></pre>  }<br>}</li></ul><p>@end</p><h4 id="2-3-方案三：Hook"><a href="#2-3-方案三：Hook" class="headerlink" title="2.3 方案三：Hook"></a>2.3 方案三：Hook</h4><p>iOS 中 hook 技术有2类，一种是 NSProxy，一种是 method swizzling（isa swizzling）</p><h5 id="2-3-1-方法一"><a href="#2-3-1-方法一" class="headerlink" title="2.3.1 方法一"></a>2.3.1 方法一</h5><p>写 SDK 肯定不可能手动侵入业务代码（你没那个权限提交到线上代码 😂），所以不管是 APM 还是无痕埋点都是通过 Hook 的方式。</p><p>面向切面程序设计（Aspect-oriented Programming，AOP）是计算机科学中的一种程序设计范型，将<strong>横切关注点</strong>与业务主体进一步分离，以提高程序代码的模块化程度。在不修改源代码的情况下给程序动态增加功能。其核心思想是将业务逻辑（核心关注点，系统主要功能）与公共功能（横切关注点，比如日志系统）进行分离，降低复杂性，保持系统模块化程度、可维护性、可重用性。常被用在日志系统、性能统计、安全控制、事务处理、异常处理等场景下。</p><p>在 iOS 中 AOP 的实现是基于 Runtime 机制，目前由3种方式：Method Swizzling、NSProxy、FishHook（主要用用于 hook c 代码）。</p><p>文章上面 <a href="https://segmentfault.com/a/1190000040277799#network-2.1">2.1</a> 讨论了满足大多数的需求的场景，NSURLProtocol 监控了 NSURLConnection、NSURLSession 的网络请求，自身代理后可以发起网络请求并得到诸如请求开始时间、请求结束时间、header 信息等，但是无法得到非常详细的网络性能数据，比如 DNS 开始解析时间、DNS 解析用了多久、reponse 开始返回的时间、返回了多久等。 iOS10 之后 NSURLSessionTaskDelegate 增加了一个代理方法 <code>- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didFinishCollectingMetrics:(NSURLSessionTaskMetrics *)metrics API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));</code>，可以获取到精确的各项网络数据。但是具有兼容性。文章上面 <a href="https://segmentfault.com/a/1190000040277799#network-2.2">2.2</a> 讨论了从 Webkit 源码中得到的信息，通过私有方法 <code>_setCollectsTimingData:</code> 、<code>_timingData</code> 可以获取到 TimingData。</p><p>但是如果需要监全部的网络请求就不能满足需求了，查阅资料后发现了阿里百川有 APM 的解决方案，于是有了方案3，对于网络监控需要做如下的处理</p><p><img src="https://segmentfault.com/img/bVbIOh5"></p><p>可能对于 CFNetwork 比较陌生，可以看一下 CFNetwork 的层级和简单用法<br><img src="https://segmentfault.com/img/bVbIOiA"></p><p>CFNetwork 的基础是 CFSocket 和 CFStream。</p><p>CFSocket：Socket 是网络通信的底层基础，可以让2个 socket 端口互发数据，iOS 中最常用的 socket 抽象是 BSD socket。而 CFSocket 是 BSD socket 的 OC 包装，几乎实现了所有的 BSD 功能，此外加入了 RunLoop。</p><p>CFStream：提供了与设备无关的读写数据方法，使用它可以为内存、文件、网络（使用 socket）的数据建立流，使用 stream 可以不必将所有数据写入到内存中。CFStream 提供 API 对2种 CFType 对象提供抽象：CFReadStream、CFWriteStream。同时也是 CFHTTP、CFFTP 的基础。</p><p>简单 Demo</p><p>- (void)testCFNetwork<br>{<br>    CFURLRef urlRef = CFURLCreateWithString(kCFAllocatorDefault, CFSTR(“<a href="https://httpbin.org/get&quot;">https://httpbin.org/get&quot;</a>), NULL);<br>    CFHTTPMessageRef httpMessageRef = CFHTTPMessageCreateRequest(kCFAllocatorDefault, CFSTR(“GET”), urlRef, kCFHTTPVersion1_1);<br>    CFRelease(urlRef);</p><pre><code>CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, httpMessageRef);CFRelease(httpMessageRef);CFReadStreamScheduleWithRunLoop(readStream, CFRunLoopGetCurrent(), kCFRunLoopCommonModes);CFOptionFlags eventFlags = (kCFStreamEventHasBytesAvailable | kCFStreamEventErrorOccurred | kCFStreamEventEndEncountered);CFStreamClientContext context = &#123;    0,    NULL,    NULL,    NULL,   NULL&#125; ;// Assigns a client to a stream, which receives callbacks when certain events occur.CFReadStreamSetClient(readStream, eventFlags, CFNetworkRequestCallback, &amp;context);// Opens a stream for reading.CFReadStreamOpen(readStream);</code></pre><p>}<br>// callback<br>void CFNetworkRequestCallback (CFReadStreamRef _Null_unspecified stream, CFStreamEventType type, void * _Null_unspecified clientCallBackInfo) {<br>    CFMutableDataRef responseBytes = CFDataCreateMutable(kCFAllocatorDefault, 0);<br>    CFIndex numberOfBytesRead = 0;<br>    do {<br>        UInt8 buffer[2014];<br>        numberOfBytesRead = CFReadStreamRead(stream, buffer, sizeof(buffer));<br>        if (numberOfBytesRead &gt; 0) {<br>            CFDataAppendBytes(responseBytes, buffer, numberOfBytesRead);<br>        }<br>    } while (numberOfBytesRead &gt; 0);</p><pre><code>CFHTTPMessageRef response = (CFHTTPMessageRef)CFReadStreamCopyProperty(stream, kCFStreamPropertyHTTPResponseHeader);if (responseBytes) &#123;    if (response) &#123;        CFHTTPMessageSetBody(response, responseBytes);    &#125;    CFRelease(responseBytes);&#125;// close and cleanupCFReadStreamClose(stream);CFReadStreamUnscheduleFromRunLoop(stream, CFRunLoopGetCurrent(), kCFRunLoopCommonModes);CFRelease(stream);// print responseif (response) &#123;    CFDataRef reponseBodyData = CFHTTPMessageCopyBody(response);    CFRelease(response);    printResponseData(reponseBodyData);    CFRelease(reponseBodyData);&#125;</code></pre><p>}</p><p>void printResponseData (CFDataRef responseData) {<br>    CFIndex dataLength = CFDataGetLength(responseData);<br>    UInt8 *bytes = (UInt8 *)malloc(dataLength);<br>    CFDataGetBytes(responseData, CFRangeMake(0, CFDataGetLength(responseData)), bytes);<br>    CFStringRef responseString = CFStringCreateWithBytes(kCFAllocatorDefault, bytes, dataLength, kCFStringEncodingUTF8, TRUE);<br>    CFShow(responseString);<br>    CFRelease(responseString);<br>    free(bytes);<br>}<br>// console<br>{<br>  “args”: {},<br>  “headers”: {<br>    “Host”: “httpbin.org”,<br>    “User-Agent”: “Test/1 CFNetwork/1125.2 Darwin/19.3.0”,<br>    “X-Amzn-Trace-Id”: “Root=1-5e8980d0-581f3f44724c7140614c2564”<br>  },<br>  “origin”: “183.159.122.102”,<br>  “url”: “<a href="https://httpbin.org/get&quot;">https://httpbin.org/get&quot;</a><br>}</p><p>我们知道 NSURLSession、NSURLConnection、CFNetwork 的使用都需要调用一堆方法进行设置然后需要设置代理对象，实现代理方法。所以针对这种情况进行监控首先想到的是使用 runtime hook 掉方法层级。但是针对设置的代理对象的代理方法没办法 hook，因为不知道代理对象是哪个类。所以想办法可以 hook 设置代理对象这个步骤，将代理对象替换成我们设计好的某个类，然后让这个类去实现 NSURLConnection、NSURLSession、CFNetwork 相关的代理方法。然后在这些方法的内部都去调用一下原代理对象的方法实现。所以我们的需求得以满足，我们在相应的方法里面可以拿到监控数据，比如请求开始时间、结束时间、状态码、内容大小等。</p><p>NSURLSession、NSURLConnection hook 如下。</p><p><img src="https://segmentfault.com/img/bVbIOiI"></p><p><img src="https://segmentfault.com/img/bVbIOiT"></p><p>业界有 APM 针对 CFNetwork 的方案，整理描述下：</p><p>CFNetwork 是 c 语言实现的，要对 c 代码进行 hook 需要使用 Dynamic Loader Hook 库 - <a href="https://link.segmentfault.com/?enc=tcKJVyEvs7dexHInMoDCyw==.U6nR6eU3JMfqS5fGvu0zKDtIo2B6MLKTgyx0LvekE3gw4lJm88QrCDo9LH1aCMnC">fishhook</a>。</p><blockquote><p><strong>Dynamic Loader</strong>（dyld）通过更新 <strong>Mach-O</strong> 文件中保存的指针的方法来绑定符号。借用它可以在 <strong>Runtime</strong> 修改 <strong>C</strong> 函数调用的函数指针。<strong>fishhook</strong> 的实现原理：遍历 <code>__DATA segment</code> 里面 <code>__nl_symbol_ptr</code> 、<code>__la_symbol_ptr</code> 两个 section 里面的符号，通过 Indirect Symbol Table、Symbol Table 和 String Table 的配合，找到自己要替换的函数，达到 hook 的目的。</p><p>/* Returns the number of bytes read, or -1 if an error occurs preventing any</p><p>bytes from being read, or 0 if the stream’s end was encountered.</p><p>It is an error to try and read from a stream that hasn’t been opened first.</p><p>This call will block until at least one byte is available; it will NOT block</p><p>until the entire buffer can be filled. To avoid blocking, either poll using</p><p>CFReadStreamHasBytesAvailable() or use the run loop and listen for the</p><p>kCFStreamEventHasBytesAvailable event for notification of data available. */</p><p>CF_EXPORT</p><p>CFIndex CFReadStreamRead(CFReadStreamRef <strong>_Null_unspecified</strong> stream, UInt8 * <strong>_Null_unspecified</strong> buffer, CFIndex bufferLength);</p></blockquote><p>CFNetwork 使用 CFReadStreamRef 来传递数据，使用回调函数的形式来接受服务器的响应。当回调函数受到</p><p>具体步骤及其关键代码如下，以 NSURLConnection 举例</p><ul><li><p>因为要 Hook 挺多地方，所以写一个 method swizzling 的工具类</p><p>  #import &lt;Foundation/Foundation.h&gt;</p><p>  NS_ASSUME_NONNULL_BEGIN</p><p>  @interface NSObject (hook)</p><p>  /**<br>   hook对象方法</p><p>   @param originalSelector 需要hook的原始对象方法<br>   @param swizzledSelector 需要替换的对象方法<br>   */</p><ul><li><p>(void)apm_swizzleMethod:(SEL)originalSelector swizzledSelector:(SEL)swizzledSelector;</p><p>/**<br>hook类方法</p><p>@param originalSelector 需要hook的原始类方法<br>@param swizzledSelector 需要替换的类方法<br>*/</p></li><li><p>(void)apm_swizzleClassMethod:(SEL)originalSelector swizzledSelector:(SEL)swizzledSelector;</p><p>@end</p><p>NS_ASSUME_NONNULL_END</p></li><li><p>(void)apm_swizzleMethod:(SEL)originalSelector swizzledSelector:(SEL)swizzledSelector<br>{<br>  class_swizzleInstanceMethod(self, originalSelector, swizzledSelector);<br>}</p></li><li><p>(void)apm_swizzleClassMethod:(SEL)originalSelector swizzledSelector:(SEL)swizzledSelector<br>{<br>  //类方法实际上是储存在类对象的类(即元类)中，即类方法相当于元类的实例方法,所以只需要把元类传入，其他逻辑和交互实例方法一样。<br>  Class class2 = object_getClass(self);<br>  class_swizzleInstanceMethod(class2, originalSelector, swizzledSelector);<br>}</p><p>void class_swizzleInstanceMethod(Class class, SEL originalSEL, SEL replacementSEL)<br>{<br>  Method originMethod = class_getInstanceMethod(class, originalSEL);<br>  Method replaceMethod = class_getInstanceMethod(class, replacementSEL);</p><p>  if(class_addMethod(class, originalSEL, method_getImplementation(replaceMethod),method_getTypeEncoding(replaceMethod)))<br>  {</p><pre><code>  class\_replaceMethod(class,replacementSEL, method\_getImplementation(originMethod), method\_getTypeEncoding(originMethod));</code></pre><p>  }else {</p><pre><code>  method\_exchangeImplementations(originMethod, replaceMethod);</code></pre><p>  }<br>}</p></li></ul></li><li><p>建立一个继承自 NSProxy 抽象类的类，实现相应方法。</p><p>  #import &lt;Foundation/Foundation.h&gt;</p><p>  NS_ASSUME_NONNULL_BEGIN</p><p>  // 为 NSURLConnection、NSURLSession、CFNetwork 代理设置代理转发<br>  @interface NetworkDelegateProxy : NSProxy</p><ul><li><p>(instancetype)setProxyForObject:(id)originalTarget withNewDelegate:(id)newDelegate;</p><p>@end</p><p>NS_ASSUME_NONNULL_END</p><p>// .m<br>@interface NetworkDelegateProxy () {<br>  id _originalTarget;<br>  id _NewDelegate;<br>}</p><p>@end</p><p>@implementation NetworkDelegateProxy</p><p>#pragma mark - life cycle</p></li><li><p>(instancetype)sharedInstance {<br>  static NetworkDelegateProxy *_sharedInstance = nil;</p><p>  static dispatch_once_t onceToken;</p><p>  dispatch_once(&amp;onceToken, ^{</p><pre><code>  \_sharedInstance = \[NetworkDelegateProxy alloc\];</code></pre><p>  });</p><p>  return _sharedInstance;<br>}</p><p>#pragma mark - public Method</p></li><li><p>(instancetype)setProxyForObject:(id)originalTarget withNewDelegate:(id)newDelegate<br>{<br>  NetworkDelegateProxy *instance = [NetworkDelegateProxy sharedInstance];<br>  instance-&gt;_originalTarget = originalTarget;<br>  instance-&gt;_NewDelegate = newDelegate;<br>  return instance;<br>}</p></li></ul><ul><li><p>(void)forwardInvocation:(NSInvocation *)invocation<br>{<br>  if ([_originalTarget respondsToSelector:invocation.selector]) {</p><pre><code>  \[invocation invokeWithTarget:\_originalTarget\];  \[((NSURLSessionAndConnectionImplementor \*)\_NewDelegate) invoke:invocation\];</code></pre><p>  }<br>}</p></li><li><p>(nullable NSMethodSignature *)methodSignatureForSelector:(SEL)sel<br>{<br>  return [_originalTarget methodSignatureForSelector:sel];<br>}</p><p>@end</p></li></ul></li><li><p>创建一个对象，实现 NSURLConnection、NSURLSession、NSIuputStream 代理方法</p><p>  // NetworkImplementor.m</p><p>  #pragma mark-NSURLConnectionDelegate</p><ul><li><p>(void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error {<br>  NSLog(@”%s”, __func__);<br>}</p></li><li><p>(nullable NSURLRequest *)connection:(NSURLConnection *)connection willSendRequest:(NSURLRequest *)request redirectResponse:(nullable NSURLResponse *)response {<br>  NSLog(@”%s”, __func__);<br>  return request;<br>}</p><p>#pragma mark-NSURLConnectionDataDelegate</p></li><li><p>(void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response {<br>  NSLog(@”%s”, __func__);<br>}</p></li><li><p>(void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data {<br> NSLog(@”%s”, __func__);<br>}</p></li><li><p>(void)connection:(NSURLConnection *)connection   didSendBodyData:(NSInteger)bytesWritten<br>totalBytesWritten:(NSInteger)totalBytesWritten<br>totalBytesExpectedToWrite:(NSInteger)totalBytesExpectedToWrite {<br>  NSLog(@”%s”, __func__);<br>}</p></li><li><p>(void)connectionDidFinishLoading:(NSURLConnection *)connection {<br>  NSLog(@”%s”, __func__);<br>}</p><p>#pragma mark-NSURLConnectionDownloadDelegate</p></li><li><p>(void)connection:(NSURLConnection *)connection didWriteData:(long long)bytesWritten totalBytesWritten:(long long)totalBytesWritten expectedTotalBytes:(long long) expectedTotalBytes {<br>  NSLog(@”%s”, __func__);<br>}</p></li><li><p>(void)connectionDidResumeDownloading:(NSURLConnection *)connection totalBytesWritten:(long long)totalBytesWritten expectedTotalBytes:(long long) expectedTotalBytes {<br>  NSLog(@”%s”, __func__);<br>}</p></li><li><p>(void)connectionDidFinishDownloading:(NSURLConnection *)connection destinationURL:(NSURL *) destinationURL {<br>  NSLog(@”%s”, __func__);<br>}<br>// 根据需求自己去写需要监控的数据项</p></li></ul></li><li><p>给 NSURLConnection 添加 Category，专门设置 hook 代理对象、hook NSURLConnection 对象方法</p><p>  // NSURLConnection+Monitor.m<br>  @implementation NSURLConnection (Monitor)</p><ul><li>(void)load<br>{<br>  static dispatch_once_t onceToken;<br>  dispatch_once(&amp;onceToken, ^{<pre><code>  @autoreleasepool &#123;      \[\[self class\] apm\_swizzleMethod:@selector(apm\_initWithRequest:delegate:) swizzledSelector:@selector(initWithRequest: delegate:)\];  &#125;</code></pre>  });<br>}</li></ul><ul><li><p>(_Nonnull instancetype)apm_initWithRequest:(NSURLRequest *)request delegate:(nullable id)delegate<br>{<br>  /*</p><ol><li><p>在设置 Delegate 的时候替换 delegate。</p></li><li><p>因为要在每个代理方法里面，监控数据，所以需要将代理方法都 hook 下</p></li><li><p>在原代理方法执行的时候，让新的代理对象里面，去执行方法的转发，<br>*/<br>NSString *traceId = @”traceId”;<br>NSMutableURLRequest *rq = [request mutableCopy];<br>NSString *preTraceId = [request.allHTTPHeaderFields valueForKey:@”head_key_traceid”];<br>if (preTraceId) {<br>// 调用 hook 之前的初始化方法，返回 NSURLConnection<br>return [self apm_initWithRequest:rq delegate:delegate];<br>} else {<br>[rq setValue:traceId forHTTPHeaderField:@”head_key_traceid”];</p><p>NSURLSessionAndConnectionImplementor *mockDelegate = [NSURLSessionAndConnectionImplementor new];<br>[self registerDelegateMethod:@”connection:didFailWithError:” originalDelegate:delegate newDelegate:mockDelegate flag:”v@:@@”];</p><p>[self registerDelegateMethod:@”connection:didReceiveResponse:” originalDelegate:delegate newDelegate:mockDelegate flag:”v@:@@”];<br>[self registerDelegateMethod:@”connection:didReceiveData:” originalDelegate:delegate newDelegate:mockDelegate flag:”v@:@@”];<br>[self registerDelegateMethod:@”connection:didFailWithError:” originalDelegate:delegate newDelegate:mockDelegate flag:”v@:@@”];</p><p>[self registerDelegateMethod:@”connectionDidFinishLoading:” originalDelegate:delegate newDelegate:mockDelegate flag:”v@:@”];<br>[self registerDelegateMethod:@”connection:willSendRequest:redirectResponse:” originalDelegate:delegate newDelegate:mockDelegate flag:”@@:@@”];<br>delegate = [NetworkDelegateProxy setProxyForObject:delegate withNewDelegate:mockDelegate];</p><p>// 调用 hook 之前的初始化方法，返回 NSURLConnection<br>return [self apm_initWithRequest:rq delegate:delegate];<br>}<br>}</p></li></ol></li><li><p>(void)registerDelegateMethod:(NSString *)methodName originalDelegate:(id&lt;NSURLConnectionDelegate&gt;)originalDelegate newDelegate:(NSURLSessionAndConnectionImplementor *)newDelegate flag:(const char *)flag<br>{<br>  if ([originalDelegate respondsToSelector:NSSelectorFromString(methodName)]) {</p><pre><code>  IMP originalMethodImp = class\_getMethodImplementation(\[originalDelegate class\], NSSelectorFromString(methodName));  IMP newMethodImp = class\_getMethodImplementation(\[newDelegate class\], NSSelectorFromString(methodName));  if (originalMethodImp != newMethodImp) &#123;      \[newDelegate registerSelector: methodName\];      NSLog(@&quot;&quot;);  &#125;</code></pre><p>  } else {</p><pre><code>  class\_addMethod(\[originalDelegate class\], NSSelectorFromString(methodName), class\_getMethodImplementation(\[newDelegate class\], NSSelectorFromString(methodName)), flag);</code></pre><p>  }<br>}</p><p>@end</p></li></ul></li></ul><p>这样下来就是可以监控到网络信息了，然后将数据交给数据上报 SDK，按照下发的数据上报策略去上报数据。</p><h5 id="2-3-2-方法二"><a href="#2-3-2-方法二" class="headerlink" title="2.3.2 方法二"></a>2.3.2 方法二</h5><p>其实，针对上述的需求还有另一种方法一样可以达到目的，那就是 <strong>isa swizzling</strong>。</p><p>顺道说一句，上面针对 NSURLConnection、NSURLSession、NSInputStream 代理对象的 hook 之后，利用 NSProxy 实现代理对象方法的转发，有另一种方法可以实现，那就是 <strong>isa swizzling</strong>。</p><ul><li><p>Method swizzling 原理</p><p>  struct old_method {</p><pre><code>  SEL method\_name;  char \*method\_types;  IMP method\_imp;</code></pre><p>  };</p></li></ul><p><img src="https://segmentfault.com/img/bVbIOi3"></p><p>method swizzling 改进版如下</p><p>Method originalMethod = class_getInstanceMethod(aClass, aSEL);<br>IMP originalIMP = method_getImplementation(originalMethod);<br>char *cd = method_getTypeEncoding(originalMethod);<br>IMP newIMP = imp_implementationWithBlock(^(id self) {<br>  void (*tmp)(id self, SEL _cmd) = originalIMP;<br>  tmp(self, aSEL);<br>});<br>class_replaceMethod(aClass, aSEL, newIMP, cd);</p><ul><li><p>isa swizzling</p><p>  /// Represents an instance of a class.<br>  struct objc_object {</p><pre><code>  Class \_Nonnull isa  OBJC\_ISA\_AVAILABILITY;</code></pre><p>  };</p><p>  /// A pointer to an instance of a class.<br>  typedef struct objc_object *id;</p></li></ul><p><img src="https://segmentfault.com/img/bVbIOjh"></p><p>我们来分析一下为什么修改 <code>isa</code> 可以实现目的呢？</p><ol><li> 写 APM 监控的人没办法确定业务代码</li><li> 不可能为了方便监控 APM，写某些类，让业务线开发者别使用系统 NSURLSession、NSURLConnection 类</li></ol><p>想想 KVO 的实现原理？结合上面的图</p><ul><li>  创建监控对象子类</li><li>  重写子类中属性的 getter、seeter</li><li>  将监控对象的 isa 指针指向新创建的子类</li><li>  在子类的 getter、setter 中拦截值的变化，通知监控对象值的变化</li><li>  监控完之后将监控对象的 isa 还原回去</li></ul><p>按照这个思路，我们也可以对 NSURLConnection、NSURLSession 的 load 方法中动态创建子类，在子类中重写方法，比如 <code>- (**nullable** **instancetype**)initWithRequest:(NSURLRequest *)request delegate:(**nullable** **id**)delegate startImmediately:(**BOOL**)startImmediately;</code> ，然后将 NSURLSession、NSURLConnection 的 isa 指向动态创建的子类。在这些方法处理完之后还原本身的 isa 指针。</p><p>不过 isa swizzling 针对的还是 method swizzling，代理对象不确定，还是需要 NSProxy 进行动态处理。</p><p>至于如何修改 isa，我写一个简单的 Demo 来模拟 KVO</p><p>- (void)lbpKVO_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context {<br>    //生成自定义的名称<br>    NSString *className = NSStringFromClass(self.class);<br>    NSString *currentClassName = [@”LBPKVONotifying_“ stringByAppendingString:className];<br>    //1. runtime 生成类<br>    Class myclass = objc_allocateClassPair(self.class, [currentClassName UTF8String], 0);<br>    // 生成后不能马上使用，必须先注册<br>    objc_registerClassPair(myclass);</p><pre><code>//2. 重写 setter 方法class\_addMethod(myclass,@selector(say) , (IMP)say, &quot;v@:@&quot;);</code></pre><p>//    class_addMethod(myclass,@selector(setName:) , (IMP)setName, “v@:@”);<br>    //3. 修改 isa<br>    object_setClass(self, myclass);</p><pre><code>//4. 将观察者保存到当前对象里面objc\_setAssociatedObject(self, &quot;observer&quot;, observer, OBJC\_ASSOCIATION\_ASSIGN);//5. 将传递的上下文绑定到当前对象里面objc\_setAssociatedObject(self, &quot;context&quot;, (\_\_bridge id \_Nullable)(context), OBJC\_ASSOCIATION\_RETAIN);</code></pre><p>}</p><p>void say(id self, SEL _cmd)<br>{<br>   // 调用父类方法一<br>    struct objc_super superclass = {self, [self superclass]};<br>    ((void(*)(struct objc_super *,SEL))objc_msgSendSuper)(&amp;superclass,@selector(say));<br>    NSLog(@”%s”, __func__);<br>// 调用父类方法二<br>//    Class class = [self class];<br>//    object_setClass(self, class_getSuperclass(class));<br>//    objc_msgSend(self, @selector(say));<br>}</p><p>void setName (id self, SEL _cmd, NSString *name) {<br>    NSLog(@”come here”);<br>    //先切换到当前类的父类，然后发送消息 setName，然后切换当前子类<br>    //1. 切换到父类<br>    Class class = [self class];<br>    object_setClass(self, class_getSuperclass(class));<br>    //2. 调用父类的 setName 方法<br>    objc_msgSend(self, @selector(setName:), name);</p><pre><code>//3. 调用观察id observer = objc\_getAssociatedObject(self, &quot;observer&quot;);id context = objc\_getAssociatedObject(self, &quot;context&quot;);if (observer) &#123;    objc\_msgSend(observer, @selector(observeValueForKeyPath:ofObject:change:context:), @&quot;name&quot;, self, @&#123;@&quot;new&quot;: name, @&quot;kind&quot;: @1 &#125; , context);&#125;//4. 改回子类object\_setClass(self, class);</code></pre><p>}</p><p>@end</p><h4 id="2-4-方案四：监控-App-常见网络请求"><a href="#2-4-方案四：监控-App-常见网络请求" class="headerlink" title="2.4 方案四：监控 App 常见网络请求"></a>2.4 方案四：监控 App 常见网络请求</h4><p>本着成本的原因，由于现在大多数的项目的网络能力都是通过 <a href="https://link.segmentfault.com/?enc=MYj1ggNH/meF+oxXiYJbZg==.IYz8wJ/KSEXObkRzTOxLYjdN5RNFlQyunNtJO1Se9wGa3x76x0tMSjB/U+kVQy7b">AFNetworking</a> 完成的，所以本文的网络监控可以快速完成。</p><p>AFNetworking 在发起网络的时候会有相应的通知。<code>AFNetworkingTaskDidResumeNotification</code> 和 <code>AFNetworkingTaskDidCompleteNotification</code>。通过监听通知携带的参数获取网络情况信息。</p><p> self.didResumeObserver = [[NSNotificationCenter defaultCenter] addObserverForName:AFNetworkingTaskDidResumeNotification object:nil queue:self.queue usingBlock:^(NSNotification * _Nonnull note) {<br>    // 开始<br>    __strong __typeof(weakSelf)strongSelf = weakSelf;<br>    NSURLSessionTask *task = note.object;<br>    NSString *requestId = [[NSUUID UUID] UUIDString];<br>    task.apm_requestId = requestId;<br>    [strongSelf.networkRecoder recordStartRequestWithRequestID:requestId task:task];<br>}];</p><p>self.didCompleteObserver = [[NSNotificationCenter defaultCenter] addObserverForName:AFNetworkingTaskDidCompleteNotification object:nil queue:self.queue usingBlock:^(NSNotification * _Nonnull note) {</p><pre><code>\_\_strong \_\_typeof(weakSelf)strongSelf = weakSelf;NSError \*error = note.userInfo\[AFNetworkingTaskDidCompleteErrorKey\];NSURLSessionTask \*task = note.object;if (!error) &#123;    // 成功    \[strongSelf.networkRecoder recordFinishRequestWithRequestID:task.apmn\_requestId task:task\];&#125; else &#123;    // 失败    \[strongSelf.networkRecoder recordResponseErrorWithRequestID:task.apmn\_requestId task:task error:error\];&#125;</code></pre><p>}];</p><p>在 networkRecoder 的方法里面去组装数据，交给数据上报组件，等到合适的时机策略去上报。</p><p>因为网络是一个异步的过程，所以当网络请求开始的时候需要为每个网络设置唯一标识，等到网络请求完成后再根据每个请求的标识，判断该网络耗时多久、是否成功等。所以措施是为 <strong>NSURLSessionTask</strong> 添加分类，通过 runtime 增加一个属性，也就是唯一标识。</p><p>这里插一嘴，为 Category 命名、以及内部的属性和方法命名的时候需要注意下。假如不注意会怎么样呢？假如你要为 NSString 类增加身份证号码中间位数隐藏的功能，那么写代码久了的老司机 A，为 NSString 增加了一个方法名，叫做 getMaskedIdCardNumber，但是他的需求是从 [9, 12] 这4位字符串隐藏掉。过了几天同事 B 也遇到了类似的需求，他也是一位老司机，为 NSString 增加了一个也叫 getMaskedIdCardNumber 的方法，但是他的需求是从 [8, 11] 这4位字符串隐藏，但是他引入工程后发现输出并不符合预期，为该方法写的单测没通过，他以为自己写错了截取方法，检查了几遍才发现工程引入了另一个 NSString 分类，里面的方法同名 😂 真坑。</p><p>下面的例子是 SDK，但是日常开发也是一样。</p><ul><li>  Category 类名：建议按照当前 SDK 名称的简写作为前缀，再加下划线，再加当前分类的功能，也就是<code>类名+SDK名称简写_功能名称</code>。比如当前 SDK 叫 JuhuaSuanAPM，那么该 NSURLSessionTask Category 名称就叫做 <code>NSURLSessionTask+JuHuaSuanAPM_NetworkMonitor.h</code></li><li>  Category 属性名：建议按照当前 SDK 名称的简写作为前缀，再加下划线，再加属性名，也就是<code>SDK名称简写_属性名称</code>。比如 JuhuaSuanAPM_requestId`</li><li>  Category 方法名：建议按照当前 SDK 名称的简写作为前缀，再加下划线，再加方法名，也就是<code>SDK名称简写_方法名称</code>。比如 <code>-(BOOL)JuhuaSuanAPM__isGzippedData</code></li></ul><p>例子如下：</p><p>#import &lt;Foundation/Foundation.h&gt;</p><p>@interface NSURLSessionTask (JuhuaSuanAPM_NetworkMonitor)</p><p>@property (nonatomic, copy) NSString* JuhuaSuanAPM_requestId;</p><p>@end</p><p>#import “NSURLSessionTask+JuHuaSuanAPM_NetworkMonitor.h”<br>#import &lt;objc/runtime.h&gt;</p><p>@implementation NSURLSessionTask (JuHuaSuanAPM_NetworkMonitor)</p><ul><li><p>(NSString*)JuhuaSuanAPM_requestId<br>{<br>  return objc_getAssociatedObject(self, _cmd);<br>}</p></li><li><p>(void)setJuhuaSuanAPM_requestId:(NSString*)requestId<br>{<br>  objc_setAssociatedObject(self, @selector(JuhuaSuanAPM_requestId), requestId, OBJC_ASSOCIATION_COPY_NONATOMIC);<br>}<br>@end</p></li></ul><h4 id="2-5-iOS-流量监控"><a href="#2-5-iOS-流量监控" class="headerlink" title="2.5 iOS 流量监控"></a>2.5 iOS 流量监控</h4><h5 id="2-5-1-HTTP-请求、响应数据结构"><a href="#2-5-1-HTTP-请求、响应数据结构" class="headerlink" title="2.5.1 HTTP 请求、响应数据结构"></a>2.5.1 HTTP 请求、响应数据结构</h5><p>HTTP 请求报文结构</p><p><img src="https://segmentfault.com/img/bVbIOjv"></p><p>响应报文的结构<br><img src="https://segmentfault.com/img/bVbIOjA"></p><ol><li> HTTP 报文是格式化的数据块，每条报文由三部分组成：对报文进行描述的起始行、包含属性的首部块、以及可选的包含数据的主体部分。</li><li> 起始行和手部就是由行分隔符的 ASCII 文本，每行都以一个由2个字符组成的行终止序列作为结束（包括一个回车符、一个换行符）</li><li> 实体的主体或者报文的主体是一个可选的数据块。与起始行和首部不同的是，主体中可以包含文本或者二进制数据，也可以为空。</li><li> HTTP 首部（也就是 Headers）总是应该以一个空行结束，即使没有实体部分。浏览器发送了一个空白行来通知服务器，它已经结束了该头信息的发送。</li></ol><p>请求报文的格式</p><p>&lt;method&gt; &lt;request-URI&gt; &lt;version&gt;<br>&lt;headers&gt;</p><p>&lt;entity-body&gt;</p><p>响应报文的格式</p><p><version> <status> <reason-phrase><br><headers></p><entity-body><p>下图是打开 Chrome 查看极课时间网页的请求信息。包括响应行、响应头、响应体等信息。</p><p><img src="https://segmentfault.com/img/bVbIOjS"></p><p>下图是在终端使用 <code>curl</code> 查看一个完整的请求和响应数据<br><img src="https://segmentfault.com/img/bVbIOj9"></p><p>我们都知道在 HTTP 通信中，响应数据会使用 gzip 或其他压缩方式压缩，用 NSURLProtocol 等方案监听，用 NSData 类型去计算分析流量等会造成数据的不精确，因为正常一个 HTTP 响应体的内容是使用 gzip 或其他压缩方式压缩的，所以使用 NSData 会偏大。</p><h5 id="2-5-2-问题"><a href="#2-5-2-问题" class="headerlink" title="2.5.2 问题"></a>2.5.2 问题</h5><ol><li><p>Request 和 Response 不一定成对存在</p><p> 比如网络断开、App 突然 Crash 等，所以 Request 和 Response 监控后不应该记录在一条记录里</p></li><li><p>请求流量计算方式不精确</p><p> 主要原因有：</p><ul><li>  监控技术方案忽略了请求头和请求行部分的数据大小</li><li>  监控技术方案忽略了 Cookie 部分的数据大小</li><li>  监控技术方案在对请求体大小计算的时候直接使用 <code>HTTPBody.length</code>，导致不够精确</li></ul></li><li><p>响应流量计算方式不精确</p><p> 主要原因有：</p><ul><li>  监控技术方案忽略了响应头和响应行部分的数据大小</li><li>  监控技术方案在对 body 部分的字节大小计算，因采用 <code>exceptedContentLength</code> 导致不够准确</li><li>  监控技术方案忽略了响应体使用 gzip 压缩。真正的网络通信过程中，客户端在发起请求的请求头中 <code>Accept-Encoding</code> 字段代表客户端支持的数据压缩方式（表明客户端可以正常使用数据时支持的压缩方法），同样服务端根据客户端想要的压缩方式、服务端当前支持的压缩方式，最后处理数据，在响应头中<code>Content-Encoding</code> 字段表示当前服务器采用了什么压缩方式。</li></ul></li></ol><h5 id="2-5-3-技术实现"><a href="#2-5-3-技术实现" class="headerlink" title="2.5.3 技术实现"></a>2.5.3 技术实现</h5><p>第五部分讲了网络拦截的各种原理和技术方案，这里拿 NSURLProtocol 来说实现流量监控（Hook 的方式）。从上述知道了我们需要什么样的，那么就逐步实现吧。</p><h6 id="2-5-3-1-Request-部分"><a href="#2-5-3-1-Request-部分" class="headerlink" title="2.5.3.1 Request 部分"></a>2.5.3.1 Request 部分</h6><ol><li><p> 先利用网络监控方案将 NSURLProtocol 管理 App 的各种网络请求</p></li><li><p>在各个方法内部记录各项所需参数（NSURLProtocol 不能分析请求握手、挥手等数据大小和时间消耗，不过对于正常情况的接口流量分析足够了，最底层需要 Socket 层）</p><p> @property(nonatomic, strong) NSURLConnection *internalConnection;<br> @property(nonatomic, strong) NSURLResponse *internalResponse;<br> @property(nonatomic, strong) NSMutableData *responseData;<br> @property (nonatomic, strong) NSURLRequest *internalRequest;</p></li></ol><p>- (void)startLoading<br>{<br>    NSMutableURLRequest *mutableRequest = [[self request] mutableCopy];<br>    self.internalConnection = [[NSURLConnection alloc] initWithRequest:mutableRequest delegate:self];<br>    self.internalRequest = self.request;<br>}</p><ul><li><p>(void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response<br>{<br>  [self.client URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageNotAllowed];<br>  self.internalResponse = response;<br>}</p></li><li><p>(void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data<br>{<br>  [self.responseData appendData:data];<br>  [self.client URLProtocol:self didLoadData:data];<br>}</p></li></ul><ol start="3"><li><p>Status Line 部分</p><p> NSURLResponse 没有 Status Line 等属性或者接口，HTTP Version 信息也没有，所以要想获取 Status Line 想办法转换到 CFNetwork 层试试看。发现有私有 API 可以实现。</p><p> <strong>思路：将 NSURLResponse 通过 <code>_CFURLResponse</code> 转换为 <code>CFTypeRef</code>，然后再将 <code>CFTypeRef</code> 转换为 <code>CFHTTPMessageRef</code>，再通过 <code>CFHTTPMessageCopyResponseStatusLine</code> 获取 <code>CFHTTPMessageRef</code> 的 Status Line 信息。</strong></p><p> 将读取 Status Line 的功能添加一个 NSURLResponse 的分类。</p><p> // NSURLResponse+apm_FetchStatusLineFromCFNetwork.h<br> #import &lt;Foundation/Foundation.h&gt;</p><p> NS_ASSUME_NONNULL_BEGIN</p><p> @interface NSURLResponse (apm_FetchStatusLineFromCFNetwork)</p><ul><li><p>(NSString *)apm_fetchStatusLineFromCFNetwork;</p><p>@end</p><p>NS_ASSUME_NONNULL_END</p><p>// NSURLResponse+apm_FetchStatusLineFromCFNetwork.m<br>#import “NSURLResponse+apm_FetchStatusLineFromCFNetwork.h”<br>#import &lt;dlfcn.h&gt;</p><p>#define SuppressPerformSelectorLeakWarning(Stuff) \<br>do { \<br>_Pragma(“clang diagnostic push”) \<br>_Pragma(“clang diagnostic ignored \“-Warc-performSelector-leaks\“”) \<br>Stuff; \<br>_Pragma(“clang diagnostic pop”) \<br>} while (0)</p><p>typedef CFHTTPMessageRef (*APMURLResponseFetchHTTPResponse)(CFURLRef response);</p><p>@implementation NSURLResponse (apm_FetchStatusLineFromCFNetwork)</p></li><li><p>(NSString *)apm_fetchStatusLineFromCFNetwork<br>{<br>NSString *statusLine = @””;<br>NSString *funcName = @”CFURLResponseGetHTTPResponse”;<br>APMURLResponseFetchHTTPResponse originalURLResponseFetchHTTPResponse = dlsym(RTLD_DEFAULT, [funcName UTF8String]);</p><p>SEL getSelector = NSSelectorFromString(@”_CFURLResponse”);<br>if ([self respondsToSelector:getSelector] &amp;&amp; NULL != originalURLResponseFetchHTTPResponse) {<br>  CFTypeRef cfResponse;<br>  SuppressPerformSelectorLeakWarning(</p><pre><code>  cfResponse = CFBridgingRetain(\[self performSelector:getSelector\]);</code></pre><p>  );<br>  if (NULL != cfResponse) {</p><pre><code>  CFHTTPMessageRef messageRef = originalURLResponseFetchHTTPResponse(cfResponse);  statusLine = (\_\_bridge\_transfer NSString \*)CFHTTPMessageCopyResponseStatusLine(messageRef);  CFRelease(cfResponse);</code></pre><p>  }<br>}<br>return statusLine;<br>}</p><p>@end</p></li></ul></li><li><p>将获取到的 Status Line 转换为 NSData，再计算大小</p><p> - (NSUInteger)apm_getLineLength {<br> NSString *statusLineString = @””;<br> if ([self isKindOfClass:[NSHTTPURLResponse class]]) {</p><pre><code> NSHTTPURLResponse \*httpResponse = (NSHTTPURLResponse \*)self; statusLineString = \[self apm\_fetchStatusLineFromCFNetwork\];</code></pre><p> }<br> NSData *lineData = [statusLineString dataUsingEncoding:NSUTF8StringEncoding];<br> return lineData.length;<br> }</p></li><li><p>Header 部分</p><p> <code>allHeaderFields</code> 获取到 NSDictionary，然后按照 <code>key: value</code> 拼接成字符串，然后转换成 NSData 计算大小</p><p> 注意：<code>key: value</code> key 后是有空格的，curl 或者 chrome Network 面板可以查看印证下。</p><p> - (NSUInteger)apm_getHeadersLength<br> {<br> NSUInteger headersLength = 0;<br> if ([self isKindOfClass:[NSHTTPURLResponse class]]) {</p><pre><code> NSHTTPURLResponse \*httpResponse = (NSHTTPURLResponse \*)self; NSDictionary \*headerFields = httpResponse.allHeaderFields; NSString \*headerString = @&quot;&quot;; for (NSString \*key in headerFields.allKeys) &#123;     headerString = \[headerStr stringByAppendingString:key\];     headheaderStringerStr = \[headerString stringByAppendingString:@&quot;: &quot;\];     if (\[headerFields objectForKey:key\]) &#123;         headerString = \[headerString stringByAppendingString:headerFields\[key\]\];     &#125;     headerString = \[headerString stringByAppendingString:@&quot;\\n&quot;\]; &#125; NSData \*headerData = \[headerString dataUsingEncoding:NSUTF8StringEncoding\]; headersLength = headerData.length;</code></pre><p> }<br> return headersLength;<br> }</p></li><li><p>Body 部分</p><p> Body 大小的计算不能直接使用 excepectedContentLength，官方文档说明了其不准确性，只可以作为参考。或者 <code>allHeaderFields</code> 中的 <code>Content-Length</code> 值也是不够准确的。</p><blockquote><p>/*!</p><p><strong>@abstract</strong> Returns the expected content length of the receiver.</p><p><strong>@discussion</strong> Some protocol implementations report a content length</p><p>as part of delivering load metadata, but not all protocols</p><p>guarantee the amount of data that will be delivered in actuality.</p><p>Hence, this method returns an expected amount. Clients should use</p><p>this value as an advisory, and should be prepared to deal with</p><p>either more or less data.</p><p><strong>@result</strong> The expected content length of the receiver, or -1 if</p><p>there is no expectation that can be arrived at regarding expected</p><p>content length.</p><p>*/</p><p><strong>@property</strong> (<strong>readonly</strong>) <strong>long</strong> <strong>long</strong> expectedContentLength;</p></blockquote><ul><li><p>  HTTP 1.1 版本规定，如果存在 <code>Transfer-Encoding: chunked</code>，则在 header 中不能有 <code>Content-Length</code>，有也会被忽视。</p></li><li><p>  在 HTTP 1.0及之前版本中，<code>content-length</code> 字段可有可无</p></li><li><p>在 HTTP 1.1及之后版本。如果是 <code>keep alive</code>，则 <code>Content-Length</code> 和 <code>chunked</code> 必然是二选一。若是非<code>keep alive</code>，则和 HTTP 1.0一样。<code>Content-Length</code> 可有可无。</p><p>什么是 <code>Transfer-Encoding: chunked</code></p><p>数据以一系列分块的形式进行发送 <code>Content-Length</code> 首部在这种情况下不被发送. 在每一个分块的开头需要添加当前分块的长度, 以十六进制的形式表示，后面紧跟着 <code>\r\n</code> , 之后是分块本身, 后面也是 <code>\r\n</code> ，终止块是一个常规的分块, 不同之处在于其长度为0.</p><p>我们之前拿 NSMutableData 记录了数据，所以我们可以在 <code>stopLoading</code> 方法中计算出 Body 大小。步骤如下：</p></li><li><p>在 <code>didReceiveData</code> 中不断添加 data</p><p>- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data<br>{<br>  [self.responseData appendData:data];<br>  [self.client URLProtocol:self didLoadData:data];<br>}</p></li></ul></li></ol><ul><li><p>在 <code>stopLoading</code> 方法中拿到 <code>allHeaderFields</code> 字典，获取 <code>Content-Encoding</code> key 的值，如果是 <strong>gzip</strong>，则在 <code>stopLoading</code> 中将 NSData 处理为 gzip 压缩后的数据，再计算大小。（gzip 相关功能可以使用这个<a href="https://link.segmentfault.com/?enc=wIhdNGkCq9yrL31VzIBqyA==.zCMe4OPXbL0XTEsiuqivL7za/Z0ccjxY3A8kt2LI7OCHkRWiBCvTwvl+50VVeo6Q">工具</a>）</p><p>  需要额外计算一个空白行的长度</p><p>  - (void)stopLoadi<br>  {</p><pre><code>  \[self.internalConnection cancel\];  HCTNetworkTrafficModel \*model = \[\[HCTNetworkTrafficModel alloc\] init\];  model.path = self.request.URL.path;  model.host = self.request.URL.host;  model.type = DMNetworkTrafficDataTypeResponse;  model.lineLength = \[self.internalResponse apm\_getStatusLineLength\];  model.headerLength = \[self.internalResponse apm\_getHeadersLength\];  model.emptyLineLength = \[self.internalResponse apm\_getEmptyLineLength\];  if (\[self.dm\_response isKindOfClass:\[NSHTTPURLResponse class\]\]) &#123;      NSHTTPURLResponse \*httpResponse = (NSHTTPURLResponse \*)self.dm\_response;      NSData \*data = self.dm\_data;      if (\[\[httpResponse.allHeaderFields objectForKey:@&quot;Content-Encoding&quot;\] isEqualToString:@&quot;gzip&quot;\]) &#123;          data = \[self.dm\_data gzippedData\];      &#125;      model.bodyLength = data.length;  &#125;  model.length = model.lineLength + model.headerLength + model.bodyLength + model.emptyLineLength;  NSDictionary \*networkTrafficDictionary = \[model convertToDictionary\];  \[\[HermesClient sharedInstance\] sendWithType:APMMonitorNetworkTrafficType meta:networkTrafficDictionary payload:nil\];</code></pre><p>  }</p></li></ul><h6 id="2-5-3-2-Resquest-部分"><a href="#2-5-3-2-Resquest-部分" class="headerlink" title="2.5.3.2 Resquest 部分"></a>2.5.3.2 Resquest 部分</h6><ol><li><p> 先利用网络监控方案将 NSURLProtocol 管理 App 的各种网络请求</p></li><li><p>在各个方法内部记录各项所需参数（NSURLProtocol 不能分析请求握手、挥手等数据大小和时间消耗，不过对于正常情况的接口流量分析足够了，最底层需要 Socket 层）</p><p> @property(nonatomic, strong) NSURLConnection *internalConnection;<br> @property(nonatomic, strong) NSURLResponse *internalResponse;<br> @property(nonatomic, strong) NSMutableData *responseData;<br> @property (nonatomic, strong) NSURLRequest *internalRequest;</p></li></ol><p>- (void)startLoading<br>{<br>    NSMutableURLRequest *mutableRequest = [[self request] mutableCopy];<br>    self.internalConnection = [[NSURLConnection alloc] initWithRequest:mutableRequest delegate:self];<br>    self.internalRequest = self.request;<br>}</p><ul><li><p>(void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response<br>{<br>  [self.client URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageNotAllowed];<br>  self.internalResponse = response;<br>}</p></li><li><p>(void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data<br>{<br>  [self.responseData appendData:data];<br>  [self.client URLProtocol:self didLoadData:data];<br>}</p></li></ul><ol start="3"><li><p>Status Line 部分</p><p> 对于 NSURLRequest 没有像 NSURLResponse 一样的方法找到 StatusLine。所以兜底方案是自己根据 Status Line 的结构，自己手动构造一个。结构为：<code>协议版本号+空格+状态码+空格+状态文本+换行</code></p><p> 为 NSURLRequest 添加一个专门获取 Status Line 的分类。</p><p> // NSURLResquest+apm_FetchStatusLineFromCFNetwork.m</p><ul><li>(NSUInteger)apm_fetchStatusLineLength<br>{<br>NSString *statusLineString = [NSString stringWithFormat:@”%@ %@ %@\n”, self.HTTPMethod, self.URL.path, @”HTTP/1.1”];<br>NSData *statusLineData = [statusLineString dataUsingEncoding:NSUTF8StringEncoding];<br>return statusLineData.length;<br>}</li></ul></li><li><p>Header 部分</p><p> 一个 HTTP 请求会先构建判断是否存在缓存，然后进行 DNS 域名解析以获取请求域名的服务器 IP 地址。如果请求协议是 HTTPS，那么还需要建立 TLS 连接。接下来就是利用 IP 地址和服务器建立 TCP 连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。</p><p> 所以一个网络监控不考虑 cookie 😂，借用王多鱼的一句话「那不完犊子了吗」。</p><p> 看过一些文章说 NSURLRequest 不能完整获取到请求头信息。其实问题不大， 几个信息获取不完全也没办法。衡量监控方案本身就是看接口在不同版本或者某些情况下数据消耗是否异常，WebView 资源请求是否过大，类似于控制变量法的思想。</p><p> 所以获取到 NSURLRequest 的 <code>allHeaderFields</code> 后，加上 cookie 信息，计算完整的 Header 大小</p><p> // NSURLResquest+apm_FetchHeaderWithCookies.m</p><ul><li><p>(NSUInteger)apm_fetchHeaderLengthWithCookie<br>{<br>  NSDictionary *headerFields = self.allHTTPHeaderFields;<br>  NSDictionary *cookiesHeader = [self apm_fetchCookies];</p><p>  if (cookiesHeader.count) {</p><pre><code>  NSMutableDictionary \*headerDictionaryWithCookies = \[NSMutableDictionary dictionaryWithDictionary:headerFields\];  \[headerDictionaryWithCookies addEntriesFromDictionary:cookiesHeader\];  headerFields = \[headerDictionaryWithCookies copy\];</code></pre><p>  }</p><p>  NSString *headerString = @””;</p><p>  for (NSString *key in headerFields.allKeys) {</p><pre><code>  headerString = \[headerString stringByAppendingString:key\];  headerString = \[headerString stringByAppendingString:@&quot;: &quot;\];  if (\[headerFields objectForKey:key\]) &#123;      headerString = \[headerString stringByAppendingString:headerFields\[key\]\];  &#125;  headerString = \[headerString stringByAppendingString:@&quot;\\n&quot;\];</code></pre><p>  }<br>  NSData *headerData = [headerString dataUsingEncoding:NSUTF8StringEncoding];<br>  headersLength = headerData.length;<br>  return headerString;<br>}</p></li><li><p>(NSDictionary *)apm_fetchCookies<br>{<br>  NSDictionary *cookiesHeaderDictionary;<br>  NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];<br>  NSArray&lt;NSHTTPCookie *&gt; *cookies = [cookieStorage cookiesForURL:self.URL];<br>  if (cookies.count) {</p><pre><code>  cookiesHeaderDictionary = \[NSHTTPCookie requestHeaderFieldsWithCookies:cookies\];</code></pre><p>  }<br>  return cookiesHeaderDictionary;<br>}</p></li></ul></li><li><p>Body 部分</p><p> NSURLConnection 的 <code>HTTPBody</code> 有可能获取不到，问题类似于 WebView 上 ajax 等情况。所以可以通过 <code>HTTPBodyStream</code> 读取 stream 来计算 body 大小.</p><p> - (NSUInteger)apm_fetchRequestBody<br> {</p><pre><code> NSDictionary \*headerFields = self.allHTTPHeaderFields; NSUInteger bodyLength = \[self.HTTPBody length\]; if (\[headerFields objectForKey:@&quot;Content-Encoding&quot;\]) &#123;     NSData \*bodyData;     if (self.HTTPBody == nil) &#123;         uint8\_t d\[1024\] = &#123;0&#125;;         NSInputStream \*stream = self.HTTPBodyStream;         NSMutableData \*data = \[\[NSMutableData alloc\] init\];         \[stream open\];         while (\[stream hasBytesAvailable\]) &#123;             NSInteger len = \[stream read:d maxLength:1024\];             if (len &gt; 0 &amp;&amp; stream.streamError == nil) &#123;                 \[data appendBytes:(void \*)d length:len\];             &#125;         &#125;         bodyData = \[data copy\];         \[stream close\];     &#125; else &#123;         bodyData = self.HTTPBody;     &#125;     bodyLength = \[\[bodyData gzippedData\] length\]; &#125; return bodyLength;</code></pre><p> }</p></li><li><p>在 <code>- (NSURLRequest *)connection:(NSURLConnection *)connection willSendRequest:(NSURLRequest *)request redirectResponse:(NSURLResponse *)response</code> 方法中将数据上报会在 <a href="https://link.segmentfault.com/?enc=eA1igiLRIyzxo5vMT8tLmQ==.AHKgASs3qLXjTEPL9wX33oDkOMD1zeDvkG6R9Jp1OXq1zlKsABF2yM0xNspPp96Eq/t1yL+R/k/H7p1hkZh50wttauZx5eHaAgCWyi7opMUOqkwqVl5SGWY4PwJtG5Ys">打造功能强大、灵活可配置的数据上报组件</a> 讲</p><p> -(NSURLRequest *)connection:(NSURLConnection *)connection willSendRequest:(NSURLRequest *)request redirectResponse:(NSURLResponse *)response<br> {</p><pre><code> if (response != nil) &#123;     self.internalResponse = response;     \[self.client URLProtocol:self wasRedirectedToRequest:request redirectResponse:response\]; &#125; HCTNetworkTrafficModel \*model = \[\[HCTNetworkTrafficModel alloc\] init\]; model.path = request.URL.path; model.host = request.URL.host; model.type = DMNetworkTrafficDataTypeRequest; model.lineLength = \[connection.currentRequest dgm\_getLineLength\]; model.headerLength = \[connection.currentRequest dgm\_getHeadersLengthWithCookie\]; model.bodyLength = \[connection.currentRequest dgm\_getBodyLength\]; model.emptyLineLength = \[self.internalResponse apm\_getEmptyLineLength\]; model.length = model.lineLength + model.headerLength + model.bodyLength + model.emptyLineLength; NSDictionary \*networkTrafficDictionary = \[model convertToDictionary\]; \[\[HermesClient sharedInstance\] sendWithType:APMMonitorNetworkTrafficType meta:networkTrafficDictionary payload:nil\]; return request;</code></pre><p> }</p></li></ol><h2 id="六、-电量消耗"><a href="#六、-电量消耗" class="headerlink" title="六、 电量消耗"></a>六、 电量消耗</h2><p>移动设备上电量一直是比较敏感的问题，如果用户在某款 App 的时候发现耗电量严重、手机发热严重，那么用户很大可能会马上卸载这款 App。所以需要在开发阶段关心耗电量问题。</p><p>一般来说遇到耗电量较大，我们立马会想到是不是使用了定位、是不是使用了频繁网络请求、是不是不断循环做某件事情？</p><p>开发阶段基本没啥问题，我们可以结合 <code>Instrucments</code> 里的 <code>Energy Log</code> 工具来定位问题。但是线上问题就需要代码去监控耗电量，可以作为 APM 的能力之一。</p><h3 id="1-如何获取电量"><a href="#1-如何获取电量" class="headerlink" title="1. 如何获取电量"></a>1. 如何获取电量</h3><p>在 iOS 中，<code>IOKit</code> 是一个私有框架，用来获取硬件和设备的详细信息，也是硬件和内核服务通信的底层框架。所以我们可以通过 <code>IOKit</code> 来获取硬件信息，从而获取到电量信息。步骤如下：</p><ul><li>  首先在苹果开放源代码 opensource 中找到 <a href="https://link.segmentfault.com/?enc=b/6fURTOumUTAheQuqpyxw==.dtXSUx10pYnebLQ48O8hnlF0B3mu1BzrOerkThTmYrlnpOwSNKQFCRC847ewVPpe5IgUj5QgS085FsKXyfzn74H35iPkjiQ8aT/fwMuVVp+QOBpakYTdYuZvMsZbG59F/gB5bS8STsX272y03dvAJQ==">IOPowerSources.h</a>、<a href="https://link.segmentfault.com/?enc=JL4sd8PzpJH1P4eo4y6QNQ==.XAH/9UR0Dplko4Zt/s1ZHcsZZOWvPu7K/KAe1o+BdDFcemfyCycdcPwe2G5Hpw9JmvBGhliBSx6fFM5u4ruadbsuWy6Ev0CWwoeUoMTa4EBFjwqYkIdPoZIZkaaNm8gU">IOPSKeys.h</a>。在 Xcode 的 <code>Package Contents</code> 里面找到 <code>IOKit.framework</code>。 路径为 <code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/System/Library/Frameworks/IOKit.framework</code></li><li>  然后将 IOPowerSources.h、IOPSKeys.h、IOKit.framework 导入项目工程</li><li>  设置 UIDevice 的 batteryMonitoringEnabled 为 true</li><li>  获取到的耗电量精确度为 1%</li></ul><h3 id="2-定位问题"><a href="#2-定位问题" class="headerlink" title="2. 定位问题"></a>2. 定位问题</h3><p>通常我们通过 Instrucments 里的 Energy Log 解决了很多问题后，App 上线了，线上的耗电量解决就需要使用 APM 来解决了。耗电地方可能是二方库、三方库，也可能是某个同事的代码。</p><p>思路是：在检测到耗电后，先找到有问题的线程，然后堆栈 dump，还原案发现场。</p><p>在上面部分我们知道了线程信息的结构， <code>thread_basic_info</code> 中有个记录 CPU 使用率百分比的字段 <code>cpu_usage</code>。所以我们可以通过遍历当前线程，判断哪个线程的 CPU 使用率较高，从而找出有问题的线程。然后再 dump 堆栈，从而定位到发生耗电量的代码。详细请看 <a href="https://segmentfault.com/a/1190000040277799#threadInfo">3.2</a> 部分。</p><p>- (double)fetchBatteryCostUsage<br>{<br>  // returns a blob of power source information in an opaque CFTypeRef<br>    CFTypeRef blob = IOPSCopyPowerSourcesInfo();<br>    // returns a CFArray of power source handles, each of type CFTypeRef<br>    CFArrayRef sources = IOPSCopyPowerSourcesList(blob);<br>    CFDictionaryRef pSource = NULL;<br>    const void *psValue;<br>    // returns the number of values currently in an array<br>    int numOfSources = CFArrayGetCount(sources);<br>    // error in CFArrayGetCount<br>    if (numOfSources == 0) {<br>        NSLog(@”Error in CFArrayGetCount”);<br>        return -1.0f;<br>    }</p><pre><code>// calculating the remaining energyfor (int i=0; i&lt;numOfSources; i++) &#123;    // returns a CFDictionary with readable information about the specific power source    pSource = IOPSGetPowerSourceDescription(blob, CFArrayGetValueAtIndex(sources, i));    if (!pSource) &#123;        NSLog(@&quot;Error in IOPSGetPowerSourceDescription&quot;);        return \-1.0f;    &#125;    psValue = (CFStringRef) CFDictionaryGetValue(pSource, CFSTR(kIOPSNameKey));    int curCapacity = 0;    int maxCapacity = 0;    double percentage;    psValue = CFDictionaryGetValue(pSource, CFSTR(kIOPSCurrentCapacityKey));    CFNumberGetValue((CFNumberRef)psValue, kCFNumberSInt32Type, &amp;curCapacity);    psValue = CFDictionaryGetValue(pSource, CFSTR(kIOPSMaxCapacityKey));    CFNumberGetValue((CFNumberRef)psValue, kCFNumberSInt32Type, &amp;maxCapacity);    percentage = ((double) curCapacity / (double) maxCapacity \* 100.0f);    NSLog(@&quot;curCapacity : %d / maxCapacity: %d , percentage: %.1f &quot;, curCapacity, maxCapacity, percentage);    return percentage;&#125;return \-1.0f;</code></pre><p>}</p><h3 id="3-开发阶段针对电量消耗我们能做什么"><a href="#3-开发阶段针对电量消耗我们能做什么" class="headerlink" title="3. 开发阶段针对电量消耗我们能做什么"></a>3. 开发阶段针对电量消耗我们能做什么</h3><p>CPU 密集运算是耗电量主要原因。所以我们对 CPU 的使用需要精打细算。尽量避免让 CPU 做无用功。对于大量数据的复杂运算，可以借助服务器的能力、GPU 的能力。如果方案设计必须是在 CPU 上完成数据的运算，则可以利用 GCD 技术，使用 <code>dispatch_block_create_with_qos_class(&lt;#dispatch_block_flags_t flags#&gt;, dispatch_qos_class_t qos_class, &lt;#int relative_priority#&gt;, &lt;#^(void)block#&gt;)()</code> 并指定 队列的 qos 为 <code>QOS_CLASS_UTILITY</code>。将任务提交到这个队列的 block 中，在 QOS_CLASS_UTILITY 模式下，系统针对大量数据的计算，做了电量优化</p><p>除了 CPU 大量运算，I/O 操作也是耗电主要原因。业界常见方案都是将「碎片化的数据写入磁盘存储」这个操作延后，先在内存中聚合吗，然后再进行磁盘存储。碎片化数据先聚合，在内存中进行存储的机制，iOS 提供 <code>NSCache</code> 这个对象。</p><p>NSCache 是线程安全的，NSCache 会在达到达预设的缓存空间的条件时清理缓存，此时会触发 <code>- (**void**)cache:(NSCache *)cache willEvictObject:(**id**)obj;</code> 方法回调，在该方法内部对数据进行 I/O 操作，达到将聚合的数据 I/O 延后的目的。I/O 次数少了，对电量的消耗也就减少了。</p><p>NSCache 的使用可以查看 SDWebImage 这个图片加载框架。在图片读取缓存处理时，没直接读取硬盘文件（I/O），而是使用系统的 NSCache。</p><p>- (nullable UIImage *)imageFromMemoryCacheForKey:(nullable NSString *)key {<br>    return [self.memoryCache objectForKey:key];<br>}</p><ul><li><p>(nullable UIImage *)imageFromDiskCacheForKey:(nullable NSString *)key {<br>  UIImage *diskImage = [self diskImageForKey:key];<br>  if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) {</p><pre><code>  NSUInteger cost = diskImage.sd\_memoryCost;  \[self.memoryCache setObject:diskImage forKey:key cost:cost\];</code></pre><p>  }</p><p>  return diskImage;<br>}</p></li></ul><p>可以看到主要逻辑是先从磁盘中读取图片，如果配置允许开启内存缓存，则将图片保存到 NSCache 中，使用的时候也是从 NSCache 中读取图片。NSCache 的 <code>totalCostLimit、countLimit</code> 属性，</p><p><code>- (void)setObject:(ObjectType)obj forKey:(KeyType)key cost:(NSUInteger)g;</code> 方法用来设置缓存条件。所以我们写磁盘、内存的文件操作时可以借鉴该策略，以优化耗电量。</p><h2 id="七、-Crash-监控"><a href="#七、-Crash-监控" class="headerlink" title="七、 Crash 监控"></a>七、 Crash 监控</h2><h3 id="1-异常相关知识回顾"><a href="#1-异常相关知识回顾" class="headerlink" title="1. 异常相关知识回顾"></a>1. 异常相关知识回顾</h3><h4 id="1-1-Mach-层对异常的处理"><a href="#1-1-Mach-层对异常的处理" class="headerlink" title="1.1 Mach 层对异常的处理"></a>1.1 Mach 层对异常的处理</h4><p>Mach 在消息传递基础上实现了一套独特的异常处理方法。Mach 异常处理在设计时考虑到：</p><ul><li>  带有一致的语义的单一异常处理设施：Mach 只提供一个异常处理机制用于处理所有类型的异常（包括用户定义的异常、平台无关的异常以及平台特定的异常）。根据异常类型进行分组，具体的平台可以定义具体的子类型。</li><li>  清晰和简洁：异常处理的接口依赖于 Mach 已有的具有良好定义的消息和端口架构，因此非常优雅（不会影响效率）。这就允许调试器和外部处理程序的拓展-甚至在理论上还支持拓展基于网络的异常处理。</li></ul><p>在 Mach 中，异常是通过内核中的基础设施-消息传递机制处理的。一个异常并不比一条消息复杂多少，异常由出错的线程或者任务（通过 msg_send()） 抛出，然后由一个处理程序通过 msg_recv()）捕捉。处理程序可以处理异常，也可以清楚异常（将异常标记为已完成并继续），还可以决定终止线程。</p><p>Mach 的异常处理模型和其他的异常处理模型不同，其他模型的异常处理程序运行在出错的线程上下文中，而 Mach 的异常处理程序在不同的上下文中运行异常处理程序，出错的线程向预先指定好的异常端口发送消息，然后等待应答。每一个任务都可以注册一个异常处理端口，这个异常处理端口会对该任务中的所有线程生效。此外，每个线程都可以通过 <code>thread_set_exception_ports(&lt;#thread_act_t thread#&gt;, &lt;#exception_mask_t exception_mask#&gt;, &lt;#mach_port_t new_port#&gt;, &lt;#exception_behavior_t behavior#&gt;, &lt;#thread_state_flavor_t new_flavor#&gt;)</code> 注册自己的异常处理端口。通常情况下，任务和线程的异常端口都是 NULL，也就是异常不会被处理，而一旦创建异常端口，这些端口就像系统中的其他端口一样，可以转交给其他任务或者其他主机。（有了端口，就可以使用 UDP 协议，通过网络能力让其他的主机上应用程序处理异常）。</p><p>发生异常时，首先尝试将异常抛给线程的异常端口，然后尝试抛给任务的异常端口，最后再抛给主机的异常端口（即主机注册的默认端口）。如果没有一个端口返回 <code>KERN_SUCCESS</code>，那么整个任务将被终止。也就是 Mach 不提供异常处理逻辑，只提供传递异常通知的框架。</p><p>异常首先是由处理器陷阱引发的。为了处理陷阱，每一个现代的内核都会安插陷阱处理程序。这些底层函数是由内核的汇编部分安插的。</p><h4 id="1-2-BSD-层对异常的处理"><a href="#1-2-BSD-层对异常的处理" class="headerlink" title="1.2 BSD 层对异常的处理"></a>1.2 BSD 层对异常的处理</h4><p>BSD 层是用户态主要使用的 XUN 接口，这一层展示了一个符合 POSIX 标准的接口。开发者可以使用 UNIX 系统的一切功能，但不需要了解 Mach 层的细节实现。</p><p>Mach 已经通过异常机制提供了底层的陷进处理，而 BSD 则在异常机制之上构建了信号处理机制。硬件产生的信号被 Mach 层捕捉，然后转换为对应的 UNIX 信号，为了维护一个统一的机制，操作系统和用户产生的信号首先被转换为 Mach 异常，然后再转换为信号。</p><p>Mach 异常都在 host 层被 <code>ux_exception</code> 转换为相应的 unix 信号，并通过 <code>threadsignal</code> 将信号投递到出错的线程。</p><p><img src="https://segmentfault.com/img/bVbIOko"></p><h3 id="2-Crash-收集方式"><a href="#2-Crash-收集方式" class="headerlink" title="2. Crash 收集方式"></a>2. Crash 收集方式</h3><p>iOS 系统自带的 Apples`s Crash Reporter 在设置中记录 Crash 日志，我们先观察下 Crash 日志</p><p>Incident Identifier: 7FA6736D-09E8-47A1-95EC-76C4522BDE1A<br>CrashReporter Key:   4e2d36419259f14413c3229e8b7235bcc74847f3<br>Hardware Model:      iPhone7,1<br>Process:         APMMonitorExample [3608]<br>Path:            /var/containers/Bundle/Application/9518A4F4-59B7-44E9-BDDA-9FBEE8CA18E5/APMMonitorExample.app/APMMonitorExample<br>Identifier:      com.Wacai.APMMonitorExample<br>Version:         1.0 (1)<br>Code Type:       ARM-64<br>Parent Process:  ? [1]</p><p>Date/Time:       2017-01-03 11:43:03.000 +0800<br>OS Version:      iOS 10.2 (14C92)<br>Report Version:  104</p><p>Exception Type:  EXC_CRASH (SIGABRT)<br>Exception Codes: 0x00000000 at 0x0000000000000000<br>Crashed Thread:  0</p><p>Application Specific Information:<br>*** Terminating app due to uncaught exception ‘NSInvalidArgumentException’, reason: ‘-[__NSSingleObjectArrayI objectForKey:]: unrecognized selector sent to instance 0x174015060’</p><p>Thread 0 Crashed:<br>0   CoreFoundation                  0x0000000188f291b8 0x188df9000 + 1245624 (<redacted> + 124)<br>1   libobjc.A.dylib                 0x000000018796055c 0x187958000 + 34140 (objc_exception_throw + 56)<br>2   CoreFoundation                  0x0000000188f30268 0x188df9000 + 1274472 (<redacted> + 140)<br>3   CoreFoundation                  0x0000000188f2d270 0x188df9000 + 1262192 (<redacted> + 916)<br>4   CoreFoundation                  0x0000000188e2680c 0x188df9000 + 186380 (_CF_forwarding_prep_0 + 92)<br>5   APMMonitorExample                0x000000010004c618 0x100044000 + 34328 (-[MakeCrashHandler throwUncaughtNSException] + 80)</p><p>会发现，Crash 日志中 <code>Exception Type</code> 项由2部分组成：Mach 异常 + Unix 信号。</p><p>所以 <code>Exception Type: EXC_CRASH (SIGABRT)</code> 表示：Mach 层发生了 <code>EXC_CRASH</code> 异常，在 host 层被转换为 <code>SIGABRT</code> 信号投递到出错的线程。</p><p><strong>问题：</strong> 捕获 Mach 层异常、注册 Unix 信号处理都可以捕获 Crash，这两种方式如何选择？</p><p><strong>答：</strong> 优选 Mach 层异常拦截。根据上面 1.2 中的描述我们知道 Mach 层异常处理时机更早些，假如 Mach 层异常处理程序让进程退出，这样 Unix 信号永远不会发生了。</p><p>业界关于崩溃日志的收集开源项目很多，著名的有： KSCrash、plcrashreporter，提供一条龙服务的 Bugly、友盟等。我们一般使用开源项目在此基础上开发成符合公司内部需求的 bug 收集工具。一番对比后选择 KSCrash。为什么选择 KSCrash 不在本文重点。</p><p>KSCrash 功能齐全，可以捕获如下类型的 Crash</p><ul><li>  Mach kernel exceptions</li><li>  Fatal signals</li><li>  C++ exceptions</li><li>  Objective-C exceptions</li><li>  Main thread deadlock (experimental)</li><li>  Custom crashes (e.g. from scripting languages)</li></ul><p>所以分析 iOS 端的 Crash 收集方案也就是分析 KSCrash 的 Crash 监控实现原理。</p><h4 id="2-1-Mach-层异常处理"><a href="#2-1-Mach-层异常处理" class="headerlink" title="2.1. Mach 层异常处理"></a>2.1. Mach 层异常处理</h4><p>大体思路是：先创建一个异常处理端口，为该端口申请权限，再设置异常端口、新建一个内核线程，在该线程内循环等待异常。但是为了防止自己注册的 Mach 层异常处理抢占了其他 SDK、或者业务线开发者设置的逻辑，我们需要在最开始保存其他的异常处理端口，等逻辑执行完后将异常处理交给其他的端口内的逻辑处理。收集到 Crash 信息后组装数据，写入 json 文件。</p><p>流程图如下：</p><p><img src="https://segmentfault.com/img/bVbIOku"></p><p>对于 Mach 异常捕获，可以注册一个异常端口，该端口负责对当前任务的所有线程进行监听。</p><p>下面来看看关键代码:</p><p>注册 Mach 层异常监听代码</p><p>static bool installExceptionHandler()<br>{<br>    KSLOG_DEBUG(“Installing mach exception handler.”);</p><pre><code>bool attributes\_created = false;pthread\_attr\_t attr;kern\_return\_t kr;int error;// 拿到当前进程const task\_t thisTask = mach\_task\_self();exception\_mask\_t mask = EXC\_MASK\_BAD\_ACCESS |EXC\_MASK\_BAD\_INSTRUCTION |EXC\_MASK\_ARITHMETIC |EXC\_MASK\_SOFTWARE |EXC\_MASK\_BREAKPOINT;KSLOG\_DEBUG(&quot;Backing up original exception ports.&quot;);// 获取该 Task 上的注册好的异常端口kr = task\_get\_exception\_ports(thisTask,                              mask,                              g\_previousExceptionPorts.masks,                              &amp;g\_previousExceptionPorts.count,                              g\_previousExceptionPorts.ports,                              g\_previousExceptionPorts.behaviors,                              g\_previousExceptionPorts.flavors);// 获取失败走 failed 逻辑if(kr != KERN\_SUCCESS)&#123;    KSLOG\_ERROR(&quot;task\_get\_exception\_ports: %s&quot;, mach\_error\_string(kr));    goto failed;&#125;// KSCrash 的异常为空则走执行逻辑if(g\_exceptionPort == MACH\_PORT\_NULL)&#123;    KSLOG\_DEBUG(&quot;Allocating new port with receive rights.&quot;);    // 申请异常处理端口    kr = mach\_port\_allocate(thisTask,                            MACH\_PORT\_RIGHT\_RECEIVE,                            &amp;g\_exceptionPort);    if(kr != KERN\_SUCCESS)    &#123;        KSLOG\_ERROR(&quot;mach\_port\_allocate: %s&quot;, mach\_error\_string(kr));        goto failed;    &#125;    KSLOG\_DEBUG(&quot;Adding send rights to port.&quot;);    // 为异常处理端口申请权限：MACH\_MSG\_TYPE\_MAKE\_SEND    kr = mach\_port\_insert\_right(thisTask,                                g\_exceptionPort,                                g\_exceptionPort,                                MACH\_MSG\_TYPE\_MAKE\_SEND);    if(kr != KERN\_SUCCESS)    &#123;        KSLOG\_ERROR(&quot;mach\_port\_insert\_right: %s&quot;, mach\_error\_string(kr));        goto failed;    &#125;&#125;KSLOG\_DEBUG(&quot;Installing port as exception handler.&quot;);// 为该 Task 设置异常处理端口kr = task\_set\_exception\_ports(thisTask,                              mask,                              g\_exceptionPort,                              EXCEPTION\_DEFAULT,                              THREAD\_STATE\_NONE);if(kr != KERN\_SUCCESS)&#123;    KSLOG\_ERROR(&quot;task\_set\_exception\_ports: %s&quot;, mach\_error\_string(kr));    goto failed;&#125;KSLOG\_DEBUG(&quot;Creating secondary exception thread (suspended).&quot;);pthread\_attr\_init(&amp;attr);attributes\_created = true;pthread\_attr\_setdetachstate(&amp;attr, PTHREAD\_CREATE\_DETACHED);// 设置监控线程error = pthread\_create(&amp;g\_secondaryPThread,                       &amp;attr,                       &amp;handleExceptions,                       kThreadSecondary);if(error != 0)&#123;    KSLOG\_ERROR(&quot;pthread\_create\_suspended\_np: %s&quot;, strerror(error));    goto failed;&#125;// 转换为 Mach 内核线程g\_secondaryMachThread = pthread\_mach\_thread\_np(g\_secondaryPThread);ksmc\_addReservedThread(g\_secondaryMachThread);KSLOG\_DEBUG(&quot;Creating primary exception thread.&quot;);error = pthread\_create(&amp;g\_primaryPThread,                       &amp;attr,                       &amp;handleExceptions,                       kThreadPrimary);if(error != 0)&#123;    KSLOG\_ERROR(&quot;pthread\_create: %s&quot;, strerror(error));    goto failed;&#125;pthread\_attr\_destroy(&amp;attr);g\_primaryMachThread = pthread\_mach\_thread\_np(g\_primaryPThread);ksmc\_addReservedThread(g\_primaryMachThread);KSLOG\_DEBUG(&quot;Mach exception handler installed.&quot;);return true;</code></pre><p>failed:<br>    KSLOG_DEBUG(“Failed to install mach exception handler.”);<br>    if(attributes_created)<br>    {<br>        pthread_attr_destroy(&amp;attr);<br>    }<br>    // 还原之前的异常注册端口，将控制权还原<br>    uninstallExceptionHandler();<br>    return false;<br>}</p><p>处理异常的逻辑、组装崩溃信息</p><p>/** Our exception handler thread routine.<br> * Wait for an exception message, uninstall our exception port, record the<br> * exception information, and write a report.<br> */<br>static void* handleExceptions(void* const userData)<br>{<br>    MachExceptionMessage exceptionMessage = 0;<br>    MachReplyMessage replyMessage = 0;<br>    char* eventID = g_primaryEventID;</p><pre><code>const char\* threadName = (const char\*) userData;pthread\_setname\_np(threadName);if(threadName == kThreadSecondary)&#123;    KSLOG\_DEBUG(&quot;This is the secondary thread. Suspending.&quot;);    thread\_suspend((thread\_t)ksthread\_self());    eventID = g\_secondaryEventID;&#125;// 循环读取注册好的异常端口信息for(;;)&#123;    KSLOG\_DEBUG(&quot;Waiting for mach exception&quot;);    // Wait for a message.    kern\_return\_t kr = mach\_msg(&amp;exceptionMessage.header,                                MACH\_RCV\_MSG,                                0,                                sizeof(exceptionMessage),                                g\_exceptionPort,                                MACH\_MSG\_TIMEOUT\_NONE,                                MACH\_PORT\_NULL);    // 获取到信息后则代表发生了 Mach 层异常，跳出 for 循环，组装数据    if(kr == KERN\_SUCCESS)    &#123;        break;    &#125;    // Loop and try again on failure.    KSLOG\_ERROR(&quot;mach\_msg: %s&quot;, mach\_error\_string(kr));&#125;KSLOG\_DEBUG(&quot;Trapped mach exception code 0x%x, subcode 0x%x&quot;,            exceptionMessage.code\[0\], exceptionMessage.code\[1\]);if(g\_isEnabled)&#123;    // 挂起所有线程    ksmc\_suspendEnvironment();    g\_isHandlingCrash = true;    // 通知发生了异常    kscm\_notifyFatalExceptionCaptured(true);    KSLOG\_DEBUG(&quot;Exception handler is installed. Continuing exception handling.&quot;);    // Switch to the secondary thread if necessary, or uninstall the handler    // to avoid a death loop.    if(ksthread\_self() == g\_primaryMachThread)    &#123;        KSLOG\_DEBUG(&quot;This is the primary exception thread. Activating secondary thread.&quot;);</code></pre><p>// TODO: This was put here to avoid a freeze. Does secondary thread ever fire?<br>            restoreExceptionPorts();<br>            if(thread_resume(g_secondaryMachThread) != KERN_SUCCESS)<br>            {<br>                KSLOG_DEBUG(“Could not activate secondary thread. Restoring original exception ports.”);<br>            }<br>        }<br>        else<br>        {<br>            KSLOG_DEBUG(“This is the secondary exception thread. Restoring original exception ports.”);<br>//            restoreExceptionPorts();<br>        }</p><pre><code>    // Fill out crash information    // 组装异常所需要的方案现场信息    KSLOG\_DEBUG(&quot;Fetching machine state.&quot;);    KSMC\_NEW\_CONTEXT(machineContext);    KSCrash\_MonitorContext\* crashContext = &amp;g\_monitorContext;    crashContext-&gt;offendingMachineContext = machineContext;    kssc\_initCursor(&amp;g\_stackCursor, NULL, NULL);    if(ksmc\_getContextForThread(exceptionMessage.thread.name, machineContext, true))    &#123;        kssc\_initWithMachineContext(&amp;g\_stackCursor, 100, machineContext);        KSLOG\_TRACE(&quot;Fault address 0x%x, instruction address 0x%x&quot;, kscpu\_faultAddress(machineContext), kscpu\_instructionAddress(machineContext));        if(exceptionMessage.exception == EXC\_BAD\_ACCESS)        &#123;            crashContext-&gt;faultAddress = kscpu\_faultAddress(machineContext);        &#125;        else        &#123;            crashContext-&gt;faultAddress = kscpu\_instructionAddress(machineContext);        &#125;    &#125;    KSLOG\_DEBUG(&quot;Filling out context.&quot;);    crashContext-&gt;crashType = KSCrashMonitorTypeMachException;    crashContext-&gt;eventID = eventID;    crashContext-&gt;registersAreValid = true;    crashContext-&gt;mach.type = exceptionMessage.exception;    crashContext-&gt;mach.code = exceptionMessage.code\[0\];    crashContext-&gt;mach.subcode = exceptionMessage.code\[1\];    if(crashContext-&gt;mach.code == KERN\_PROTECTION\_FAILURE &amp;&amp; crashContext-&gt;isStackOverflow)    &#123;        // A stack overflow should return KERN\_INVALID\_ADDRESS, but        // when a stack blasts through the guard pages at the top of the stack,        // it generates KERN\_PROTECTION\_FAILURE. Correct for this.        crashContext-&gt;mach.code = KERN\_INVALID\_ADDRESS;    &#125;    crashContext-&gt;signal.signum = signalForMachException(crashContext-&gt;mach.type, crashContext-&gt;mach.code);    crashContext-&gt;stackCursor = &amp;g\_stackCursor;    kscm\_handleException(crashContext);    KSLOG\_DEBUG(&quot;Crash handling complete. Restoring original handlers.&quot;);    g\_isHandlingCrash = false;    ksmc\_resumeEnvironment();&#125;KSLOG\_DEBUG(&quot;Replying to mach exception message.&quot;);// Send a reply saying &quot;I didn&#39;t handle this exception&quot;.replyMessage.header = exceptionMessage.header;replyMessage.NDR = exceptionMessage.NDR;replyMessage.returnCode = KERN\_FAILURE;mach\_msg(&amp;replyMessage.header,         MACH\_SEND\_MSG,         sizeof(replyMessage),         0,         MACH\_PORT\_NULL,         MACH\_MSG\_TIMEOUT\_NONE,         MACH\_PORT\_NULL);return NULL;</code></pre><p>}</p><p>还原异常处理端口，转移控制权</p><p>/** Restore the original mach exception ports.<br> */<br>static void restoreExceptionPorts(void)<br>{<br>    KSLOG_DEBUG(“Restoring original exception ports.”);<br>    if(g_previousExceptionPorts.count == 0)<br>    {<br>        KSLOG_DEBUG(“Original exception ports were already restored.”);<br>        return;<br>    }</p><pre><code>const task\_t thisTask = mach\_task\_self();kern\_return\_t kr;// Reinstall old exception ports.// for 循环去除保存好的在 KSCrash 之前注册好的异常端口，将每个端口注册回去for(mach\_msg\_type\_number\_t i = 0; i &lt; g\_previousExceptionPorts.count; i++)&#123;    KSLOG\_TRACE(&quot;Restoring port index %d&quot;, i);    kr = task\_set\_exception\_ports(thisTask,                                  g\_previousExceptionPorts.masks\[i\],                                  g\_previousExceptionPorts.ports\[i\],                                  g\_previousExceptionPorts.behaviors\[i\],                                  g\_previousExceptionPorts.flavors\[i\]);    if(kr != KERN\_SUCCESS)    &#123;        KSLOG\_ERROR(&quot;task\_set\_exception\_ports: %s&quot;,                    mach\_error\_string(kr));    &#125;&#125;KSLOG\_DEBUG(&quot;Exception ports restored.&quot;);g\_previousExceptionPorts.count = 0;</code></pre><p>}</p><h4 id="2-2-Signal-异常处理"><a href="#2-2-Signal-异常处理" class="headerlink" title="2.2. Signal 异常处理"></a>2.2. Signal 异常处理</h4><p>对于 Mach 异常，操作系统会将其转换为对应的 <code>Unix 信号</code>，所以开发者可以通过注册 <code>signanHandler</code> 的方式来处理。</p><p>KSCrash 在这里的处理逻辑如下图：</p><p><img src="https://segmentfault.com/img/bVbIOkv"><br>看一下关键代码:</p><p>设置信号处理函数</p><p>static bool installSignalHandler()<br>{<br>    KSLOG_DEBUG(“Installing signal handler.”);</p><p>#if KSCRASH_HAS_SIGNAL_STACK<br>    // 在堆上分配一块内存，<br>    if(g_signalStack.ss_size == 0)<br>    {<br>        KSLOG_DEBUG(“Allocating signal stack area.”);<br>        g_signalStack.ss_size = SIGSTKSZ;<br>        g_signalStack.ss_sp = malloc(g_signalStack.ss_size);<br>    }<br>    // 信号处理函数的栈挪到堆中，而不和进程共用一块栈区<br>    // sigaltstack() 函数，该函数的第 1 个参数 sigstack 是一个 stack_t 结构的指针，该结构存储了一个“可替换信号栈” 的位置及属性信息。第 2 个参数 old_sigstack 也是一个 stack_t 类型指针，它用来返回上一次建立的“可替换信号栈”的信息(如果有的话)<br>    KSLOG_DEBUG(“Setting signal stack area.”);<br>    // sigaltstack 第一个参数为创建的新的可替换信号栈，第二个参数可以设置为NULL，如果不为NULL的话，将会将旧的可替换信号栈的信息保存在里面。函数成功返回0，失败返回-1.<br>    if(sigaltstack(&amp;g_signalStack, NULL) != 0)<br>    {<br>        KSLOG_ERROR(“signalstack: %s”, strerror(errno));<br>        goto failed;<br>    }<br>#endif</p><pre><code>const int\* fatalSignals = kssignal\_fatalSignals();int fatalSignalsCount = kssignal\_numFatalSignals();if(g\_previousSignalHandlers == NULL)&#123;    KSLOG\_DEBUG(&quot;Allocating memory to store previous signal handlers.&quot;);    g\_previousSignalHandlers = malloc(sizeof(\*g\_previousSignalHandlers)                                      \* (unsigned)fatalSignalsCount);&#125;// 设置信号处理函数 sigaction 的第二个参数，类型为 sigaction 结构体struct sigaction action = &#123;&#123;0&#125;&#125;;// sa\_flags 成员设立 SA\_ONSTACK 标志，该标志告诉内核信号处理函数的栈帧就在“可替换信号栈”上建立。action.sa\_flags = SA\_SIGINFO | SA\_ONSTACK;</code></pre><p>#if KSCRASH_HOST_APPLE &amp;&amp; defined(__LP64__)<br>    action.sa_flags |= SA_64REGSET;<br>#endif<br>    sigemptyset(&amp;action.sa_mask);<br>    action.sa_sigaction = &handleSignal;</p><pre><code>// 遍历需要处理的信号数组for(int i = 0; i &lt; fatalSignalsCount; i++)&#123;    // 将每个信号的处理函数绑定到上面声明的 action 去，另外用 g\_previousSignalHandlers 保存当前信号的处理函数    KSLOG\_DEBUG(&quot;Assigning handler for signal %d&quot;, fatalSignals\[i\]);    if(sigaction(fatalSignals\[i\], &amp;action, &amp;g\_previousSignalHandlers\[i\]) != 0)    &#123;        char sigNameBuff\[30\];        const char\* sigName = kssignal\_signalName(fatalSignals\[i\]);        if(sigName == NULL)        &#123;            snprintf(sigNameBuff, sizeof(sigNameBuff), &quot;%d&quot;, fatalSignals\[i\]);            sigName = sigNameBuff;        &#125;        KSLOG\_ERROR(&quot;sigaction (%s): %s&quot;, sigName, strerror(errno));        // Try to reverse the damage        for(i--;i &gt;= 0; i--)        &#123;            sigaction(fatalSignals\[i\], &amp;g\_previousSignalHandlers\[i\], NULL);        &#125;        goto failed;    &#125;&#125;KSLOG\_DEBUG(&quot;Signal handlers installed.&quot;);return true;</code></pre><p>failed:<br>    KSLOG_DEBUG(“Failed to install signal handlers.”);<br>    return false;<br>}</p><p>信号处理时记录线程等上下文信息</p><p>static void handleSignal(int sigNum, siginfo_t* signalInfo, void* userContext)<br>{<br>    KSLOG_DEBUG(“Trapped signal %d”, sigNum);<br>    if(g_isEnabled)<br>    {<br>        ksmc_suspendEnvironment();<br>        kscm_notifyFatalExceptionCaptured(false);</p><pre><code>    KSLOG\_DEBUG(&quot;Filling out context.&quot;);    KSMC\_NEW\_CONTEXT(machineContext);    ksmc\_getContextForSignal(userContext, machineContext);    kssc\_initWithMachineContext(&amp;g\_stackCursor, 100, machineContext);    // 记录信号处理时的上下文信息    KSCrash\_MonitorContext\* crashContext = &amp;g\_monitorContext;    memset(crashContext, 0, sizeof(\*crashContext));    crashContext-&gt;crashType = KSCrashMonitorTypeSignal;    crashContext-&gt;eventID = g\_eventID;    crashContext-&gt;offendingMachineContext = machineContext;    crashContext-&gt;registersAreValid = true;    crashContext-&gt;faultAddress = (uintptr\_t)signalInfo-&gt;si\_addr;    crashContext-&gt;signal.userContext = userContext;    crashContext-&gt;signal.signum = signalInfo-&gt;si\_signo;    crashContext-&gt;signal.sigcode = signalInfo-&gt;si\_code;    crashContext-&gt;stackCursor = &amp;g\_stackCursor;    kscm\_handleException(crashContext);    ksmc\_resumeEnvironment();&#125;KSLOG\_DEBUG(&quot;Re-raising signal for regular handlers to catch.&quot;);// This is technically not allowed, but it works in OSX and iOS.raise(sigNum);</code></pre><p>}</p><p>KSCrash 信号处理后还原之前的信号处理权限</p><p>static void uninstallSignalHandler(void)<br>{<br>    KSLOG_DEBUG(“Uninstalling signal handlers.”);</p><pre><code>const int\* fatalSignals = kssignal\_fatalSignals();int fatalSignalsCount = kssignal\_numFatalSignals();// 遍历需要处理信号数组，将之前的信号处理函数还原for(int i = 0; i &lt; fatalSignalsCount; i++)&#123;    KSLOG\_DEBUG(&quot;Restoring original handler for signal %d&quot;, fatalSignals\[i\]);    sigaction(fatalSignals\[i\], &amp;g\_previousSignalHandlers\[i\], NULL);&#125;KSLOG\_DEBUG(&quot;Signal handlers uninstalled.&quot;);</code></pre><p>}</p><p>说明：</p><ol><li><p>先从堆上分配一块内存区域，被称为“可替换信号栈”，目的是将信号处理函数的栈干掉，用堆上的内存区域代替，而不和进程共用一块栈区。</p><p> 为什么这么做？一个进程可能有 n 个线程，每个线程都有自己的任务，假如某个线程执行出错，这样就会导致整个进程的崩溃。所以为了信号处理函数正常运行，需要为信号处理函数设置单独的运行空间。另一种情况是递归函数将系统默认的栈空间用尽了，但是信号处理函数使用的栈是它实现在堆中分配的空间，而不是系统默认的栈，所以它仍旧可以正常工作。</p></li><li><p><code>int sigaltstack(const stack_t * __restrict, stack_t * __restrict)</code> 函数的二个参数都是 <code>stack_t</code> 结构的指针，存储了可替换信号栈的信息（栈的起始地址、栈的长度、状态）。第1个参数该结构存储了一个“可替换信号栈” 的位置及属性信息。第 2 个参数用来返回上一次建立的“可替换信号栈”的信息(如果有的话)。</p><p> _STRUCT_SIGALTSTACK<br> {</p><pre><code> void            \*ss\_sp;         /\* signal stack base \*/ \_\_darwin\_size\_t ss\_size;        /\* signal stack length \*/ int             ss\_flags;       /\* SA\_DISABLE and/or SA\_ONSTACK \*/</code></pre><p> };<br> typedef _STRUCT_SIGALTSTACK     stack_t; /* [???] signal stack */</p></li></ol><p>新创建的可替换信号栈，<code>ss_flags</code> 必须设置为 0。系统定义了 <code>SIGSTKSZ</code> 常量，可满足绝大多可替换信号栈的需求。</p><p>/*<br> * Structure used in sigaltstack call.<br> */</p><p>#define SS_ONSTACK      0x0001  /* take signal on signal stack */<br>#define SS_DISABLE      0x0004  /* disable taking signals on alternate stack */<br>#define MINSIGSTKSZ     32768   /* (32K)minimum allowable stack */<br>#define SIGSTKSZ        131072  /* (128K)recommended stack size */</p><p><code>sigaltstack</code> 系统调用通知内核“可替换信号栈”已经建立。</p><p><code>ss_flags</code> 为 <code>SS_ONSTACK</code> 时，表示进程当前正在“可替换信号栈”中执行，如果此时试图去建立一个新的“可替换信号栈”，那么会遇到 <code>EPERM</code> (禁止该动作) 的错误；为 <code>SS_DISABLE</code> 说明当前没有已建立的“可替换信号栈”，禁止建立“可替换信号栈”。</p><ol start="3"><li><p><code>int sigaction(int, const struct sigaction * __restrict, struct sigaction * __restrict);</code></p><p> 第一个函数表示需要处理的信号值，但不能是 <code>SIGKILL</code> 和 <code>SIGSTOP</code> ，这两个信号的处理函数不允许用户重写，因为它们给超级用户提供了终止程序的方法（ <code>SIGKILL</code> and <code>SIGSTOP</code> cannot be caught, blocked, or ignored）；</p><p> 第二个和第三个参数是一个 <code>sigaction</code> 结构体。如果第二个参数不为空则代表将其指向信号处理函数，第三个参数不为空，则将之前的信号处理函数保存到该指针中。如果第二个参数为空，第三个参数不为空，则可以获取当前的信号处理函数。</p><p> /*<br>  * Signal vector “template” used in sigaction call.<br>  */<br> struct  sigaction {</p><pre><code> union \_\_sigaction\_u \_\_sigaction\_u;  /\* signal handler \*/ sigset\_t sa\_mask;               /\* signal mask to apply \*/ int     sa\_flags;               /\* see signal options below \*/</code></pre><p> };</p></li></ol><p><code>sigaction</code> 函数的 <code>sa_flags</code> 参数需要设置 <code>SA_ONSTACK</code> 标志，告诉内核信号处理函数的栈帧就在“可替换信号栈”上建立。</p><h4 id="2-3-C-异常处理"><a href="#2-3-C-异常处理" class="headerlink" title="2.3. C++ 异常处理"></a>2.3. C++ 异常处理</h4><p>c++ 异常处理的实现是依靠了标准库的 <code>std::set_terminate(CPPExceptionTerminate)</code> 函数。</p><p>iOS 工程中某些功能的实现可能使用了C、C++等。假如抛出 C++ 异常，如果该异常可以被转换为 NSException，则走 OC 异常捕获机制，如果不能转换，则继续走 C++ 异常流程，也就是 <code>default_terminate_handler</code>。这个 C++ 异常的默认 terminate 函数内部调用 <code>abort_message</code> 函数，最后触发了一个 <code>abort</code> 调用，系统产生一个 <code>SIGABRT</code> 信号。</p><p>在系统抛出 C++ 异常后，加一层 <code>try...catch...</code> 来判断该异常是否可以转换为 <code>NSException</code>，再重新抛出的C++异常。此时异常的现场堆栈已经消失，所以上层通过捕获 <code>SIGABRT</code> 信号是无法还原发生异常时的场景，即异常堆栈缺失。</p><p>为什么？<code>try...catch...</code> 语句内部会调用 <code>__cxa_rethrow()</code> 抛出异常，<code>__cxa_rethrow()</code> 内部又会调用 <code>unwind</code>，<code>unwind</code> 可以简单理解为函数调用的逆调用，主要用来清理函数调用过程中每个函数生成的局部变量，一直到最外层的 catch 语句所在的函数，并把控制移交给 catch 语句，这就是C++异常的堆栈消失原因。</p><p>static void setEnabled(bool isEnabled) {<br>    if(isEnabled != g_isEnabled)<br>    {<br>        g_isEnabled = isEnabled;<br>        if(isEnabled)<br>        {<br>            initialize();</p><pre><code>        ksid\_generate(g\_eventID);        g\_originalTerminateHandler = std::set\_terminate(CPPExceptionTerminate);    &#125;    else    &#123;        std::set\_terminate(g\_originalTerminateHandler);    &#125;    g\_captureNextStackTrace = isEnabled;&#125;</code></pre><p>}</p><p>static void initialize() {<br>    static bool isInitialized = false;<br>    if(!isInitialized)<br>    {<br>        isInitialized = true;<br>        kssc_initCursor(&amp;g_stackCursor, NULL, NULL);<br>    }<br>}</p><p>void kssc_initCursor(KSStackCursor *cursor,<br>                     void (*resetCursor)(KSStackCursor*),<br>                     bool (*advanceCursor)(KSStackCursor*)) {<br>    cursor-&gt;symbolicate = kssymbolicator_symbolicate;<br>    cursor-&gt;advanceCursor = advanceCursor != NULL ? advanceCursor : g_advanceCursor;<br>    cursor-&gt;resetCursor = resetCursor != NULL ? resetCursor : kssc_resetCursor;<br>    cursor-&gt;resetCursor(cursor);<br>}</p><p>static void CPPExceptionTerminate(void) {<br>    ksmc_suspendEnvironment();<br>    KSLOG_DEBUG(“Trapped c++ exception”);<br>    const char* name = NULL;<br>    std::type_info* tinfo = __cxxabiv1::__cxa_current_exception_type();<br>    if(tinfo != NULL)<br>    {<br>        name = tinfo-&gt;name();<br>    }</p><pre><code>if(name == NULL || strcmp(name, &quot;NSException&quot;) != 0)&#123;    kscm\_notifyFatalExceptionCaptured(false);    KSCrash\_MonitorContext\* crashContext = &amp;g\_monitorContext;    memset(crashContext, 0, sizeof(\*crashContext));    char descriptionBuff\[DESCRIPTION\_BUFFER\_LENGTH\];    const char\* description = descriptionBuff;    descriptionBuff\[0\] = 0;    KSLOG\_DEBUG(&quot;Discovering what kind of exception was thrown.&quot;);    g\_captureNextStackTrace = false;    try    &#123;        throw;    &#125;    catch(std::exception&amp; exc)    &#123;        strncpy(descriptionBuff, exc.what(), sizeof(descriptionBuff));    &#125;</code></pre><p>#define CATCH_VALUE(TYPE, PRINTFTYPE) \<br>catch(TYPE value)\<br>{ \<br>    snprintf(descriptionBuff, sizeof(descriptionBuff), “%” #PRINTFTYPE, value); \<br>}<br>        CATCH_VALUE(char,                 d)<br>        CATCH_VALUE(short,                d)<br>        CATCH_VALUE(int,                  d)<br>        CATCH_VALUE(long,                ld)<br>        CATCH_VALUE(long long,          lld)<br>        CATCH_VALUE(unsigned char,        u)<br>        CATCH_VALUE(unsigned short,       u)<br>        CATCH_VALUE(unsigned int,         u)<br>        CATCH_VALUE(unsigned long,       lu)<br>        CATCH_VALUE(unsigned long long, llu)<br>        CATCH_VALUE(float,                f)<br>        CATCH_VALUE(double,               f)<br>        CATCH_VALUE(long double,         Lf)<br>        CATCH_VALUE(char*,                s)<br>        catch(…)<br>        {<br>            description = NULL;<br>        }<br>        g_captureNextStackTrace = g_isEnabled;</p><pre><code>    // TODO: Should this be done here? Maybe better in the exception handler?    KSMC\_NEW\_CONTEXT(machineContext);    ksmc\_getContextForThread(ksthread\_self(), machineContext, true);    KSLOG\_DEBUG(&quot;Filling out context.&quot;);    crashContext-&gt;crashType = KSCrashMonitorTypeCPPException;    crashContext-&gt;eventID = g\_eventID;    crashContext-&gt;registersAreValid = false;    crashContext-&gt;stackCursor = &amp;g\_stackCursor;    crashContext-&gt;CPPException.name = name;    crashContext-&gt;exceptionName = name;    crashContext-&gt;crashReason = description;    crashContext-&gt;offendingMachineContext = machineContext;    kscm\_handleException(crashContext);&#125;else&#123;    KSLOG\_DEBUG(&quot;Detected NSException. Letting the current NSException handler deal with it.&quot;);&#125;ksmc\_resumeEnvironment();KSLOG\_DEBUG(&quot;Calling original terminate handler.&quot;);g\_originalTerminateHandler();</code></pre><p>}</p><h4 id="2-4-Objective-C-异常处理"><a href="#2-4-Objective-C-异常处理" class="headerlink" title="2.4. Objective-C 异常处理"></a>2.4. Objective-C 异常处理</h4><p>对于 OC 层面的 NSException 异常处理较为容易，可以通过注册 <code>NSUncaughtExceptionHandler</code> 来捕获异常信息，通过 NSException 参数来做 Crash 信息的收集，交给数据上报组件。</p><p>static void setEnabled(bool isEnabled) {<br>    if(isEnabled != g_isEnabled)<br>    {<br>        g_isEnabled = isEnabled;<br>        if(isEnabled)<br>        {<br>            KSLOG_DEBUG(@”Backing up original handler.”);<br>            // 记录之前的 OC 异常处理函数<br>            g_previousUncaughtExceptionHandler = NSGetUncaughtExceptionHandler();</p><pre><code>        KSLOG\_DEBUG(@&quot;Setting new handler.&quot;);        // 设置新的 OC 异常处理函数        NSSetUncaughtExceptionHandler(&amp;handleException);        KSCrash.sharedInstance.uncaughtExceptionHandler = &amp;handleException;    &#125;    else    &#123;        KSLOG\_DEBUG(@&quot;Restoring original handler.&quot;);        NSSetUncaughtExceptionHandler(g\_previousUncaughtExceptionHandler);    &#125;&#125;</code></pre><p>}</p><h4 id="2-5-主线程死锁"><a href="#2-5-主线程死锁" class="headerlink" title="2.5. 主线程死锁"></a>2.5. 主线程死锁</h4><p>主线程死锁的检测和 ANR 的检测有些类似</p><ul><li><p>  创建一个线程，在线程运行方法中用 <code>do...while...</code> 循环处理逻辑，加了 autorelease 避免内存过高</p></li><li><p>有一个 <code>awaitingResponse</code> 属性和 <code>watchdogPulse</code> 方法。watchdogPulse 主要逻辑为设置 <code>awaitingResponse</code> 为 YES，切换到主线程中，设置 <code>awaitingResponse</code> 为 NO，</p><p>  - (void) watchdogPulse<br>  {</p><pre><code>  \_\_block id blockSelf = self;  self.awaitingResponse = YES;  dispatch\_async(dispatch\_get\_main\_queue(), ^                 &#123;                     \[blockSelf watchdogAnswer\];                 &#125;);</code></pre><p>  }</p></li><li><p>线程的执行方法里面不断循环，等待设置的 <code>g_watchdogInterval</code> 后判断 <code>awaitingResponse</code> 的属性值是不是初始状态的值，否则判断为死锁</p><p>  - (void) runMonitor<br>  {</p><pre><code>  BOOL cancelled = NO;  do  &#123;      // Only do a watchdog check if the watchdog interval is &gt; 0.      // If the interval is &lt;= 0, just idle until the user changes it.      @autoreleasepool &#123;          NSTimeInterval sleepInterval = g\_watchdogInterval;          BOOL runWatchdogCheck = sleepInterval &gt; 0;          if(!runWatchdogCheck)          &#123;              sleepInterval = kIdleInterval;          &#125;          \[NSThread sleepForTimeInterval:sleepInterval\];          cancelled = self.monitorThread.isCancelled;          if(!cancelled &amp;&amp; runWatchdogCheck)          &#123;              if(self.awaitingResponse)              &#123;                  \[self handleDeadlock\];              &#125;              else              &#123;                  \[self watchdogPulse\];              &#125;          &#125;      &#125;  &#125; while (!cancelled);</code></pre><p>  }</p></li></ul><h4 id="2-6-Crash-的生成与保存"><a href="#2-6-Crash-的生成与保存" class="headerlink" title="2.6 Crash 的生成与保存"></a>2.6 Crash 的生成与保存</h4><h5 id="2-6-1-Crash-日志的生成逻辑"><a href="#2-6-1-Crash-日志的生成逻辑" class="headerlink" title="2.6.1 Crash 日志的生成逻辑"></a>2.6.1 Crash 日志的生成逻辑</h5><p>上面的部分讲过了 iOS 应用开发中的各种 crash 监控逻辑，接下来就应该分析下 crash 捕获后如何将 crash 信息记录下来，也就是保存到应用沙盒中。</p><p>拿主线程死锁这种 crash 举例子，看看 KSCrash 是如何记录 crash 信息的。</p><p>// KSCrashMonitor_Deadlock.m</p><ul><li><p>(void) handleDeadlock<br>{<br>  ksmc_suspendEnvironment();<br>  kscm_notifyFatalExceptionCaptured(false);</p><p>  KSMC_NEW_CONTEXT(machineContext);<br>  ksmc_getContextForThread(g_mainQueueThread, machineContext, false);<br>  KSStackCursor stackCursor;<br>  kssc_initWithMachineContext(&amp;stackCursor, 100, machineContext);<br>  char eventID[37];<br>  ksid_generate(eventID);</p><p>  KSLOG_DEBUG(@”Filling out context.”);<br>  KSCrash_MonitorContext* crashContext = &amp;g_monitorContext;<br>  memset(crashContext, 0, sizeof(*crashContext));<br>  crashContext-&gt;crashType = KSCrashMonitorTypeMainThreadDeadlock;<br>  crashContext-&gt;eventID = eventID;<br>  crashContext-&gt;registersAreValid = false;<br>  crashContext-&gt;offendingMachineContext = machineContext;<br>  crashContext-&gt;stackCursor = &stackCursor;</p><p>  kscm_handleException(crashContext);<br>  ksmc_resumeEnvironment();</p><p>  KSLOG_DEBUG(@”Calling abort()”);<br>  abort();<br>}</p></li></ul><p>其他几个 crash 也是一样，异常信息经过包装交给 <code>kscm_handleException()</code> 函数处理。可以看到这个函数被其他几种 crash 捕获后所调用。</p><p><img src="https://segmentfault.com/img/bVbIOkD"></p><p>/** Start general exception processing.<br> *<br> * @oaram context Contextual information about the exception.<br> */<br>void kscm_handleException(struct KSCrash_MonitorContext* context)<br>{<br>    context-&gt;requiresAsyncSafety = g_requiresAsyncSafety;<br>    if(g_crashedDuringExceptionHandling)<br>    {<br>        context-&gt;crashedDuringCrashHandling = true;<br>    }<br>    for(int i = 0; i &lt; g_monitorsCount; i++)<br>    {<br>        Monitor* monitor = &amp;g_monitors[i];<br>        // 判断当前的 crash 监控是开启状态<br>        if(isMonitorEnabled(monitor))<br>        {<br>            // 针对每种 crash 类型做一些额外的补充信息<br>            addContextualInfoToEvent(monitor, context);<br>        }<br>    }<br>    // 真正处理 crash 信息，保存 json 格式的 crash 信息<br>    g_onExceptionEvent(context);</p><pre><code>if(g\_handlingFatalException &amp;&amp; !g\_crashedDuringExceptionHandling)&#123;    KSLOG\_DEBUG(&quot;Exception is fatal. Restoring original handlers.&quot;);    kscm\_setActiveMonitors(KSCrashMonitorTypeNone);&#125;</code></pre><p>}</p><p><code>g_onExceptionEvent</code> 是一个 block，声明为 <code>static void (*g_onExceptionEvent)(struct KSCrash_MonitorContext* monitorContext);</code> 在 <code>KSCrashMonitor.c</code> 中被赋值</p><p>void kscm_setEventCallback(void (*onEvent)(struct KSCrash_MonitorContext* monitorContext))<br>{<br>    g_onExceptionEvent = onEvent;<br>}</p><p><code>kscm_setEventCallback()</code> 函数在 <code>KSCrashC.c</code> 文件中被调用</p><p>KSCrashMonitorType kscrash_install(const char* appName, const char* const installPath)<br>{<br>    KSLOG_DEBUG(“Installing crash reporter.”);</p><pre><code>if(g\_installed)&#123;    KSLOG\_DEBUG(&quot;Crash reporter already installed.&quot;);    return g\_monitoring;&#125;g\_installed = 1;char path\[KSFU\_MAX\_PATH\_LENGTH\];snprintf(path, sizeof(path), &quot;%s/Reports&quot;, installPath);ksfu\_makePath(path);kscrs\_initialize(appName, path);snprintf(path, sizeof(path), &quot;%s/Data&quot;, installPath);ksfu\_makePath(path);snprintf(path, sizeof(path), &quot;%s/Data/CrashState.json&quot;, installPath);kscrashstate\_initialize(path);snprintf(g\_consoleLogPath, sizeof(g\_consoleLogPath), &quot;%s/Data/ConsoleLog.txt&quot;, installPath);if(g\_shouldPrintPreviousLog)&#123;    printPreviousLog(g\_consoleLogPath);&#125;kslog\_setLogFilename(g\_consoleLogPath, true);ksccd\_init(60);// 设置 crash 发生时的 callback 函数kscm\_setEventCallback(onCrash);KSCrashMonitorType monitors = kscrash\_setMonitoring(g\_monitoring);KSLOG\_DEBUG(&quot;Installation complete.&quot;);return monitors;</code></pre><p>}</p><p>/** Called when a crash occurs.<br> *<br> * This function gets passed as a callback to a crash handler.<br> */<br>static void onCrash(struct KSCrash_MonitorContext* monitorContext)<br>{<br>    KSLOG_DEBUG(“Updating application state to note crash.”);<br>    kscrashstate_notifyAppCrash();<br>    monitorContext-&gt;consoleLogPath = g_shouldAddConsoleLogToReport ? g_consoleLogPath : NULL;</p><pre><code>// 正在处理 crash 的时候，发生了再次 crashif(monitorContext-&gt;crashedDuringCrashHandling)&#123;    kscrashreport\_writeRecrashReport(monitorContext, g\_lastCrashReportFilePath);&#125;else&#123;    // 1. 先根据当前时间创建新的 crash 的文件路径    char crashReportFilePath\[KSFU\_MAX\_PATH\_LENGTH\];    kscrs\_getNextCrashReportPath(crashReportFilePath);    // 2. 将新生成的文件路径保存到 g\_lastCrashReportFilePath    strncpy(g\_lastCrashReportFilePath, crashReportFilePath, sizeof(g\_lastCrashReportFilePath));    // 3. 将新生成的文件路径传入函数进行 crash 写入    kscrashreport\_writeStandardReport(monitorContext, crashReportFilePath);&#125;</code></pre><p>}</p><p>接下来的函数就是具体的日志写入文件的实现。2个函数做的事情相似，都是格式化为 json 形式并写入文件。区别在于 crash 写入时如果再次发生 crash， 则走简易版的写入逻辑 <code>kscrashreport_writeRecrashReport()</code>，否则走标准的写入逻辑 <code>kscrashreport_writeStandardReport()</code>。</p><p>bool ksfu_openBufferedWriter(KSBufferedWriter* writer, const char* const path, char* writeBuffer, int writeBufferLength)<br>{<br>    writer-&gt;buffer = writeBuffer;<br>    writer-&gt;bufferLength = writeBufferLength;<br>    writer-&gt;position = 0;<br>    /*<br>     open() 的第二个参数描述的是文件操作的权限<br>     #define O_RDONLY        0x0000         open for reading only<br>     #define O_WRONLY        0x0001         open for writing only<br>     #define O_RDWR          0x0002         open for reading and writing<br>     #define O_ACCMODE       0x0003         mask for above mode</p><pre><code> #define O\_CREAT         0x0200         create if nonexistant #define O\_TRUNC         0x0400         truncate to zero length #define O\_EXCL          0x0800         error if already exists 0755：即用户具有读/写/执行权限，组用户和其它用户具有读写权限； 0644：即用户具有读写权限，组用户和其它用户具有只读权限； 成功则返回文件描述符，若出现则返回 -1 \*/writer-&gt;fd = open(path, O\_RDWR | O\_CREAT | O\_EXCL, 0644);if(writer-&gt;fd &lt; 0)&#123;    KSLOG\_ERROR(&quot;Could not open crash report file %s: %s&quot;, path, strerror(errno));    return false;&#125;return true;</code></pre><p>}</p><p>/**<br> * Write a standard crash report to a file.<br> *<br> *  @param monitorContext Contextual information about the crash and environment.<br> *                      The caller must fill this out before passing it in.<br> *<br> *  @param path The file to write to.<br> */<br>void kscrashreport_writeStandardReport(const struct KSCrash_MonitorContext* const monitorContext,<br>                                       const char* path)<br>{<br>        KSLOG_INFO(“Writing crash report to %s”, path);<br>    char writeBuffer[1024];<br>    KSBufferedWriter bufferedWriter;</p><pre><code>if(!ksfu\_openBufferedWriter(&amp;bufferedWriter, path, writeBuffer, sizeof(writeBuffer)))&#123;    return;&#125;ksccd\_freeze();KSJSONEncodeContext jsonContext;jsonContext.userData = &amp;bufferedWriter;KSCrashReportWriter concreteWriter;KSCrashReportWriter\* writer = &amp;concreteWriter;prepareReportWriter(writer, &amp;jsonContext);ksjson\_beginEncode(getJsonContext(writer), true, addJSONData, &amp;bufferedWriter);writer-&gt;beginObject(writer, KSCrashField\_Report);&#123;    writeReportInfo(writer,                    KSCrashField\_Report,                    KSCrashReportType\_Standard,                    monitorContext-&gt;eventID,                    monitorContext-&gt;System.processName);    ksfu\_flushBufferedWriter(&amp;bufferedWriter);    writeBinaryImages(writer, KSCrashField\_BinaryImages);    ksfu\_flushBufferedWriter(&amp;bufferedWriter);    writeProcessState(writer, KSCrashField\_ProcessState, monitorContext);    ksfu\_flushBufferedWriter(&amp;bufferedWriter);    writeSystemInfo(writer, KSCrashField\_System, monitorContext);    ksfu\_flushBufferedWriter(&amp;bufferedWriter);    writer-&gt;beginObject(writer, KSCrashField\_Crash);    &#123;        writeError(writer, KSCrashField\_Error, monitorContext);        ksfu\_flushBufferedWriter(&amp;bufferedWriter);        writeAllThreads(writer,                        KSCrashField\_Threads,                        monitorContext,                        g\_introspectionRules.enabled);        ksfu\_flushBufferedWriter(&amp;bufferedWriter);    &#125;    writer-&gt;endContainer(writer);    if(g\_userInfoJSON != NULL)    &#123;        addJSONElement(writer, KSCrashField\_User, g\_userInfoJSON, false);        ksfu\_flushBufferedWriter(&amp;bufferedWriter);    &#125;    else    &#123;        writer-&gt;beginObject(writer, KSCrashField\_User);    &#125;    if(g\_userSectionWriteCallback != NULL)    &#123;        ksfu\_flushBufferedWriter(&amp;bufferedWriter);        g\_userSectionWriteCallback(writer);    &#125;    writer-&gt;endContainer(writer);    ksfu\_flushBufferedWriter(&amp;bufferedWriter);    writeDebugInfo(writer, KSCrashField\_Debug, monitorContext);&#125;writer-&gt;endContainer(writer);ksjson\_endEncode(getJsonContext(writer));ksfu\_closeBufferedWriter(&amp;bufferedWriter);ksccd\_unfreeze();</code></pre><p>}</p><p>/** Write a minimal crash report to a file.<br> *<br> * @param monitorContext Contextual information about the crash and environment.<br> *                       The caller must fill this out before passing it in.<br> *<br> * @param path The file to write to.<br> */<br>void kscrashreport_writeRecrashReport(const struct KSCrash_MonitorContext* const monitorContext,<br>                                      const char* path)<br>{<br>  char writeBuffer[1024];<br>    KSBufferedWriter bufferedWriter;<br>    static char tempPath[KSFU_MAX_PATH_LENGTH];<br>    // 将传递过来的上份 crash report 文件名路径（/var/mobile/Containers/Data/Application/******/Library/Caches/KSCrash/Test/Reports/Test-report-******.json）修改为去掉 .json ，加上 .old 成为新的文件路径 /var/mobile/Containers/Data/Application/******/Library/Caches/KSCrash/Test/Reports/Test-report-******.old</p><pre><code>strncpy(tempPath, path, sizeof(tempPath) - 10);strncpy(tempPath + strlen(tempPath) - 5, &quot;.old&quot;, 5);KSLOG\_INFO(&quot;Writing recrash report to %s&quot;, path);if(rename(path, tempPath) &lt; 0)&#123;    KSLOG\_ERROR(&quot;Could not rename %s to %s: %s&quot;, path, tempPath, strerror(errno));&#125;// 根据传入路径来打开内存写入需要的文件if(!ksfu\_openBufferedWriter(&amp;bufferedWriter, path, writeBuffer, sizeof(writeBuffer)))&#123;    return;&#125;ksccd\_freeze();// json 解析的 c 代码KSJSONEncodeContext jsonContext;jsonContext.userData = &amp;bufferedWriter;KSCrashReportWriter concreteWriter;KSCrashReportWriter\* writer = &amp;concreteWriter;prepareReportWriter(writer, &amp;jsonContext);ksjson\_beginEncode(getJsonContext(writer), true, addJSONData, &amp;bufferedWriter);writer-&gt;beginObject(writer, KSCrashField\_Report);&#123;    writeRecrash(writer, KSCrashField\_RecrashReport, tempPath);    ksfu\_flushBufferedWriter(&amp;bufferedWriter);    if(remove(tempPath) &lt; 0)    &#123;        KSLOG\_ERROR(&quot;Could not remove %s: %s&quot;, tempPath, strerror(errno));    &#125;    writeReportInfo(writer,                    KSCrashField\_Report,                    KSCrashReportType\_Minimal,                    monitorContext-&gt;eventID,                    monitorContext-&gt;System.processName);    ksfu\_flushBufferedWriter(&amp;bufferedWriter);    writer-&gt;beginObject(writer, KSCrashField\_Crash);    &#123;        writeError(writer, KSCrashField\_Error, monitorContext);        ksfu\_flushBufferedWriter(&amp;bufferedWriter);        int threadIndex = ksmc\_indexOfThread(monitorContext-&gt;offendingMachineContext,                                             ksmc\_getThreadFromContext(monitorContext-&gt;offendingMachineContext));        writeThread(writer,                    KSCrashField\_CrashedThread,                    monitorContext,                    monitorContext-&gt;offendingMachineContext,                    threadIndex,                    false);        ksfu\_flushBufferedWriter(&amp;bufferedWriter);    &#125;    writer-&gt;endContainer(writer);&#125;writer-&gt;endContainer(writer);ksjson\_endEncode(getJsonContext(writer));ksfu\_closeBufferedWriter(&amp;bufferedWriter);ksccd\_unfreeze();</code></pre><p>}</p><h5 id="2-6-2-Crash-日志的读取逻辑"><a href="#2-6-2-Crash-日志的读取逻辑" class="headerlink" title="2.6.2 Crash 日志的读取逻辑"></a>2.6.2 Crash 日志的读取逻辑</h5><p>当前 App 在 Crash 之后，KSCrash 将数据保存到 App 沙盒目录下，App 下次启动后我们读取存储的 crash 文件，然后处理数据并上传。</p><p>App 启动后函数调用：</p><p><code>[KSCrashInstallation sendAllReportsWithCompletion:]</code> -&gt; <code>[KSCrash sendAllReportsWithCompletion:]</code> -&gt; <code>[KSCrash allReports]</code> -&gt; <code>[KSCrash reportWithIntID:]</code> -&gt;<code>[KSCrash loadCrashReportJSONWithID:]</code> -&gt; <code>kscrs_readReport</code></p><p>在 <code>sendAllReportsWithCompletion</code> 里读取沙盒里的Crash 数据。</p><p>// 先通过读取文件夹，遍历文件夹内的文件数量来判断 crash 报告的个数<br>static int getReportCount()<br>{<br>    int count = 0;<br>    DIR* dir = opendir(g_reportsPath);<br>    if(dir == NULL)<br>    {<br>        KSLOG_ERROR(“Could not open directory %s”, g_reportsPath);<br>        goto done;<br>    }<br>    struct dirent* ent;<br>    while((ent = readdir(dir)) != NULL)<br>    {<br>        if(getReportIDFromFilename(ent-&gt;d_name) &gt; 0)<br>        {<br>            count++;<br>        }<br>    }</p><p>done:<br>    if(dir != NULL)<br>    {<br>        closedir(dir);<br>    }<br>    return count;<br>}</p><p>// 通过 crash 文件个数、文件夹信息去遍历，一次获取到文件名（文件名的最后一部分就是 reportID），拿到 reportID 再去读取 crash 报告内的文件内容，写入数组</p><ul><li><p>(NSArray*) allReports<br>{<br>  int reportCount = kscrash_getReportCount();<br>  int64_t reportIDs[reportCount];<br>  reportCount = kscrash_getReportIDs(reportIDs, reportCount);<br>  NSMutableArray* reports = [NSMutableArray arrayWithCapacity:(NSUInteger)reportCount];<br>  for(int i = 0; i &lt; reportCount; i++)<br>  {</p><pre><code>  NSDictionary\* report = \[self reportWithIntID:reportIDs\[i\]\];  if(report != nil)  &#123;      \[reports addObject:report\];  &#125;</code></pre><p>  }</p><p>  return reports;<br>}</p></li></ul><p>//  根据 reportID 找到 crash 信息</p><ul><li><p>(NSDictionary*) reportWithIntID:(int64_t) reportID<br>{<br>  NSData* jsonData = [self loadCrashReportJSONWithID:reportID];<br>  if(jsonData == nil)<br>  {</p><pre><code>  return nil;</code></pre><p>  }</p><p>  NSError* error = nil;<br>  NSMutableDictionary* crashReport = [KSJSONCodec decode:jsonData</p><pre><code>                                             options:KSJSONDecodeOptionIgnoreNullInArray |                                                     KSJSONDecodeOptionIgnoreNullInObject |                                                     KSJSONDecodeOptionKeepPartialObject                                               error:&amp;error\];</code></pre><p>  if(error != nil)<br>  {</p><pre><code>  KSLOG\_ERROR(@&quot;Encountered error loading crash report %&quot; PRIx64 &quot;: %@&quot;, reportID, error);</code></pre><p>  }<br>  if(crashReport == nil)<br>  {</p><pre><code>  KSLOG\_ERROR(@&quot;Could not load crash report&quot;);  return nil;</code></pre><p>  }<br>  [self doctorReport:crashReport];</p><p>  return crashReport;<br>}</p></li></ul><p>//  reportID 读取 crash 内容并转换为 NSData 类型</p><ul><li>(NSData*) loadCrashReportJSONWithID:(int64_t) reportID<br>{<br>  char* report = kscrash_readReport(reportID);<br>  if(report != NULL)<br>  {<pre><code>  return \[NSData dataWithBytesNoCopy:report length:strlen(report) freeWhenDone:YES\];</code></pre>  }<br>  return nil;<br>}</li></ul><p>// reportID 读取 crash 数据到 char 类型<br>char* kscrash_readReport(int64_t reportID)<br>{<br>    if(reportID &lt;= 0)<br>    {<br>        KSLOG_ERROR(“Report ID was %” PRIx64, reportID);<br>        return NULL;<br>    }</p><pre><code>char\* rawReport = kscrs\_readReport(reportID);if(rawReport == NULL)&#123;    KSLOG\_ERROR(&quot;Failed to load report ID %&quot; PRIx64, reportID);    return NULL;&#125;char\* fixedReport = kscrf\_fixupCrashReport(rawReport);if(fixedReport == NULL)&#123;    KSLOG\_ERROR(&quot;Failed to fixup report ID %&quot; PRIx64, reportID);&#125;free(rawReport);return fixedReport;</code></pre><p>}</p><p>// 多线程加锁，通过 reportID 执行 c 函数 getCrashReportPathByID，将路径设置到 path 上。然后执行 ksfu_readEntireFile 读取 crash 信息到 result<br>char* kscrs_readReport(int64_t reportID)<br>{<br>    pthread_mutex_lock(&amp;g_mutex);<br>    char path[KSCRS_MAX_PATH_LENGTH];<br>    getCrashReportPathByID(reportID, path);<br>    char* result;<br>    ksfu_readEntireFile(path, &amp;result, NULL, 2000000);<br>    pthread_mutex_unlock(&amp;g_mutex);<br>    return result;<br>}</p><p>int kscrash_getReportIDs(int64_t* reportIDs, int count)<br>{<br>    return kscrs_getReportIDs(reportIDs, count);<br>}</p><p>int kscrs_getReportIDs(int64_t* reportIDs, int count)<br>{<br>    pthread_mutex_lock(&amp;g_mutex);<br>    count = getReportIDs(reportIDs, count);<br>    pthread_mutex_unlock(&amp;g_mutex);<br>    return count;<br>}<br>// 循环读取文件夹内容，根据 ent-&gt;d_name 调用 getReportIDFromFilename 函数，来获取 reportID，循环内部填充数组<br>static int getReportIDs(int64_t* reportIDs, int count)<br>{<br>    int index = 0;<br>    DIR* dir = opendir(g_reportsPath);<br>    if(dir == NULL)<br>    {<br>        KSLOG_ERROR(“Could not open directory %s”, g_reportsPath);<br>        goto done;<br>    }</p><pre><code>struct dirent\* ent;while((ent = readdir(dir)) != NULL &amp;&amp; index &lt; count)&#123;    int64\_t reportID = getReportIDFromFilename(ent-&gt;d\_name);    if(reportID &gt; 0)    &#123;        reportIDs\[index++\] = reportID;    &#125;&#125;qsort(reportIDs, (unsigned)count, sizeof(reportIDs\[0\]), compareInt64);</code></pre><p>done:<br>    if(dir != NULL)<br>    {<br>        closedir(dir);<br>    }<br>    return index;<br>}</p><p>// sprintf(参数1， 格式2) 函数将格式2的值返回到参数1上，然后执行 sscanf(参数1， 参数2， 参数3)，函数将字符串参数1的内容，按照参数2的格式，写入到参数3上。crash 文件命名为 “App名称-report-reportID.json”<br>static int64_t getReportIDFromFilename(const char* filename)<br>{<br>    char scanFormat[100];<br>    sprintf(scanFormat, “%s-report-%%” PRIx64 “.json”, g_appName);</p><pre><code>int64\_t reportID = 0;sscanf(filename, scanFormat, &amp;reportID);return reportID;</code></pre><p>}</p><p><img src="https://segmentfault.com/img/bVbIOkN"></p><h4 id="2-7-前端-js-相关的-Crash-的监控"><a href="#2-7-前端-js-相关的-Crash-的监控" class="headerlink" title="2.7 前端 js 相关的 Crash 的监控"></a>2.7 前端 js 相关的 Crash 的监控</h4><h5 id="2-7-1-JavascriptCore-异常监控"><a href="#2-7-1-JavascriptCore-异常监控" class="headerlink" title="2.7.1 JavascriptCore 异常监控"></a>2.7.1 JavascriptCore 异常监控</h5><p>这部分简单粗暴，直接通过 JSContext 对象的 exceptionHandler 属性来监控，比如下面的代码</p><p>jsContext.exceptionHandler = ^(JSContext *context, JSValue *exception) {<br>    // 处理 jscore 相关的异常信息<br>};</p><h5 id="2-7-2-h5-页面异常监控"><a href="#2-7-2-h5-页面异常监控" class="headerlink" title="2.7.2 h5 页面异常监控"></a>2.7.2 h5 页面异常监控</h5><p>当 h5 页面内的 Javascript 运行异常时会 window 对象会触发 <code>ErrorEvent</code> 接口的 error 事件，并执行 <code>window.onerror()</code>。</p><p>window.onerror = function (msg, url, lineNumber, columnNumber, error) {<br>   // 处理异常信息<br>};</p><p><img src="https://segmentfault.com/img/bVbIOkO"></p><h5 id="2-7-3-React-Native-异常监控"><a href="#2-7-3-React-Native-异常监控" class="headerlink" title="2.7.3 React Native 异常监控"></a>2.7.3 React Native 异常监控</h5><p>小实验：下图是写了一个 RN Demo 工程，在 Debug Text 控件上加了事件监听代码，内部人为触发 crash</p><p>&lt;Text style={styles.sectionTitle} onPress={()=&gt;{1+qw;}}&gt;Debug&lt;/Text&gt;</p><p>对比组1：</p><p>条件： iOS 项目 debug 模式。在 RN 端增加了异常处理的代码。</p><p>模拟器点击 <code>command + d</code> 调出面板，选择 Debug，打开 Chrome 浏览器， Mac 下快捷键 <code>Command + Option + J</code> 打开调试面板，就可以像调试 React 一样调试 RN 代码了。</p><p>查看到 crash stack 后点击可以跳转到 sourceMap 的地方。</p><p>Tips：RN 项目打 Release 包</p><ul><li><p>  在项目根目录下创建文件夹（ release_iOS），作为资源的输出文件夹</p></li><li><p>在终端切换到工程目录，然后执行下面的代码</p><p>  react-native bundle –entry-file index.js –platform ios –dev false –bundle-output release_ios/main.jsbundle –assets-dest release_iOS –sourcemap-output release_ios/index.ios.map;</p></li><li><p>  将 release_iOS 文件夹内的 <code>.jsbundle</code> 和 <code>assets</code> 文件夹内容拖入到 iOS 工程中即可</p></li></ul><p>对比组2：</p><p>条件：iOS 项目 release 模式。在 RN 端不增加异常处理代码</p><p>操作：运行 iOS 工程，点击按钮模拟 crash</p><p>现象：iOS 项目奔溃。截图以及日志如下</p><p><img src="https://segmentfault.com/img/bVbIOkX"></p><p>2020-06-22 22:26:03.318 [info][tid:main][RCTRootView.m:294] Running application todos ({<br>    initialProps =     {<br>    };<br>    rootTag = 1;<br>})<br>2020-06-22 22:26:03.490 [info][tid:com.facebook.react.JavaScript] Running “todos” with {“rootTag”:1,”initialProps”:{}}<br>2020-06-22 22:27:38.673 [error][tid:com.facebook.react.JavaScript] ReferenceError: Can’t find variable: qw<br>2020-06-22 22:27:38.675 [fatal][tid:com.facebook.react.ExceptionsManagerQueue] Unhandled JS Exception: ReferenceError: Can’t find variable: qw<br>2020-06-22 22:27:38.691300+0800 todos[16790:314161] *** Terminating app due to uncaught exception ‘RCTFatalException: Unhandled JS Exception: ReferenceError: Can’t find variable: qw’, reason: ‘Unhandled JS Exception: ReferenceError: Can’t find variable: qw, stack:<br>onPress@397:1821<br><unknown>@203:3896<br>_performSideEffectsForTransition@210:9689<br>_performSideEffectsForTransition@(null):(null)<br>_receiveSignal@210:8425<br>_receiveSignal@(null):(null)<br>touchableHandleResponderRelease@210:5671<br>touchableHandleResponderRelease@(null):(null)<br>onResponderRelease@203:3006<br>b@97:1125<br>S@97:1268<br>w@97:1322<br>R@97:1617<br>M@97:2401<br>forEach@(null):(null)<br>U@97:2201<br><unknown>@97:13818<br>Pe@97:90199<br>Re@97:13478<br>Ie@97:13664<br>receiveTouches@97:14448<br>value@27:3544<br><unknown>@27:840<br>value@27:2798<br>value@27:812<br>value@(null):(null)<br>‘<br>*** First throw call stack:<br>(<br>    0   CoreFoundation                      0x00007fff23e3cf0e __exceptionPreprocess + 350<br>    1   libobjc.A.dylib                     0x00007fff50ba89b2 objc_exception_throw + 48<br>    2   todos                               0x00000001017b0510 RCTFormatError + 0<br>    3   todos                               0x000000010182d8ca -[RCTExceptionsManager reportFatal:stack:exceptionId:suppressRedBox:] + 503<br>    4   todos                               0x000000010182e34e -[RCTExceptionsManager reportException:] + 1658<br>    5   CoreFoundation                      0x00007fff23e43e8c __invoking___ + 140<br>    6   CoreFoundation                      0x00007fff23e41071 -[NSInvocation invoke] + 321<br>    7   CoreFoundation                      0x00007fff23e41344 -[NSInvocation invokeWithTarget:] + 68<br>    8   todos                               0x00000001017e07fa -[RCTModuleMethod invokeWithBridge:module:arguments:] + 578<br>    9   todos                               0x00000001017e2a84 _ZN8facebook5reactL11invokeInnerEP9RCTBridgeP13RCTModuleDatajRKN5folly7dynamicE + 246<br>    10  todos                               0x00000001017e280c ___ZN8facebook5react15RCTNativeModule6invokeEjON5folly7dynamicEi_block_invoke + 78<br>    11  libdispatch.dylib                   0x00000001025b5f11 _dispatch_call_block_and_release + 12<br>    12  libdispatch.dylib                   0x00000001025b6e8e _dispatch_client_callout + 8<br>    13  libdispatch.dylib                   0x00000001025bd6fd _dispatch_lane_serial_drain + 788<br>    14  libdispatch.dylib                   0x00000001025be28f _dispatch_lane_invoke + 422<br>    15  libdispatch.dylib                   0x00000001025c9b65 _dispatch_workloop_worker_thread + 719<br>    16  libsystem_pthread.dylib             0x00007fff51c08a3d _pthread_wqthread + 290<br>    17  libsystem_pthread.dylib             0x00007fff51c07b77 start_wqthread + 15<br>)<br>libc++abi.dylib: terminating with uncaught exception of type NSException<br>(lldb) </p><p>Tips：如何在 RN release 模式下调试（看到 js 侧的 console 信息）</p><ul><li>  在 <code>AppDelegate.m</code> 中引入 <code>#import &lt;React/RCTLog.h&gt;</code></li><li>  在 <code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code> 中加入 <code>RCTSetLogThreshold(RCTLogLevelTrace);</code></li></ul><p>对比组3：</p><p>条件：iOS 项目 release 模式。在 RN 端增加异常处理代码。</p><p>global.ErrorUtils.setGlobalHandler((e) =&gt; {<br>  console.log(e);<br>  let message = { name: e.name,<br>                message: e.message,<br>                stack: e.stack<br>  };<br>  axios.get(‘<a href="http://192.168.1.100:8888/test.php&#39;">http://192.168.1.100:8888/test.php&#39;</a>, {<br>      params: { ‘message’: JSON.stringify(message) }<br>  }).then(function (response) {<br>          console.log(response)<br>  }).catch(function (error) {<br>  console.log(error)<br>  });<br>}, true)</p><p>操作：运行 iOS 工程，点击按钮模拟 crash。</p><p>现象：iOS 项目不奔溃。日志信息如下，对比 bundle 包中的 js。</p><p><img src="https://segmentfault.com/img/bVbIOk9"></p><p>结论：</p><p>在 RN 项目中，如果发生了 crash 则会在 Native 侧有相应体现。如果 RN 侧写了 crash 捕获的代码，则 Native 侧不会奔溃。如果 RN 侧的 crash 没有捕获，则 Native 直接奔溃。</p><p>RN 项目写了 crash 监控，监控后将堆栈信息打印出来发现对应的 js 信息是经过 webpack 处理的，crash 分析难度很大。所以我们针对 RN 的 crash 需要在 RN 侧写监控代码，监控后需要上报，此外针对监控后的信息需要写专门的 crash 信息还原给你，也就是 sourceMap 解析。</p><h6 id="2-7-3-1-js-逻辑错误"><a href="#2-7-3-1-js-逻辑错误" class="headerlink" title="2.7.3.1 js 逻辑错误"></a>2.7.3.1 js 逻辑错误</h6><p>写过 RN 的人都知道在 DEBUG 模式下 js 代码有问题则会产生红屏，在 RELEASE 模式下则会白屏或者闪退，为了体验和质量把控需要做异常监控。</p><p>在看 RN 源码时候发现了 <code>ErrorUtils</code>，看代码可以设置处理错误信息。</p><p>/**<br> * Copyright (c) Facebook, Inc. and its affiliates.<br> *<br> * This source code is licensed under the MIT license found in the<br> * LICENSE file in the root directory of this source tree.<br> *<br> * @format<br> * @flow strict<br> * @polyfill<br> */</p><p>let _inGuard = 0;</p><p>type ErrorHandler = (error: mixed, isFatal: boolean) =&gt; void;<br>type Fn&lt;Args, Return&gt; = (…Args) =&gt; Return;</p><p>/**<br> * This is the error handler that is called when we encounter an exception<br> * when loading a module. This will report any errors encountered before<br> * ExceptionsManager is configured.<br> */<br>let _globalHandler: ErrorHandler = function onError( e: mixed,<br>  isFatal: boolean, ) {<br>  throw e;<br>};</p><p>/**<br> * The particular require runtime that we are using looks for a global<br> * `ErrorUtils` object and if it exists, then it requires modules with the<br> * error handler specified via ErrorUtils.setGlobalHandler by calling the<br> * require function with applyWithGuard. Since the require module is loaded<br> * before any of the modules, this ErrorUtils must be defined (and the handler<br> * set) globally before requiring anything.<br> */<br>const ErrorUtils = {<br>  setGlobalHandler(fun: ErrorHandler): void {<br>    _globalHandler = fun;<br>  },<br>  getGlobalHandler(): ErrorHandler {<br>    return _globalHandler;<br>  },<br>  reportError(error: mixed): void {<br>    _globalHandler &amp;&amp; _globalHandler(error, false);<br>  },<br>  reportFatalError(error: mixed): void {<br>    // NOTE: This has an untyped call site in Metro.<br>    _globalHandler &amp;&amp; _globalHandler(error, true);<br>  },<br>  applyWithGuard&lt;TArgs: $ReadOnlyArray<mixed>, TOut&gt;(<br>    fun: Fn&lt;TArgs, TOut&gt;,<br>    context?: ?mixed,<br>    args?: ?TArgs,<br>    // Unused, but some code synced from www sets it to null.<br>    unused_onError?: null,<br>    // Some callers pass a name here, which we ignore.<br>    unused_name?: ?string,<br>  ): ?TOut {<br>    try {<br>      _inGuard++;<br>      // $FlowFixMe: TODO T48204745 (1) apply(context, null) is fine. (2) array -&gt; rest array should work<br>      return fun.apply(context, args);<br>    } catch (e) {<br>      ErrorUtils.reportError(e);<br>    } finally {<br>      _inGuard–;<br>    }<br>    return null;<br>  },<br>  applyWithGuardIfNeeded&lt;TArgs: $ReadOnlyArray<mixed>, TOut&gt;(<br>    fun: Fn&lt;TArgs, TOut&gt;,<br>    context?: ?mixed,<br>    args?: ?TArgs,<br>  ): ?TOut {<br>    if (ErrorUtils.inGuard()) {<br>      // $FlowFixMe: TODO T48204745 (1) apply(context, null) is fine. (2) array -&gt; rest array should work<br>      return fun.apply(context, args);<br>    } else {<br>      ErrorUtils.applyWithGuard(fun, context, args);<br>    }<br>    return null;<br>  },<br>  inGuard(): boolean {<br>    return !!_inGuard;<br>  },<br>  guard&lt;TArgs: $ReadOnlyArray<mixed>, TOut&gt;(<br>    fun: Fn&lt;TArgs, TOut&gt;,<br>    name?: ?string,<br>    context?: ?mixed,<br>  ): ?(…TArgs) =&gt; ?TOut {<br>    // TODO: (moti) T48204753 Make sure this warning is never hit and remove it - types<br>    // should be sufficient.<br>    if (typeof fun !== ‘function’) {<br>      console.warn(‘A function must be passed to ErrorUtils.guard, got ‘, fun);<br>      return null;<br>    }<br>    const guardName = name ?? fun.name ?? ‘<generated guard>‘;<br>    function guarded(…args: TArgs): ?TOut {<br>      return ErrorUtils.applyWithGuard(<br>        fun,<br>        context ?? this,<br>        args,<br>        null,<br>        guardName,<br>      );<br>    }</p><pre><code>return guarded;</code></pre><p>  },<br>};</p><p>global.ErrorUtils = ErrorUtils;</p><p>export type ErrorUtilsT = typeof ErrorUtils;</p><p>所以 RN 的异常可以使用 <code>global.ErrorUtils</code> 来设置错误处理。举个例子</p><p>global.ErrorUtils.setGlobalHandler(e =&gt; {<br>   // e.name e.message e.stack<br>}, true);</p><h6 id="2-7-3-2-组件问题"><a href="#2-7-3-2-组件问题" class="headerlink" title="2.7.3.2 组件问题"></a>2.7.3.2 组件问题</h6><p>其实对于 RN 的 crash 处理还有个需要注意的就是 <strong>React Error Boundaries</strong>。<a href="https://link.segmentfault.com/?enc=pryYiUIXt6rDMGiBW9JdrA==.m0P9N0YFY2i5YfbUeQ3tNbz+v2HXBviSU/EGkeGwkl7Fc1Aj96LYcBtAFcW4WJbnHu/Rjtl+A+CX/DLsjgJCAw==">详细资料</a></p><blockquote><p>过去，组件内的 JavaScript 错误会导致 React 的内部状态被破坏，并且在下一次渲染时 <a href="https://link.segmentfault.com/?enc=+LL4iGAJU9MD0cUXcZy1VA==.2F/oGJUCX0ff9hXmb2uYfiOBp8YAXVdK2oHwA1wPhCIo/Xas7UOC6IoywXqhn9EG">产生</a> <a href="https://link.segmentfault.com/?enc=7dOxkzsfnRZKbyVDhQABvw==.3rdyWD6oNR35X8Plfr1hv4kEcLcD9nB7/USWO4ck9QCl2eyv0i5RuSPqmFesUTgV">可能无法追踪的</a> <a href="https://link.segmentfault.com/?enc=j4GzfPPN8psI9QIBipaswA==.foxVhlbMGnly4jHG/uBHeYEQ/j8DTTnrqzGyzMQJcQeWcBwyuNjZaEOVJU8ylyqv">错误</a>。这些错误基本上是由较早的其他代码（非 React 组件代码）错误引起的，但 React 并没有提供一种在组件中优雅处理这些错误的方式，也无法从错误中恢复。</p><p>部分 UI 的 JavaScript 错误不应该导致整个应用崩溃，为了解决这个问题，React 16 引入了一个新的概念 —— 错误边界。</p><p>错误边界是一种 React 组件，这种组件<strong>可以捕获并打印发生在其子组件树任何位置的 JavaScript 错误，并且，它会渲染出备用 UI</strong>，而不是渲染那些崩溃了的子组件树。错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误。</p></blockquote><p>它能捕获子组件生命周期函数中的异常，包括构造函数（constructor）和 render 函数</p><p>而不能捕获以下异常：</p><ul><li>  Event handlers（事件处理函数）</li><li>  Asynchronous code（异步代码，如setTimeout、promise等）</li><li>  Server side rendering（服务端渲染）</li><li>  Errors thrown in the error boundary itself (rather than its children)（异常边界组件本身抛出的异常）</li></ul><p>所以可以通过异常边界组件捕获组件生命周期内的所有异常然后渲染兜底组件 ，防止 App crash，提高用户体验。也可引导用户反馈问题，方便问题的排查和修复</p><p>至此 RN 的 crash 分为2种，分别是 js 逻辑错误、组件 js 错误，都已经被监控处理了。接下来就看看如何从工程化层面解决这些问题</p><h5 id="2-7-4-RN-Crash-还原"><a href="#2-7-4-RN-Crash-还原" class="headerlink" title="2.7.4 RN Crash 还原"></a>2.7.4 RN Crash 还原</h5><p>SourceMap 文件对于前端日志的解析至关重要，SourceMap 文件中各个参数和如何计算的步骤都在里面有写，可以查看<a href="https://link.segmentfault.com/?enc=lqiIX9uf0T1epu78J0gMgw==.pFeUKkKaFchytJc+k6N9CiVIXf+Zzdo/IXobGvd9lG9/BsxgN/VLg2E8JDIHq5RaxvB9mG4FtsbHKdGuvlcx5aHf52FIeYmsLA0QJeBQG3WdAjdo8ozUy257Y33FfaDk">这篇文章</a>。</p><p>有了 SourceMap 文件，借助于 <a href="https://link.segmentfault.com/?enc=xxCynZ245I7o4l2TUjBHjA==.6aGTndpktKHB4Vx3d8dlszqp+ujJC8og3LAhDdL0c7s=">mozilla</a> 的 <a href="https://link.segmentfault.com/?enc=+gvuXOyReT1RLpCGgzsiqQ==.GgVByZjqibYalVB7iwMXK5MHsJbVAU/d+GeQlMviGFlM1ytvmQeMtU2G0EcmEC+E">source-map</a> 项目，可以很好的还原 RN 的 crash 日志。</p><p>我写了个 NodeJS 脚本，代码如下</p><p>var fs = require(‘fs’);<br>var sourceMap = require(‘source-map’);<br>var arguments = process.argv.splice(2);</p><p>function parseJSError(aLine, aColumn) {<br>    fs.readFile(‘./index.ios.map’, ‘utf8’, function (err, data) {<br>        const whatever =  sourceMap.SourceMapConsumer.with(data, null, consumer =&gt; {<br>            // 读取 crash 日志的行号、列号<br>            let parseData = consumer.originalPositionFor({<br>                line: parseInt(aLine),<br>                column: parseInt(aColumn)<br>            });<br>            // 输出到控制台<br>            console.log(parseData);<br>            // 输出到文件中<br>            fs.writeFileSync(‘./parsed.txt’, JSON.stringify(parseData) + ‘\n’, ‘utf8’, function(err) {<br>                if(err) {<br>                    console.log(err);<br>                }<br>            });<br>        });<br>    });<br>}</p><p>var line = arguments[0];<br>var column = arguments[1];<br>parseJSError(line, column);</p><p>接下来做个实验，还是上述的 todos 项目。</p><ol><li><p>在 Text 的点击事件上模拟 crash</p><p> &lt;Text style={styles.sectionTitle} onPress={()=&gt;{1+qw;}}&gt;Debug&lt;/Text&gt;</p></li><li><p>将 RN 项目打 bundle 包、产出 sourceMap 文件。执行命令,</p><p> react-native bundle –entry-file index.js –platform android –dev false –bundle-output release_ios/main.jsbundle –assets-dest release_iOS –sourcemap-output release_ios/index.android.map;</p></li></ol><p>因为高频使用，所以给 iterm2 增加 alias 别名设置，修改 <code>.zshrc</code> 文件</p><p>alias RNRelease=’react-native bundle –entry-file index.js –platform ios –dev false –bundle-output release_ios/main.jsbundle –assets-dest release_iOS –sourcemap-output release_ios/index.ios.map;’ # RN 打 Release 包</p><ol start="3"><li><p> 将 js bundle 和图片资源拷贝到 Xcode 工程中</p></li><li><p>点击模拟 crash，将日志下面的行号和列号拷贝，在 Node 项目下，执行下面命令</p><p> node index.js 397 1822</p></li><li><p> 拿脚本解析好的行号、列号、文件信息去和源代码文件比较，结果很正确。</p></li></ol><p><img src="https://segmentfault.com/img/bVbIOlg"></p><h5 id="2-7-5-SourceMap-解析系统设计"><a href="#2-7-5-SourceMap-解析系统设计" class="headerlink" title="2.7.5 SourceMap 解析系统设计"></a>2.7.5 SourceMap 解析系统设计</h5><p>目的：通过平台可以将 RN 项目线上 crash 可以还原到具体的文件、代码行数、代码列数。可以看到具体的代码，可以看到 RN stack trace、提供源文件下载功能。</p><ol><li><p>打包系统下管理的服务器：</p><ul><li>  生产环境下打包才生成 source map 文件</li><li>  存储打包前的所有文件（install）</li></ul></li><li><p> 开发产品侧 RN 分析界面。点击收集到的 RN crash，在详情页可以看到具体的文件、代码行数、代码列数。可以看到具体的代码，可以看到 RN stack trace、Native stack trace。（具体技术实现上面讲过了）</p></li><li><p> 由于 souece map 文件较大，RN 解析过长虽然不久，但是是对计算资源的消耗，所以需要设计高效读取方式</p></li><li><p> SourceMap 在 iOS、Android 模式下不一样，所以 SoureceMap 存储需要区分 os。</p></li></ol><h3 id="3-KSCrash-的使用包装"><a href="#3-KSCrash-的使用包装" class="headerlink" title="3. KSCrash 的使用包装"></a>3. KSCrash 的使用包装</h3><p>然后再封装自己的 Crash 处理逻辑。比如要做的事情就是：</p><ul><li><p>继承自 KSCrashInstallation 这个抽象类，设置初始化工作（抽象类比如 NSURLProtocol 必须继承后使用），实现抽象类中的 <code>sink</code> 方法。</p><p>  /**<br>   * Crash system installation which handles backend-specific details.<br>   *<br>   * Only one installation can be installed at a time.<br>   *<br>   * This is an abstract class.<br>   */<br>  @interface KSCrashInstallation : NSObject</p></li></ul><p>#import “APMCrashInstallation.h”<br>#import &lt;KSCrash/KSCrashInstallation+Private.h&gt;<br>#import “APMCrashReporterSink.h”</p><p>@implementation APMCrashInstallation</p><ul><li>(instancetype)sharedInstance {<br>  static APMCrashInstallation *sharedInstance = nil;<br>  static dispatch_once_t onceToken;<br>  dispatch_once(&amp;onceToken, ^{<pre><code>  sharedInstance = \[\[APMCrashInstallation alloc\] init\];</code></pre>  });<br>  return sharedInstance;<br>}</li></ul><ul><li><p>(id)init {<br>  return [super initWithRequiredProperties: nil];<br>}</p></li><li><p>(id<KSCrashReportFilter>)sink {<br>  APMCrashReporterSink *sink = [[APMCrashReporterSink alloc] init];<br>  return [sink defaultCrashReportFilterSetAppleFmt];<br>}</p></li></ul><p>@end</p><ul><li><p><code>sink</code> 方法内部的 <code>APMCrashReporterSink</code> 类，遵循了 <strong>KSCrashReportFilter</strong> 协议，声明了公有方法 <code>defaultCrashReportFilterSetAppleFmt</code></p><p>  // .h<br>  #import &lt;Foundation/Foundation.h&gt;<br>  #import &lt;KSCrash/KSCrashReportFilter.h&gt;</p><p>  @interface APMCrashReporterSink : NSObject&lt;KSCrashReportFilter&gt;</p><ul><li><p>(id <KSCrashReportFilter>) defaultCrashReportFilterSetAppleFmt;</p><p>@end</p><p>// .m<br>#pragma mark - public Method</p></li><li><p>(id <KSCrashReportFilter>) defaultCrashReportFilterSetAppleFmt<br>{<br>  return [KSCrashReportFilterPipeline filterWithFilters:</p><pre><code>      \[APMCrashReportFilterAppleFmt filterWithReportStyle:KSAppleReportStyleSymbolicatedSideBySide\],      self,      nil\];</code></pre><p>}</p></li></ul></li></ul><p>其中 <code>defaultCrashReportFilterSetAppleFmt</code> 方法内部返回了一个 <code>KSCrashReportFilterPipeline</code> 类方法 <code>filterWithFilters</code> 的结果。</p><p><code>APMCrashReportFilterAppleFmt</code> 是一个继承自 <code>KSCrashReportFilterAppleFmt</code> 的类，遵循了 <code>KSCrashReportFilter</code> 协议。协议方法允许开发者处理 Crash 的数据格式。</p><p>/** Filter the specified reports.<br> *<br> * @param reports The reports to process.<br> * @param onCompletion Block to call when processing is complete.<br> */</p><ul><li>(void) filterReports:(NSArray*) reports<pre><code>    onCompletion:(KSCrashReportFilterCompletion) onCompletion;</code></pre></li></ul><p>#import &lt;KSCrash/KSCrashReportFilterAppleFmt.h&gt;</p><p>@interface APMCrashReportFilterAppleFmt : KSCrashReportFilterAppleFmt&lt;KSCrashReportFilter&gt;</p><p>@end</p><p>// .m</p><ul><li>(void) filterReports:(NSArray*)reports onCompletion:(KSCrashReportFilterCompletion)onCompletion<br>{<br>  NSMutableArray* filteredReports = [NSMutableArray arrayWithCapacity:[reports count]];<br>  for(NSDictionary *report in reports){<pre><code>if(\[self majorVersion:report\] == kExpectedMajorVersion)&#123;  id monitorInfo = \[self generateMonitorInfoFromCrashReport:report\];  if(monitorInfo != nil)&#123;    \[filteredReports addObject:monitorInfo\];  &#125;&#125;</code></pre>  }<br>  kscrash_callCompletion(onCompletion, filteredReports, YES, nil);<br>}</li></ul><p>/**<br> @brief 获取Crash JSON中的crash时间、mach name、signal name和apple report<br> */</p><ul><li><p>(NSDictionary *)generateMonitorInfoFromCrashReport:(NSDictionary *)crashReport<br>{<br>  NSDictionary *infoReport = [crashReport objectForKey:@”report”];<br>  // …<br>  id appleReport = [self toAppleFormat:crashReport];</p><p>  NSMutableDictionary *info = [NSMutableDictionary dictionary];<br>  [info setValue:crashTime forKey:@”crashTime”];<br>  [info setValue:appleReport forKey:@”appleReport”];<br>  [info setValue:userException forKey:@”userException”];<br>  [info setValue:userInfo forKey:@”custom”];</p><p>  return [info copy];<br>}</p></li></ul><p>/**<br> * A pipeline of filters. Reports get passed through each subfilter in order.<br> *<br> * Input: Depends on what’s in the pipeline.<br> * Output: Depends on what’s in the pipeline.<br> */<br>@interface KSCrashReportFilterPipeline : NSObject &lt;KSCrashReportFilter&gt;</p><ul><li><p>APM 能力中为 Crash 模块设置一个启动器。启动器内部设置 KSCrash 的初始化工作，以及触发 Crash 时候监控所需数据的组装。比如：SESSION_ID、App 启动时间、App 名称、崩溃时间、App 版本号、当前页面信息等基础信息。</p><p>  /** C Function to call during a crash report to give the callee an opportunity to<br>   * add to the report. NULL = ignore.<br>   *<br>   * WARNING: Only call async-safe functions from this function! DO NOT call<br>   * Objective-C methods!!!<br>   */<br>  @property(atomic,readwrite,assign) KSReportWriteCallback onCrash;</p></li></ul><p>+ (instancetype)sharedInstance<br>{<br>    static APMCrashMonitor *_sharedManager = nil;<br>    static dispatch_once_t onceToken;<br>    dispatch_once(&amp;onceToken, ^{<br>        _sharedManager = [[APMCrashMonitor alloc] init];<br>    });<br>    return _sharedManager;<br>}</p><p>#pragma mark - public Method</p><ul><li>(void)startMonitor<br>{<br>  APMMLog(@”crash monitor started”);</li></ul><p>#ifdef DEBUG<br>    BOOL _trackingCrashOnDebug = [APMMonitorConfig sharedInstance].trackingCrashOnDebug;<br>    if (_trackingCrashOnDebug) {<br>        [self installKSCrash];<br>    }<br>#else<br>    [self installKSCrash];<br>#endif<br>}</p><p>#pragma mark - private method</p><p>static void onCrash(const KSCrashReportWriter* writer)<br>{<br>    NSString *sessionId = [NSString stringWithFormat:@”\“%@\“”, ***]];<br>    writer-&gt;addJSONElement(writer, “SESSION_ID”, [sessionId UTF8String], true);</p><pre><code>NSString \*appLaunchTime = \*\*\*;writer-&gt;addJSONElement(writer, &quot;USER\_APP\_START\_DATE&quot;, \[\[NSString stringWithFormat:@&quot;\\&quot;%@\\&quot;&quot;, appLaunchTime\] UTF8String\], true);// ...</code></pre><p>}</p><ul><li>(void)installKSCrash<br>{<br>  [[APMCrashInstallation sharedInstance] install];<br>  [[APMCrashInstallation sharedInstance] sendAllReportsWithCompletion:nil];<br>  [APMCrashInstallation sharedInstance].onCrash = onCrash;<br>  dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.f * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{<pre><code>  \_isCanAddCrashCount = NO;</code></pre>  });<br>}</li></ul><p>在 <code>installKSCrash</code> 方法中调用了 <code>[[APMCrashInstallation sharedInstance] sendAllReportsWithCompletion: nil]</code>，内部实现如下</p><p>- (void) sendAllReportsWithCompletion:(KSCrashReportFilterCompletion) onCompletion<br>{<br>    NSError* error = [self validateProperties];<br>    if(error != nil)<br>    {<br>        if(onCompletion != nil)<br>        {<br>            onCompletion(nil, NO, error);<br>        }<br>        return;<br>    }</p><pre><code>id&lt;KSCrashReportFilter&gt; sink = \[self sink\];if(sink == nil)&#123;    onCompletion(nil, NO, \[NSError errorWithDomain:\[\[self class\] description\]                                              code:0                                       description:@&quot;Sink was nil (subclasses must implement method \\&quot;sink\\&quot;)&quot;\]);    return;&#125;sink = \[KSCrashReportFilterPipeline filterWithFilters:self.prependedFilters, sink, nil\];KSCrash\* handler = \[KSCrash sharedInstance\];handler.sink = sink;\[handler sendAllReportsWithCompletion:onCompletion\];</code></pre><p>}</p><p>方法内部将 <code>KSCrashInstallation</code> 的 <code>sink</code> 赋值给 <code>KSCrash</code> 对象。 内部还是调用了 <code>KSCrash</code> 的 <code>sendAllReportsWithCompletion</code> 方法，实现如下</p><p>- (void) sendAllReportsWithCompletion:(KSCrashReportFilterCompletion) onCompletion<br>{<br>    NSArray* reports = [self allReports];</p><pre><code>KSLOG\_INFO(@&quot;Sending %d crash reports&quot;, \[reports count\]);\[self sendReports:reports     onCompletion:^(NSArray\* filteredReports, BOOL completed, NSError\* error) &#123;     KSLOG\_DEBUG(@&quot;Process finished with completion: %d&quot;, completed);     if(error != nil)     &#123;         KSLOG\_ERROR(@&quot;Failed to send reports: %@&quot;, error);     &#125;     if((self.deleteBehaviorAfterSendAll == KSCDeleteOnSucess &amp;&amp; completed) ||        self.deleteBehaviorAfterSendAll == KSCDeleteAlways)     &#123;         kscrash\_deleteAllReports();     &#125;     kscrash\_callCompletion(onCompletion, filteredReports, completed, error); &#125;\];</code></pre><p>}</p><p>该方法内部调用了对象方法 <code>sendReports: onCompletion:</code>，如下所示</p><p>- (void) sendReports:(NSArray*) reports onCompletion:(KSCrashReportFilterCompletion) onCompletion<br>{<br>    if([reports count] == 0)<br>    {<br>        kscrash_callCompletion(onCompletion, reports, YES, nil);<br>        return;<br>    }</p><pre><code>if(self.sink == nil)&#123;    kscrash\_callCompletion(onCompletion, reports, NO,                             \[NSError errorWithDomain:\[\[self class\] description\]                                                 code:0                                          description:@&quot;No sink set. Crash reports not sent.&quot;\]);    return;&#125;\[self.sink filterReports:reports            onCompletion:^(NSArray\* filteredReports, BOOL completed, NSError\* error) &#123;     kscrash\_callCompletion(onCompletion, filteredReports, completed, error); &#125;\];</code></pre><p>}</p><p>方法内部的 <code>[self.sink filterReports: onCompletion: ]</code> 实现其实就是 <code>APMCrashInstallation</code> 中设置的 <code>sink</code> getter 方法，内部返回了 <code>APMCrashReporterSink</code> 对象的 <code>defaultCrashReportFilterSetAppleFmt</code> 方法的返回值。内部实现如下</p><p>- (id <KSCrashReportFilter>) defaultCrashReportFilterSetAppleFmt<br>{<br>    return [KSCrashReportFilterPipeline filterWithFilters:<br>            [APMCrashReportFilterAppleFmt filterWithReportStyle:KSAppleReportStyleSymbolicatedSideBySide],<br>            self,<br>            nil];<br>}</p><p>可以看到这个函数内部设置了多个 <strong>filters</strong>，其中一个就是 <strong>self</strong>，也就是 <code>APMCrashReporterSink</code> 对象，所以上面的 <code>[self.sink filterReports: onCompletion:]</code> ，也就是调用 <code>APMCrashReporterSink</code> 内的数据处理方法。完了之后通过 <code>kscrash_callCompletion(onCompletion, reports, YES, nil);</code> 告诉 <code>KSCrash</code> 本地保存的 Crash 日志已经处理完毕，可以删除了。</p><p>- (void)filterReports:(NSArray *)reports onCompletion:(KSCrashReportFilterCompletion)onCompletion<br>{<br>    for (NSDictionary *report in reports) {<br>        // 处理 Crash 数据，将数据交给统一的数据上报组件处理…<br>    }<br>    kscrash_callCompletion(onCompletion, reports, YES, nil);<br>}</p><p>至此，概括下 KSCrash 做的事情，提供各种 crash 的监控能力，在 crash 后将进程信息、基本信息、异常信息、线程信息等用 c 高效转换为 json 写入文件，App 下次启动后读取本地的 crash 文件夹中的 crash 日志，让开发者可以自定义 key、value 然后去上报日志到 APM 系统，然后删除本地 crash 文件夹中的日志。</p><h3 id="4-符号化"><a href="#4-符号化" class="headerlink" title="4. 符号化"></a>4. 符号化</h3><p>应用 crash 之后，系统会生成一份崩溃日志，存储在设置中，应用的运行状态、调用堆栈、所处线程等信息会记录在日志中。但是这些日志是地址，并不可读，所以需要进行符号化还原。</p><h4 id="4-1-DSYM-文件"><a href="#4-1-DSYM-文件" class="headerlink" title="4.1 .DSYM 文件"></a>4.1 .DSYM 文件</h4><p><code>.DSYM</code> （debugging symbol）文件是保存十六进制函数地址映射信息的中转文件，调试信息（symbols）都包含在该文件中。Xcode 工程每次编译运行都会生成新的 <code>.DSYM</code> 文���。默认情况下 debug 模式时不生成 <code>.DSYM</code> ，可以在 Build Settings -&gt; Build Options -&gt; Debug Information Format 后将值 <code>DWARF</code> 修改为 <code>DWARF with DSYM File</code>，这样再次编译运行就可以生成 <code>.DSYM</code> 文件。</p><p>所以每次 App 打包的时候都需要保存每个版本的 <code>.DSYM</code> 文件。</p><p><code>.DSYM</code> 文件中包含 DWARF 信息，打开文件的包内容 <code>Test.app.DSYM/Contents/Resources/DWARF/Test</code> 保存的就是 <code>DWARF</code> 文件。</p><p><code>.DSYM</code> 文件是从 Mach-O 文件中抽取调试信息而得到的文件目录，发布的时候为了安全，会把调试信息存储在单独的文件，<code>.DSYM</code> 其实是一个文件目录，结构如下：</p><p><img src="https://segmentfault.com/img/bVbIOlA"></p><h4 id="4-2-DWARF-文件"><a href="#4-2-DWARF-文件" class="headerlink" title="4.2 DWARF 文件"></a>4.2 DWARF 文件</h4><blockquote><p>DWARF is a debugging file format used by many compilers and debuggers to support source level debugging. It addresses the requirements of a number of procedural languages, such as C, C++, and Fortran, and is designed to be extensible to other languages. DWARF is architecture independent and applicable to any processor or operating system. It is widely used on Unix, Linux and other operating systems, as well as in stand-alone environments.</p></blockquote><p><strong>DWARF 是一种调试文件格式，它被许多编译器和调试器所广泛使用以支持源代码级别的调试</strong>。它满足许多过程语言（C、C++、Fortran）的需求，它被设计为支持拓展到其他语言。DWARF 是架构独立的，适用于其他任何的处理器和操作系统。被广泛使用在 Unix、Linux 和其他的操作系统上，以及独立环境上。</p><p>DWARF 全称是 Debugging With Arbitrary Record Formats，是一种使用属性化记录格式的调试文件。</p><p>DWARF 是可执行程序与源代码关系的一个紧凑表示。</p><p>大多数现代编程语言都是块结构：每个实体（一个类、一个函数）被包含在另一个实体中。一个 c 程序，每个文件可能包含多个数据定义、多个变量、多个函数，所以 DWARF 遵循这个模型，也是块结构。DWARF 里基本的描述项是调试信息项 DIE（Debugging Information Entry）。一个 DIE 有一个标签，表示这个 DIE 描述了什么以及一个填入了细节并进一步描述该项的属性列表（类比 html、xml 结构）。一个 DIE（除了最顶层的）被一个父 DIE 包含，可能存在兄弟 DIE 或者子 DIE，属性可能包含各种值：常量（比如一个函数名），变量（比如一个函数的起始地址），或对另一个DIE的引用（比如一个函数的返回值类型）。</p><p>DWARF 文件中的数据如下：</p><p>数据列</p><p>信息说明</p><p>.debug_loc</p><p>在 DW_AT_location 属性中使用的位置列表</p><p>.debug_macinfo</p><p>宏信息</p><p>.debug_pubnames</p><p>全局对象和函数的查找表</p><p>.debug_pubtypes</p><p>全局类型的查找表</p><p>.debug_ranges</p><p>在 DW_AT_ranges 属性中使用的地址范围</p><p>.debug_str</p><p>在 .debug_info 中使用的字符串表</p><p>.debug_types</p><p>类型描述</p><p>常用的标记与属性如下：</p><p>数据列</p><p>信息说明</p><p>DW_TAG_class_type</p><p>表示类名称和类型信息</p><p>DW_TAG_structure_type</p><p>表示结构名称和类型信息</p><p>DW_TAG_union_type</p><p>表示联合名称和类型信息</p><p>DW_TAG_enumeration_type</p><p>表示枚举名称和类型信息</p><p>DW_TAG_typedef</p><p>表示 typedef 的名称和类型信息</p><p>DW_TAG_array_type</p><p>表示数组名称和类型信息</p><p>DW_TAG_subrange_type</p><p>表示数组的大小信息</p><p>DW_TAG_inheritance</p><p>表示继承的类名称和类型信息</p><p>DW_TAG_member</p><p>表示类的成员</p><p>DW_TAG_subprogram</p><p>表示函数的名称信息</p><p>DW_TAG_formal_parameter</p><p>表示函数的参数信息</p><p>DW_TAG_name</p><p>表示名称字符串</p><p>DW_TAG_type</p><p>表示类型信息</p><p>DW_TAG_artifical</p><p>在创建时由编译程序设置</p><p>DW_TAG_sibling</p><p>表示兄弟位置信息</p><p>DW_TAG_data_memver_location</p><p>表示位置信息</p><p>DW_TAG_virtuality</p><p>在虚拟时设置</p><p>简单看一个 DWARF 的例子：将测试工程的 <code>.DSYM</code> 文件夹下的 DWARF 文件用下面命令解析</p><p>dwarfdump -F –debug-info Test.app.DSYM/Contents/Resources/DWARF/Test &gt; debug-info.txt</p><p>打开如下</p><p>Test.app.DSYM/Contents/Resources/DWARF/Test:    file format Mach-O arm64</p><p>.debug_info contents:<br>0x00000000: Compile Unit: length = 0x0000004f version = 0x0004 abbr_offset = 0x0000 addr_size = 0x08 (next unit at 0x00000053)</p><p>0x0000000b: DW_TAG_compile_unit<br>              DW_AT_producer [DW_FORM_strp]    (“Apple clang version 11.0.3 (clang-1103.0.32.62)”)<br>              DW_AT_language [DW_FORM_data2]    (DW_LANG_ObjC)<br>              DW_AT_name [DW_FORM_strp]    (“_Builtin_stddef_max_align_t”)<br>              DW_AT_stmt_list [DW_FORM_sec_offset]    (0x00000000)<br>              DW_AT_comp_dir [DW_FORM_strp]    (“/Users/lbp/Desktop/Test”)<br>              DW_AT_APPLE_major_runtime_vers [DW_FORM_data1]    (0x02)<br>              DW_AT_GNU_dwo_id [DW_FORM_data8]    (0x392b5344d415340c)</p><p>0x00000027:   DW_TAG_module<br>                DW_AT_name [DW_FORM_strp]    (“_Builtin_stddef_max_align_t”)<br>                DW_AT_LLVM_config_macros [DW_FORM_strp]    (“\“-DDEBUG=1\“ \“-DOBJC_OLD_DISPATCH_PROTOTYPES=1\“”)<br>                DW_AT_LLVM_include_path [DW_FORM_strp]    (“/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/11.0.3/include”)<br>                DW_AT_LLVM_isysroot [DW_FORM_strp]    (“/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk”)</p><p>0x00000038:     DW_TAG_typedef<br>                  DW_AT_type [DW_FORM_ref4]    (0x0000004b “long double”)<br>                  DW_AT_name [DW_FORM_strp]    (“max_align_t”)<br>                  DW_AT_decl_file [DW_FORM_data1]    (“/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/11.0.3/include/__stddef_max_align_t.h”)<br>                  DW_AT_decl_line [DW_FORM_data1]    (16)</p><p>0x00000043:     DW_TAG_imported_declaration<br>                  DW_AT_decl_file [DW_FORM_data1]    (“/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/11.0.3/include/__stddef_max_align_t.h”)<br>                  DW_AT_decl_line [DW_FORM_data1]    (27)<br>                  DW_AT_import [DW_FORM_ref_addr]    (0x0000000000000027)</p><p>0x0000004a:     NULL</p><p>0x0000004b:   DW_TAG_base_type<br>                DW_AT_name [DW_FORM_strp]    (“long double”)<br>                DW_AT_encoding [DW_FORM_data1]    (DW_ATE_float)<br>                DW_AT_byte_size [DW_FORM_data1]    (0x08)</p><p>0x00000052:   NULL<br>0x00000053: Compile Unit: length = 0x000183dc version = 0x0004 abbr_offset = 0x0000 addr_size = 0x08 (next unit at 0x00018433)</p><p>0x0000005e: DW_TAG_compile_unit<br>              DW_AT_producer [DW_FORM_strp]    (“Apple clang version 11.0.3 (clang-1103.0.32.62)”)<br>              DW_AT_language [DW_FORM_data2]    (DW_LANG_ObjC)<br>              DW_AT_name [DW_FORM_strp]    (“Darwin”)<br>              DW_AT_stmt_list [DW_FORM_sec_offset]    (0x000000a7)<br>              DW_AT_comp_dir [DW_FORM_strp]    (“/Users/lbp/Desktop/Test”)<br>              DW_AT_APPLE_major_runtime_vers [DW_FORM_data1]    (0x02)<br>              DW_AT_GNU_dwo_id [DW_FORM_data8]    (0xa4a1d339379e18a5)</p><p>0x0000007a:   DW_TAG_module<br>                DW_AT_name [DW_FORM_strp]    (“Darwin”)<br>                DW_AT_LLVM_config_macros [DW_FORM_strp]    (“\“-DDEBUG=1\“ \“-DOBJC_OLD_DISPATCH_PROTOTYPES=1\“”)<br>                DW_AT_LLVM_include_path [DW_FORM_strp]    (“/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include”)<br>                DW_AT_LLVM_isysroot [DW_FORM_strp]    (“/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk”)</p><p>0x0000008b:     DW_TAG_module<br>                  DW_AT_name [DW_FORM_strp]    (“C”)<br>                  DW_AT_LLVM_config_macros [DW_FORM_strp]    (“\“-DDEBUG=1\“ \“-DOBJC_OLD_DISPATCH_PROTOTYPES=1\“”)<br>                  DW_AT_LLVM_include_path [DW_FORM_strp]    (“/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include”)<br>                  DW_AT_LLVM_isysroot [DW_FORM_strp]    (“/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk”)</p><p>0x0000009c:       DW_TAG_module<br>                    DW_AT_name [DW_FORM_strp]    (“fenv”)<br>                    DW_AT_LLVM_config_macros [DW_FORM_strp]    (“\“-DDEBUG=1\“ \“-DOBJC_OLD_DISPATCH_PROTOTYPES=1\“”)<br>                    DW_AT_LLVM_include_path [DW_FORM_strp]    (“/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include”)<br>                    DW_AT_LLVM_isysroot [DW_FORM_strp]    (“/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk”)</p><p>0x000000ad:         DW_TAG_enumeration_type<br>                      DW_AT_type [DW_FORM_ref4]    (0x00017276 “unsigned int”)<br>                      DW_AT_byte_size [DW_FORM_data1]    (0x04)<br>                      DW_AT_decl_file [DW_FORM_data1]    (“/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/fenv.h”)<br>                      DW_AT_decl_line [DW_FORM_data1]    (154)</p><p>0x000000b5:           DW_TAG_enumerator<br>                        DW_AT_name [DW_FORM_strp]    (“__fpcr_trap_invalid”)<br>                        DW_AT_const_value [DW_FORM_udata]    (256)</p><p>0x000000bc:           DW_TAG_enumerator<br>                        DW_AT_name [DW_FORM_strp]    (“__fpcr_trap_divbyzero”)<br>                        DW_AT_const_value [DW_FORM_udata]    (512)</p><p>0x000000c3:           DW_TAG_enumerator<br>                        DW_AT_name [DW_FORM_strp]    (“__fpcr_trap_overflow”)<br>                        DW_AT_const_value [DW_FORM_udata]    (1024)</p><p>0x000000ca:           DW_TAG_enumerator<br>                        DW_AT_name [DW_FORM_strp]    (“__fpcr_trap_underflow”)<br>// ……<br>0x000466ee:   DW_TAG_subprogram<br>                DW_AT_name [DW_FORM_strp]    (“CFBridgingRetain”)<br>                DW_AT_decl_file [DW_FORM_data1]    (“/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/System/Library/Frameworks/Foundation.framework/Headers/NSObject.h”)<br>                DW_AT_decl_line [DW_FORM_data1]    (105)<br>                DW_AT_prototyped [DW_FORM_flag_present]    (true)<br>                DW_AT_type [DW_FORM_ref_addr]    (0x0000000000019155 “CFTypeRef”)<br>                DW_AT_inline [DW_FORM_data1]    (DW_INL_inlined)</p><p>0x000466fa:     DW_TAG_formal_parameter<br>                  DW_AT_name [DW_FORM_strp]    (“X”)<br>                  DW_AT_decl_file [DW_FORM_data1]    (“/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/System/Library/Frameworks/Foundation.framework/Headers/NSObject.h”)<br>                  DW_AT_decl_line [DW_FORM_data1]    (105)<br>                  DW_AT_type [DW_FORM_ref4]    (0x00046706 “id”)</p><p>0x00046705:     NULL</p><p>0x00046706:   DW_TAG_typedef<br>                DW_AT_type [DW_FORM_ref4]    (0x00046711 “objc_object*“)<br>                DW_AT_name [DW_FORM_strp]    (“id”)<br>                DW_AT_decl_file [DW_FORM_data1]    (“/Users/lbp/Desktop/Test/Test/NetworkAPM/NSURLResponse+apm_FetchStatusLineFromCFNetwork.m”)<br>                DW_AT_decl_line [DW_FORM_data1]    (44)</p><p>0x00046711:   DW_TAG_pointer_type<br>                DW_AT_type [DW_FORM_ref4]    (0x00046716 “objc_object”)</p><p>0x00046716:   DW_TAG_structure_type<br>                DW_AT_name [DW_FORM_strp]    (“objc_object”)<br>                DW_AT_byte_size [DW_FORM_data1]    (0x00)</p><p>0x0004671c:     DW_TAG_member<br>                  DW_AT_name [DW_FORM_strp]    (“isa”)<br>                  DW_AT_type [DW_FORM_ref4]    (0x00046727 “objc_class*“)<br>                  DW_AT_data_member_location [DW_FORM_data1]    (0x00)<br>// ……</p><p>这里就不粘贴全部内容了（太长了）。可以看到 DIE 包含了函数开始地址、结束地址、函数名、文件名、所在行数，对于给定的地址，找到函数开始地址、结束地址之间包含该地址的 DIE，则可以还原函数名和文件名信息。</p><p>debug_line 可以还原文件行数等信息</p><p>dwarfdump -F –debug-line Test.app.DSYM/Contents/Resources/DWARF/Test &gt; debug-inline.txt</p><p>贴部分信息</p><p>Test.app.DSYM/Contents/Resources/DWARF/Test:    file format Mach-O arm64</p><p>.debug_line contents:<br>debug_line[0x00000000]<br>Line table prologue:<br>    total_length: 0x000000a3<br>         version: 4<br> prologue_length: 0x0000009a<br> min_inst_length: 1<br>max_ops_per_inst: 1<br> default_is_stmt: 1<br>       line_base: -5<br>      line_range: 14<br>     opcode_base: 13<br>standard_opcode_lengths[DW_LNS_copy] = 0<br>standard_opcode_lengths[DW_LNS_advance_pc] = 1<br>standard_opcode_lengths[DW_LNS_advance_line] = 1<br>standard_opcode_lengths[DW_LNS_set_file] = 1<br>standard_opcode_lengths[DW_LNS_set_column] = 1<br>standard_opcode_lengths[DW_LNS_negate_stmt] = 0<br>standard_opcode_lengths[DW_LNS_set_basic_block] = 0<br>standard_opcode_lengths[DW_LNS_const_add_pc] = 0<br>standard_opcode_lengths[DW_LNS_fixed_advance_pc] = 1<br>standard_opcode_lengths[DW_LNS_set_prologue_end] = 0<br>standard_opcode_lengths[DW_LNS_set_epilogue_begin] = 0<br>standard_opcode_lengths[DW_LNS_set_isa] = 1<br>include_directories[  1] = “/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/11.0.3/include”<br>file_names[  1]:<br>           name: “__stddef_max_align_t.h”<br>      dir_index: 1<br>       mod_time: 0x00000000<br>         length: 0x00000000</p><p>Address            Line   Column File   ISA Discriminator Flags</p><hr><p>0x0000000000000000      1      0      1   0             0  is_stmt end_sequence<br>debug_line[0x000000a7]<br>Line table prologue:<br>    total_length: 0x0000230a<br>         version: 4<br> prologue_length: 0x00002301<br> min_inst_length: 1<br>max_ops_per_inst: 1<br> default_is_stmt: 1<br>       line_base: -5<br>      line_range: 14<br>     opcode_base: 13<br>standard_opcode_lengths[DW_LNS_copy] = 0<br>standard_opcode_lengths[DW_LNS_advance_pc] = 1<br>standard_opcode_lengths[DW_LNS_advance_line] = 1<br>standard_opcode_lengths[DW_LNS_set_file] = 1<br>standard_opcode_lengths[DW_LNS_set_column] = 1<br>standard_opcode_lengths[DW_LNS_negate_stmt] = 0<br>standard_opcode_lengths[DW_LNS_set_basic_block] = 0<br>standard_opcode_lengths[DW_LNS_const_add_pc] = 0<br>standard_opcode_lengths[DW_LNS_fixed_advance_pc] = 1<br>standard_opcode_lengths[DW_LNS_set_prologue_end] = 0<br>standard_opcode_lengths[DW_LNS_set_epilogue_begin] = 0<br>standard_opcode_lengths[DW_LNS_set_isa] = 1<br>include_directories[  1] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include”<br>include_directories[  2] = “/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/11.0.3/include”<br>include_directories[  3] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/sys”<br>include_directories[  4] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/mach”<br>include_directories[  5] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/libkern”<br>include_directories[  6] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/architecture”<br>include_directories[  7] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/sys/_types”<br>include_directories[  8] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/_types”<br>include_directories[  9] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/arm”<br>include_directories[ 10] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/sys/_pthread”<br>include_directories[ 11] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/mach/arm”<br>include_directories[ 12] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/libkern/arm”<br>include_directories[ 13] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/uuid”<br>include_directories[ 14] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/netinet”<br>include_directories[ 15] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/netinet6”<br>include_directories[ 16] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/net”<br>include_directories[ 17] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/pthread”<br>include_directories[ 18] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/mach_debug”<br>include_directories[ 19] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/os”<br>include_directories[ 20] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/malloc”<br>include_directories[ 21] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/bsm”<br>include_directories[ 22] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/machine”<br>include_directories[ 23] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/mach/machine”<br>include_directories[ 24] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/secure”<br>include_directories[ 25] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/xlocale”<br>include_directories[ 26] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/arpa”<br>file_names[  1]:<br>           name: “fenv.h”<br>      dir_index: 1<br>       mod_time: 0x00000000<br>         length: 0x00000000<br>file_names[  2]:<br>           name: “stdatomic.h”<br>      dir_index: 2<br>       mod_time: 0x00000000<br>         length: 0x00000000<br>file_names[  3]:<br>           name: “wait.h”<br>      dir_index: 3<br>       mod_time: 0x00000000<br>         length: 0x00000000<br>// ……<br>Address            Line   Column File   ISA Discriminator Flags</p><hr><p>0x000000010000b588     14      0      2   0             0  is_stmt<br>0x000000010000b5b4     16      5      2   0             0  is_stmt prologue_end<br>0x000000010000b5d0     17     11      2   0             0  is_stmt<br>0x000000010000b5d4      0      0      2   0             0<br>0x000000010000b5d8     17      5      2   0             0<br>0x000000010000b5dc     17     11      2   0             0<br>0x000000010000b5e8     18      1      2   0             0  is_stmt<br>0x000000010000b608     20      0      2   0             0  is_stmt<br>0x000000010000b61c     22      5      2   0             0  is_stmt prologue_end<br>0x000000010000b628     23      5      2   0             0  is_stmt<br>0x000000010000b644     24      1      2   0             0  is_stmt<br>0x000000010000b650     15      0      1   0             0  is_stmt<br>0x000000010000b65c     15     41      1   0             0  is_stmt prologue_end<br>0x000000010000b66c     11      0      2   0             0  is_stmt<br>0x000000010000b680     11     17      2   0             0  is_stmt prologue_end<br>0x000000010000b6a4     11     17      2   0             0  is_stmt end_sequence<br>debug_line[0x0000def9]<br>Line table prologue:<br>    total_length: 0x0000015a<br>         version: 4<br> prologue_length: 0x000000eb<br> min_inst_length: 1<br>max_ops_per_inst: 1<br> default_is_stmt: 1<br>       line_base: -5<br>      line_range: 14<br>     opcode_base: 13<br>standard_opcode_lengths[DW_LNS_copy] = 0<br>standard_opcode_lengths[DW_LNS_advance_pc] = 1<br>standard_opcode_lengths[DW_LNS_advance_line] = 1<br>standard_opcode_lengths[DW_LNS_set_file] = 1<br>standard_opcode_lengths[DW_LNS_set_column] = 1<br>standard_opcode_lengths[DW_LNS_negate_stmt] = 0<br>standard_opcode_lengths[DW_LNS_set_basic_block] = 0<br>standard_opcode_lengths[DW_LNS_const_add_pc] = 0<br>standard_opcode_lengths[DW_LNS_fixed_advance_pc] = 1<br>standard_opcode_lengths[DW_LNS_set_prologue_end] = 0<br>standard_opcode_lengths[DW_LNS_set_epilogue_begin] = 0<br>standard_opcode_lengths[DW_LNS_set_isa] = 1<br>include_directories[  1] = “Test”<br>include_directories[  2] = “Test/NetworkAPM”<br>include_directories[  3] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/objc”<br>file_names[  1]:<br>           name: “AppDelegate.h”<br>      dir_index: 1<br>       mod_time: 0x00000000<br>         length: 0x00000000<br>file_names[  2]:<br>           name: “JMWebResourceURLProtocol.h”<br>      dir_index: 2<br>       mod_time: 0x00000000<br>         length: 0x00000000<br>file_names[  3]:<br>           name: “AppDelegate.m”<br>      dir_index: 1<br>       mod_time: 0x00000000<br>         length: 0x00000000<br>file_names[  4]:<br>           name: “objc.h”<br>      dir_index: 3<br>       mod_time: 0x00000000<br>         length: 0x00000000<br>// ……</p><p>可以看到 debug_line 里包含了每个代码地址对应的行数。上面贴了 AppDelegate 的部分。</p><h4 id="4-3-symbols"><a href="#4-3-symbols" class="headerlink" title="4.3 symbols"></a>4.3 symbols</h4><blockquote><p>在链接中，我们将函数和变量统称为符合（Symbol），函数名或变量名就是符号名（Symbol Name），我们可以将符号看成是链接中的粘合剂，整个链接过程正是基于符号才能正确完成的。</p></blockquote><p>上述文字来自《程序员的自我修养》。所以符号就是函数、变量、类的统称。</p><p>按照类型划分，符号可以分为三类：</p><ul><li>  全局符号：目标文件外可见的符号，可以被其他目标文件所引用，或者需要其他目标文件定义</li><li>  局部符号：只在目标文件内可见的符号，指只在目标文件内可见的函数和变量</li><li>  调试符号：包括行号信息的调试符号信息，行号信息记录了函数和变量对应的文件和文件行号。</li></ul><p><strong>符号表（Symbol Table）</strong>：是内存地址与函数名、文件名、行号的映射表。每个定义的符号都有一个对应的值得，叫做符号值（Symbol Value），对于变量和函数来说，符号值就是地址，符号表组成如下</p><p>&lt;起始地址&gt; &lt;结束地址&gt; &lt;函数&gt; [&lt;文件名：行号&gt;]</p><h4 id="4-4-如何获取地址？"><a href="#4-4-如何获取地址？" class="headerlink" title="4.4 如何获取地址？"></a>4.4 <strong>如何获取地址？</strong></h4><p>image 加载的时候会进行相对基地址进行重定位，并且每次加载的基地址都不一样，函数栈 frame 的地址是重定位后的绝对地址，我们要的是重定位前的相对地址。</p><p>Binary Images</p><p>拿测试工程的 crash 日志举例子，打开贴部分 Binary Images 内容</p><p>// …<br>Binary Images:<br>0x102fe0000 - 0x102ff3fff Test arm64  &lt;37eaa57df2523d95969e47a9a1d69ce5&gt; /var/containers/Bundle/Application/643F0DFE-A710-4136-A278-A89D780B7208/Test.app/Test<br>0x1030e0000 - 0x1030ebfff libobjc-trampolines.dylib arm64  &lt;181f3aa866d93165ac54344385ac6e1d&gt; /usr/lib/libobjc-trampolines.dylib<br>0x103204000 - 0x103267fff dyld arm64  &lt;6f1c86b640a3352a8529bca213946dd5&gt; /usr/lib/dyld<br>0x189a78000 - 0x189a8efff libsystem_trace.dylib arm64  <b7477df8f6ab3b2b9275ad23c6cc0b75> /usr/lib/system/libsystem_trace.dylib<br>// …</p><p>可以看到 Crash 日志的 Binary Images 包含每个 Image 的加载开始地址、结束地址、image 名称、arm 架构、uuid、image 路径。</p><p>crash 日志中的信息</p><p>Last Exception Backtrace:<br>// …<br>5   Test                              0x102fe592c -[ViewController testMonitorCrash] + 22828 (ViewController.mm:58)</p><p>Binary Images:<br>0x102fe0000 - 0x102ff3fff Test arm64  &lt;37eaa57df2523d95969e47a9a1d69ce5&gt; /var/containers/Bundle/Application/643F0DFE-A710-4136-A278-A89D780B7208/Test.app/Test</p><p>所以 frame 5 的相对地址为 <code>0x102fe592c - 0x102fe0000</code> 。再使用 命令可以还原符号信息。</p><p>使用 atos 来解析，<code>0x102fe0000</code> 为 image 加载的开始地址，<code>0x102fe592c</code> 为 frame 需要还原的地址。</p><p>atos -o Test.app.DSYM/Contents/Resources/DWARF/Test-arch arm64 -l 0x102fe0000 0x102fe592c</p><h4 id="4-5-UUID"><a href="#4-5-UUID" class="headerlink" title="4.5 UUID"></a>4.5 UUID</h4><ul><li><p>crash 文件的 UUID</p><p>  grep –after-context=2 “Binary Images:” *.crash</p></li></ul><p>Test  5-28-20, 7-47 PM.crash:Binary Images:<br>Test  5-28-20, 7-47 PM.crash-0x102fe0000 - 0x102ff3fff Test arm64  &lt;37eaa57df2523d95969e47a9a1d69ce5&gt; /var/containers/Bundle/Application/643F0DFE-A710-4136-A278-A89D780B7208/Test.app/Test<br>Test  5-28-20, 7-47 PM.crash-0x1030e0000 - 0x1030ebfff libobjc-trampolines.dylib arm64  &lt;181f3aa866d93165ac54344385ac6e1d&gt; /usr/lib/libobjc-trampolines.dylib<br>–<br>Test.crash:Binary Images:<br>Test.crash-0x102fe0000 - 0x102ff3fff Test arm64  &lt;37eaa57df2523d95969e47a9a1d69ce5&gt; /var/containers/Bundle/Application/643F0DFE-A710-4136-A278-A89D780B7208/Test.app/Test<br>Test.crash-0x1030e0000 - 0x1030ebfff libobjc-trampolines.dylib arm64  &lt;181f3aa866d93165ac54344385ac6e1d&gt; /usr/lib/libobjc-trampolines.dylib</p><p>Test App 的 UUID 为 <code>37eaa57df2523d95969e47a9a1d69ce5</code>.</p><ul><li><p>.DSYM 文件的 UUID</p><p>  dwarfdump –uuid Test.app.DSYM</p></li></ul><p>结果为</p><p>UUID: 37EAA57D-F252-3D95-969E-47A9A1D69CE5 (arm64) Test.app.DSYM/Contents/Resources/DWARF/Test</p><ul><li><p>app 的 UUID</p><p>  dwarfdump –uuid Test.app/Test</p></li></ul><p>结果为</p><p>UUID: 37EAA57D-F252-3D95-969E-47A9A1D69CE5 (arm64) Test.app/Test</p><h4 id="4-6-符号化（解析-Crash-日志）"><a href="#4-6-符号化（解析-Crash-日志）" class="headerlink" title="4.6 符号化（解析 Crash 日志）"></a>4.6 符号化（解析 Crash 日志）</h4><p>上述篇幅分析了如何捕获各种类型的 crash，App 在用户手中我们通过技术手段可以获取 crash 案发现场信息并结合一定的机制去上报，但是这种堆栈是十六进制的地址，无法定位问题，所以需要做符号化处理。</p><p>上面也说明了<a href="https://segmentfault.com/a/1190000040277799#DSYM">.DSYM 文件</a> 的作用，<strong>通过符号地址结合 DSYM 文件来还原文件名、所在行、函数名，这个过程叫符号化</strong>。但是 .DSYM 文件必须和 crash log 文件的 bundle id、version 严格对应。</p><p>获取 Crash 日志可以通过 Xcode -&gt; Window -&gt; Devices and Simulators 选择对应设备，找到 Crash 日志文件，根据时间和 App 名称定位。</p><p>app 和 .DSYM 文件可以通过打包的产物得到，路径为 <code>~/Library/Developer/Xcode/Archives</code>。</p><p>解析方法一般有2种：</p><ul><li><p>使用 <strong>symbolicatecrash</strong></p><p>  symbolicatecrash 是 Xcode 自带的 crash 日志分析工具，先确定所在路径，在终端执行下面的命令</p><p>  find /Applications/Xcode.app -name symbolicatecrash -type f</p></li></ul><p>会返回几个路径，找到 <code>iPhoneSimulator.platform</code> 所在那一行</p><p>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/Library/PrivateFrameworks/DVTFoundation.framework/symbolicatecrash</p><p>将 symbolicatecrash 拷贝到指定文件夹下（保存了 app、DSYM、crash 文件的文件夹）</p><p>执行命令</p><p>./symbolicatecrash Test.crash Test.DSYM &gt; Test.crash</p><p>第一次做这事儿应该会报错 <code>Error: &quot;DEVELOPER_DIR&quot; is not defined at ./symbolicatecrash line 69.</code>，解决方案：在终端执行下面命令</p><p>export DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer</p><ul><li><p>使用 atos</p><p>  区别于 symbolicatecrash，atos 较为灵活，只要 <code>.crash</code> 和 <code>.DSYM</code> 或者 <code>.crash</code> 和 <code>.app</code> 文件对应即可。</p><p>  用法如下，-l 最后跟得是符号地址</p><p>  xcrun atos -o Test.app.DSYM/Contents/Resources/DWARF/Test -arch armv7 -l 0x1023c592c</p></li></ul><p>也可以解析 .app 文件（不存在 .DSYM 文件），其中xxx为段地址，xx为偏移地址</p><p>atos -arch architecture -o binary -l xxx xx</p><p>因为我们的 App 可能有很多，每个 App 在用户手中可能是不同的版本，所以在 APM 拦截之后需要符号化的时候需要将 crash 文件和 <code>.DSYM</code> 文件一一对应，才能正确符号化，对应的原则就是 <strong>UUID</strong> 一致。</p><h4 id="4-7-系统库符号化解析"><a href="#4-7-系统库符号化解析" class="headerlink" title="4.7 系统库符号化解析"></a>4.7 系统库符号化解析</h4><p>我们每次真机连接 Xcode 运行程序，会提示等待，其实系统为了堆栈解析，都会把当前版本的系统符号库自动导入到 <code>/Users/你自己的用户名/Library/Developer/Xcode/iOS DeviceSupport</code> 目录下安装了一大堆系统库的符号化文件。你可以访问下面目录看看</p><p>/Users/你自己的用户名/Library/Developer/Xcode/iOS DeviceSupport/</p><p><img src="https://segmentfault.com/img/bVbIOlY"></p><h3 id="5-服务端处理"><a href="#5-服务端处理" class="headerlink" title="5. 服务端处理"></a>5. 服务端处理</h3><h5 id="5-1-ELK-日志系统"><a href="#5-1-ELK-日志系统" class="headerlink" title="5.1 ELK 日志系统"></a>5.1 ELK 日志系统</h5><p>业界设计日志监控系统一般会采用基于 ELK 技术。ELK 是 Elasticsearch、Logstash、Kibana 三个开源框架缩写。Elasticsearch 是一个分布式、通过 Restful 方式进行交互的近实时搜索的平台框架。Logstash 是一个中央数据流引擎，用于从不同目标（文件/数据存储/MQ）收集不同格式的数据，经过过滤后支持输出到不同目的地（文件/MQ/Redis/ElasticsSearch/Kafka）。Kibana 可以将 Elasticserarch 的数据通过友好的页面展示出来，提供可视化分析功能。所以 ELK 可以搭建一个高效、企业级的日志分析系统。</p><p>早期单体应用时代，几乎应用的所有功能都在一台机器上运行，出了问题，运维人员打开终端输入命令直接查看系统日志，进而定位问题、解决问题。随着系统的功能越来越复杂，用户体量越来越大，单体应用几乎很难满足需求，所以技术架构迭代了，通过水平拓展来支持庞大的用户量，将单体应用进行拆分为多个应用，每个应用采用集群方式部署，负载均衡控制调度，假如某个子模块发生问题，去找这台服务器上终端找日志分析吗？显然台落后，所以日志管理平台便应运而生。通过 Logstash 去收集分析每台服务器的日志文件，然后按照定义的正则模版过滤后传输到 Kafka 或 Redis，然后由另一个 Logstash 从 Kafka 或 Redis 上读取日志存储到 ES 中创建索引，最后通过 Kibana 进行可视化分析。此外可以将收集到的数据进行数据分析，做更进一步的维护和决策。</p><p><img src="https://segmentfault.com/img/bVbIOma"></p><p>上图展示了一个 ELK 的日志架构图。简单说明下：</p><ul><li>  Logstash 和 ES 之前存在一个 Kafka 层，因为 Logstash 是架设在数据资源服务器上，将收集到的数据进行实时过滤，过滤需要消耗时间和内存，所以存在 Kafka，起到了数据缓冲存储作用，因为 Kafka 具备非常出色的读写性能。</li><li>  再一步就是 Logstash 从 Kafka 里面进行读取数据，将数据过滤、处理，将结果传输到 ES</li><li>  这个设计不但性能好、耦合低，还具备可拓展性。比如可以从 n 个不同的 Logstash 上读取传输到 n 个 Kafka 上，再由 n 个 Logstash 过滤处理。日志来源可以是 m 个，比如 App 日志、Tomcat 日志、Nginx 日志等等</li></ul><p>下图贴一个 Elasticsearch 社区分享的一个 “Elastic APM 动手实战”<a href="https://link.segmentfault.com/?enc=GlmdPehBhmCplzSNC0/ymQ==.C5++ytucOFOBjcXb+QzqtRBG55cXLxvwvo82vEIrH1aL4Zm4o/dwEaHgQ0LAE6VM">主题</a>的内容截图。</p><p><img src="https://segmentfault.com/img/bVbIOmc"></p><h5 id="5-2-服务侧"><a href="#5-2-服务侧" class="headerlink" title="5.2 服务侧"></a>5.2 服务侧</h5><p>Crash log 统一入库 Kibana 时是没有符号化的，所以需要符号化处理，以方便定位问题、crash 产生报表和后续处理。</p><p><img src="https://segmentfault.com/img/bVbIOmh"></p><p>所以整个流程就是：客户端 APM SDK 收集 crash log -&gt; Kafka 存储 -&gt; Mac 机执行定时任务符号化 -&gt; 数据回传 Kafka -&gt; 产品侧（显示端）对数据进行分类、报表、报警等操作。</p><p>因为公司的产品线有多条，相应的 App 有多个，用户使用的 App 版本也各不相同，所以 crash 日志分析必须要有正确的 .DSYM 文件，那么多 App 的不同版本，自动化就变得非常重要了。</p><p>自动化有2种手段，规模小一点的公司或者图省事，可以在 Xcode中 添加 runScript 脚本代码来自动在 release 模式下上传DSYM）。</p><p>因为我们大前端有一套体系，可以同时管理 iOS SDK、iOS App、Android SDK、Android App、Node、React、React Native 工程项目的初始化、依赖管理、构建（持续集成、Unit Test、Lint、统跳检测）、测试、打包、部署、动态能力（热更新、统跳路由下发）等能力于一身。可以基于各个阶段做能力的插入，所以可以在打包系统中，当调用打包后在打包机上传 <code>.DSYM</code> 文件到七牛云存储（规则可以是以 AppName + Version 为 key，value 为 .DSYM 文件）。</p><p>现在很多架构设计都是微服务，至于为什么选微服务，不在本文范畴。所以 crash 日志的符号化被设计为一个微服务。架构图如下</p><p><img src="https://segmentfault.com/img/bVcKBTl"><br>说明：</p><ul><li>  Symbolication Service 作为整个监控系统的一个组成部分，是专注于 crash report 符号化的微服务。</li><li>  接收来自任务调度框架的包含预处理过的 crash report 和 DSYM index 的请求，从七牛拉取对应的 DSYM，对 crash report 做符号化解析，计算 hash，并将 hash 响应给「数据处理和任务调度框架」。</li><li>  接收来自 APM 管理系统的包含原始 crash report 和 DSYM index 的请求，从七牛拉取对应的 DSYM，对crash report 做符号化解析，并将符号化的 crash report 响应给 APM 管理系统。</li><li>  脚手架 cli 有个能力就是调用打包系统的打包构建能力，会根据项目的特点，选择合适的打包机（打包平台是维护了多个打包任务，不同任务根据特点被派发到不同的打包机上，任务详情页可以看到依赖的下载、编译、运行过程等，打包好的产物包括二进制包、下载二维码等等）</li></ul><p>其中符号化服务是大前端背景下大前端团队的产物，所以是 NodeJS 实现的（单线程，所以为了提高机器利用率，就要开启多进程能力）。iOS 的符号化机器是 双核的 Mac mini，这就需要做实验测评到底需要开启几个 worker 进程做符号化服务。结果是双进程处理 crash log，比单进程效率高近一倍，而四进程比双进程效率提升不明显，符合双核 mac mini 的特点。所以开启两个 worker 进程做符号化处理。</p><p>下图是完整设计图</p><p><img src="https://segmentfault.com/img/bVcKBTm"></p><p>简单说明下，符号化流程是一个主从模式，一台 master 机，多个 slave 机，master 机读取 .DSYM 和 crash 结果的 cache。「数据处理和任务调度框架」调度符号化服务（内部2个 symbolocate worker）同时从七牛云上获取 .DSYM 文件。</p><p>系统架构图如下<br><img src="https://segmentfault.com/img/bVbIOmt"></p><h2 id="八、-APM-小结"><a href="#八、-APM-小结" class="headerlink" title="八、 APM 小结"></a>八、 APM 小结</h2><ol><li><p> 通常来说各个端的监控能力是不太一致的，技术实现细节也不统一。所以在技术方案评审的时候需要将监控能力对齐统一。每个能力在各个端的数据字段必须对齐（字段个数、名称、数据类型和精度），因为 APM 本身是一个闭环，监控了之后需符号化解析、数据整理，进行产品化开发、最后需要监控大盘展示等</p></li><li><p> 一些 crash 或者 ANR 等根据等级需要邮件、短信、企业内容通信工具告知干系人，之后快速发布版本、hot fix 等。</p></li><li><p> 监控的各个能力需要做成可配置，灵活开启关闭。</p></li><li><p> 监控数据需要做内存到文件的写入处理，需要注意策略。监控数据需要存储数据库，数据库大小、设计规则等。存入数据库后如何上报，上报机制等会在另一篇文章讲：<a href="https://link.segmentfault.com/?enc=tHMPJBwKBqGAnYO7hYcQqg==./eOLWZKsqJHhNAhfSn2gbQ2a7WVL9mUUlYeQsXYOSjBISZB2NR17mPajVWwk5TDY5Dn4xXC6MPLu/eK8jzZhnSvMtXciC76PEuTuT2+PpAAYT5v/pm2vmYaTDoGykKi6">打造一个通用、可配置的数据上报 SDK</a></p></li><li><p>尽量在技术评审后，将各端的技术实现写进文档中，同步给相关人员。比如 ANR 的实现</p><p> /*<br> android 端</p><p> 根据设备分级，一般超过 300ms 视为一次卡顿<br> hook 系统 loop，在消息处理前后插桩，用以计算每条消息的时长<br> 开启另外线程 dump 堆栈，处理结束后关闭<br> */<br> new ExceptionProcessor().init(this, new Runnable() {</p><pre><code>         @Override         public void run() &#123;             //监测卡顿             try &#123;                 ProxyPrinter proxyPrinter = new ProxyPrinter(PerformanceMonitor.this);                 Looper.getMainLooper().setMessageLogging(proxyPrinter);                 mWeakPrinter = new WeakReference&lt;ProxyPrinter&gt;(proxyPrinter);             &#125; catch (FileNotFoundException e) &#123;             &#125;         &#125;     &#125;)</code></pre><p> /*<br> iOS 端</p><p> 子线程通过 ping 主线程来确认主线程当前是否卡顿。<br> 卡顿阈值设置为 300ms，超过阈值时认为卡顿。<br> 卡顿时获取主线程的堆栈，并存储上传。<br> */ </p><ul><li>(void) main() {<br>  while (self.cancle == NO) {<pre><code>  self.isMainThreadBlocked = YES;  dispatch\_async(dispatch\_get\_main\_queue(), ^&#123;      self.isMainThreadBlocked = YES;      \[self.semaphore singal\];  &#125;);  \[Thread sleep:300\];  if (self.isMainThreadBlocked) &#123;      \[self handleMainThreadBlock\];  &#125;  \[self.semaphore wait\];</code></pre>  }<br>}</li></ul></li><li><p>整个 APM 的架构图如下</p><p> <img src="https://segmentfault.com/img/bVbIOnN"></p><p> 说明：</p><ul><li>  埋点 SDK，通过 sessionId 来关联日志数据</li></ul></li><li><p> APM 技术方案本身是随着技术手段、分析需求不断调整升级的。上图的几个结构示意图是早期几个版本的，目前使用的是在此基础上进行了升级和结构调整，提几个关键词：Hermes、Flink SQL、InfluxDB。</p></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;h1 id=&quot;打造一套客户端功能最全的-APM-监控系统&quot;&gt;&lt;a href=&quot;#打造一套客户端功能最全的-APM-监控系统&quot; class=&quot;headerlink&quot; title=&quot;打造一套客户端功能最全的 APM 监控系统&quot;&gt;&lt;/a&gt;&lt;a href=&quot;h</summary>
      
    
    
    
    <category term="监控" scheme="http://zhangyu.info/categories/%E7%9B%91%E6%8E%A7/"/>
    
    
    <category term="监控" scheme="http://zhangyu.info/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>谈谈如何设计好网站的URL</title>
    <link href="http://zhangyu.info/2022/04/12/%E8%B0%88%E8%B0%88%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%A5%BD%E7%BD%91%E7%AB%99%E7%9A%84URL/"/>
    <id>http://zhangyu.info/2022/04/12/%E8%B0%88%E8%B0%88%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%A5%BD%E7%BD%91%E7%AB%99%E7%9A%84URL/</id>
    <published>2022-04-11T16:00:00.000Z</published>
    <updated>2022-04-12T01:49:09.960Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>来源: IT架构师联盟  </p><blockquote><p>URL设计，这是一个非常重要但是往往容易给忽略的部分，也比较少架构师会去关注或者重视。在整个系统架构中，有时候一个好的URL设计对整个系统会起到一个好的作用。</p></blockquote><p>URI和URL及URN</p><p>URL大家都比较熟悉，其他两个词就比较陌生了。URI、URL和URN是识别、定位和命名互联网上的资源的标准途径。1989年Tim Berners-Lee发明了互联网（World Wide Web）。WWW被认为是全球互连的实际的和抽象的资源的集合–它按需求提供信息实体–通过互联网访问。实际的资源的范围从文件到人，抽象的资源包括数据库查询。</p><p>因为要通过多样的方式识别资源（人的名字可能相同，然而计算机文件只能通过唯一的路径名称组合访问），所以需要标准的识别WWW资源的途径。为了满足这种需要，Tim Berners-Lee引入了标准的识别、定位和命名的途径：URI、URL和URN。</p><ul><li><p>  URI：Uniform Resource Identifier，统一资源标识符</p></li><li><p>  URL：Uniform Resource Locator，统一资源定位符</p></li><li><p>  URN：Uniform Resource Name，统一资源名称</p></li></ul><p>在这个体系中的URI、URL和URN是彼此关联的。URI的范畴位于体系的顶层，URL和URN的范畴位于体系的底层。这种排列显示URL和URN都是URI的子范畴。</p><p><img src="https://nimg.ws.126.net/?url=http://dingyue.ws.126.net/2022/0412/c967c46fj00ra7dat000yd200bt00brg00bt00br.jpg&thumbnail=660x2147483647&quality=80&type=jpg">  </p><p>URI可被视为定位符（URL），名称（URN）或两者兼备。统一资源名（URN）如同一个人的名称，而统一资源定位符（URL）代表一个人的住址。换言之，URN定义某事物的身份，而URL提供查找该事物的方法。</p><p>用于标志唯一书目的ISBN系统是一个典型的URN使用范例。例如，ISBN 0-486-27557-4无二义性地标志出莎士比亚的戏剧《罗密欧与朱丽叶》的某一特定版本。为获得该资源并阅读该书，人们需要它的位置，也就是一个URL地址。在类Unix操作系统中，一个典型的URL地址可能是一个文件目录，例如file:///home/username/RomeoAndJuliet.pdf。该URL标志出存储于本地硬盘中的电子书文件。因此，URL和URN有着互补的作用。</p><p>URL</p><p>URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上。采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。</p><p><img src="https://nimg.ws.126.net/?url=http://dingyue.ws.126.net/2022/0412/dda5bb43j00ra7dau000xd200k00074g00it006o.jpg&thumbnail=660x2147483647&quality=80&type=jpg">  </p><p>URL的格式由下列三部分组成：</p><ul><li><p>  协议（或称为服务方式）</p></li><li><p>  存有该资源的主机IP地址（有时也包括端口号）</p></li><li><p>  主机资源的具体地址。如目录和文件名等</p></li></ul><p>第一部分和第二部分之间用”：//”符号隔开，第二部分和第三部分用”/”符号隔开。第一部分和第二部分是不可缺少的，第三部分有时可以省略。</p><p>目前最大的缺点是当信息资源的存放地点发生变化时，必须对URL作相应的改变。因此人们正在研究新的信息资源表示方法。</p><p>URN</p><p>URN（统一资源名称）是标准格式的URI，指的是资源而不指定其位置或是否存在。这个例子来自RFC3986:urn:oasis:names:specification:docbook:dtd:xml:4.1.2</p><p>URN与URL之间仍存在重大区别：</p><ul><li><p>  URN对一项资源予以持久性的识别。</p></li><li><p>  URL主要为资源标识路径。路径可能随着时间的推移发生改变，原因有二：首先，可于特定URL获取的资源可能发生改变（互联网上的内容变更非常频繁）。另外，资源可能被移至其它定位，也可能同时出现在多个定位。因此，URL往往并不具有唯一性或持久性。</p></li></ul><p>因此，URL与URN的设计相似，宗旨不同。</p><p>URN的设计旨在确保与现行标准标识符系统（例如ISSN或任何其它新标准系统）具有互操作性。因此，URN拥有与标识符系统挂钩的命名空间，有别于其它持久性标识符系统（例如DOI前缀并不代表任何标识符系统，而是指明提供标识符的相关组织) 。URL与URI则完全不考虑传统标识符系统。因此，一项期刊的URN基于其ISSN号，URN:ISSN 命名空间则适用ISSN相关规则。相反的，期刊主页的URL往往与ISSN号无关。</p><p>URN的结构</p><p>URN采用URI语法。</p><p>URN:NID:NSS</p><p>因此，URN至少包括三个部分：</p><ul><li><p>  URN：URN首先标注URN方案Scheme</p></li><li><p>  NID：于IANA（互联网号码分配机构）注册的命名空间标识符</p></li><li><p>  NSS：NSS（命名空间特定字符串）予以精确标识</p></li></ul><p>ISSN与URN</p><p>ISSN是最早接受URN方案的书目标识符，以期通过标准方式在互联网上进行使用和表达。每一个ISSN号都可根据以下语法以URN形式予以表达：</p><ul><li><p>  URN:ISSN:xxxx-xxxx</p></li><li><p>  urn:issn:xxxx-xxxx</p></li><li><p>  UrN:IsSn:xxxx-xxxx</p></li></ul><p>xxxx-xxxx即转化为URN的ISSN号，例如：urn:issn:1234-1231</p><p>建议将URN:ISSN记录于可获取的网络资源（例如在线发布的报刊等）的嵌入元数据中。以HTML文件为例，URN:ISSN应录入于HEAD部分：</p><p>META NAME=”Identifier” SCHEME=”URN:ISSN” CONTENT=”1234-1231”</p><p>URI</p><p>URI是以某种统一的（标准化的）方式标识资源的简单字符串，一般由三部分组成：</p><ul><li><p>  访问资源的命名机制</p></li><li><p>  存放资源的主机名</p></li><li><p>  资源自身的名称，由路径表示</p></li></ul><p>统一资源标志符URI就是在某一规则下能把一个资源独一无二地标识出来。URL是URI的子集。</p><p><img src="https://nimg.ws.126.net/?url=http://dingyue.ws.126.net/2022/0412/465561e7j00ra7dau000ed200bj006mg00bj006m.jpg&thumbnail=660x2147483647&quality=80&type=jpg">  </p><p>典型情况下，这种字符串以scheme开头，语法如下：</p><p><img src="https://nimg.ws.126.net/?url=http://dingyue.ws.126.net/2022/0412/84ced650j00ra7dau000vd200c5005gg00c5005g.jpg&thumbnail=660x2147483647&quality=80&type=jpg">  </p><p>有的URI指向一个资源的内部。这种URI以”#”结束，并跟着一个anchor标志符（称为片断标志符）。</p><p>相对URI不包含任何命名规范信息。它的路径通常指同一台机器上的资源。相对URI可能含有相对路径（如：“..”表示上一层路径），还可以包含片断标志符。</p><p>URI的常见问题</p><ul><li><p>  难以输入，URI不必要的冗长</p></li><li><p>  莫明其妙的大写字母</p></li><li><p>  不常见的标点符号</p></li><li><p>  在纸介质上显示很困难，一些字符在纸上打印出来不容易辨认</p></li><li><p>  主机和端口的问题除了scheme-specific部分，domain和port也可能给用户带来困惑。</p></li></ul><p>不成熟的技术：Data URI</p><p>Data URI是由RFC 2397定义的一种把小文件直接嵌入文档的方案。通过如下语法就可以把小文件变成指定编码直接嵌入到页面中：</p><p>data:[][;base64],</p><p>MIME-type：指定嵌入数据的MIME。其形式是[type]/[subtype]; parameter，比如png图片对应的MIME是image/png。parameter可以用來指定附加的信息，更多情況下是用于指定text/plain和text/htm等的文字编码方式的charset参数。默认是text/plain;charset=US-ASCII。</p><p>base64：声明后面的数据的编码是base64的，否则数据必须要用百分号编码（即对内容进行urlencode）。</p><p>Data URI的优点：</p><ul><li><p>  减少HTTP请求数，没有了TCP连接消耗和同一域名下浏览器的并发数限制。</p></li><li><p>  对于小文件会降低带宽。虽然编码后数据量会增加，但是却减少了http头，当http头的数据量大于文件编码的增量，那么就会降低带宽。</p></li><li><p>  对于HTTPS站点，HTTPS和HTTP混用会有安全提示，而HTTPS相对于HTTP来讲开销要大更多，所以Data URI在这方面的优势更明显。</p></li><li><p>  可以把整个多媒体页面保存为一个文件。</p></li></ul><p>Data URI的缺点：</p><ul><li><p>  无法被重复利用，同一个文档应用多次同一个内容，则需要重复多次，数据量大量增加，增加了下载时间。</p></li><li><p>  无法被独自缓存，所以其包含文档重新加载时，它也要重新加载。</p></li><li><p>  客户端需要重新解码和显示，增加了点消耗。不支持数据压缩，base64编码会增加1/3大小，而urlencode后数据量会增加更多。</p></li><li><p>  不利于安全软件的过滤，同时也存在一定的安全隐患。</p></li></ul><p>转换工具：Data URI Generator</p><p>优秀的URI不会改变</p><p>什么样的URI称得上优秀的URI？优秀的URI就是不需要改变的URI。是什么迫使URI做出改变？不改变的是URI：改变的是人。理论上人们没有什么原因去改变URI，但是在实际运行中却存在着成百上千的原因。从理论上讲，域名的所有者拥有该域名下的所有URI。理论上您域名下的所有URI是完全由您控制的，所以你是可以按照自己喜欢的方式使URI变得稳定。迫使一个文件地址消失的原因是域名过期或服务器没有在继续运行。这就是为了会有这么多改来改去的链接。其中的一部分是由于缺乏远见导致的。下面是您可以听到的一些原因。</p><ul><li><p>  为了使网站更好，我们刚改版了网站。</p></li><li><p>  我们有大量过期的、保密的、无效的文档需要进行区分。</p></li><li><p>  我们发现不得不移动文件。</p></li><li><p>  我们曾经使用的是一个CGI脚本，现在我们使用的是一个二进制程序。</p></li><li><p>  我不认为URI是需要持久的，需要持久的那是URN。</p></li></ul><p>当你在服务器上修改了URI，你不会知道还有多少人会使用旧的URI。他们可能把你的链接发布到了其他网站上，他们可能把你的链接存为了书签。他们可能把你的URI告诉了别人。当一些人点击链接，但是发现链接无法打开的时候，他们就会对网站拥有者失去信心。他们会因为不能完成自己想要的目标而沮丧。</p><p>我该怎么去设计URI?</p><p>使一个URI可以持续2年、20年、200年，这是一个网站管理员的责任。这需要思想、组织和承诺。一般来说URI改变时因为文档里的一些信息发生了改变，这和URI的设计至关重要的。文件的创建日期这是不会改变的。这对分离旧的系统和新的系统非常有用。这能很好的让你开始设计一个URI。即使这个文件会被多次修改，但是他还是只会有一个创建日期。唯一例外的是一个网页是故意“最新”的，例如频道的首页。</p><p><a href="http://www.example.com/money/moneydaily/latest/">http://www.example.com/money/moneydaily/latest/</a></p><p>此URI不需要日期的主要原因是此页面时不断更新的，如果你需要者页面的存档，存档地址可以是</p><p><a href="http://www.example.com/money/moneydaily/1998/981212.moneyonline.html">http://www.example.com/money/moneydaily/1998/981212.moneyonline.html</a></p><p>（这个URI看上去不错，除了”98″和“.html”有些多余）</p><p>哪些信息需要被抛弃？</p><p>在使用日期以后，把任何信息放入URI都有可能带来问题。</p><ul><li><p>  作者的名字：著作权可能会因为版本的修改而改变，比如团队里的某些人离开使事务被转手。</p></li><li><p>  标题：这个是非常棘手的，他总是现在看起来非常合适，但是过些时间久需要改变。</p></li><li><p>  状态：如”old”,”new”,”latest”等，文件很可能会改变状态。</p></li><li><p>  访问权限：一个文件的访问权限可能会因为情况而改变，不要将文档放在”public”、”team”下。</p></li><li><p>  文件扩展名：即使是”.html”也有可能会改变。</p></li><li><p>  程序机制：如”cgi”和”exec”</p></li><li><p>  磁盘名称：这个也有用使用的！</p></li></ul><p>按文章主题进行分类</p><p>这是非常危险的操作。通常情况下，你URI中的文档分类是按你正在进行的工作进行区分的。这就可能带来隐患，你从事的领域可能会在今后发生变化。在W3C，我们期望吧“MarkUp”修改为“Markup”，后来又期望修改为“HTML”，我们不能保证现在的命名在以后是否适用。</p><p>按主题分类这是一个非常理想的分类方案，包括把整个互联网进行分类一样，这是一个非常不错的解决办法，但是从长远看存在着严重的缺陷。每个人对语言中的每个聚类的主题词都有不同的理解，网络之间的主题关系，并不是像树型那么简单。事实上，当你在你的URI中绑定分类时，未来你很有可能去改变这个分类，到时候URI就需要跟随着改变。</p><p>在URI中使用主题进行分类的一个原因是你需要一个名称作为URI的一个部分来组织内容，比如内容细分，通常来说在日期存在（日期在左边）的情况下还是非常安全的，1998/pics可以理解为，我们在1998年的照片。而不是照片中1998年我们在做什么。</p><p>不要忘记你的域名</p><p>请记住，这不仅适用于URI“路径”，同时也使用与服务器名称。在域名中无论代表公司，或文件状态，或访问级别，或者安全级别划分，要非常非常小心，特别是在使用多个域名访问一个文件的时候，不要忘记，你可以在服务器端使用重定向。</p><p>URL即UI</p><p>尽管APP和小程序在替代WEB网站。但WEB网站最终难以被完全替代。未来的很多年，URL还将成为用户界面的一部分。所以一个可用性好的网站需要：</p><ul><li><p>  一个容易记忆及拼写的域名</p></li><li><p>  简短的URL网址</p></li><li><p>  容易输入的URL</p></li><li><p>  可视化的URL结构</p></li><li><p>  用户可以删除URL最后的一层到达上级目录</p></li><li><p>  URL保持不变</p></li></ul><p>用户不需要像服务器一样了解每个URL，事实上更多的人是通过大概的印象访问网站的：</p><ul><li><p>  很多人会在没有访问网站前猜测网站的域名，所以你最好使用公司名称或品牌作为域名</p></li><li><p>  更多的人更喜欢记住网站名而不是将网站添加到书签，所以最好注册一个易于拼写的域名</p></li><li><p>  在用户将你的URL通过邮件告知别人时，保证你的URL要少于78个字符，因为如果URL过程可能会造成换行</p></li><li><p>  如果很多人通过输入那么最好使用简短的URL</p></li><li><p>  不要再URL中大下写混用，因为很多人会忽视大小写，但是部分服务器不会</p></li><li><p>  在服务器上进行拼写检查来减少由于拼写错误造成的问题</p></li></ul><p>来自第三网站的外链对流量很重要，所以在生成你的URL的时候要考虑到易于传播。</p><ul><li><p>  保证所有的URL都是持续可以访问的，且链向的页面不做改变。</p></li><li><p>  不要把文件的URL改来改去， 保证同一个文件前后只有一个URL。</p></li></ul><p>很多人考虑是否.COM域名是否要比.CN（国别域名）要好？是的，很多人已经习惯了域名以.COM结尾。这是由于早期由美国人开发的浏览器会自动补全.COM（现在苹果的iPad上默认也有.COM按钮），基于这种情况，我的建议是：</p><ul><li><p>  如果网站是英文的或国际性最好使用.com域名</p></li><li><p>  如果网站使用的是其他语言可以使用国别域名代替</p></li><li><p>  如果网站内容是区域性的，无所谓使用哪种域名</p></li></ul><p>国别域名相比.COM域名主要优势是，还有很多可以注册的简短的、易记的域名。</p><p>从长远的发展来看，需要大量的名称（按照人类语言习惯）来识别世界上每个实体。新的顶级域名会不断出现，但由于旧的用户习惯，旧的浏览器或软件还是会存在很多年，所以好的域名还是会影响很多年。</p><p>怎样设计一个好的URL</p><p>URL是网站UI的一部分，因此，可用的网站应该满足这些URL要求：</p><ul><li><p>  简单，好记的域名</p></li><li><p>  简短（short）的URL</p></li><li><p>  容易录入的URI</p></li><li><p>  URL能反应站点的结构</p></li><li><p>  URL是可以被用户猜测和hack的（也鼓励用户如此）</p></li><li><p>  永久链接</p></li></ul><p>记住下面四句话，你就知道应该设计什么样的URL了。</p><ul><li><p>  URL应当是用户友好的</p></li><li><p>  URL应当是可读的</p></li><li><p>  URL应当是可预测的</p></li><li><p>  URL应当是统一的</p></li></ul><p>网址根目录（level section）是非常珍贵的</p><p>对于任何一个URL而言，它最用价值的方面是在他的根目录（level section），我的观点是她必须在你写任何代码前确定下来，他会确定你网站最后是怎么组织起来的。当你想建立新的站点的时候，一定要想好哪些根目录的网址是需要保留的。</p><p>命名空间是一个非常有用的拓展网址方案</p><p>命名空间是一个建立容易记忆的良好网址结构的方案。那命名空间是什么意思呢？下面是一个例子：</p><p><a href="https://github.com/pallets/flask/issues">https://github.com/pallets/flask/issues</a></p><p>在上面的URL中，pallets/flask是命名空间。为什么这个是有用的？因为任何跟在命名空间后面的部分都将成为level section。在可以在任何 / 后面跟上/issues或/wiki来生成页面。</p><p>为了命名空间的通用性，保持命名空间的简洁，不要将内容加在前面或后面，类似/feature/ / 或/ / /feature.</p><p>查询字符串对排序和过滤非常的有用</p><p>网站都有一些查询字符串，很多网站使用多个查询字符串。他们通常使用同一的模式来对页面或内容进行排序或过滤（sort=alpha&amp;dir=desc），他们可以是URL更加简单和易记。</p><p>需要记住的是，在URL上没有带任何查询字符串时需要显示一个不同的页面。</p><p>非ASCII字符出现在网址中</p><p>非 ASCII字符不但难以输入，而且还难以记忆。URL是为人设计的，不是为搜索引擎设计的。在URL中堆砌关键词的手法，并不罕见，比如下面的URL：这样的URL在Google 2003年修改算法前对SEO很有效，但是一些SEO教程上现在还是叫你将关键词写入URL。他们错了，忽略他们。</p><p>除此之外，你还需要记住以下两点：</p><ul><li><p>  下划线很不好，请在URL中使用中划线。</p></li><li><p>  在URL中使用一些短的、通俗的词，如果一段URL中有中划线会特殊的字符，那它可能有些长。</p></li></ul><p>URL是为人使用的，也是为人设计的。</p><p>一个URL就是一个协议</p><p>一个URL是一个协议，你需要让他保存做够长的时间。一旦有人点击了你的URL，他们就是和你签署有了一个协议，他们期望下次再打开这个网址的时候看到同样的内容。在你的URL公布出去以后，不要轻易的去修改它，如果你真的迫不得已要去修改它，那么请对原来的URL做跳转。</p><p>任何页面都需要有个URL</p><p>在理想的情况下，每个单独的页面都需要一个URL，这个URL在复制到别的浏览器的时候要还可以访问。事实上这样做是完全不可能的，直到新的HTML5浏览器历史记录Javascript API的出现，这里有两种方法：</p><ul><li><p>  onReplaceState：这个方法取代了浏览器历史记录中的URL，使URL留下后退按钮。</p></li><li><p>  onPushState：这个方法能push一个新的URL到浏览器历史记录，用来更换浏览器中的历史堆栈。</p></li></ul><p>这两个新的方法可以改变浏览器中的访问历史，有了这个新的特征，我们需要为页面设计后退页面。在使用前需要问自己：这个动作是否需要产生新的内容或用不同的方法显示相同的内容。</p><ul><li><p>  生成新的内容：你应该使用onPushState（如分页链接）</p></li><li><p>  用不同的方法显示相同的内容：你应该使用onReplaceState（如排序了过滤）</p></li></ul><p>通过自己的判断，想想你需要实现怎样的效果。</p><p>链接需要看上去像个链接</p><p>很多生成链接的方法如、，如果你点击它们它们会打开新的页面，当你将鼠标放在标签时，你的浏览器状态栏就会告诉你URL地址是什么。在使用onReplaceState和onPushState时不要破坏这样的规则。</p><p>POST后的网站需要转向</p><p>过去很多开发人员喜欢生成不能再次使用的URL，这种URL也称为Post-specific URLs，当你提交一个表单的时候你不会发现地址栏中的URL会发生任何变化，当你将复制URL重新打开后却得到一个错误的页面。这样的URL本身没有任何错误，他们的主要作用是进行重定向和在API中使用，并不应该给用户使用。</p><p>一定要短</p><p>为了URI能被方便的录入，写下，拼写和记忆，URI 要尽可能的短，根据w3c 提供的参考数据，一个URI的长度最好不要超过80个字节（这并非一个技术限制，经验和统计提供的数据），包括schema和host,port等。</p><p>大小写策略</p><p>URI的大小写策略要适当，要么全部小写，要么首字母大写，应避免混乱的大小写组合，在Unix 世界，文件路径队大小写是敏感的，而在Windows 世界，则不对大小写敏感。</p><p>允许URL管理URL映射</p><p>管理员可以重新组织服务器上的文件系统结构，而无需改动URI，这就需要URI和真实的服务器文件系统结构之间有一个映射机制。而不是生硬的对应。这种映射机制可以通过如下技术手段实现：</p><ul><li><p>  Aliases，别名，Apache上的目录别名，IIS上的虚拟目录</p></li><li><p>  Symbolic links，符号链接，Unix世界的符号链接</p></li><li><p>  Table or database of mappings，数据库映射，URI和文件系统结构的对应关系存储在数据库中。</p></li></ul><p>标准的重定向</p><p>管理员可以简单的通过修改HTTP 状态代码来实现服务器文件系统结构变更之后的URL兼容，可以利用的HTTP Status Code有：</p><ul><li><p>  301 Moved Permanently ([RFC2616] section 10.3.2)</p></li><li><p>  302 Found (undefined redirect scheme, [RFC2616] Section 10.3.3)</p></li><li><p>  Temporary Redirect ([RFC2616] Section 10.3.8)</p></li></ul><p>用独立的URI</p><p>技术无关的URI</p><ul><li><p>  提供动态内容服务时，应使用技术无关的URI。即URI不暴露服务器端使用的脚本语言，平台引擎，而这些语言，平台，引擎的变化也不会导致URI的变更。因此，sevelet,cgi-bin之类的单词不应该出现在URI 中。</p></li><li><p>  提供静态内容服务时，应当隐去文件的扩展名取而代之的技术是content-negotiation, proxy, 和URI mapping</p></li></ul><p>身份标志和Session机制</p><ul><li><p>  使用标准的身份认证机制，而不是每个用户一个特定的URI</p></li><li><p>  使用标准的Session机制，而不是把Session ID放在URI中使用</p></li></ul><p>内容变更时使用标准转向：</p><ul><li><p>  对变更的内容使用标准的重定向</p></li><li><p>  对删除的资源使用 HTTP 410</p></li></ul><p>提供索引代理：索引策略</p><ul><li><p>  Content-Location</p></li><li><p>  Content-MD5</p></li></ul><p>提供适当的缓存信息：</p><ul><li><p>  缓存相关的HTTP头</p></li><li><p>  缓存策略</p></li><li><p>  缓存生成内容HTTP HEAD和HTTP GET</p></li></ul><p>总结</p><ul><li><p>  URI 是Web UI 的一部分，应当像对待网站Logo 和公司品牌一样对待它</p></li><li><p>  URI 是网站和普通用户之间的唯一接口，应当像对待你的商务电话号码一样对待它</p></li></ul><p>URL中井号的作用</p><ul><li><p>  井号在URL中指定的是页面中的一个位置。井号作为页面定位符出现在URL中，浏览器读取这个URL后，会自动将位置滚动至指定区域。</p></li><li><p>  井号后面的数据不会发送到HTTP请求中。井号后面的参数是针对浏览器起作用的而不是服务器端。</p></li><li><p>  任何位于井号后面的字符都是位置标识符。不管第一个井号后面跟的是什么参数，只要是在井号后面的参数一律看成是位置标识符。比如这样一个链接（<a href="http://example.com/?color=#fff&amp;;shape=circle%EF%BC%89%EF%BC%8C%E5%90%8E%E9%9D%A2%E8%B7%9F%E7%9A%84%E5%8F%82%E6%95%B0%E6%98%AF%E9%A2%9C%E8%89%B2%E5%92%8C%E5%BD%A2%E7%8A%B6%EF%BC%8C%E4%BD%86%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8D%B4%E5%B9%B6%E4%B8%8D%E8%83%BD%E7%90%86%E8%A7%A3URL%E4%B8%AD%E7%9A%84%E5%90%AB%E4%B9%89%E3%80%82%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A5%E6%94%B6%E5%88%B0%E7%9A%84%E5%8F%AA%E6%98%AF%EF%BC%9Ahttp://example.com/?color=">http://example.com/?color=#fff&amp;;shape=circle），后面跟的参数是颜色和形状，但是服务器却并不能理解URL中的含义。服务器接收到的只是：http://example.com/?color=</a></p></li><li><p>  改变井号后面的参数不会触发页面的重新加载但是会留下一个历史记录。仅改变井号后面的内容，只会使浏览器滚动到相应的位置，并不会重现加载页面。浏览器并不会去重新请求页面，但是此操作会在浏览器的历史记录中添加一次记录，即你可以通过返回按钮回到上次的位置。这个特性对Ajax来说特别的有用，可以通过设置不同井号值，来表示不同的访问状态，并返回不同的内容给用户。</p></li><li><p>  可以通过javascript使用location.hash来改变井号后面的值。window.location.hash这个属性可以对URL中的井号参数进行修改，基于这个原理，我们可以在不重载页面的前提下创造一条新的访问记录。除此之外，HTML 5新增的onhashchange事件，当#值发生变化时，就会触发这个事件。</p></li><li><p>  Googlebot对井号的过滤机制。默认情况下Google在索引页面的时候会忽略井号后面的参数，同时也不会去执行页面中的javascript。然而谷歌为了支持对Ajax生成内容的索引，定义了如果在URL中使用“#!”，则Google会自动将其后面的内容转成查询字符串_escaped_fragment_的值。比如最新的twitter URL：<a href="http://twitter.com/#!/username%EF%BC%8CGoogle%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%AF%B7%E6%B1%82http://twitter.com/?\_escaped\_fragment\_=/username%E6%9D%A5%E8%8E%B7%E5%8F%96Ajax%E5%86%85%E5%AE%B9%E3%80%82">http://twitter.com/#!/username，Google会自动请求http://twitter.com/?\_escaped\_fragment\_=/username来获取Ajax内容。</a></p></li></ul><p>实例：Flickr API 中的URL规则</p><p>Flickr API中的URL规则非常值得我们学习，下面就来揭开Flickr URL的神秘面纱。</p><p>Flickr图片地址</p><p>URL主要有下面三类：</p><ul><li><p>  <a href="http://farm{farm-id}.static.flickr.com/%7Bserver-id%7D/%7Bid%7D/_%7Bsecret%7D.jpg">http://farm{farm-id}.static.flickr.com/{server-id}/{id}\_{secret}.jpg</a></p></li><li><p>  <a href="http://farm{farm-id}.static.flickr.com/%7Bserver-id%7D/%7Bid%7D/_%7Bsecret%7D/_/[mstzb/].jpg">http://farm{farm-id}.static.flickr.com/{server-id}/{id}\_{secret}\_\[mstzb\].jpg</a></p></li><li><p>  <a href="http://farm{farm-id}.static.flickr.com/%7Bserver-id%7D/%7Bid%7D/_%7Bo-secret%7D/_o.(jpg|gif|png)">http://farm{farm-id}.static.flickr.com/{server-id}/{id}\_{o-secret}\_o.(jpg|gif|png)</a></p></li></ul><p>尺寸字母后缀说明：</p><p>s small square,小正方形,75×75 t thumbnail,缩微图,最长边为100 m small 小图,最长边为240 – medium,中图,最长边为500 z medium 640,中等尺寸640,最长边为640 b large,大图,最长边为1024 o original image,原始图片,可能是jpg,或是png,或是gif</p><p>注意：原始图片有些不同，他们有自己的密钥，在返回数据中被称为originalsecret，除此之外还包含原始图片格式，被称为originalformat。这些值都会在向API请求原始图片时返回。</p><p>以下为图片地址URL示例：</p><p><a href="http://farm1.static.flickr.com/2/1418878/_1e92283336/_m.jpg">http://farm1.static.flickr.com/2/1418878\_1e92283336\_m.jpg</a></p><ul><li><p>  farm-id: 1</p></li><li><p>  server-id: 2</p></li><li><p>  photo-id: 1418878</p></li><li><p>  secret: 1e92283336</p></li><li><p>  size: m</p></li></ul><p>Flickr网页地址URL</p><p>个人档案及相片页面的URL使用NSID（带@ 符号的数字）或自定义URL（需要设置），可以通过请求flickr.people.getInfo获取自定义URL。不管用户是否设置自定义URL，NSID一直是有效的。所以你可以使用用户ID来进行所有的请求。</p><p>你可以非常轻松的创建个人档案、影集、所有照片、个人相片或影集的URL：</p><ul><li><p>  <a href="http://www.flickr.com/people/%7Buser-id%7D/">http://www.flickr.com/people/{user-id}/</a> – profile</p></li><li><p>  <a href="http://www.flickr.com/photos/%7Buser-id%7D/">http://www.flickr.com/photos/{user-id}/</a> – photostream</p></li><li><p>  <a href="http://www.flickr.com/photos/%7Buser-id%7D/%7Bphoto-id%7D">http://www.flickr.com/photos/{user-id}/{photo-id}</a> – individual photo</p></li><li><p>  <a href="http://www.flickr.com/photos/%7Buser-id%7D/sets/">http://www.flickr.com/photos/{user-id}/sets/</a> – all photosets</p></li><li><p>  <a href="http://www.flickr.com/photos/%7Buser-id%7D/sets/%7Bphotoset-id%7D">http://www.flickr.com/photos/{user-id}/sets/{photoset-id}</a> – single photoset</p></li></ul><p>同样还可以构建其他页面，比如用户在登录的情况，可以让他们链向 <a href="http://www.flickr.com/photos/me//">http://www.flickr.com/photos/me/\</a>* 或 <a href="http://www.flickr.com/people/me//">http://www.flickr.com/people/me/\</a>* ，將使用其自己的ID 取代「me」。</p><p>链接示例：</p><ul><li><p>  <a href="http://www.flickr.com/photos/12037949754@N01/">http://www.flickr.com/photos/12037949754@N01/</a></p></li><li><p>  <a href="http://www.flickr.com/photos/12037949754@N01/155761353/">http://www.flickr.com/photos/12037949754@N01/155761353/</a></p></li><li><p>  <a href="http://www.flickr.com/photos/12037949754@N01/sets/">http://www.flickr.com/photos/12037949754@N01/sets/</a></p></li><li><p>  <a href="http://www.flickr.com/photos/12037949754@N01/sets/72157594162136485/">http://www.flickr.com/photos/12037949754@N01/sets/72157594162136485/</a></p></li></ul><p>短网址服务</p><p>Flickr 针对上传的图片提供短网址服务。Flickr上每张相片均拥有经数学计算的简短URL：<a href="http://flic.kr/p/%7Bbase58-photo-id%7D">http://flic.kr/p/{base58-photo-id}</a></p><p>利用Base58将数字和字母进行组合对照片ID进行压缩。Base58和base62[0-9a-zA-Z]差不多，只是为了更加利于辨认，删除了容易混淆的0, O, I,和 l。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;来源: IT架构师联盟  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;URL设计，这是一个非常重要但是往往容易给忽略的部分，也比较少架构师会去关注或者重视。在整个系统架构中，有时候一个好的URL设计对整个系统会起到一个好的作用。&lt;/p&gt;
&lt;/bloc</summary>
      
    
    
    
    <category term="优化" scheme="http://zhangyu.info/categories/%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="优化" scheme="http://zhangyu.info/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>敏捷教练第01课-敏捷教练和ScrumMaster基本功四部曲</title>
    <link href="http://zhangyu.info/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC01%E8%AF%BE-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%92%8CScrumMaster%E5%9F%BA%E6%9C%AC%E5%8A%9F%E5%9B%9B%E9%83%A8%E6%9B%B2/"/>
    <id>http://zhangyu.info/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC01%E8%AF%BE-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%92%8CScrumMaster%E5%9F%BA%E6%9C%AC%E5%8A%9F%E5%9B%9B%E9%83%A8%E6%9B%B2/</id>
    <published>2022-04-11T16:00:00.000Z</published>
    <updated>2022-04-12T01:53:52.858Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="课程概述"><a href="#课程概述" class="headerlink" title="课程概述"></a>课程概述</h1><p>敏捷教练是一个职业。Scrum Master 和敏捷教练是同一职业的不同阶段。当一个人能带好一个 Scrum 团队时，他是一个 Scrum Master。当他能带各种不同类型的团队，并持续追求更好，他就是一个敏捷教练。</p><p>Scrum Master 职责的范围和边界相对确定，敏捷教练职责的范围和边界相对不确定。但从学习的角度，他们所需要的基本功是一致的。本课程中对这两个角色，在大多数时候不太区分。鉴于这两个角色既有相似处又有区别，大家在使用时对这两个名称的理解上又有变异，所以课程的名称中就把这两个名称并称，以求相对准确地表达这个课程所要服务的角色。就算是您所采用的敏捷方法不是 Scrum，依然可以从本课程中受益。</p><p>如同任何其他职业，敏捷教练有它的技能，也需要并且能够通过练习达到精通。我们可以通过四部曲的结构理解敏捷教练这个职业及其技能：</p><ul><li>  目的：任何一个职业，都有它存在的目的。这个目的包括职业产生的背景，工作的环境，以及所承担的职责。</li><li>  储备：即敏捷教练所必备的基础知识。</li><li>  技巧：即如何运用基础知识履行职责。</li><li>  实战：即在一个典型完整的工作周期中，如何利用储备和技巧取得成功。</li></ul><p>本章会介绍：<br><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC01%E8%AF%BE-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%92%8C%20ScrumMaster%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E5%9B%9B%E9%83%A8%E6%9B%B2/%E5%9B%9B%E9%83%A8%E6%9B%B2.jpg"><img src="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC01%E8%AF%BE-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%92%8C%20ScrumMaster%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E5%9B%9B%E9%83%A8%E6%9B%B2/%E5%9B%9B%E9%83%A8%E6%9B%B2.jpg"></a></p><ul><li>  敏捷教练这个职业产生的背景</li><li>  敏捷教练的工作环境</li><li>  敏捷教练的职责</li><li>  体系化的参考书目</li></ul><p><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC01%E8%AF%BE-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%92%8C%20ScrumMaster%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E5%9B%9B%E9%83%A8%E6%9B%B2/%E5%9F%BA%E6%9C%AC%E5%8A%9F.jpg"><img src="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC01%E8%AF%BE-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%92%8C%20ScrumMaster%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E5%9B%9B%E9%83%A8%E6%9B%B2/%E5%9F%BA%E6%9C%AC%E5%8A%9F.jpg"></a></p><h1 id="敏捷教练职业产生背景"><a href="#敏捷教练职业产生背景" class="headerlink" title="敏捷教练职业产生背景"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC01%E8%AF%BE-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%92%8C%20ScrumMaster%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E5%9B%9B%E9%83%A8%E6%9B%B2/#%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E8%81%8C%E4%B8%9A%E4%BA%A7%E7%94%9F%E8%83%8C%E6%99%AF" title="敏捷教练职业产生背景"></a>敏捷教练职业产生背景</h1><blockquote><p>“追求更好”旅途的守护者</p></blockquote><p>敏捷方式可以追溯到1620年弗朗西斯·培根（Francis Bacon）科学方法的发源时期。更合理一点的起点可能是在20世纪30年代，那时候贝尔实验室的物理学家和统计学家沃特·阿曼德·休哈特（Walter A. Shewhart）开始使用计划-执行-学习-调整（PDSA）循环对产品和过程进行改善。</p><p>休哈特把这种反复渐进的开发过程教给了他的学员戴明（W.Edwards Deming），后者在二次大战后的日本大量使用了该方法。戴明将 PDSA 改造为 PDCA。丰田公司雇用了戴明来培训公司中数百名经理，并在他的经验之上创立了著名的丰田生产体系——这也是如今精益思想的最初由来。这种反复渐进的方式对于20世纪50年代的 X-15 超音速飞机的制造也是贡献巨大。</p><p>丰田模式的关键，以及使丰田有杰出表现的原因并不是任何个别要素，而是一个由各要素组成的 4P 体系：</p><ul><li><p>  长期理念（philosophy）：重视着眼于长期的思维，公司高层注重为顾客及社会创造与提升价值，这个目的主导了该公司的长期方法——建立学习型组织，投资于人员、产品与工厂，以及绝不松懈地坚持质量，以适应环境的变迁，成为高效的组织。</p></li><li><p>  正确的流程（process）：正确的流程方能产生优异成果，流程是以低成本，高安全性与高昂的士气达成最佳质量的关键。</p></li><li><p>  借助员工与合作伙伴（people and partner）的发展，为组织创造价值：丰田公司管理层的看法是，他们打造的是“人”，不是汽车。尊重员工的智慧和能力，并不断激励他们做得更好。</p></li><li><p>  持续解决根本问题（problems）是组织型学习的驱动力：丰田模式的最高境界是组织型学习，丰田的持续学习制度重心在于辨识问题的根源，并预防问题的发生，持续改善。</p></li></ul><p>此体系必须每天以贯彻一致的态度实行，而非只是一阵旋风。这个体系成功的秘诀是，经理即教练。培养深谙公司理念的领袖，使他们能教导其他员工。这是我们今天思考敏捷教练职责的最重要参照物。丰田的 4P 模式，也能帮助我们从根本上去思考什么是敏捷。</p><p>大野耐一是将丰田生产方式体系化的重要人物。大野耐一退休后，与其弟子创建了 NPS（New Production System），为其他企业服务。精益教练诞生，教练与经理分离。这也预示着在今天敏捷教练和管理者通常是分离的职位。</p><p>Scrum 的另一根植于日本的基础，是1986年野中郁次郎和竹内弘高在哈佛商业评论上发表的名为《新的新产品开发游戏》的文章。通过研究那些比竞争者更快发布新产品的制造商们，比如富士-施乐的复印机，本田的摩托车引擎，佳能的照相机，定义了以团队为基础的新的产品设计和研发过程。这种过程不是通常在产品开发中的“接力赛”——一组专家完成产品部分功能并将项目传递到下一组专家手中。这种方式被野中郁次郎和竹内弘高称作为“橄榄球”方式，“团队试图作为一个整体完成所有任务，将球传来传去。”</p><p>在1993年，Jeff Sutherland 面临一项似乎是不可能完成的挑战：Easel 是一家软件公司，需要在半年之内开发一款新产品来替代它的传统产品。Jeff Sutherland 通晓很多方法，比如快速应用程序研发，面向对象设计，PDSA 循环，专案工作等等。他希望在公司总部建立一个类似于专案工作的文化氛围，将组织分割和合并的好处结合起来。他开始学习任何和提高组织效率相关的知识。通过阅读上百篇研究报告和顶尖的产品管理专家面谈，他脑海中逐渐有了一些有煽动力的想法。</p><p>这中间有一个想法来自于贝尔实验室的关于 Borland Quattro Pro 团队的文章。该文章主张，每天短的团队会议能显著增加团队效率。而 Jeff Sutherland 的核心概念则来自于竹内弘高和野中郁次郎的“橄榄球”方式，虽然该方法更关注制造过程而不是软件开发过程。通过借鉴哈佛商业评论文章中的关键想法和进行一些特别的试验，Jeff Sutherland 创建了一种新的软件开发方法，归功于橄榄球带来的灵感，Sutherland 将这种方法称为“争球”（Scrum）。Scrum 方式最后确保了他准时完成了似乎不可能的任务，也没有超出预算，程序漏洞比之前版本还要少很多。Sutherland 随后就长时间和 Ken Schwaber 对该方法进行长期研究，并在1995年两人首次在公众面前发布 Scrum 的方法。</p><p>在2001年，17位自称“有组织的无政府主义者”在美国犹他州的雪鸟滑雪场会面，分享他们的想法。Jeff Sutherland 和其它 Scrum 的先驱也在其中。参与者们分享了互相竞争的几种方式：极限编程（XP）、水晶方法、自适应软件开发（ASD）、特性驱动开发（FDD）、动态系统开发方法（DSDM）。所有这些方式都是“轻量版”的框架，因为这些方法使用更少、更简单的规则来适应快速变化的环境。不少与会者都觉得“轻量”这个术语挺适用的。</p><p>虽然与会者不能在方法上达成一致，但是他们还是为这个运动取了个名字：敏捷。这个词是一位参与者提出的，他当时正在读《敏捷竞争者和虚拟组织：给客户更多的策略》一书。书中列举了100家公司的例子——包括 ABB， 联邦快递，波音，博士和哈雷戴维森，这些公司正在创建适应动荡市场的新方法。有了这个名字，参与者达成一致，发布了“敏捷软件开发宣言”，该宣言中突出了每个人都同意的4个关键价值。稍后在会议中，以及之后的几个月中，他们发展了12个原则，被称为“敏捷宣言背后的原则”。 从2001年开始，所有的开发框架，以及与之匹配的价值观和原则就被称作为敏捷技术。</p><p>同时，敏捷方法继续演化。在20世纪80年代后期和90年代前期，MIT 的研究学者们开始研究日本的制造体系，特别是丰田生产体系。他们借用了名词“精益”来描述改善效率的这套体系，包括消除浪费（muda)， 减少波动（mura）和降低负荷（muri）。虽然精益方法并没有在雪鸟会议上被表述成敏捷方法，但是精益和看板软件开发系统在后来被并入敏捷系统。在开始时候，一些纯粹的敏捷主义者拒绝承认精益方法。 但是精益宣传该方法能关注客户协作，最终更多的敏捷践行者开始接受精益，看板，还有混合方法（比如 Scrumban 和 Lean scrum），作为敏捷价值和原则合法的应用。</p><p>这些新方法论的创始人们是精通技术的管理者，和管理者中的思想者。敏捷宣言的17位创始人，是敏捷思想的传道者，可以被认为是最早的敏捷教练。他们所创造的这些方法的本质，不是一些死板的规定，而是在追求“更好”的旅途中，作为承载“更好”的载体。这些方法论的落地，以及作为这些方法论内在精神的追求“更好”，不会自动发生。</p><p>一种可能的逻辑是，由管理者来承担落实新方法论的责任。管理者可以转型为教练，重拾作为精益鼻祖的丰田的精神。对于管理者无法承担教练职责但又想追随敏捷潮流的组织，则需要专职的敏捷教练。</p><h2 id="敏捷教练工作的环境"><a href="#敏捷教练工作的环境" class="headerlink" title="敏捷教练工作的环境"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC01%E8%AF%BE-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%92%8C%20ScrumMaster%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E5%9B%9B%E9%83%A8%E6%9B%B2/#%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%B7%A5%E4%BD%9C%E7%9A%84%E7%8E%AF%E5%A2%83" title="敏捷教练工作的环境"></a>敏捷教练工作的环境</h2><p>守破离的概念来自日本，大致可以理解为遵守、突破和脱离。这个概念在敏捷界被广泛运用，含义也会有所变迁。下面这个关于组织所处阶段的守破离，来自于 Scrum 之父 Jeff Sutherland。</p><h4 id="组织的守的状态"><a href="#组织的守的状态" class="headerlink" title="组织的守的状态"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC01%E8%AF%BE-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%92%8C%20ScrumMaster%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E5%9B%9B%E9%83%A8%E6%9B%B2/#%E7%BB%84%E7%BB%87%E7%9A%84%E5%AE%88%E7%9A%84%E7%8A%B6%E6%80%81" title="组织的守的状态"></a>组织的守的状态</h4><ul><li>  CEO 没有敏捷思维。以命令和控制的文化为主。</li><li>  依据传统的管理层级结构产生项目组。</li><li>  即使采用敏捷，也是跟风，流于形式，无法深入。</li><li>  在这种状态之下的效率提升通常只能做到20%~30%</li></ul><h4 id="组织的破的状态"><a href="#组织的破的状态" class="headerlink" title="组织的破的状态"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC01%E8%AF%BE-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%92%8C%20ScrumMaster%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E5%9B%9B%E9%83%A8%E6%9B%B2/#%E7%BB%84%E7%BB%87%E7%9A%84%E7%A0%B4%E7%9A%84%E7%8A%B6%E6%80%81" title="组织的破的状态"></a>组织的破的状态</h4><ul><li>  CEO 改变管理者的角色。教练和支持的文化浮现。</li><li>  管理者教导团队自组织和自管理。管理者成为领导者。</li><li>  领导者为团队提供有挑战的排好优先级的目标。</li><li>  消除组织债，创建可行的商业和组织计划，提供团队所需的资源。</li><li>  识别和移除障碍，消除浪费和技术债，确保团队速率最大化。</li><li>  确保产品负责人对交付的价值负责。</li><li>  确保 Scrum Master 对流程改善和团队快乐负责。</li><li>  确保团队对质量提升和技术债修复负责。</li><li>  团队依据排好优先级的产品列表自我形成。</li><li>  领导者在组织内驱动不同技能的虚拟实践社区，为组织提供能力建设。</li><li>  领导者按需重构组织。</li><li>  在生产力方面会取得200%~400%的提升。</li><li>  示例公司：Spotify，SAP，Salesforce，Microsoft。</li></ul><h4 id="组织的离的状态"><a href="#组织的离的状态" class="headerlink" title="组织的离的状态"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC01%E8%AF%BE-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%92%8C%20ScrumMaster%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E5%9B%9B%E9%83%A8%E6%9B%B2/#%E7%BB%84%E7%BB%87%E7%9A%84%E7%A6%BB%E7%9A%84%E7%8A%B6%E6%80%81" title="组织的离的状态"></a>组织的离的状态</h4><ul><li>  层级仍然存在，但主要是为技能培养服务。</li><li>  团队自组织负责产品方向和组织重构。</li><li>  领导者支持团队所需的技能。</li><li>  群游使组织在压力之下更强壮。</li><li>  产生500%~1000%的生产力提升。</li><li>  示例公司：Valve，Zappos，Morning Star，Gore，Grindr。</li></ul><blockquote><p>这三种状态，跟建国方略中的军政、训政和宪政暗合，可参照理解。</p></blockquote><p>瓶颈通常在瓶子的上部，一个公司最大的瓶颈是 CEO。作为一个敏捷教练，针对所处的组织形态，可以采取运用敏捷基本功加上变通的方法来开展工作。</p><p>至于团队，也会有三种形态。</p><h4 id="无组织团队"><a href="#无组织团队" class="headerlink" title="无组织团队"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC01%E8%AF%BE-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%92%8C%20ScrumMaster%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E5%9B%9B%E9%83%A8%E6%9B%B2/#%E6%97%A0%E7%BB%84%E7%BB%87%E5%9B%A2%E9%98%9F" title="无组织团队"></a>无组织团队</h4><ul><li>  从团队绩效方面看，是相对不高和不稳定的，时好时坏。迭代计划预测的靠谱度较差，速度也不高。</li><li>  从团队动态和互动看，呈现出一种各自为政的状态，沟通不畅，合作困难。从会议看，目的不明确，流程不清晰，效率低，参与者沮丧。</li></ul><h4 id="自运转团队"><a href="#自运转团队" class="headerlink" title="自运转团队"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC01%E8%AF%BE-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%92%8C%20ScrumMaster%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E5%9B%9B%E9%83%A8%E6%9B%B2/#%E8%87%AA%E8%BF%90%E8%BD%AC%E5%9B%A2%E9%98%9F" title="自运转团队"></a>自运转团队</h4><ul><li>  从团队绩效看，呈现出相对稳定的状态，迭代目标承诺靠谱度较好，迭代目标基本能完成。</li><li>  从团队动态和互动看，团队成员目标一致，有良好的沟通合作，在各项活动中，团队成员都能主动参与。会议的目的和流程清晰，没有 Scrum Master 的情况下，会议也能按照打磨好的流程自动运转起来。</li></ul><h4 id="自组织团队"><a href="#自组织团队" class="headerlink" title="自组织团队"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC01%E8%AF%BE-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%92%8C%20ScrumMaster%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E5%9B%9B%E9%83%A8%E6%9B%B2/#%E8%87%AA%E7%BB%84%E7%BB%87%E5%9B%A2%E9%98%9F" title="自组织团队"></a>自组织团队</h4><ul><li>  从团队绩效看，在稳定的基础上，呈现出阶段性的持续提升，生产率和质量不断提高。</li><li>  从团队动态和互动看，团队有更多高质量的互动，团队除了关心共同的目标，还关心持续改善和从根本上解决问题。呈现出上文中所说的丰田 4P 的一些特征。</li></ul><blockquote><p>敏捷教练所要做的，就是把团队从无组织状态带到自运转状态，再进一步带到自组织状态。这个使命的履行，本课程中敏捷教练和 ScrumMaster 的基本功可以帮到您。</p></blockquote><h2 id="敏捷教练的职责：流程与人两手抓"><a href="#敏捷教练的职责：流程与人两手抓" class="headerlink" title="敏捷教练的职责：流程与人两手抓"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC01%E8%AF%BE-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%92%8C%20ScrumMaster%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E5%9B%9B%E9%83%A8%E6%9B%B2/#%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E8%81%8C%E8%B4%A3%EF%BC%9A%E6%B5%81%E7%A8%8B%E4%B8%8E%E4%BA%BA%E4%B8%A4%E6%89%8B%E6%8A%93" title="敏捷教练的职责：流程与人两手抓"></a>敏捷教练的职责：流程与人两手抓</h2><p>在设计本课程之前，针对一部分敏捷从业人员和经历者做了一个小调查，想了解他们对 Scrum Master 职责的理解。这个调查虽然样本较小，不具备统计意义，但依然可以帮助我们了解跟我们处在同样角色的人对这个问题怎么看。调查结果如下：</p><ul><li>  精通管理规则，精通业务梳理，极强的沟通协作能力，技术熟练，懂业务管理。</li><li>  敏捷教练确保 Scrum 被正确的运用和贯彻，同时保护团队和引导新的想法落地。</li><li>  Scrum Master 是牧羊犬的作用，让团队在一个迭代中不受打扰，同时他应该对敏捷的流程、理念有深入的了解，具有较强的管理能力。</li><li>  引导团队进行效率的提升，通过各种工具的导入，来实现项目目标。但是，究竟是否要像传统团队一样，也要引导团队进行项目交付，并解决依赖问题，这个要商榷。</li><li>  保证团队资源，保证各个角色及职责协作，解决团队开发中的障碍，协调解决沟通问题，保证开发过程按计划进行。</li><li>  指导 Scrum 小组成员理解为什么、知道如何参与 Scrum 实践的每一个环节，把控好 Scrum 实践的产出，为整个小组的 Scrum 迭代/计划结果负责。</li><li>  基于对 Scrum 角色的了解，以及对项目和资源的认识，帮助 stakeholder 决定最佳的按照 Agile 路线来实施项目的教练。</li><li>  培训和指导团队践行敏捷实践；关注项目的度量数据，及时带领团队调整，加速或稳步前进；关注成员的状态，激励督促团队前进；带领和辅导团队按照敏捷和精益的方式做事，打造优秀自组织团队。</li><li>  牧羊犬守护团队，流程；教练，培训，引导团队，PO，相关人知识，技能；推动过程改进，促进变革；提升团队，组织效能。</li><li>  在敏捷团队中推进敏捷开发模式和流程，是团队的组织者，保证团队资源，协调内外部关系，解决出现的问题。</li><li>  帮助团队进行敏捷实践落地，梳理流程，减少外部干扰，鼓舞士气，提高团队作战能力。提高工作效率。</li><li>  传播敏捷思想，指导团队，指导 PO，组织敏捷会议，排除团队干扰。</li><li>  指导团队按 Scrum 方式运转，传播 Scrum 思想，指导敏捷实践，提高效率。</li><li>  保证团队资源完全可被利用并且全部是高产出的。保证各个角色及职责的良好协作。解决团队开发中的障碍。做为团队和外部的接口，屏蔽外界对团队成员的干扰。保证开发过程按计划进行，组织 Daily Scrum，Sprint Review and Sprint Planning meetings。</li><li>  Scrum Master 是 Sprint 的负责人，Sprint 做得好不好的终责者。负责计划，执行 Sprint，并使团队团结及有自主创造能力。</li><li>  搭建 team 架构，分配各个角色成员，开展 scrum 常规的事项，并让敏捷的理念深入人心。帮助团队更好的按照 Scrum 框架有效的运行，对团队遇到的问题和障碍提供帮助，协助扫清研发过程中的障碍，打造高效能的团队。</li><li>  组织项目团队，承诺项目开发，回顾项目过程，总结项目经验教训，组织每日站会，制定 Sprint 计划。</li><li>  Facilitate everything and eventually retire，留下一个自组织团队，悄然离去，深藏功与名。激励团队，coach，team lead，life tutor。</li><li>  Scrum Master 应该是作为团队初步接触敏捷时作为流程与套路教授和规范。在团队逐步成熟后，Scrum Master 的职责可以旁落，而专职 Scrum Master 可以取消。</li></ul><p>那么敏捷教练的职责到底是什么呢？</p><p>《敏捷教练》一书的作者之一，瑞秋·戴维斯（Rachel Davies）对敏捷教练的观点：</p><blockquote><p>概括地说，敏捷教练帮助团队在工作中应用敏捷实践，从而帮助团队发展的更健壮。接受这些变化需要时间，所以没法通过“点到即止”的方法立即让它们生效。你需要与团队长时间呆在一起，并帮他们，让他们更加关注工作流程、关注如何更有效地协作。你对团队的目标是在你离开后，让他们能“自我指导”并且擅长应用敏捷。这样不会限制敏捷教练向组织引进敏捷，以及建立新敏捷团队。</p></blockquote><p>&lt; Coaching Agile Teams &gt; 的作者 Lyssa Adkins 对敏捷教练的观点：</p><blockquote><p>敏捷教练确实非常重要，因为现在有许多人在运用一堆蹩脚的敏捷工作方式。即使运用了，它们只是更快地产出了平庸的结果，我知道，那并不是他们运用所谓“敏捷”工作方式的主要意图。我认为教练是帮助团队取得惊人成果所不可或缺的组成部分，因为所有的成果都是人互相交互所产生的。敏捷框架中没有说明如何处理人与人交互的部分。为了使敏捷框架良好运作，它当然会提供可让其正常运行的结构和容器。但是在敏捷框架之外，还有很多事情要做，还有很多东西需要带给团队，针对不同的规则，需要给团队很多建议——如冲突管理、敏捷促进、教导及指引人、专业指导等等。</p></blockquote><p>本文给出的敏捷教练的职责定义是：</p><ul><li>  贯彻一种工作方式，包括精益、敏捷和系统思考。</li><li>  打造自组织团队，特别是要面对人（包括自我与他人）这个最复杂的实体。</li><li>  以此来消除浪费，增加价值，达到组织的目标。</li></ul><p>要履行这些职责，需要理解敏捷，这是本课程基本功的储备部分；要能够在组织中用敏捷影响他人，这是基本功中技能的部分；要体会真实环境中的敏捷运用，这是本课程基本功中的实战部分。</p><h2 id="体系化的参考书目"><a href="#体系化的参考书目" class="headerlink" title="体系化的参考书目"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC01%E8%AF%BE-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%92%8C%20ScrumMaster%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E5%9B%9B%E9%83%A8%E6%9B%B2/#%E4%BD%93%E7%B3%BB%E5%8C%96%E7%9A%84%E5%8F%82%E8%80%83%E4%B9%A6%E7%9B%AE" title="体系化的参考书目"></a>体系化的参考书目</h2><blockquote><p>敏捷是敏捷教练的代码</p></blockquote><p>敏捷的历史是一场不断追求更好的历史，在这个过程中，先行者们为我们留下了众多可供参考和让我们无须重新发明轮子的书籍。</p><p>本节以类库、框架、架构，和编辑、编译、链接、运行的视角解析敏捷和敏捷教练，以及如何运用先行者们留下的书籍。</p><p>敏捷是一种代码，2001年2月，17人在美国犹他州的雪鸟滑雪场，解码和发明了这门语言，并贡献了敏捷基础类库。</p><h3 id="敏捷基础类库"><a href="#敏捷基础类库" class="headerlink" title="敏捷基础类库"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC01%E8%AF%BE-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%92%8C%20ScrumMaster%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E5%9B%9B%E9%83%A8%E6%9B%B2/#%E6%95%8F%E6%8D%B7%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%BA%93" title="敏捷基础类库"></a>敏捷基础类库</h3><ul><li>  Kent Beck 等的 （《敏捷宣言》）。</li></ul><h3 id="敏捷框架类库"><a href="#敏捷框架类库" class="headerlink" title="敏捷框架类库"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC01%E8%AF%BE-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%92%8C%20ScrumMaster%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E5%9B%9B%E9%83%A8%E6%9B%B2/#%E6%95%8F%E6%8D%B7%E6%A1%86%E6%9E%B6%E7%B1%BB%E5%BA%93" title="敏捷框架类库"></a>敏捷框架类库</h3><ul><li>  Jeff Sutherland &amp; Ken Schwaber</li><li>  Kent Beck （《拥抱变化：解析极限编程》）</li><li>  Mike Cohn （《用户故事与敏捷方法》）（《敏捷估算与规划》）</li><li>  David Anderson （《看板方法》）</li><li>  Mary Poppendieck （《精益软件开发》）</li><li>  Craig Larman 的 Large Scale Scrum</li><li>  Dean Leffingwell 的 SAFe</li></ul><h3 id="敏捷扩展类库"><a href="#敏捷扩展类库" class="headerlink" title="敏捷扩展类库"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC01%E8%AF%BE-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%92%8C%20ScrumMaster%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E5%9B%9B%E9%83%A8%E6%9B%B2/#%E6%95%8F%E6%8D%B7%E6%89%A9%E5%B1%95%E7%B1%BB%E5%BA%93" title="敏捷扩展类库"></a>敏捷扩展类库</h3><ul><li><p>  野中郁次郎和竹内宏高《新的新产品开发游戏》《场理论》</p></li><li><p>  Henrik Kniberg （《硝烟中的 Scrum 和 XP 》）</p></li><li><p>  Kenny Rubin （《Scrum 精髓》）</p></li><li><p>  Jeff Patton （《用户故事地图》）</p></li><li><p>  Mitch Lacey （《Scrum 实战指南》）</p></li><li><p>  Ken Schwaber （《Scrum 敏捷项目管理》）</p></li><li><p>  Mike Cohn （《Scrum 敏捷软件开发》）</p></li><li><p>  Eric Ries （《精益创业》）</p></li><li><p>  Ellen Gottesdiener</p></li><li><p>  Jezz Humble （《持续交付》）</p></li><li><p>  《戴明14条》</p></li><li><p>  艾永亮《腾讯之道》</p></li><li><p>  何勉《精益产品开发原则、方法与实施》</p></li></ul><h3 id="精益类库"><a href="#精益类库" class="headerlink" title="精益类库"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC01%E8%AF%BE-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%92%8C%20ScrumMaster%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E5%9B%9B%E9%83%A8%E6%9B%B2/#%E7%B2%BE%E7%9B%8A%E7%B1%BB%E5%BA%93" title="精益类库"></a>精益类库</h3><ul><li>  大野耐一 《丰田生产方式》《现场管理》</li><li>  新乡重夫《从 IE 的角度看丰田生产方式》</li><li>  James Womack （《改变世界的机器》）（《精益思想》）</li><li>  Jeffery Liker （《丰田模式》）系列</li><li>  John Shook （A3 报告）（价值流图）</li></ul><h3 id="引导与心理学类库"><a href="#引导与心理学类库" class="headerlink" title="引导与心理学类库"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC01%E8%AF%BE-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%92%8C%20ScrumMaster%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E5%9B%9B%E9%83%A8%E6%9B%B2/#%E5%BC%95%E5%AF%BC%E4%B8%8E%E5%BF%83%E7%90%86%E5%AD%A6%E7%B1%BB%E5%BA%93" title="引导与心理学类库"></a>引导与心理学类库</h3><ul><li>  NLP 神经语言程式</li><li>  世界咖啡</li><li>  六顶思考帽</li></ul><h3 id="管理与变革类库"><a href="#管理与变革类库" class="headerlink" title="管理与变革类库"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC01%E8%AF%BE-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%92%8C%20ScrumMaster%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E5%9B%9B%E9%83%A8%E6%9B%B2/#%E7%AE%A1%E7%90%86%E4%B8%8E%E5%8F%98%E9%9D%A9%E7%B1%BB%E5%BA%93" title="管理与变革类库"></a>管理与变革类库</h3><ul><li>  Chip &amp; Dan Heath （《瞬变》）</li><li>  Jurgen Appelo （《管理3.0》）</li><li>  Jurgen Appelo （《变革管理3.0》）</li><li>  Daniel Pink （《驱动力》）</li><li>  （《重新定义公司》）</li></ul><h3 id="敏捷模式类库"><a href="#敏捷模式类库" class="headerlink" title="敏捷模式类库"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC01%E8%AF%BE-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%92%8C%20ScrumMaster%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E5%9B%9B%E9%83%A8%E6%9B%B2/#%E6%95%8F%E6%8D%B7%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%BA%93" title="敏捷模式类库"></a>敏捷模式类库</h3><ul><li>  Scrum 本身就是个模式</li><li>  《用户故事地图》也是模式</li><li>  Linda Rising</li><li>  本课程中的 Scrum 子模式，例如故事泳道、一人天任务、随机一分钟项目经理。</li></ul><h3 id="敏捷教练方法类库"><a href="#敏捷教练方法类库" class="headerlink" title="敏捷教练方法类库"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC01%E8%AF%BE-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%92%8C%20ScrumMaster%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E5%9B%9B%E9%83%A8%E6%9B%B2/#%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E6%96%B9%E6%B3%95%E7%B1%BB%E5%BA%93" title="敏捷教练方法类库"></a>敏捷教练方法类库</h3><ul><li>  Lyssa Adkins</li></ul><h3 id="修身类库"><a href="#修身类库" class="headerlink" title="修身类库"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC01%E8%AF%BE-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%92%8C%20ScrumMaster%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E5%9B%9B%E9%83%A8%E6%9B%B2/#%E4%BF%AE%E8%BA%AB%E7%B1%BB%E5%BA%93" title="修身类库"></a>修身类库</h3><ul><li>  《大学》《中庸》《论语》《孟子》</li><li>  《王阳明全集》</li><li>  《心经》《金刚经》</li><li>  《圣经》</li><li>  阿德勒《超越自卑》</li><li>  《人生五大问题》</li><li>  斯蒂芬柯维《七个习惯》</li><li>  《红与黑》</li><li>  《基督山伯爵》</li><li>  《悲惨世界》</li><li>  《百年孤独》</li><li>  《活着》</li><li>  《常识》</li></ul><p>而在设计敏捷工作方法的架构时，可以基于上面提到的敏捷框架中的一个或多个。可以使用的思维线索有：</p><ul><li>  软件开发的阶段：概念，机会，策略，需求，方案，计划，实施，验证，部署，维护，退役。</li><li>  PDCA</li><li>  5W2H</li></ul><p>在做敏捷工作方法的实施时,</p><p>第一步是需求：</p><ul><li>  与关键人员交流，了解问题与目标</li><li>  这一步要放下敏捷的代码，倾听了解问题与目标本身。</li></ul><p>第二步是制定解决方案：</p><ul><li>  根据现状，参考敏捷方法，制定关键举措。</li><li>  使用类库和框架，制定架构。</li></ul><p>敏捷工作方法的编码就是用上面的各种类库和框架，生成适合组织和团队的可执行的敏捷方法，包括架构和详细实现。执行的环境是团队中每个人的大脑。</p><p>编辑，是把方案细化的过程：</p><ul><li>  把敏捷方法动作化，做好剧本。无剧本，不操作。</li><li>  为每一次谈话做好充分准备。</li></ul><p>编译，是与团队中所有人交流的过程，使所有人理解敏捷方法：</p><ul><li>  可以是讨论，针对某个具体变化的方案与执行。</li><li>  可以是培训，介绍整体或某个环节的工作方法。</li><li>  可以是一对一交流，让方法切实而不只是形式上发生。</li></ul><p>链接，是处理与现状和与已有工作方法的冲突：</p><ul><li>  分析问题，解决问题。</li><li>  调整“代码”</li></ul><p>运行，是新方法的执行：</p><ul><li>  落实每一个动作，并检查调整。</li></ul><p>编辑、编译、链接、运行会反复多次进行，跟程序员写代码没有区别。</p><p><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC01%E8%AF%BE-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%92%8C%20ScrumMaster%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E5%9B%9B%E9%83%A8%E6%9B%B2/%E8%BF%9B%E9%98%B6%E5%8A%9F.jpg"><img src="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC01%E8%AF%BE-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%92%8C%20ScrumMaster%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E5%9B%9B%E9%83%A8%E6%9B%B2/%E8%BF%9B%E9%98%B6%E5%8A%9F.jpg"></a></p></blockquote><p>本文作者： <a href="mailto:&#106;&#111;&#110;&#105;&#x40;&#x65;&#102;&#98;&#105;&#122;&#46;&#x6f;&#x72;&#103;">&#106;&#111;&#110;&#105;&#x40;&#x65;&#102;&#98;&#105;&#122;&#46;&#x6f;&#x72;&#103;</a><br>本文链接： <a href="https://github.com/efbiz/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC01%E8%AF%BE-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%92%8C">https://github.com/efbiz/2018/05/14/敏捷教练第01课-敏捷教练和</a> ScrumMaster 基本功四部曲/ </p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;h1 id=&quot;课程概述&quot;&gt;&lt;a href=&quot;#课程概述&quot; class=&quot;headerlink&quot; title=&quot;课程概述&quot;&gt;&lt;/a&gt;课程概述&lt;/h1&gt;&lt;p&gt;敏捷教练是一个职业。Scrum Master 和敏捷教练是同一职业的不同阶段。当一个人能带好一个 </summary>
      
    
    
    
    <category term="Scrum" scheme="http://zhangyu.info/categories/Scrum/"/>
    
    
    <category term="Scrum" scheme="http://zhangyu.info/tags/Scrum/"/>
    
  </entry>
  
  <entry>
    <title>敏捷教练第02课-储备-Scrum精要</title>
    <link href="http://zhangyu.info/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum%E7%B2%BE%E8%A6%81/"/>
    <id>http://zhangyu.info/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum%E7%B2%BE%E8%A6%81/</id>
    <published>2022-04-11T16:00:00.000Z</published>
    <updated>2022-04-12T01:57:08.352Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍 Scrum 的书虽然还没有达到汗牛充栋的程度，但已经是著作等身了——所有著作加起来能够等同于一个人的身高了。本文并不是对 Scrum 理论的简单重复，而是立意能做到两点：</p><ul><li>  涵盖 Scrum 中所有重要的概念。</li><li>  所介绍的方法达到说明书的程度，拿过去就能用。</li></ul><h1 id="敏捷产生的历史背景"><a href="#敏捷产生的历史背景" class="headerlink" title="敏捷产生的历史背景"></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#%E6%95%8F%E6%8D%B7%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%86%E5%8F%B2%E8%83%8C%E6%99%AF" title="敏捷产生的历史背景"></a>敏捷产生的历史背景</h1><p>首先简要谈一下敏捷产生的历史背景，以及由 Scrum 及其众多兄弟方法共同抽象出的敏捷宣言。</p><p>敏捷产生的历史背景，在于世界变化越来越快。人们不断产生更多更新的需求，技术因此不断进步，两者交相辉映，使得变化越来越快。</p><p>以通信行业为例，从 1G 到 5G 呈现出一种升级越来越快的状态。</p><p>1986年，作为 1G 标志的使用模拟信号的世界上第一套移动通信系统在美国芝加哥诞生。</p><p>1995年，诺基亚崛起，进入数字调制的 2G 时代。</p><p>2009年左右，CDMA 大行其道，进入数据传输速率更高的 3G 时代。</p><p>2013年左右，伴随移动互联网，移动通信进入网速更高的 4G 时代。</p><p>最近一两年，随着 AR、VR、车联网、物联网的诞生，5G 的商用化指日可待。</p><p>在这种变化越来越快的环境之下，传统的软件开发方法不再奏效。敏捷先驱们开始探索一些新的方法，对丰田生产方式、组织模式等进行了大量学习，发明了 Scrum、XP 等各种方法论。2001年，新方法论的创始人们聚首一堂，总结了各家方法论的共同点，提出了敏捷软件开发宣言。</p><p>敏捷宣言有4个价值观和12个原则，它们也是 Scrum 的基础。对4个价值观要能够背诵下来，对12个原则也要熟悉，以便达到遇到实践情况时能容易对照的目的。我们为您精制了手绘版的敏捷宣言价值观和原则，可以打印张贴备查。</p><h1 id="敏捷软件开发宣言"><a href="#敏捷软件开发宣言" class="headerlink" title="敏捷软件开发宣言"></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%AE%A3%E8%A8%80" title="敏捷软件开发宣言"></a>敏捷软件开发宣言</h1><p><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/%E5%BC%80%E5%8F%91%E5%AE%A3%E8%A8%80.jpg"><img src="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/%E5%BC%80%E5%8F%91%E5%AE%A3%E8%A8%80.jpg"></a></p><p>我们一直在实践中探寻更好的软件开发方法，身体力行的同时也帮助他人。由此我们建立了如下价值观：</p><ul><li>  个体和互动 &gt; 流程和工具</li><li>  工作的软件 &gt; 详尽的文档</li><li>  客户合作 &gt; 合同谈判</li><li>  响应变化 &gt; 遵循计划</li></ul><p>也就是说，尽管右项有其价值，我们更重视左项的价值。</p><h2 id="敏捷宣言遵循的原则"><a href="#敏捷宣言遵循的原则" class="headerlink" title="敏捷宣言遵循的原则"></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#%E6%95%8F%E6%8D%B7%E5%AE%A3%E8%A8%80%E9%81%B5%E5%BE%AA%E7%9A%84%E5%8E%9F%E5%88%99" title="敏捷宣言遵循的原则"></a>敏捷宣言遵循的原则</h2><p><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/12%E5%8E%9F%E5%88%99.jpg"><img src="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/12%E5%8E%9F%E5%88%99.jpg"></a></p><ul><li>  我们最重要的目标，是通过持续不断地及早交付有价值的软件使客户满意。</li><li>  欣然面对需求变化，即使在开发后期也一样。为了客户的竞争优势，敏捷过程掌控变化。</li><li>  经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期。</li><li>  业务人员和开发人员必须相互合作，项目中的每一天都不例外。</li><li>  激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支援，辅以信任，从而达成目标。</li><li>  不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈。</li><li>  可工作的软件是进度的首要度量标准。</li><li>  敏捷过程倡导可持续开发。责任人、开发人员和用户要能够共同维持其步调稳定延续。</li><li>  坚持不懈地追求技术卓越和良好设计，敏捷能力由此增强。</li><li>  以简洁为本，它是极力减少不必要工作量的艺术。</li><li>  最好的架构、需求和设计出自自组织团队。</li><li>  团队定期地反思如何能提高成效，并依此调整自身的举止表现。</li></ul><h1 id="Scrum-方法论"><a href="#Scrum-方法论" class="headerlink" title="Scrum 方法论"></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#Scrum-%E6%96%B9%E6%B3%95%E8%AE%BA" title="Scrum 方法论"></a>Scrum 方法论</h1><p><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/3355.jpg"><img src="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/3355.jpg"></a></p><p>我们力求把方法论介绍到可操作的程度，从方便理解和记忆的角度，Scrum 方法论可以被概括为3355</p><h2 id="3个角色"><a href="#3个角色" class="headerlink" title="3个角色"></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#3%E4%B8%AA%E8%A7%92%E8%89%B2" title="3个角色"></a>3个角色</h2><ul><li>  PO（产品负责人）</li><li>  SM（Scrum Master）</li><li>  团队成员。</li></ul><h2 id="3个物件"><a href="#3个物件" class="headerlink" title="3个物件"></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#3%E4%B8%AA%E7%89%A9%E4%BB%B6" title="3个物件"></a>3个物件</h2><ul><li>  Product Backlog（产品列表）</li><li>  Sprint Backlog（迭代列表）</li><li>  Product Increment（产品增量）</li></ul><h2 id="5个会议"><a href="#5个会议" class="headerlink" title="5个会议"></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#5%E4%B8%AA%E4%BC%9A%E8%AE%AE" title="5个会议"></a>5个会议</h2><ul><li>  Product Backlog Grooming （产品列表精化）</li><li>  Sprint Planning（迭代计划会）</li><li>  Daily Stand（每日站会）</li><li>  Spring Review （迭代评审会）</li><li>  Sprint Retrospective（迭代回顾会）</li></ul><h2 id="5个价值观"><a href="#5个价值观" class="headerlink" title="5个价值观"></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#5%E4%B8%AA%E4%BB%B7%E5%80%BC%E8%A7%82" title="5个价值观"></a>5个价值观</h2><p>勇气，承诺，专注，开放，尊重。</p><p>Scrum 由上述四种要素及背后的规则粘合起来。</p><p>3个角色各有担当又通力合作。 3个简单的物件统摄产品层面与迭代层面的交付物。 5个会议贯通产品层面与迭代层面的计划与执行活动。 5个价值观作为方法论的一部分，体现了 Scrum 以价值观为方法论的特色。</p><h2 id="3个角色的职责"><a href="#3个角色的职责" class="headerlink" title="3个角色的职责"></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#3%E4%B8%AA%E8%A7%92%E8%89%B2%E7%9A%84%E8%81%8C%E8%B4%A3" title="3个角色的职责"></a>3个角色的职责</h2><p><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/3%E4%B8%AA%E8%A7%92%E8%89%B2.jpg"><img src="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/3%E4%B8%AA%E8%A7%92%E8%89%B2.jpg"></a></p><h3 id="Scrum-Master-的职责"><a href="#Scrum-Master-的职责" class="headerlink" title="Scrum Master 的职责"></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#Scrum-Master-%E7%9A%84%E8%81%8C%E8%B4%A3" title="Scrum Master 的职责"></a>Scrum Master 的职责</h3><p>Scrum Master 的职责最难讲得清楚。有一个思路是参照卡诺模型。日本教授把产品需求分为三类：</p><ul><li>  必备型需求：这类需求没有满足，客户不会购买这个产品。</li><li>  多多益善型需求：这类需求的实现程度与客户付钱的愿望呈线性关系。</li><li>  喜出望外型需求：这类需求是区别于竞争产品的分水岭，客户愿意付出溢价。</li></ul><p>按照这个思路，我们可以把 Scrum Master 的职责分为三类：</p><ul><li>  必备型职责：协助管理 Scrum 的3个物件和5个会议。</li><li>  多多益善型职责：与各方沟通和协调问题解决。</li><li>  喜出望外型职责：系统思考，发现流程和团队工作中的改善点，并推动改善。</li></ul><h3 id="产品负责人职责"><a href="#产品负责人职责" class="headerlink" title="产品负责人职责"></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#%E4%BA%A7%E5%93%81%E8%B4%9F%E8%B4%A3%E4%BA%BA%E8%81%8C%E8%B4%A3" title="产品负责人职责"></a>产品负责人职责</h3><p>管好产品列表。理解了什么是好的产品列表，也就理解了产品负责人的职责。后面会讲产品列表。</p><h3 id="团队职责"><a href="#团队职责" class="headerlink" title="团队职责"></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#%E5%9B%A2%E9%98%9F%E8%81%8C%E8%B4%A3" title="团队职责"></a>团队职责</h3><p>与传统团队职责不太一样的主要有两点：</p><ul><li>  跨职能：个人不一定是全能的，但团队要是全能的，具备把产品列表变成产品增量的全部技能。团队成员之间，不受角色和头衔的制约，只要具备能力，每个人都可以认领所有任务。</li><li>自组织：团队自行决定自己的工作方式，只要团队有共识。原则上是全员参与估算和计划，全员进行项目进度的监控和调整。<br>  在现实的团队中，有专职人员，也可能有浮动人员，不管是专职人员还是浮动人员，几个共同的基础是：自动化与及时化，每个人都做好本职工作，彼此之间良好配合；每个人都理解团队的产品目标和迭代目标；每个人都了解团队的工作方式和节拍。</li></ul><h3 id="浮动人员的类别"><a href="#浮动人员的类别" class="headerlink" title="浮动人员的类别"></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#%E6%B5%AE%E5%8A%A8%E4%BA%BA%E5%91%98%E7%9A%84%E7%B1%BB%E5%88%AB" title="浮动人员的类别"></a>浮动人员的类别</h3><ul><li><p>  一类浮动人员，例如架构师和设计师，有全局影响，但又不是全职参与。有两种变通的参与方式，一是跟专职人员一样，参加 Scrum 会议，二是在团队中指定他的影子，与他密切协作保证他能及时贡献到团队的目标。</p></li><li><p>  二类浮动人员，如固定在两个团队之间共享的测试人员。</p></li></ul><blockquote><p>减少共享的人数，尽量把测试人员固定在其中一个团队；<br>由有能力多任务的资深人员在两个团队之间浮动领任务，以缓解对其他人员的共享需要；<br>在极端情况下，才让（1）中的人员也在两个团队之间浮动。</p></blockquote><ul><li><p>  三类浮动人员，如在一段时间之内有部分时间花在该 Scrum 团队的人员。与一类浮动人员相比，这类人员的全局影响相对小，更多是因为技能或资源问题而导致的安排。其变通的参与方式与一类浮动人员类似。</p></li><li><p>  四类浮动人员，如尚不能独立工作的新员工。变通的方法是由其导师协助领取任务。</p></li></ul><h3 id="团队之要"><a href="#团队之要" class="headerlink" title="团队之要"></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#%E5%9B%A2%E9%98%9F%E4%B9%8B%E8%A6%81" title="团队之要"></a>团队之要</h3><ul><li>  在 Scrum Master 的引导和辅导下理解 Scrum 框架，特别是从事情角度的严密的 PDCA 循环，和从人的角度的紧密合作。</li><li>  以严密的纪律性使 Scrum 能良好运转，达成业务上的目标，并收获高效快乐的团队。</li><li>  在纪律的支撑之下，技术上精益求精，更好地发挥创造性，包括在技术领域，并适当参与产品探索领域。</li></ul><h3 id="Team-在-Scrum-中的活动"><a href="#Team-在-Scrum-中的活动" class="headerlink" title="Team 在 Scrum 中的活动"></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#Team-%E5%9C%A8-Scrum-%E4%B8%AD%E7%9A%84%E6%B4%BB%E5%8A%A8" title="Team 在 Scrum 中的活动"></a>Team 在 Scrum 中的活动</h3><ul><li>  梳理</li><li>  计划</li><li>  执行</li><li>  每日检查和适应</li><li>  迭代检查和适应（评审与回顾）</li></ul><h3 id="Team-特征"><a href="#Team-特征" class="headerlink" title="Team 特征"></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#Team-%E7%89%B9%E5%BE%81" title="Team 特征"></a>Team 特征</h3><ul><li>  自组织：自组织不能来自命令与控制，而是简单规则支持下的群游。</li><li>  跨职能团队：多样性，跨职能，不同背景，不同的思考角度，造就更好的产出，更快更好的解决方案、更棒的创新。</li><li>  一专多能</li><li>  火枪手精神（互助）</li><li>  宽带宽沟通（沟通带宽递减：面对面 &gt; 电话 &gt; 即时消息 &gt; 邮件）</li><li>  透明</li><li>  团队大小5~9人</li><li>  专注与承诺</li><li>  可持续步伐</li><li>  长期稳定的团队</li></ul><h2 id="3个物件-1"><a href="#3个物件-1" class="headerlink" title="3个物件"></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#3%E4%B8%AA%E7%89%A9%E4%BB%B6-1" title="3个物件"></a>3个物件</h2><p><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/3%E4%B8%AA%E7%89%A9%E4%BB%B6.jpg"><img src="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/3%E4%B8%AA%E7%89%A9%E4%BB%B6.jpg"></a></p><h3 id="产品列表（Product-Backlog）"><a href="#产品列表（Product-Backlog）" class="headerlink" title="产品列表（Product Backlog）"></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#%E4%BA%A7%E5%93%81%E5%88%97%E8%A1%A8%EF%BC%88Product-Backlog%EF%BC%89" title="产品列表（Product Backlog）"></a>产品列表（Product Backlog）</h3><p>产品列表（Product Backlog）是产品列表项（Product Backlog Item，简称PBI）的列表。PBI 包括特性、故障、技术工作和知识学习。</p><p>好的产品列表要满足 DEEP 原则：</p><ul><li>  Detailed Appropriately 细节得当。越是马上要做的 PBI，越是要有足够的细节。很久以后才做的，可以粗略一点。</li><li>  Emergent 涌现式的。PBI 可以根据实际情况随时插入。</li><li>  Estimated 有估算的。同样是近期要做的 PBI，估算要较精细，可以采用费波纳契序列的故事点估算，即1，2，3，5，8 …对于远期要做的 PBI，估算可以粗略，可以采用粗略的T恤尺寸估算，即 XS，S，M，L，XL 等。</li><li>  Prioritized 排好优先级的。近期要发布版本中的 PBI 的优先级要明确排列，中期的可粗略排列，远期的可不必排列。</li></ul><h3 id="迭代列表"><a href="#迭代列表" class="headerlink" title="迭代列表"></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#%E8%BF%AD%E4%BB%A3%E5%88%97%E8%A1%A8" title="迭代列表"></a>迭代列表</h3><p>迭代列表由从产品列表中选出当前迭代要完成的 PBI，及由 PBI 分解产生的任务构成。对于任务的估算，可以采用天或小时估算，也可以不估算。采用哪种方式，以团队能够做出靠谱的迭代承诺，以及在迭代工作的每一天方便监测趋势为标准。</p><h3 id="产品增量"><a href="#产品增量" class="headerlink" title="产品增量"></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#%E4%BA%A7%E5%93%81%E5%A2%9E%E9%87%8F" title="产品增量"></a>产品增量</h3><p>产品增量是一个迭代结束时，输出的用户可用的新功能。产品增量要达到潜在可交付状态，即如果用户需要，可以快速部署给用户使用。</p><h2 id="5个价值观-1"><a href="#5个价值观-1" class="headerlink" title="5个价值观"></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#5%E4%B8%AA%E4%BB%B7%E5%80%BC%E8%A7%82-1" title="5个价值观"></a>5个价值观</h2><p><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/5%E4%B8%AA%E4%BB%B7%E5%80%BC%E8%A7%82.jpg"><img src="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/5%E4%B8%AA%E4%BB%B7%E5%80%BC%E8%A7%82.jpg"></a></p><p>5个价值观的落实与否，是 Scrum 团队形成的重要标志。</p><p>对于5个价值观的运用，可以由团队一起讨论，每个价值观分别意味着什么，并进而把价值观转化为可执行的团队规范。利用迭代回顾会议，审视团队规范的执行情况。</p><h2 id="5个会议-1"><a href="#5个会议-1" class="headerlink" title="5个会议"></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#5%E4%B8%AA%E4%BC%9A%E8%AE%AE-1" title="5个会议"></a>5个会议</h2><p><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/5%E4%B8%AA%E4%BC%9A%E8%AE%AE.jpg"><img src="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/5%E4%B8%AA%E4%BC%9A%E8%AE%AE.jpg"></a></p><h3 id="产品列表精化会"><a href="#产品列表精化会" class="headerlink" title="产品列表精化会"></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#%E4%BA%A7%E5%93%81%E5%88%97%E8%A1%A8%E7%B2%BE%E5%8C%96%E4%BC%9A" title="产品列表精化会"></a>产品列表精化会</h3><h4 id="目的：准备好。"><a href="#目的：准备好。" class="headerlink" title="目的：准备好。"></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#%E7%9B%AE%E7%9A%84%EF%BC%9A%E5%87%86%E5%A4%87%E5%A5%BD%E3%80%82" title="目的：准备好。"></a>目的：准备好。</h4><p>准备好的意思是，经过精化，PBI 达到可估算可计划和可执行的状态。开发人员可以对之进行开发工作了。</p><h4 id="流程："><a href="#流程：" class="headerlink" title="流程："></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#%E6%B5%81%E7%A8%8B%EF%BC%9A" title="流程："></a>流程：</h4><p>主要是围绕 DEEP 标准</p><p>细节得当。产品负责人讲解每个 PBI，达到团队成员理解需求的程度。<br>涌现式。在精化的过程中，根据产品负责人与团队的互动，可能会产生新的 PBI。<br>估算。在产品负责人讲完每个 PBI 时，团队可以用估算纸牌进行估算。通过纸牌对话，也可以保证每位团队成员都理解了需求。<br>优先级。优先级主要由产品负责人排列，但团队的估算和实现的难易程度，也会影响产品负责人重新考虑优先级的排列。</p><h4 id="辅助物件："><a href="#辅助物件：" class="headerlink" title="辅助物件："></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#%E8%BE%85%E5%8A%A9%E7%89%A9%E4%BB%B6%EF%BC%9A" title="辅助物件："></a>辅助物件：</h4><p>为了保证产品列表精化达到准备好的标准，可以制定一个叫做准备好的定义（Definition of Ready，简称DoR）的检查列表。DoR 列表示例如下：</p><ul><li>  业务价值清晰。</li><li>  团队了解需求细节，能够做出是否能完成的决定。</li><li>  依赖被清楚地识别和管理，没有妨碍完成 PBI 的依赖。</li><li>  团队具备完成 PBI 的技能。</li><li>  PBI 被估算，并且足够小，能够装到一个迭代里。</li><li>  验收标准清晰和可测试。</li><li>  性能指标清晰和可测试。</li><li>  团队知道在完成后如何演示。</li></ul><h3 id="迭代计划会"><a href="#迭代计划会" class="headerlink" title="迭代计划会"></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#%E8%BF%AD%E4%BB%A3%E8%AE%A1%E5%88%92%E4%BC%9A" title="迭代计划会"></a>迭代计划会</h3><h4 id="目的：在计划会结束时，给出靠谱的迭代承诺。"><a href="#目的：在计划会结束时，给出靠谱的迭代承诺。" class="headerlink" title="目的：在计划会结束时，给出靠谱的迭代承诺。"></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#%E7%9B%AE%E7%9A%84%EF%BC%9A%E5%9C%A8%E8%AE%A1%E5%88%92%E4%BC%9A%E7%BB%93%E6%9D%9F%E6%97%B6%EF%BC%8C%E7%BB%99%E5%87%BA%E9%9D%A0%E8%B0%B1%E7%9A%84%E8%BF%AD%E4%BB%A3%E6%89%BF%E8%AF%BA%E3%80%82" title="目的：在计划会结束时，给出靠谱的迭代承诺。"></a>目的：在计划会结束时，给出靠谱的迭代承诺。</h4><h4 id="流程：-1"><a href="#流程：-1" class="headerlink" title="流程："></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#%E6%B5%81%E7%A8%8B%EF%BC%9A-1" title="流程："></a>流程：</h4><ul><li>  产品负责人建议迭代目标和要完成的 PBI。</li><li>  团队把 PBI 分解成任务。</li><li>  团队决定是在计划会上就把所有任务分配到个人，还是在迭代过程中动态分配。分配的方式是团队成员认领。要不要分配的标准是，团队是否能对迭代计划进行承诺。</li><li>  评估计划的工作量与团队容量是否平衡。</li><li>  从迭代计划中提炼出迭代目标，把 PBI 粘合在一起，把团队团结在一起。</li><li>  团队对迭代目标和计划进行承诺。</li></ul><h4 id="辅助物件：-1"><a href="#辅助物件：-1" class="headerlink" title="辅助物件："></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#%E8%BE%85%E5%8A%A9%E7%89%A9%E4%BB%B6%EF%BC%9A-1" title="辅助物件："></a>辅助物件：</h4><p>为了对完成有统一的标准，需要完成的定义（Definition of Done，简称DoD）检查列表。DoD 检查列表示例如下：</p><ul><li>  设计有评审。</li><li>  代码完成，包括：代码有重构，代码符合标准，有注释，有签入，有评审。</li><li>  用户文档更新。</li><li>  测试完成，包括：单元测试，集成测试，回归测试，平台测试，语言测试等。</li><li>  零已知故障。</li><li>  验收测试完成。</li><li>  部署到生产环境。</li></ul><p>可以用 A1 纸和便利贴辅助计划会议：</p><blockquote><p>Scrum 的两个要点是：人的有效参与，做事的有效轨道。<br>这个计划会的设计，是以有效的轨道辅助人的主动参与。</p><p>贴出一张 A1 大白纸。 左边第一列是故事，由 PO 用同一种颜色的便利贴书写和表达。字要大，用白板笔写，保证不用站得很近也能看清楚。故障，新特性或任何要交付的事情统称故事。<br>故事右边，用另一种颜色的便利贴列出任务。任务是为完成故事所要做的事，由团队书写。可以写上任务的执行人与估算。</p><p>整个会议，一次围绕一个焦点，即当前讨论的故事。以故事为单位流动起来。</p><p>PO 的注意事项：清晰讲述。随着会议的焦点流动，把故事讲得让团队明白。</p><p>SM 的注意事项：适度引导。控制焦点与流动，一个故事充分讨论完并分解成任务，再进行下一个。保持紧凑的节奏和整体时间盒。</p><p>团队注意事项：主动参与。一是对故事不清楚的主动提问，而是主动参与任务分解、估算、认领。</p><p>全部故事讨论完和分解成任务后，统计每人工作量，看工作量与容量是否平衡，个人之间工作是否能置换以达到每个人的工作相对均衡。<br>最后是团队决定是否能对迭代计划和目标承诺。</p></blockquote><h3 id="每日站会"><a href="#每日站会" class="headerlink" title="每日站会"></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#%E6%AF%8F%E6%97%A5%E7%AB%99%E4%BC%9A" title="每日站会"></a>每日站会</h3><h4 id="目的：围绕目标同步进度，掌握对于完成目标的趋势。"><a href="#目的：围绕目标同步进度，掌握对于完成目标的趋势。" class="headerlink" title="目的：围绕目标同步进度，掌握对于完成目标的趋势。"></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#%E7%9B%AE%E7%9A%84%EF%BC%9A%E5%9B%B4%E7%BB%95%E7%9B%AE%E6%A0%87%E5%90%8C%E6%AD%A5%E8%BF%9B%E5%BA%A6%EF%BC%8C%E6%8E%8C%E6%8F%A1%E5%AF%B9%E4%BA%8E%E5%AE%8C%E6%88%90%E7%9B%AE%E6%A0%87%E7%9A%84%E8%B6%8B%E5%8A%BF%E3%80%82" title="目的：围绕目标同步进度，掌握对于完成目标的趋势。"></a>目的：围绕目标同步进度，掌握对于完成目标的趋势。</h4><h4 id="流程：-2"><a href="#流程：-2" class="headerlink" title="流程："></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#%E6%B5%81%E7%A8%8B%EF%BC%9A-2" title="流程："></a>流程：</h4><ul><li>  准时开始。每天固定时间和地点。</li><li>  每人回答三个问题：为了帮助团队达到迭代目标，昨天完成了什么，今天打算完成什么，遇到了什么障碍。</li><li>  总结趋势和风险。</li><li>  15分钟之内结束。</li></ul><p>站会中细颗粒度的协作：</p><ul><li>  利用站会，促进细颗粒度协作。</li><li>  故事和任务拉动按优先级进行。</li><li>  需要协作的任务，其所有者勇于发起协作请求。</li><li>  被请求者以协作的任务先于本人可独立承担的任务进行。</li><li>  在回顾会议中明确讨论该模式，并贯彻。</li><li>  模式可以由任何一人发现。</li></ul><p>关于站会中的发散讨论：</p><ul><li>  站会中发散讨论的度以全部团队成员觉得爽为标准。</li><li>  15分钟时间盒不必严格遵守。</li><li>  Scrum Master 需要对站会之后团队成员的日程有了解，以便判断站会延长一点是否产生影响。</li><li>  Scrum Master 可以观察对于发散讨论是否全部或大部分团队成员沉浸其中，如果是，暂不打断。</li><li>  如果出现较多分神现象，打断讨论，并提议会后安排讨论。</li><li>  或者根据站会的剩余时间，询问团队，这种发散的讨论是否会影响团队成员的后续日程。</li><li>  按以上原则，打断可以由任何一人提出。</li><li>  在回顾会议明确探讨这种情景中的模式。</li></ul><h3 id="迭代评审会"><a href="#迭代评审会" class="headerlink" title="迭代评审会"></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#%E8%BF%AD%E4%BB%A3%E8%AF%84%E5%AE%A1%E4%BC%9A" title="迭代评审会"></a>迭代评审会</h3><h4 id="目的：了解过去一个迭代完成了什么，并对下一步做出预测。"><a href="#目的：了解过去一个迭代完成了什么，并对下一步做出预测。" class="headerlink" title="目的：了解过去一个迭代完成了什么，并对下一步做出预测。"></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#%E7%9B%AE%E7%9A%84%EF%BC%9A%E4%BA%86%E8%A7%A3%E8%BF%87%E5%8E%BB%E4%B8%80%E4%B8%AA%E8%BF%AD%E4%BB%A3%E5%AE%8C%E6%88%90%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%8C%E5%B9%B6%E5%AF%B9%E4%B8%8B%E4%B8%80%E6%AD%A5%E5%81%9A%E5%87%BA%E9%A2%84%E6%B5%8B%E3%80%82" title="目的：了解过去一个迭代完成了什么，并对下一步做出预测。"></a>目的：了解过去一个迭代完成了什么，并对下一步做出预测。</h4><h4 id="流程：-3"><a href="#流程：-3" class="headerlink" title="流程："></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#%E6%B5%81%E7%A8%8B%EF%BC%9A-3" title="流程："></a>流程：</h4><ul><li>  产品负责人邀请客户和干系人参与。</li><li>  团队总结过去一个迭代的成就和克服的挑战。</li><li>  团队演示完成的产品，获得反馈。</li><li>  产品负责人分享来自用户和市场的信息，预测调整发布计划，预测下一迭代的内容。</li></ul><h3 id="迭代回顾会"><a href="#迭代回顾会" class="headerlink" title="迭代回顾会"></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#%E8%BF%AD%E4%BB%A3%E5%9B%9E%E9%A1%BE%E4%BC%9A" title="迭代回顾会"></a>迭代回顾会</h3><h4 id="目的：团队建设，发掘和计划改善。"><a href="#目的：团队建设，发掘和计划改善。" class="headerlink" title="目的：团队建设，发掘和计划改善。"></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#%E7%9B%AE%E7%9A%84%EF%BC%9A%E5%9B%A2%E9%98%9F%E5%BB%BA%E8%AE%BE%EF%BC%8C%E5%8F%91%E6%8E%98%E5%92%8C%E8%AE%A1%E5%88%92%E6%94%B9%E5%96%84%E3%80%82" title="目的：团队建设，发掘和计划改善。"></a>目的：团队建设，发掘和计划改善。</h4><h4 id="流程：-4"><a href="#流程：-4" class="headerlink" title="流程："></a><a href="https://www.expectfly.com/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum%20%E7%B2%BE%E8%A6%81/#%E6%B5%81%E7%A8%8B%EF%BC%9A-4" title="流程："></a>流程：</h4><ul><li>  基调：真诚和有效。排除顾虑，真诚表达。提出有效的问题，落实有效的方案。</li><li>  白板上写两个栏目：感谢，改善。</li><li>  每人（包括 PO 和 Scrum Master）用 Post It 写出要感谢的人，每张 Post It 写一个，数量不限。写完贴在白板。</li><li>  每人（包括 PO 和 Scrum Master）用 Post It 写一个最痛的改善点，只写一个就好。写完贴出来。</li><li>  Scrum Master 无需太多发言，只需起一个指针的作用。先从感谢的纸条开始，一张一张拿出来问是谁写的，写的人面向要感谢的人表达感谢，不能太空洞，要谈一下感谢的内容。</li><li>  然后转向改善栏目，Scrum Master 同样不要多说话，一张一张拿起纸条，让写的人讲，其他人可以参与讨论，这个环节焦点放在问题澄清，而不是解决方案，Scrum Master 对这一点要有一定把控。</li><li>  每张纸条讲完后，所有人当场举手或竖大拇指，表达的是认为这个问题是否要尽快即在下一迭代解决。</li><li>  全部问题澄清后，全体针对要解决的问题，讨论方案。Scrum Master 关注一下讨论的流动情况，既不要太乱，也不要冷场。极端情况下，可以点名让大家逐一发言，但尽量不用这一招。</li><li>  产生的方案，形成改善 Backlog。Scrum Master 要跟踪起来，可以在日常或站会中跟踪落实情况。</li><li>  Scrum Master 要观察团队互动中的交互情况，如果有分歧点，就是改善点。比如说在 Demo 中，PO 对验收标准的理解与团队不一致。这就是需要改善的地方。改善的讨论和进行，可以在日常与相关人员讨论，也可以放到回顾会议。</li></ul><p>除了团队的回顾会议，还可以有一对一的回顾会议：</p><ul><li>  一对一 Retrospective 是对团队 Retrospective 的鼓励和驯化。是为了帮助打磨团队 Retrospective。</li><li>  一对一 Retrospective 是对团队 Retrospective 的补充。即使团队 Retrospective 已经搞得很好了，也还需要一对一 Retrospective。</li><li>  一对一 Retrospective 可以由 Scrum Master 发起，也可以由任何人向任何人发起。</li><li>  一对一 Retrospective 的目的，是加强人与人之间的连接，传递改善的信念，和计划和执行改善。</li><li>  一对一 Retrospective 的边界，是围绕改善的基调，就与团队项目工作相关的事进行讨论。</li><li>  一对一 Retrospective 的框架，可以包含探询交流对象对工作方式的反馈、探询痛点和关注的问题，和以 Scrum 实践和角色要求为基准、以观察到的行为为依据向交流对象提供的反馈。还可以包含不同团队之间的经验传递、桥梁和延展。</li><li>  如果希望痛点和问题的探询更封闭一点，可以分解为几个角度：就团队项目工作的上下文而言，您的目标和期望的理想状态是什么？与现状的差距是什么？流程上有什么问题，或有什么妨碍理想状态的达到？团队合作方面呢？团队工作绩效和质量呢？任何其他方面？</li><li>  这个框架的运用要灵活。人的主动参与重于规则。如果人能主动参与改善事项的发掘、计划和行动，框架就可以放下。</li><li>  Scrum Master 日常有力的观察是 Retrospective 的重要输入。</li><li>  各个角色的普适标准：专业、尊重、坚持。</li><li>  改变的第一原则：一切改变基于自愿。改善的用意是改善系统，不是改变个人。</li></ul><p>最后用十论 Scrum 就是知行合一对 Scrum 作个小结：</p><ul><li>  人人知行合一：人人计划，人人行动。</li><li>  时时知行合一：时时计划，时时行动。</li><li>  团队知行合一：团队决定，团队行动。</li><li>  敏捷知行合一：快速决定，快速行动。</li><li>  需求知行合一：接近客户，掌握需求。</li><li>  支柱知行合一：检验是知，适应是行。</li><li>  完成知行合一：定义完成，共识目标。</li><li>  透明知行合一：高度透明，流畅过程。</li><li>  纪律知行合一：自我纪律，助长能力。</li><li>  美德知行合一：积极主动，集思广益。</li></ul></blockquote><p> 本文作者： <a href="mailto:&#106;&#111;&#x6e;&#105;&#x40;&#x65;&#102;&#98;&#x69;&#122;&#x2e;&#111;&#114;&#103;">&#106;&#111;&#x6e;&#105;&#x40;&#x65;&#102;&#98;&#x69;&#122;&#x2e;&#111;&#114;&#103;</a><br>本文链接： <a href="https://github.com/efbiz/2018/06/03/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87Scrum">https://github.com/efbiz/2018/06/03/敏捷教练第02课-储备Scrum</a> 精要/ </p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;介绍 Scrum 的书虽然还没有达到汗牛充栋的程度，但已经是著作等身了——所有著作加起来能够等同于一个人的身高了。本文并不是对 Scrum 理论的简单重复，而是立意能做到两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;  涵盖 Scrum 中所有重要的概念。&lt;/</summary>
      
    
    
    
    <category term="Scrum" scheme="http://zhangyu.info/categories/Scrum/"/>
    
    
    <category term="Scrum" scheme="http://zhangyu.info/tags/Scrum/"/>
    
  </entry>
  
  <entry>
    <title>敏捷教练第03课-储备-用户故事精要</title>
    <link href="http://zhangyu.info/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/"/>
    <id>http://zhangyu.info/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/</id>
    <published>2022-04-11T16:00:00.000Z</published>
    <updated>2022-04-12T01:56:56.764Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本节课程我们主要解决三个问题：为什么要有用户故事？用户故事是什么，它们具有哪些属性、内涵和特征？在产品开发的全流程中怎么使用用户故事？  </p><h1 id="理解用户故事"><a href="#理解用户故事" class="headerlink" title="理解用户故事"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/#%E7%90%86%E8%A7%A3%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B" title="理解用户故事"></a>理解用户故事</h1><p><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/%E7%90%86%E8%A7%A3%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B.jpg"><img src="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/%E7%90%86%E8%A7%A3%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B.jpg"></a><br>理解用户故事，从两个问题开始。</p><p>用户想要达到的目标是什么？</p><ul><li>  达到这个目标的成本是多少？</li><li>  为了回答这两个问题，我们需要把大目标分解为小目标，排优先级和估算。</li></ul><p>用户故事是这个过程中使用的基本单元载体。比用户故事大或者模糊的可以叫做史诗，主题或者只是一个产品点子。</p><p>关于上面两个根本问题，“@左耳朵”有很好的描述：</p><blockquote><p>亚马逊里挑战产品和运营的方法论是 T-shirt Size Estimation。就是用 T 恤的尺寸来做评估。你要做这个东西可以，但是产品和运营必须得拿出证据说明你要做的这个东西是什么样尺寸的。</p><p>比如说 XXL 可以带来一百万人民币或一百万用户受益，XL 就是 50 万，L 是 25 万，这样砍下去，然后这些需求给到技术团队，这边技术团队也会做个评估。XXL 是要六个月做完，XL 是三个月，L 是一个月，M 是两周，S 是一周。这样两边一对。如果说业务影响力比较高，而且技术实施比较轻，这就是小而美，那就是最高优先级；如果是反过来，技术这边要花好大的力气，业务影响力又不是特别高，那就坚定不移地把它砍掉；如果两个都是中等，那就是自由行事；如果两个都是 XXL 的话，那能不能需求这边降低一个维度。比如将 XXL 降到 XL，我这边可以降好几个档次，两三个星期就可以实现出来，这样可能会是一个比较好的方式。</p></blockquote><h2 id="产品愿景是用户故事的统摄"><a href="#产品愿景是用户故事的统摄" class="headerlink" title="产品愿景是用户故事的统摄"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/#%E4%BA%A7%E5%93%81%E6%84%BF%E6%99%AF%E6%98%AF%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%9A%84%E7%BB%9F%E6%91%84" title="产品愿景是用户故事的统摄"></a>产品愿景是用户故事的统摄</h2><p><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/%E4%BB%B7%E5%80%BC%E5%8F%91%E7%8E%B0.jpg"><img src="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/%E4%BB%B7%E5%80%BC%E5%8F%91%E7%8E%B0.jpg"></a><br>产品愿景要回答三个问题：</p><ul><li>  Who：它的用户是谁？</li><li>  What：它是什么？一是要有清晰的画面感，二是与已有产品不同。</li><li>  Why：它意味着什么？有什么价值和目的？</li></ul><p>两个产品愿景的例子：</p><ul><li>  我们要在10年的时间里，把一个人送到月亮上，还要让他回来。</li><li>  把1000首歌装在口袋里。</li></ul><p>产品愿景可以从最初的一个点子开始，慢慢打磨成熟。而在产品愿景打磨的过程中，把大而模糊的点子敲碎成清晰而可执行的小块，就是用户故事。产品愿景与用户故事同生同长，用户故事全部做完了，产品愿景就实现了。</p><h2 id="用户建模，是用户故事的起点"><a href="#用户建模，是用户故事的起点" class="headerlink" title="用户建模，是用户故事的起点"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/#%E7%94%A8%E6%88%B7%E5%BB%BA%E6%A8%A1%EF%BC%8C%E6%98%AF%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%9A%84%E8%B5%B7%E7%82%B9" title="用户建模，是用户故事的起点"></a>用户建模，是用户故事的起点</h2><p>用户建模可以考虑用户的两点：</p><ul><li>  Pain 痛点：用户在产品目标领域目前有什么痛点？</li><li>  Gain 收益点：我们的产品能给用户带来什么收益？</li></ul><p>用户角色建模，要以用户为中心。建模的 BSCR 步骤：</p><ul><li>  Brainstorm：产品探索团队头脑风暴出用户角色。</li><li>  Sort：对头脑风暴出的用户角色快速分组和识别层级。</li><li>  Consolidate：对每一角色逐一讨论，整合角色。</li><li>  Refine：提炼角色。识别用户角色的：</li></ul><p>用户角色分组可以考虑用户的：</p><ul><li>  使用频次</li><li>  领域知识</li><li>  IT 知识</li><li>  使用目标</li></ul><p>用户建模的其他技术：</p><ul><li>  典型用户画像。针对一种角色，虚构出一个人物，描述他的行为特征，使用场景，核心诉求。还可以给出画像。打印出来放在团队可见的地方，让团队在开发产品时对用户的需求能感同身受。</li><li>  极端用户。想象一个极端用户会有什么诉求，以产生新的灵感。这方面不用太用力。</li></ul><h2 id="用户故事"><a href="#用户故事" class="headerlink" title="用户故事"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/#%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B" title="用户故事"></a>用户故事</h2><p><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B.jpg"><img src="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B.jpg"></a></p><h3 id="用户故事是从用户的角度描述功能。"><a href="#用户故事是从用户的角度描述功能。" class="headerlink" title="用户故事是从用户的角度描述功能。"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/#%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E6%98%AF%E4%BB%8E%E7%94%A8%E6%88%B7%E7%9A%84%E8%A7%92%E5%BA%A6%E6%8F%8F%E8%BF%B0%E5%8A%9F%E8%83%BD%E3%80%82" title="用户故事是从用户的角度描述功能。"></a>用户故事是从用户的角度描述功能。</h3><p>用户故事的 WWW 及格式</p><ul><li>  Who：谁要使用这个功能？</li><li>  What：需要完成什么样的功能？</li><li>  Why：这个功能带来的价值是什么？</li></ul><p>用户故事的格式</p><ul><li>  英文：As &lt; a user &gt; ，I want &lt; to do something &gt;， so that &lt; I can achieve some purpose &gt;.</li><li>  中文：作为 &lt; 一个用户 &gt;，我想要 &lt; 做什么 &gt;，以便 &lt; 达成什么目的 &gt;。</li></ul><p>例子：</p><p>作为一个求职者，我想要发布简历，以便用人单位找到我。</p><p>现存世界上第一张用户故事卡，from @张克强。</p><h3 id="用户故事的-AC（Acceptance-Criteria）验收标准"><a href="#用户故事的-AC（Acceptance-Criteria）验收标准" class="headerlink" title="用户故事的 AC（Acceptance Criteria）验收标准"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/#%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%9A%84-AC%EF%BC%88Acceptance-Criteria%EF%BC%89%E9%AA%8C%E6%94%B6%E6%A0%87%E5%87%86" title="用户故事的 AC（Acceptance Criteria）验收标准"></a>用户故事的 AC（Acceptance Criteria）验收标准</h3><ul><li>  验收标准也是迭代结束时 Demo 的标准</li><li>  更多代表外部质量</li><li>  简洁与完备之间平衡</li><li>  包含成功路径和失败路径</li></ul><p>对前述故事的验收标准例子：</p><ul><li>  我想要发布 Word 简历</li><li>  我想要发布 PDF 简历</li><li>  发前能预览</li><li>  发后能检查</li><li>  可以设置公开或私密状态</li><li>  失败有原因提示</li></ul><h3 id="搜集故事的方式"><a href="#搜集故事的方式" class="headerlink" title="搜集故事的方式"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/#%E6%90%9C%E9%9B%86%E6%95%85%E4%BA%8B%E7%9A%84%E6%96%B9%E5%BC%8F" title="搜集故事的方式"></a>搜集故事的方式</h3><ul><li>  用户访谈：不设定立场，问开放式问题和背景无关问题。</li><li>  问卷调查：问卷可简单直接，比如了解用户使用软件功能的频率。</li><li>  直接观察用户如何使用产品。</li><li>  产品探索团队使用故事编写工作坊，头脑风暴，输出简单原型和用户故事。</li></ul><h3 id="用户故事的一些重要特征"><a href="#用户故事的一些重要特征" class="headerlink" title="用户故事的一些重要特征"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/#%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%89%B9%E5%BE%81" title="用户故事的一些重要特征"></a>用户故事的一些重要特征</h3><ul><li>  一目了然格式一致的表达。</li><li>  用户故事有两个部分：描述部分和验收标准。描述部分的常用格式是：As &lt;用户&gt;，I want &lt;功能&gt;，so that &lt;目的&gt;。验收标准可以有多条，常用的格式是：Given &lt;前提条件&gt;，When &lt;动作&gt;，Then &lt;结果&gt;。</li><li>鼓励推迟细节，只需有足够的信息以使项目前行。<br>  我们不需要一次性把项目的所有需求搞清楚，我们只需要在迭代之前把一个迭代要做的事搞清楚即可，而以用户故事作为基本单元，可以支持这种开发模式。</li><li>  用户故事以合适的颗粒度，方便理解，方便排优先级，保证重要的事先做。随着时间的推移，不重要的事也许就不需要了。</li><li>  用户故事鼓励通过交谈了解细节。强调对话而不是书面沟通。</li><li>  用户故事的验收标准保证成果可以被审核验证。</li><li>  以用户故事为载体，促进结构化沟通，使谈话有落地点。</li><li>  从业务角度描述，可以同时被业务人员和开发人员理解。</li><li>  用户故事的大小适合估算和做计划。颗粒度适合迭代开发。</li><li>  支持随机应变的开发，检视和适应。</li><li>  鼓励各方参与交流，传播隐性知识。</li></ul><h3 id="用户故事的-3C，鼓励通过交谈了解细节"><a href="#用户故事的-3C，鼓励通过交谈了解细节" class="headerlink" title="用户故事的 3C，鼓励通过交谈了解细节"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/#%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%9A%84-3C%EF%BC%8C%E9%BC%93%E5%8A%B1%E9%80%9A%E8%BF%87%E4%BA%A4%E8%B0%88%E4%BA%86%E8%A7%A3%E7%BB%86%E8%8A%82" title="用户故事的 3C，鼓励通过交谈了解细节"></a>用户故事的 3C，鼓励通过交谈了解细节</h3><ul><li><p>  Card 卡片：用户故事通常写在卡片上，描述用户想要达到的目标，突出对用户有价值。</p></li><li><p>  Conversation 对话：书面文档是一种低带宽沟通，表达信息的能力受限，接受信息的体验受限，信息传递能力受限。面对面交流是高宽带沟通，利用检验，适应和反馈促进沟通的有效性。用户故事模式鼓励对话。无形的对话为有形的卡片补充细节。</p></li><li><p>  Confirmation 验收标准：无形的对话再次落实到有形的验收标准，并成为故事的一部分。</p></li></ul><h3 id="排优先级要考虑的要素"><a href="#排优先级要考虑的要素" class="headerlink" title="排优先级要考虑的要素"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/#%E6%8E%92%E4%BC%98%E5%85%88%E7%BA%A7%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E8%A6%81%E7%B4%A0" title="排优先级要考虑的要素"></a>排优先级要考虑的要素</h3><ul><li>  大部分用户对该功能的渴望程度。</li><li>  少部分重要用户对该功能的渴望程度。</li><li>  故事之间的关系，是否有开发的先后顺序。</li><li>  技术实现的难度。</li><li>  成本高低。</li></ul><h3 id="关于优先级的两个模型"><a href="#关于优先级的两个模型" class="headerlink" title="关于优先级的两个模型"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/#%E5%85%B3%E4%BA%8E%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%A8%A1%E5%9E%8B" title="关于优先级的两个模型"></a>关于优先级的两个模型</h3><ul><li><p>  MoSCoW 莫斯科定律：Must have 必须有；Should have 要有；Could have 可以有；Woudn’t have 不会有。</p></li><li><p>  Kano 模型：没有不行的功能，线性功能，尖叫功能。</p></li></ul><h3 id="用户故事的-INVEST-准则"><a href="#用户故事的-INVEST-准则" class="headerlink" title="用户故事的 INVEST 准则"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/#%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%9A%84-INVEST-%E5%87%86%E5%88%99" title="用户故事的 INVEST 准则"></a>用户故事的 INVEST 准则</h3><ul><li><p>  Independent：用户故事之间是独立的。如果不独立，可能是划分的方法有问题，可重新划分。</p></li><li><p>  Negotiable：用户故事是可讨论的。使用卡片是为了提醒对话。讨论的细节会变成测试。</p></li><li><p>  Valuable：用户故事对用户有价值。有条件的话，让用户写或确认用户故事。</p></li><li><p>  Estimatable：用户故事是可估算的。不可估算的原因可能是：缺乏领域知识（多与客户讨论，学习对方的语言，了解对方的想法，事实往往比想象的简单），缺乏技术知识（可以把故事分为两部分：探针实验 spike，和实际开发），故事太大(分拆)。</p></li><li><p>  Size appropriately：大小适中。故事的合适大小取决于团队，容量和使用的技术。</p></li></ul><p>需要分割的故事，可能是复合故事（按 CRUD 分拆），或复杂故事（可以分探针实验 spike 和实际开发两个故事，与其他故事一起排排优先级，然后在不同的迭代完成探针实验 spike 和实际开发）。需要合并的故事，包括若干小 bug，或小改动。</p><ul><li>  Testable：用户故事是可测试的。故事的描述需使用具体的量化的描述，而不是绝对的含糊的描述。</li></ul><p>其中有价值和可估算是第一级标准，对应着本文开始时提到的产品开发所要回答的两个根本问题。另外四个标准更多是为了方便迭代开发。</p><h3 id="用户故事的一些其他原则"><a href="#用户故事的一些其他原则" class="headerlink" title="用户故事的一些其他原则"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/#%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E5%8E%9F%E5%88%99" title="用户故事的一些其他原则"></a>用户故事的一些其他原则</h3><ul><li>  从目标开始，大目标分解成小目标。</li><li>  切蛋糕式划分故事，竖切而不是横切。</li><li>  故事的描述要封闭，有完成感。故事针对一个场景，一个画面，一次完整的动作。</li><li>  约束也可以作为一个故事。</li><li>  故事的冰山法则：近期要开发的要划分的细而清晰，远期开发的可粗而模糊。</li><li>  文档也可以作为故事。</li><li>  故事中要包含用户角色，一个故事只包含一种用户。</li><li>  为了表述简单，故事使用主动语态。</li><li>  有可能的话，让用户编写故事。</li><li>  故事不用编号。可提炼出作为标识的关键词以方便讨论时引用。</li><li>  一定不要忘记故事的意图。</li><li>  避免镀金，开发不需要的功能。团队公开透明的工作方式可以帮助这一点。</li><li>  非功能需求可以作为故事。</li><li>  缺陷可以作为故事。</li></ul><h3 id="故事分级"><a href="#故事分级" class="headerlink" title="故事分级"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/#%E6%95%85%E4%BA%8B%E5%88%86%E7%BA%A7" title="故事分级"></a>故事分级</h3><p><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E5%88%86%E7%BA%A7%E5%8F%8A%E4%BC%B0%E7%AE%97.jpg"><img src="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E5%88%86%E7%BA%A7%E5%8F%8A%E4%BC%B0%E7%AE%97.jpg"></a></p><ul><li>  Epic 史诗：一个很大的故事。</li><li>  Theme 主题：安放一组类似故事的篮子。</li><li>  Story 故事：业务角度。</li><li>  Task 任务：技术角度，一个故事可分解为多个任务。</li></ul><h3 id="用户故事分解"><a href="#用户故事分解" class="headerlink" title="用户故事分解"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/#%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E5%88%86%E8%A7%A3" title="用户故事分解"></a>用户故事分解</h3><p>大故事拆成小故事，9种不同切分方法。</p><ul><li><p>按工作流程步骤切分<br>  是否可以先完成工作流程的头尾部分，再添加中间步骤去完善该故事呢？</p></li><li><p>按操作切分<br>  是否可以把不同操作切分成独立的故事呢？（比如是有关“管理”或“配置”某物）</p></li><li><p>按不同业务规则切分<br>  是否可以先完成业务规则的一个子集，后续再添加其他规则呢？（比如故事中有没有范围型词语像是“灵活的日期”来暗示着多种变化呢？）</p></li><li><p>按不同类型数据切分<br>  是否可以先处理一种类型的数据，后续再处理其他类型的数据呢？</p></li><li><p>按实现先后依赖切分<br>  该故事的实现背后是否依赖另一个流程的数据输入？</p></li><li><p>按照体验质量切分<br>  是否可以先完成一个低体验质量的故事，然后再提高体验水平？</p></li><li><p>按不同界面切分<br>  是否能先简化复杂界面，先完成一个简单版本？如果多个界面获取相同类型数据，是否可以先从一个界面处理数据，后续再增添其他界面呢？</p></li><li><p>按简单/复杂切分<br>  如果简单的核心就能提供大部分价值，是否可以先完成简单核心，再通过后续的故事来扩充它呢？</p></li><li><p>延迟性能优化<br>  是否可以先使其工作，后续再满足非功能性需求呢？（当复杂主要来自非功能性需求时）</p></li></ul><h3 id="绝对估算与相对估算"><a href="#绝对估算与相对估算" class="headerlink" title="绝对估算与相对估算"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/#%E7%BB%9D%E5%AF%B9%E4%BC%B0%E7%AE%97%E4%B8%8E%E7%9B%B8%E5%AF%B9%E4%BC%B0%E7%AE%97" title="绝对估算与相对估算"></a>绝对估算与相对估算</h3><p>绝对估算：按天或小时。</p><p>相对估算：</p><ul><li>  按倍增数列：1，2，4，8，16，32，64</li><li>  按斐波那契数列：1，2，3，5，8，13，20，40，100</li><li>  按T恤衫尺寸：XS，S，M，L，XL</li></ul><h3 id="估算纸牌"><a href="#估算纸牌" class="headerlink" title="估算纸牌"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/#%E4%BC%B0%E7%AE%97%E7%BA%B8%E7%89%8C" title="估算纸牌"></a>估算纸牌</h3><ul><li>  产品负责人讲一个故事</li><li>  团队提问澄清</li><li>  团队成员独立出牌估算，互不干扰，喊统一翻牌时才翻牌</li><li>  出到最小点数和最大点数的人讲讲话</li><li>  其他人可参与对话</li><li>  第二轮出牌</li><li>  对同一个故事不超过三轮出牌</li></ul><h2 id="客户参与、产品探索和产品交付的全流程"><a href="#客户参与、产品探索和产品交付的全流程" class="headerlink" title="客户参与、产品探索和产品交付的全流程"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/#%E5%AE%A2%E6%88%B7%E5%8F%82%E4%B8%8E%E3%80%81%E4%BA%A7%E5%93%81%E6%8E%A2%E7%B4%A2%E5%92%8C%E4%BA%A7%E5%93%81%E4%BA%A4%E4%BB%98%E7%9A%84%E5%85%A8%E6%B5%81%E7%A8%8B" title="客户参与、产品探索和产品交付的全流程"></a>客户参与、产品探索和产品交付的全流程</h2><p><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/%E4%BA%A7%E5%93%81%E4%BA%A4%E4%BB%98%E6%B5%81%E7%A8%8B.jpg"><img src="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/%E4%BA%A7%E5%93%81%E4%BA%A4%E4%BB%98%E6%B5%81%E7%A8%8B.jpg"></a></p><h3 id="第一，产品负责人收集需求。利用前文讲到的客户团队和需求收集方法。需求来自客户和干系人，也来自产品负责人的思考。需求以业务角度为主，也考虑技术角度。需产品负责人与技术领域的架构师等密切协作完成需求的梳理。"><a href="#第一，产品负责人收集需求。利用前文讲到的客户团队和需求收集方法。需求来自客户和干系人，也来自产品负责人的思考。需求以业务角度为主，也考虑技术角度。需产品负责人与技术领域的架构师等密切协作完成需求的梳理。" class="headerlink" title="第一，产品负责人收集需求。利用前文讲到的客户团队和需求收集方法。需求来自客户和干系人，也来自产品负责人的思考。需求以业务角度为主，也考虑技术角度。需产品负责人与技术领域的架构师等密切协作完成需求的梳理。"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/#%E7%AC%AC%E4%B8%80%EF%BC%8C%E4%BA%A7%E5%93%81%E8%B4%9F%E8%B4%A3%E4%BA%BA%E6%94%B6%E9%9B%86%E9%9C%80%E6%B1%82%E3%80%82%E5%88%A9%E7%94%A8%E5%89%8D%E6%96%87%E8%AE%B2%E5%88%B0%E7%9A%84%E5%AE%A2%E6%88%B7%E5%9B%A2%E9%98%9F%E5%92%8C%E9%9C%80%E6%B1%82%E6%94%B6%E9%9B%86%E6%96%B9%E6%B3%95%E3%80%82%E9%9C%80%E6%B1%82%E6%9D%A5%E8%87%AA%E5%AE%A2%E6%88%B7%E5%92%8C%E5%B9%B2%E7%B3%BB%E4%BA%BA%EF%BC%8C%E4%B9%9F%E6%9D%A5%E8%87%AA%E4%BA%A7%E5%93%81%E8%B4%9F%E8%B4%A3%E4%BA%BA%E7%9A%84%E6%80%9D%E8%80%83%E3%80%82%E9%9C%80%E6%B1%82%E4%BB%A5%E4%B8%9A%E5%8A%A1%E8%A7%92%E5%BA%A6%E4%B8%BA%E4%B8%BB%EF%BC%8C%E4%B9%9F%E8%80%83%E8%99%91%E6%8A%80%E6%9C%AF%E8%A7%92%E5%BA%A6%E3%80%82%E9%9C%80%E4%BA%A7%E5%93%81%E8%B4%9F%E8%B4%A3%E4%BA%BA%E4%B8%8E%E6%8A%80%E6%9C%AF%E9%A2%86%E5%9F%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E5%B8%88%E7%AD%89%E5%AF%86%E5%88%87%E5%8D%8F%E4%BD%9C%E5%AE%8C%E6%88%90%E9%9C%80%E6%B1%82%E7%9A%84%E6%A2%B3%E7%90%86%E3%80%82" title="第一，产品负责人收集需求。利用前文讲到的客户团队和需求收集方法。需求来自客户和干系人，也来自产品负责人的思考。需求以业务角度为主，也考虑技术角度。需产品负责人与技术领域的架构师等密切协作完成需求的梳理。"></a>第一，产品负责人收集需求。利用前文讲到的客户团队和需求收集方法。需求来自客户和干系人，也来自产品负责人的思考。需求以业务角度为主，也考虑技术角度。需产品负责人与技术领域的架构师等密切协作完成需求的梳理。</h3><h3 id="第二，产品探索团队利用故事写作研讨会对用户建模，编写用户故事，放入待办列表，排序，估算，制定发布计划。"><a href="#第二，产品探索团队利用故事写作研讨会对用户建模，编写用户故事，放入待办列表，排序，估算，制定发布计划。" class="headerlink" title="第二，产品探索团队利用故事写作研讨会对用户建模，编写用户故事，放入待办列表，排序，估算，制定发布计划。"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/#%E7%AC%AC%E4%BA%8C%EF%BC%8C%E4%BA%A7%E5%93%81%E6%8E%A2%E7%B4%A2%E5%9B%A2%E9%98%9F%E5%88%A9%E7%94%A8%E6%95%85%E4%BA%8B%E5%86%99%E4%BD%9C%E7%A0%94%E8%AE%A8%E4%BC%9A%E5%AF%B9%E7%94%A8%E6%88%B7%E5%BB%BA%E6%A8%A1%EF%BC%8C%E7%BC%96%E5%86%99%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%EF%BC%8C%E6%94%BE%E5%85%A5%E5%BE%85%E5%8A%9E%E5%88%97%E8%A1%A8%EF%BC%8C%E6%8E%92%E5%BA%8F%EF%BC%8C%E4%BC%B0%E7%AE%97%EF%BC%8C%E5%88%B6%E5%AE%9A%E5%8F%91%E5%B8%83%E8%AE%A1%E5%88%92%E3%80%82" title="第二，产品探索团队利用故事写作研讨会对用户建模，编写用户故事，放入待办列表，排序，估算，制定发布计划。"></a>第二，产品探索团队利用故事写作研讨会对用户建模，编写用户故事，放入待办列表，排序，估算，制定发布计划。</h3><p>好的故事估算方法</p><ul><li>  允许团队随着对产品了解的加深随时改变想法。</li><li>  要能适用于史诗和小故事。 估算精度随故事变大而变小。</li><li>  估算快速。</li><li>  能帮助提供进度和剩余工作的有用信息。</li><li>  要能做到不精确也没事。</li><li>  可以用来制定发布计划。</li><li>  团队集体估算。</li><li>  故事估算的单位可采用故事点或者理想天。</li></ul><p>具体的估算方法</p><ul><li>  产品负责人拿起一个故事，进行讲解，团队成员提问澄清。</li><li>  团队成员用斐波那契序列的纸牌出牌估算，出到点数最大和最小的人说明，其他人可参与讨论。独立出牌估算，翻牌前不要把估算讲出来，也不要受他人估算的影响。</li><li>  大多数故事的估算会在一到两轮出牌后收敛。最多也不要超过三轮出牌。</li><li>  还可用冒泡分桶法进行快速估算。把故事按从小到大从左到友排成一排，从冒泡法排到大家都认可为止。然后分组分到不同的桶里。桶的大小排列也是斐波那契序列。</li><li>  每个迭代能完成的故事点数是速率。速率是一个靠谱的指标的依据是：故事的估算值与实际大小的偏差呈正态分布。每个迭代选取的故事的正负偏移可以彼此抵消。因此故事估算的精度不会影响速率指标的可靠性。速率指标可靠的前提是：在项目过程中始终采用一致化的估算方法，迭代之间的故事没有交叉重叠，项目过程中没有发生影响速率的大的异常。</li></ul><p>速率和估算的几个注意事项</p><ul><li>  不要拿速率来比团队。</li><li>  分解后小故事估算的总合不一定等于大故事的估算。</li><li>  任务工时的总和不需要跟故事点成正比。</li><li>  结对编程不影响对故事的估算方法。</li><li>  做到一半的故事不能计入速率。没有完全完成的事情是不靠谱的。鼓励一件流。迭代完成后不要修订速率。</li><li>  发布计划的制定</li><li>  选定迭代长度。</li><li>  预测速率。</li><li>  产品的总故事点除以速率，即得出需要多少个迭代完成。</li></ul><p>速率预测可采用</p><ul><li>  历史值</li><li>  执行一轮看看速率是多少</li><li>  猜测</li></ul><p>可视化发布计划的方法</p><ul><li>  墙</li><li>  电子表格</li><li>  甘特图</li></ul><h3 id="第三，与客户确认发布计划。"><a href="#第三，与客户确认发布计划。" class="headerlink" title="第三，与客户确认发布计划。"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/#%E7%AC%AC%E4%B8%89%EF%BC%8C%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%A1%AE%E8%AE%A4%E5%8F%91%E5%B8%83%E8%AE%A1%E5%88%92%E3%80%82" title="第三，与客户确认发布计划。"></a>第三，与客户确认发布计划。</h3><h3 id="第四，与交付团队梳理故事，达到准备好的状态（DoR-Definition-of-Ready）。故事要有清晰的验收标准，优先级和估算。团队成员有充分的理解。"><a href="#第四，与交付团队梳理故事，达到准备好的状态（DoR-Definition-of-Ready）。故事要有清晰的验收标准，优先级和估算。团队成员有充分的理解。" class="headerlink" title="第四，与交付团队梳理故事，达到准备好的状态（DoR - Definition of Ready）。故事要有清晰的验收标准，优先级和估算。团队成员有充分的理解。"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/#%E7%AC%AC%E5%9B%9B%EF%BC%8C%E4%B8%8E%E4%BA%A4%E4%BB%98%E5%9B%A2%E9%98%9F%E6%A2%B3%E7%90%86%E6%95%85%E4%BA%8B%EF%BC%8C%E8%BE%BE%E5%88%B0%E5%87%86%E5%A4%87%E5%A5%BD%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%88DoR-Definition-of-Ready%EF%BC%89%E3%80%82%E6%95%85%E4%BA%8B%E8%A6%81%E6%9C%89%E6%B8%85%E6%99%B0%E7%9A%84%E9%AA%8C%E6%94%B6%E6%A0%87%E5%87%86%EF%BC%8C%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E4%BC%B0%E7%AE%97%E3%80%82%E5%9B%A2%E9%98%9F%E6%88%90%E5%91%98%E6%9C%89%E5%85%85%E5%88%86%E7%9A%84%E7%90%86%E8%A7%A3%E3%80%82" title="第四，与交付团队梳理故事，达到准备好的状态（DoR - Definition of Ready）。故事要有清晰的验收标准，优先级和估算。团队成员有充分的理解。"></a>第四，与交付团队梳理故事，达到准备好的状态（DoR - Definition of Ready）。故事要有清晰的验收标准，优先级和估算。团队成员有充分的理解。</h3><h3 id="第五，迭代计划，分解任务，生成迭代待办列表。"><a href="#第五，迭代计划，分解任务，生成迭代待办列表。" class="headerlink" title="第五，迭代计划，分解任务，生成迭代待办列表。"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/#%E7%AC%AC%E4%BA%94%EF%BC%8C%E8%BF%AD%E4%BB%A3%E8%AE%A1%E5%88%92%EF%BC%8C%E5%88%86%E8%A7%A3%E4%BB%BB%E5%8A%A1%EF%BC%8C%E7%94%9F%E6%88%90%E8%BF%AD%E4%BB%A3%E5%BE%85%E5%8A%9E%E5%88%97%E8%A1%A8%E3%80%82" title="第五，迭代计划，分解任务，生成迭代待办列表。"></a>第五，迭代计划，分解任务，生成迭代待办列表。</h3><ul><li>  在迭代计划会上</li><li>  选取本迭代要完成的故事。</li><li>  把业务故事分解为技术任务。分解也是做设计。不能技能的人员可以在同一个故事中合作。</li><li>  团队做出承诺。</li></ul><h3 id="第六，每日工作，按故事和任务的优先级执行。"><a href="#第六，每日工作，按故事和任务的优先级执行。" class="headerlink" title="第六，每日工作，按故事和任务的优先级执行。"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/#%E7%AC%AC%E5%85%AD%EF%BC%8C%E6%AF%8F%E6%97%A5%E5%B7%A5%E4%BD%9C%EF%BC%8C%E6%8C%89%E6%95%85%E4%BA%8B%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E6%89%A7%E8%A1%8C%E3%80%82" title="第六，每日工作，按故事和任务的优先级执行。"></a>第六，每日工作，按故事和任务的优先级执行。</h3><ul><li>  测量和监控速率的方法</li><li>  迭代故事点燃尽图。</li><li>  迭代工时燃机图。</li><li>  每迭代计划速率和实际速率趋势图。</li><li>  每迭代计划和实际速率累计图。</li></ul><p>这些图表只是团队监测趋势的工具。团队要在每天的工作中检视和适应以保证能达到完成迭代目标的趋势。</p><h3 id="第七，迭代验收和演示。最好能有客户参与，以获得反馈。"><a href="#第七，迭代验收和演示。最好能有客户参与，以获得反馈。" class="headerlink" title="第七，迭代验收和演示。最好能有客户参与，以获得反馈。"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/#%E7%AC%AC%E4%B8%83%EF%BC%8C%E8%BF%AD%E4%BB%A3%E9%AA%8C%E6%94%B6%E5%92%8C%E6%BC%94%E7%A4%BA%E3%80%82%E6%9C%80%E5%A5%BD%E8%83%BD%E6%9C%89%E5%AE%A2%E6%88%B7%E5%8F%82%E4%B8%8E%EF%BC%8C%E4%BB%A5%E8%8E%B7%E5%BE%97%E5%8F%8D%E9%A6%88%E3%80%82" title="第七，迭代验收和演示。最好能有客户参与，以获得反馈。"></a>第七，迭代验收和演示。最好能有客户参与，以获得反馈。</h3><p>在 Scrum 中，用户故事运转在两条轨道上。一条是产品级别的产品列表精化，既帮助产品的长远规划，也为迭代的开始做好准备。另一条是迭代级别，故事经过精化准备好之后，经由迭代计划会进入迭代，经由每一天的检查与适应，在迭代评审会议上展现为产品增量和可工作的软件，在经过迭代回顾会议探讨下一个迭代如何做得更好。</p></blockquote><p> 本文作者： <a href="mailto:&#x6a;&#111;&#x6e;&#105;&#64;&#101;&#102;&#x62;&#105;&#122;&#x2e;&#111;&#x72;&#x67;">&#x6a;&#111;&#x6e;&#105;&#64;&#101;&#102;&#x62;&#105;&#122;&#x2e;&#111;&#x72;&#x67;</a><br>本文链接： <a href="https://github.com/efbiz/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/">https://github.com/efbiz/2018/05/14/敏捷教练第03课-储备-用户故事精要/</a> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本节课程我们主要解决三个问题：为什么要有用户故事？用户故事是什么，它们具有哪些属性、内涵和特征？在产品开发的全流程中怎么使用用户故事？  &lt;/p&gt;
&lt;h1 id=&quot;理解用户故事&quot;&gt;&lt;a href=&quot;#理解用户故事&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="Scrum" scheme="http://zhangyu.info/categories/Scrum/"/>
    
    
    <category term="Scrum" scheme="http://zhangyu.info/tags/Scrum/"/>
    
  </entry>
  
  <entry>
    <title>敏捷教练第04课-储备-scrum的20个子模式</title>
    <link href="http://zhangyu.info/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-scrum%E7%9A%8420%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zhangyu.info/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-scrum%E7%9A%8420%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-04-11T16:00:00.000Z</published>
    <updated>2022-04-12T02:00:31.712Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>自克里斯托弗亚历山大发明建筑模式，经由设计模式，发展到组织模式。模式是一种经过验证的、经过分类的、可以被反复重用的、场景化、定式化的经验总结。模式思维是理性和感性思维的中和，是人固有的一种能力。模式的好处是省力。敏捷管理，也存在一些这样的模式。<br>本文介绍的模式可分为三大类。第一类是 Scrum 本身存在的模式，第二类是在 Scrum 活动中探索出来的模式，第三类是 Scrum 反模式。  </p><h1 id="Scrum-中存在的模式"><a href="#Scrum-中存在的模式" class="headerlink" title="Scrum 中存在的模式"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum%20%E7%9A%8420%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%BC%8F/#Scrum-%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E6%A8%A1%E5%BC%8F" title="Scrum 中存在的模式"></a>Scrum 中存在的模式</h1><p><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum%20%E7%9A%8420%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%BC%8F/Scrum%E6%A8%A1%E5%BC%8F.jpg"><img src="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum%20%E7%9A%8420%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%BC%8F/Scrum%E6%A8%A1%E5%BC%8F.jpg"></a></p><p>这部分模式可以帮助我们更好地理解和实施 Scrum，以及评估和改进 Scrum 的实施，也能帮助我们理解 Scrum 的发明。</p><h2 id="模式名称：Backlog"><a href="#模式名称：Backlog" class="headerlink" title="模式名称：Backlog"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum%20%E7%9A%8420%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%BC%8F/#%E6%A8%A1%E5%BC%8F%E5%90%8D%E7%A7%B0%EF%BC%9ABacklog" title="模式名称：Backlog"></a>模式名称：Backlog</h2><p>解决的问题：</p><p>在本质上偏于不确定性的项目中需要知道下一步做什么。需要一种组织方法使得在项目的任何阶段都易于知道下一步要做什么。<br>甘特图方法事先定义任务和锁定时间，无法满足不确定性环境下的项目管理要求。<br>完全不管也不是一种好方法。</p><p>解决方案：</p><p>用 Backlog 组织工作。</p><ul><li>  Backlog 是一个排好优先级的列表。高优先级的工作先做。</li><li>  Backlog 的总合是产品，Backlog 中工作的完成意味着产品愿景的实现。Backlog 是动态管理的，以便完成的产品是合适的、有竞争力和有用的。</li><li>  Backlog 的内容来源很多。可以来自市场、销售、技术、开发部门和客户。</li><li>  只有一个人对 Backlog 排序。这个人对产品愿景的实现负责。</li><li>  根据市场需要和组织预算，一个或多个 Scrum 团队工作于一个 Backlog。团队从 Backlog 中选择一个迭代可以完成的工作项。</li><li>  团队在一个迭代中选择的工作要有一定的内聚度，构成迭代目标。团队在一个迭代内的工作，是为了完成迭代目标。</li><li>  团队把工作分解为任务，以便完成迭代目标。</li><li>  Backlog 这个简单的物件，上溯产品愿景，下达具体的工作项管理。</li></ul><p>达到的效果：</p><p>项目中的所有工作根据客户需要和团队能力动态排序。</p><h2 id="模式名称：Sprint"><a href="#模式名称：Sprint" class="headerlink" title="模式名称：Sprint"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum%20%E7%9A%8420%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%BC%8F/#%E6%A8%A1%E5%BC%8F%E5%90%8D%E7%A7%B0%EF%BC%9ASprint" title="模式名称：Sprint"></a>模式名称：Sprint</h2><p>解决的问题：</p><ul><li>  工作中涉及探索、创造与测试，而不是简单重复的机械式工作。</li><li>  需要优化沟通和信息共享。</li><li>  需要在一个时间盒里承诺完成来自 Backlog 的一定的工作量。</li><li>  团队需要无打扰地工作，管理层和客户需要看到进展。</li><li>  预先计划和命令与控制的方式行不通。</li></ul><p>解决方案：</p><ul><li>  给开发人员空间进行创造性的工作，学习探索，做实际的工作，免受外部干扰，运用机会和洞见来优化工作方式。</li><li>  同时显示真正的进展让管理者和干系人有信心。</li><li>  以短周期，小团队，来承载 Backlog 中的一段工作，并产生可交付的产品。</li><li>  聚焦，而不是微管理。焦点有不同层级的颗粒度，迭代层级，是团队和干系人共同关注的焦点。迭代之下的焦点和颗粒度，如每天的工作，更多由团队关注就可以了。</li><li>  在一个 Sprint 中，外部干扰被排除。团队内外及干系人对这一点有共识。</li><li>  团队在过程中可调整工作方式。团队以最好的方式，使用他们的技能经验和创造力，专注于手上的工作，产生可见、可用和可展示的交付。</li><li>  创建安全的时间盒，并向客户和干系人做出可信的承诺。</li><li>  是团队主动进行的承诺，和对创造性的工作和工作方式的优化。</li></ul><p>达到的效果：</p><ul><li>  所有参与者高度有效而又各有侧重的所有权，包括团队、干系人和客户。</li><li>  最大可能完成计划的工作。在每一个周期结束的时候，干系人可以影响和调整后续迭代的计划。因而使得长期计划具有极大的灵活性。</li><li>  每日站会的高度可见性，可以帮助发现浪费并很快回归真正的工作。</li><li>  为了能够选出迭代的工作，强制产品负责人更好地对 Backlog 排优先级。</li><li>  不适用于需要高度指导的人。</li></ul><h2 id="模式名称：每日站会"><a href="#模式名称：每日站会" class="headerlink" title="模式名称：每日站会"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum%20%E7%9A%8420%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%BC%8F/#%E6%A8%A1%E5%BC%8F%E5%90%8D%E7%A7%B0%EF%BC%9A%E6%AF%8F%E6%97%A5%E7%AB%99%E4%BC%9A" title="模式名称：每日站会"></a>模式名称：每日站会</h2><p>解决的问题：</p><ul><li>  需要一个方法来控制经验主义和不可预测的流程，例如软件开发，科研，艺术项目和创新设计等。</li><li>  对于需要探索、创造性和测试的工作，精确估算是困难的。</li><li>  过渡计划不会增加可预测性，只会浪费时间。太过详细和锁定细节日程的计划也难以执行。</li><li>  太过频繁的日常跟踪浪费时间，还会打扰开发人员。</li><li>  太多跟踪也无助于计划的完成。</li></ul><p>解决方案：</p><ul><li>  团队每天碰面15分钟，回答三个问题：昨天完成了什么，今天打算完成什么，遇到了什么困难。</li><li>  每天发生在同一时间同一地点，强化团队状态、问题和计划的社会化。</li><li>  是大家主动参与的一种目标、趋势和风险追踪。</li></ul><p>达到的效果：</p><ul><li>  增加紧迫感。</li><li>  提升知识分享，社会化，外化，内化和组合知识（参见野中郁次郎的知识管理、场理论和 SECI 模型）。技术专家成为社群资产。</li><li>  鼓励沟通和诚实。</li><li>  提升归属感。</li><li>  转变文化。通过透明，提升大家对目标的关注和主动参与，进而打磨流程，促进从根本上解决问题，建立学习型组织。</li><li>  高度可见的项目状态。</li><li>  高度可见的个人生产力。通过同事压力促进卓越。</li><li>  更少因阻碍造成的浪费。阻碍被及时发现和解决。</li><li>  更少因等待造成的浪费。通过细颗粒度的协作减少等待。</li><li>  提升团队内的社交。建立快乐高效的团队。</li></ul><h1 id="Scrum-活动中探索出来的模式"><a href="#Scrum-活动中探索出来的模式" class="headerlink" title="Scrum 活动中探索出来的模式"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum%20%E7%9A%8420%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%BC%8F/#Scrum-%E6%B4%BB%E5%8A%A8%E4%B8%AD%E6%8E%A2%E7%B4%A2%E5%87%BA%E6%9D%A5%E7%9A%84%E6%A8%A1%E5%BC%8F" title="Scrum 活动中探索出来的模式"></a>Scrum 活动中探索出来的模式</h1><p><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum%20%E7%9A%8420%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%BC%8F/Scrum%E5%AD%90%E6%A8%A1%E5%BC%8F.jpg"><img src="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum%20%E7%9A%8420%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%BC%8F/Scrum%E5%AD%90%E6%A8%A1%E5%BC%8F.jpg"></a></p><p>这部分的模式是作者在 Scrum 的使用中探索出来的模式，可以根据团队情况试用并调整。</p><h2 id="模式名称：团队生物钟"><a href="#模式名称：团队生物钟" class="headerlink" title="模式名称：团队生物钟"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum%20%E7%9A%8420%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%BC%8F/#%E6%A8%A1%E5%BC%8F%E5%90%8D%E7%A7%B0%EF%BC%9A%E5%9B%A2%E9%98%9F%E7%94%9F%E7%89%A9%E9%92%9F" title="模式名称：团队生物钟"></a>模式名称：团队生物钟</h2><p>解决的问题：</p><ul><li>  使团队成员更能感受团队工作的节律。</li><li>  使团队成员之间的合作更有节拍。</li><li>  使团队从良好惯性中受益。</li></ul><p>解决方案：</p><ul><li>  团队生物钟由团队共同讨论制定和调整。</li><li>  团队生物钟有两种，每天级别的和迭代级别的。</li><li>  在每天级别的团队生物钟里，大概包括以下四种时间。</li><li>  每日站会时间，15分钟。</li><li>  站会后讨论时间，大概1小时。不是全员参与，话题和人按需设置。</li><li>  团队核心时间，大家都能找到彼此且欢迎骚扰的时间，可以选取每天的两个时间段。</li><li>  私密时间，即不欢迎打扰的时间，个人可以集中精力做一下需要专注的事。</li><li>  迭代级别的团队生物钟也大概包括四种时间。</li><li>  日常工作时间。</li><li>  Scrum 的五个会议时间。</li><li>  Scrum 之外的会议时间，比如知识分享，代码评审等。</li><li>  发布的准备时间和发布时间。</li><li>  迭代级别及每日级别的各种生物钟要形成节律。</li></ul><p>产生的效果：</p><ul><li>  各项活动更能准时高效开展。</li><li>  团队成员有专注的时间做专注的事情。</li><li>  工作的节律感带来更高的员工满意度。</li><li>  好习惯帮助减少团队活动和任务间的切换成本，产生效益。</li></ul><h2 id="模式名称：会议议程精确到十分钟。"><a href="#模式名称：会议议程精确到十分钟。" class="headerlink" title="模式名称：会议议程精确到十分钟。"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum%20%E7%9A%8420%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%BC%8F/#%E6%A8%A1%E5%BC%8F%E5%90%8D%E7%A7%B0%EF%BC%9A%E4%BC%9A%E8%AE%AE%E8%AE%AE%E7%A8%8B%E7%B2%BE%E7%A1%AE%E5%88%B0%E5%8D%81%E5%88%86%E9%92%9F%E3%80%82" title="模式名称：会议议程精确到十分钟。"></a>模式名称：会议议程精确到十分钟。</h2><p>解决的问题：</p><ul><li>  会议目的不明确，流程不清晰，执行不聚焦，效率低。</li></ul><p>解决方案：</p><ul><li>  Scrum Master 提前收集议题，设计议程，尽量切割到以十分钟为颗粒度。</li><li>  确实不能切割的，可以以20分钟或30分钟为颗粒度。对于不能切割的，也可以寻找一些切割的角度，帮助会议的焦点有效流动，即所有人能同时有效地关注一个点，当一个点关注完，流动到下一个点。</li><li>  在执行每一议程前声明时间盒。</li><li>  执行时可以根据情况调整，并为下一次议程设计提供经验。</li></ul><p>达到的效果：</p><ul><li>  会议整体效率更高。</li><li>  在某个小议程，目标更明确，团队更专注。</li><li>  通过提升会议的效率与效能，提升团队满意度，更好地完成团队目标。</li></ul><h2 id="模式名称：产品列表业务精化会与技术精化会"><a href="#模式名称：产品列表业务精化会与技术精化会" class="headerlink" title="模式名称：产品列表业务精化会与技术精化会"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum%20%E7%9A%8420%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%BC%8F/#%E6%A8%A1%E5%BC%8F%E5%90%8D%E7%A7%B0%EF%BC%9A%E4%BA%A7%E5%93%81%E5%88%97%E8%A1%A8%E4%B8%9A%E5%8A%A1%E7%B2%BE%E5%8C%96%E4%BC%9A%E4%B8%8E%E6%8A%80%E6%9C%AF%E7%B2%BE%E5%8C%96%E4%BC%9A" title="模式名称：产品列表业务精化会与技术精化会"></a>模式名称：产品列表业务精化会与技术精化会</h2><p>解决的问题：</p><ul><li>  如果只讨论业务，不讨论技术方案，无法进行估算。因此到了计划会上也无法做出靠谱的计划和承诺。</li><li>  在同一个精化会上既讨论业务也讨论技术，时间不够，而且团队的准备度也不足。</li><li>  把技术方案的制定留到会后，可能受其他任务的挤压，无法确保能制定出。</li></ul><p>解决方案：</p><ul><li>  把精化会分解为两个，业务精化会和技术精化会。</li><li>  在业务精化会上，集中精力梳理业务需求。</li><li>  识别出需要提前制定技术方案的故事和可以直接带到计划会上的故事。</li><li>  对于需要制定技术方案的故事，指定专人调查，并在稍后的时间举行技术精化会，产生技术方案。</li><li>  两个精化会的时间都固化。</li></ul><p>产生的效果：</p><ul><li>  业务精化会聚焦于业务，主题清晰，效率高。</li><li>  技术精化会专注于技术方案的制定。</li><li>  因此到计划会时可以制定靠谱的计划和承诺。</li><li>  整体工作过程更加有条不紊，团队对完成迭代目标更有信心。</li></ul><h2 id="模式名称：一人天任务"><a href="#模式名称：一人天任务" class="headerlink" title="模式名称：一人天任务"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum%20%E7%9A%8420%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%BC%8F/#%E6%A8%A1%E5%BC%8F%E5%90%8D%E7%A7%B0%EF%BC%9A%E4%B8%80%E4%BA%BA%E5%A4%A9%E4%BB%BB%E5%8A%A1" title="模式名称：一人天任务"></a>模式名称：一人天任务</h2><p>解决的问题：</p><ul><li>  培养当日事当日毕。</li><li>  帮助发现障碍。</li><li>  形成流动。</li></ul><p>解决方案：</p><ul><li>  尽量把任务的平均大小向一人天靠拢。</li><li>  理解这个模式的目的，而不是照搬形式。</li><li>  任务可以在计划会产生，也可以在每日站会动态产生。</li></ul><p>达到的效果：</p><ul><li>  更好的流动。</li><li>  更好的风险识别和管理。</li></ul><h2 id="模式名称：故事-X-人矩阵"><a href="#模式名称：故事-X-人矩阵" class="headerlink" title="模式名称：故事 X 人矩阵"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum%20%E7%9A%8420%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%BC%8F/#%E6%A8%A1%E5%BC%8F%E5%90%8D%E7%A7%B0%EF%BC%9A%E6%95%85%E4%BA%8B-X-%E4%BA%BA%E7%9F%A9%E9%98%B5" title="模式名称：故事 X 人矩阵"></a>模式名称：故事 X 人矩阵</h2><p>解决的问题：</p><ul><li>  清晰呈现不同人员在同一个故事上的合作。</li><li>  清晰呈现每人当前手上的任务数。</li></ul><p>解决方案：</p><ul><li>  在白板 To Do 列中，按故事带任务两级呈现，故事从上到下反映优先级，任务从左到右反映大致的先后顺序。</li><li>  在 Doing 列中，自左到右按人排列。故事与人形成矩阵。</li><li>  每日站会进行的顺序是按故事泳道，故事驱动。</li><li>  每个故事涉及到的人讲解和拉动任务。</li></ul><p>达到的效果：</p><ul><li>  更清晰的合作呈现。</li><li>  更清晰的多任务呈现。</li><li>  更好的故事和任务流动。</li></ul><h2 id="模式名称：随机一分钟项目经理"><a href="#模式名称：随机一分钟项目经理" class="headerlink" title="模式名称：随机一分钟项目经理"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum%20%E7%9A%8420%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%BC%8F/#%E6%A8%A1%E5%BC%8F%E5%90%8D%E7%A7%B0%EF%BC%9A%E9%9A%8F%E6%9C%BA%E4%B8%80%E5%88%86%E9%92%9F%E9%A1%B9%E7%9B%AE%E7%BB%8F%E7%90%86" title="模式名称：随机一分钟项目经理"></a>模式名称：随机一分钟项目经理</h2><p>解决的问题：</p><ul><li>  确保在每日站会中，每人都关心团队目标。</li><li>  确保在每日站会中，每人都认真听他人说什么。</li><li>  并以此确保隐性知识传递，团队成员互相学习。</li></ul><p>解决方案：</p><ul><li>  在每日站会最后，以随机方法产生一分钟项目经理。</li><li>  一分钟项目经理做五点说明。</li><li>  我们的迭代目标是什么。</li><li>  趋势是什么，是否可控。</li><li>  主要风险和障碍是什么，如何管理。</li><li>  团队士气如何。</li><li>  邀请全体团队成员对完成迭代目标的信心点赞，以创造一个再次思考风险的契机。并宣布散会。</li></ul><p>达到的效果：</p><ul><li>  站会中团队成员更好的投入。</li><li>  更好的风险和趋势管理，更好的目标完成。</li><li>  更好的团队凝聚力。</li></ul><h2 id="模式名称：Scrum-风险管理分类"><a href="#模式名称：Scrum-风险管理分类" class="headerlink" title="模式名称：Scrum 风险管理分类"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum%20%E7%9A%8420%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%BC%8F/#%E6%A8%A1%E5%BC%8F%E5%90%8D%E7%A7%B0%EF%BC%9AScrum-%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86%E5%88%86%E7%B1%BB" title="模式名称：Scrum 风险管理分类"></a>模式名称：Scrum 风险管理分类</h2><p>解决的问题：</p><ul><li>  风险分类不清晰，难以确定合适的负责人。</li><li>  风险分类与角色职责没有匹配。</li></ul><p>解决方案：</p><ul><li>  风险分为三类：与产品和客户相关的，与技术相关的，与社会化相关的。</li><li>  产品和技术相关的，由产品负责人解决。</li><li>  技术相关的，由团队解决。</li><li>  社会化相关的，由 Scrum Master 解决。</li><li>  风险管理可视化。</li></ul><p>达到的效果：</p><ul><li>  更好的风险分配。</li><li>  风险管理与角色职责匹配。</li><li>  有意识的风险管理。</li></ul><h2 id="模式名称：知识分享基金"><a href="#模式名称：知识分享基金" class="headerlink" title="模式名称：知识分享基金"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum%20%E7%9A%8420%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%BC%8F/#%E6%A8%A1%E5%BC%8F%E5%90%8D%E7%A7%B0%EF%BC%9A%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB%E5%9F%BA%E9%87%91" title="模式名称：知识分享基金"></a>模式名称：知识分享基金</h2><p>解决的问题：</p><ul><li>  给分享者一点激励，更多代表的是团队的认可。</li><li>  让所有人，不管是分享者还是参与者，都成为分享的主动拥有者。</li></ul><p>解决方案：</p><ul><li>  由团队或个人众筹知识分享基金，不用太多。</li><li>  每迭代固定设一个知识分享时间，分享内容不限，只要对团队或项目有帮助。</li><li>  分享者主动提出分享话题。</li><li>  如多人都想分享，由多位分享者协调分享时间。</li><li>  每次分享结束时，给分享者一个小礼物。</li><li>  选取每次分享的重要照片，形成团队分享相册。</li></ul><p>达成的效果：</p><ul><li>  更好的知识传播。</li><li>  更好的团队成员之间的连接。</li></ul><h2 id="模式名称：同事赞扬"><a href="#模式名称：同事赞扬" class="headerlink" title="模式名称：同事赞扬"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum%20%E7%9A%8420%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%BC%8F/#%E6%A8%A1%E5%BC%8F%E5%90%8D%E7%A7%B0%EF%BC%9A%E5%90%8C%E4%BA%8B%E8%B5%9E%E6%89%AC" title="模式名称：同事赞扬"></a>模式名称：同事赞扬</h2><p>解决的问题：</p><ul><li>  提供一个团队成员互相感谢的机会，把内心的感谢表达出来。</li><li>  以此加深彼此了解。</li><li>  并形成一个更有凝聚力的团队。</li></ul><p>解决方案：</p><ul><li>  在回顾会议开始时，增加一个同事赞扬环节。</li><li>  每人以 Post-It 写下要感谢的人，并把所有 Post-It 放在一起。</li><li>  Scrum Master 随机抽取一张，让写的人面向要感谢的人表达感谢，包括感谢的原因。</li><li>  依次过完所有 Post-It。</li></ul><p>达到的效果：</p><ul><li>  更高的士气，更好的团队凝聚力。</li><li>  更高的产出。</li></ul><h2 id="模式名称：卓越驱动的迭代回顾会议"><a href="#模式名称：卓越驱动的迭代回顾会议" class="headerlink" title="模式名称：卓越驱动的迭代回顾会议"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum%20%E7%9A%8420%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%BC%8F/#%E6%A8%A1%E5%BC%8F%E5%90%8D%E7%A7%B0%EF%BC%9A%E5%8D%93%E8%B6%8A%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%9B%9E%E9%A1%BE%E4%BC%9A%E8%AE%AE" title="模式名称：卓越驱动的迭代回顾会议"></a>模式名称：卓越驱动的迭代回顾会议</h2><p>解决的问题：</p><ul><li>  迭代回顾会议缺乏结构与效率。</li><li>  迭代回顾会议缺乏有利于长期提升的制度化。</li></ul><p>解决方案：</p><ul><li>  团队制定一组卓越指标，例如跨职能团队、价值流、团队工作。卓越指标代表团队为了完成产品目标和迭代目标所最看重的东西。</li><li>  针对每一指标，制定一系列子项或检查项。</li><li>  定期更新指标定义。</li><li>  在迭代回顾会上，把卓越指标打印张贴。</li><li>  针对每一指标，集体评估团队做得好的地方和需要改善的地方。产生改善措施。</li></ul><p>产生的效果：</p><ul><li>  更系统化结构化制度化的回顾。</li><li>  更持续的改进。</li></ul><h2 id="模式名称：同事评估"><a href="#模式名称：同事评估" class="headerlink" title="模式名称：同事评估"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum%20%E7%9A%8420%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%BC%8F/#%E6%A8%A1%E5%BC%8F%E5%90%8D%E7%A7%B0%EF%BC%9A%E5%90%8C%E4%BA%8B%E8%AF%84%E4%BC%B0" title="模式名称：同事评估"></a>模式名称：同事评估</h2><p>解决的问题：</p><ul><li>  在传统的由经理进行的评估中，多数员工是不满意的。</li></ul><p>解决方案：</p><ul><li>  在每个迭代结束的时候，分配给每个团队成员等量的代币。</li><li>  规则只有一条，就是要把代币送给其他团队成员，自己不能留。至于全部送给一个人，还是平均送给每个人，是当事人自己的决定。</li><li>  根据组织的形态，可以有两种方式：只有结果公开，和结果和过程（即谁送给谁多少）都透明。</li><li>  根据组织的形态，决定代币的用途，如只是兑换小礼品，还是兑换奖金。</li><li>  是否要使用，如何使用，使用的程度，需获得组织和团队的共识。</li></ul><p>达到的效果：</p><ul><li>  同事评估更能反映一个人的真实表现。</li></ul><h1 id="Scrum-反模式"><a href="#Scrum-反模式" class="headerlink" title="Scrum 反模式"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum%20%E7%9A%8420%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%BC%8F/#Scrum-%E5%8F%8D%E6%A8%A1%E5%BC%8F" title="Scrum 反模式"></a>Scrum 反模式</h1><p><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum%20%E7%9A%8420%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%BC%8F/Scrum%E5%8F%8D%E6%A8%A1%E5%BC%8F.jpg"><img src="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum%20%E7%9A%8420%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%BC%8F/Scrum%E5%8F%8D%E6%A8%A1%E5%BC%8F.jpg"></a></p><p>这部分是在 Scrum 的使用中应该避免的模式。</p><h2 id="产品负责人的反模式"><a href="#产品负责人的反模式" class="headerlink" title="产品负责人的反模式"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum%20%E7%9A%8420%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%BC%8F/#%E4%BA%A7%E5%93%81%E8%B4%9F%E8%B4%A3%E4%BA%BA%E7%9A%84%E5%8F%8D%E6%A8%A1%E5%BC%8F" title="产品负责人的反模式"></a>产品负责人的反模式</h2><ul><li>  产品负责人在迭代中大部分时间缺席，不能回答团队的问题。</li><li>  在迭代计划之后，改变故事的范围或验收标准。</li><li>  对于无法实现或不再有效的验收标准，缺乏改变的灵活度。</li><li>  产品负责人不能及时对完成的故事提供反馈。</li><li>  误用取消迭代的权力。</li><li>  在迭代目标不再有效时，也不取消迭代。</li></ul><h2 id="开发团队的反模式"><a href="#开发团队的反模式" class="headerlink" title="开发团队的反模式"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum%20%E7%9A%8420%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%BC%8F/#%E5%BC%80%E5%8F%91%E5%9B%A2%E9%98%9F%E7%9A%84%E5%8F%8D%E6%A8%A1%E5%BC%8F" title="开发团队的反模式"></a>开发团队的反模式</h2><ul><li>  没有 WIP（进行中的工作项）限制。</li><li>  在遇到阻塞时，开始其他任务，使自己保持忙碌。</li><li>  任务板不能保持更新。</li><li>  工作于没有显示在任务板的工作。</li><li>  镀金，增加不必要的工作。</li></ul><h2 id="Scrum-Master-的反模式"><a href="#Scrum-Master-的反模式" class="headerlink" title="Scrum Master 的反模式"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum%20%E7%9A%8420%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%BC%8F/#Scrum-Master-%E7%9A%84%E5%8F%8D%E6%A8%A1%E5%BC%8F" title="Scrum Master 的反模式"></a>Scrum Master 的反模式</h2><ul><li>  允许管理者或干系人在迭代中打扰团队，让团队从事与迭代目标无关的事情或会议。</li><li>  不能支持需要帮助的团队成员。</li><li>  允许微管理，允许产品负责人向团队分配任务。</li><li>  没有回顾会议。</li></ul><h2 id="Scrum-团队的反模式"><a href="#Scrum-团队的反模式" class="headerlink" title="Scrum 团队的反模式"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum%20%E7%9A%8420%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%BC%8F/#Scrum-%E5%9B%A2%E9%98%9F%E7%9A%84%E5%8F%8D%E6%A8%A1%E5%BC%8F" title="Scrum 团队的反模式"></a>Scrum 团队的反模式</h2><ul><li>  有人没有询问团队就把任务加到迭代列表。</li><li>  不产生交付的迭代。</li><li>  做不是产品负责人认为当前应该做的工作。</li><li>  没有紧迫感。</li><li>  新人加入时，没有接轨计划。</li><li>  可变的迭代长度。</li></ul><h2 id="管理者的反模式"><a href="#管理者的反模式" class="headerlink" title="管理者的反模式"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum%20%E7%9A%8420%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%BC%8F/#%E7%AE%A1%E7%90%86%E8%80%85%E7%9A%84%E5%8F%8D%E6%A8%A1%E5%BC%8F" title="管理者的反模式"></a>管理者的反模式</h2><ul><li>  在紧急情况下放弃 Scrum。</li><li>  经常在团队之间重新分配团队成员。</li><li>  不经产品负责人，直接向团队分配特定任务。</li></ul><h2 id="干系人反模式"><a href="#干系人反模式" class="headerlink" title="干系人反模式"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum%20%E7%9A%8420%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%BC%8F/#%E5%B9%B2%E7%B3%BB%E4%BA%BA%E5%8F%8D%E6%A8%A1%E5%BC%8F" title="干系人反模式"></a>干系人反模式</h2><ul><li>  偷偷向团队加入任务。</li><li>  把每件事都当成紧急的。</li><li>  打扰团队。</li><li>  模式是一种语言，语言承载思想。Scrum 中的模式承载了“更好”在不同场景中的实现。下一章探讨精益体系，看作为敏捷起源的精益如何在敏捷中发挥作用。</li></ul></blockquote><p> 本文作者： <a href="mailto:&#106;&#x6f;&#110;&#105;&#64;&#x65;&#102;&#x62;&#x69;&#122;&#46;&#x6f;&#x72;&#x67;">&#106;&#x6f;&#110;&#105;&#64;&#x65;&#102;&#x62;&#x69;&#122;&#46;&#x6f;&#x72;&#x67;</a><br>本文链接： <a href="https://github.com/efbiz/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum">https://github.com/efbiz/2018/05/14/敏捷教练第04课-储备-Scrum</a> 的20个子模式/ </p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;自克里斯托弗亚历山大发明建筑模式，经由设计模式，发展到组织模式。模式是一种经过验证的、经过分类的、可以被反复重用的、场景化、定式化的经验总结。模式思维是理性和感性思维的中和，是人固有的一种能力。模式的好处是省力。敏捷管理，也存在一些这样的模式。&lt;b</summary>
      
    
    
    
    <category term="Scrum" scheme="http://zhangyu.info/categories/Scrum/"/>
    
    
    <category term="Scrum" scheme="http://zhangyu.info/tags/Scrum/"/>
    
  </entry>
  
  <entry>
    <title>敏捷教练第05课-储备-精益体系精要</title>
    <link href="http://zhangyu.info/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/"/>
    <id>http://zhangyu.info/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/</id>
    <published>2022-04-11T16:00:00.000Z</published>
    <updated>2022-04-12T02:00:21.759Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>精益是敏捷的重要来源，敏捷对精益作了继承和发扬。</p><p>精益的体系浩繁，本文按4＊2的结构进行介绍，即从思想、方法、模式和工具四个层面对精益进行介绍，并在四个层面分别谈及在敏捷中的体现和运用。最后用三纲八目的结构，总结精益中最重要的三个思想及八种落实的方法。</p><h1 id="精益学问体系有四个层面："><a href="#精益学问体系有四个层面：" class="headerlink" title="精益学问体系有四个层面："></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/#%E7%B2%BE%E7%9B%8A%E5%AD%A6%E9%97%AE%E4%BD%93%E7%B3%BB%E6%9C%89%E5%9B%9B%E4%B8%AA%E5%B1%82%E9%9D%A2%EF%BC%9A" title="精益学问体系有四个层面："></a>精益学问体系有四个层面：</h1><ul><li>  思想：是大脑，是思维。</li><li>  方法论：是在宽泛领域看事情的眼睛。是复眼。</li><li>  解决方案（模式）：是对特定场景问题的总是有效的解决方法。</li><li>  工具：是在狭窄领域看事情的眼睛。是单眼。</li></ul><p><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB.jpg"><img src="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB.jpg"></a></p><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/#%E6%80%9D%E6%83%B3" title="思想"></a>思想</h2><p>就思想而言，涉及到的人包括：</p><ul><li>  丰田佐吉、丰田喜一郎、大野耐一作为创始祖师。</li><li>  詹姆斯沃迈克作为研究第一人。</li><li>  杰弗瑞莱克作为另树一帜的研究人。</li></ul><p>思想的应用者：</p><ul><li>  Scrum 的创始人 Jeff Sutherland &amp; Ken Schwaber。</li><li>  Lean Software Development 的创始人 Mary Poppendieck。</li><li>  Kanban 方法的创始人 David Anderson。</li><li>  LeSS 的创始人 Craig Larman。</li><li>  SAFe 的创始人 Dean Leffingwell。</li></ul><p>在方法论领域的精益大师：</p><ul><li>  约翰舒克，特别是在 A3 报告和价值流图方面把相关知识显式化的功劳。</li></ul><h3 id="精益思想"><a href="#精益思想" class="headerlink" title="精益思想"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/#%E7%B2%BE%E7%9B%8A%E6%80%9D%E6%83%B3" title="精益思想"></a>精益思想</h3><p>精益学问体系的思想，无法简单描述，就脉络来说，大致三个：</p><ul><li>  丰田屋或精益屋，经由以大野耐一为代表的创始祖师，和后续发展。</li><li>  詹姆斯沃迈克的精益思想。</li><li>  杰弗瑞莱克的丰田 4P。</li></ul><p>丰田佐吉、丰田喜一郎和大野耐一等人关于丰田生产方式的思想，反映在丰田屋模型中。屋顶代表的是通过最佳质量、最低成本、最短生产周期和消除浪费来为客户创造价值。底座代表的是管理层对创造价值和消除浪费的长期承诺和支持。两个支柱是自动化和及时化。自动化是关于个人自动自发。及时化是关于团队合作。</p><p>渡边昭捷丰田之道2001版的丰田屋模型中，两个支柱演变为持续改善和尊重人。新支柱从概念上来讲，适用的范围更广泛，但也存在丢失旧支柱包含的精神的风险。</p><p>Craig Larman 写了一本 &lt; Lean Primer &gt;，将精益介绍到软件界，并使之成为其 LeSS 的重要思想基础。Craig 在书中也总结了一个精益屋，跟丰田本身的屋子模型基本相似，只是在术语上采用了软件开发人员更容易明白的术语。</p><p>LeSS 的对手 SAFe 也以精益作为基础。SAFe 的创始人在 SAFe 体系中也使用了屋子模型。这个屋子的屋顶是价值，底座是领导力，跟前几个屋子模型一致。不同的是，支柱变成了四个，在尊重人和持续改善之外，增加了流动和创新。流动和创新也是丰田模式中本有的概念。</p><p>精益软件开发的创始人 Mary Poppendieck 从精益中提炼了7个原则，应用于软件开发中：消除浪费，增加反馈，延迟承诺，尽快交付，内建质量，赋能团队和全局优化。</p><p>精益软件开发中的一部分思想来自于詹姆斯沃迈克总结的精益思想，这也是精益思想的另一个山头。沃迈克作为精益思想第一人，是把精益介绍给全球的主要桥梁。沃迈克经过对丰田的研究，提出了精益思想五原则：价值，价值流，流动，拉动和尽善尽美。</p><p>精益中重要思想“流动”的历史，则可以追溯到1574年亨利三世在威尼斯造船时采用的连续流，经由1799年埃里惠特尼的可互换件，1902年丰田佐吉的自动化，1910年亨利福特的流水线，1950年戴明的统计过程控制，发展到后来的丰田生产方式。</p><p>精益思想的第三个高耸的山头是杰弗瑞莱克的丰田模式和 4P 模型。杰弗瑞莱克对丰田的研究，不次于詹姆斯沃迈克，被称为最懂丰田的人。</p><h4 id="杰弗瑞莱克丰田-4P-模型及14条原则"><a href="#杰弗瑞莱克丰田-4P-模型及14条原则" class="headerlink" title="杰弗瑞莱克丰田 4P 模型及14条原则"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/#%E6%9D%B0%E5%BC%97%E7%91%9E%E8%8E%B1%E5%85%8B%E4%B8%B0%E7%94%B0-4P-%E6%A8%A1%E5%9E%8B%E5%8F%8A14%E6%9D%A1%E5%8E%9F%E5%88%99" title="杰弗瑞莱克丰田 4P 模型及14条原则"></a>杰弗瑞莱克丰田 4P 模型及14条原则</h4><p>Philosophy 理念</p><ul><li>  原则1. 管理决策以长期理念为基础，即使因此牺牲短期财务目标也在所不惜。</li></ul><p>Process 流程</p><ul><li><p>  原则2. 建立连续的作业流程以使问题浮现。</p></li><li><p>  原则3. 使用拉动式生产方式以避免生产过剩。</p></li><li><p>  原则4. 使工作负荷平均（生产均衡化）。</p></li><li><p>  原则5. 建立立即暂停以解决问题、从一开始就重视质量控制的文化。</p></li><li><p>  原则6. 工作的标准化是持续改善与授权员工的基础。</p></li><li><p>  原则7.通过可视化管理使问题无所隐藏 。</p></li></ul><p>People and Partners 员工与合作伙伴</p><ul><li><p>  原则8.使用可靠且已经充分测试的技术以协助员工及生产流程。</p></li><li><p>  原则9.培养深谙公司理念的领袖，使他们能教导其他员工。</p></li><li><p>  原则10. 培养与发展信奉公司理念的杰出人才与团队。</p></li><li><p>  原则11. 重视合作伙伴与供应商，激励并助其改善 。</p></li></ul><p>Problem Solving 问题解决</p><ul><li><p>  原则12.亲临现场，彻底了解情况（现地现物）。</p></li><li><p>  原则13.制定决策时要稳健，穷尽所有的选择，并征得一致意见；实施决策时要迅速 。</p></li><li><p>  原则14.通过不断省思与持续改善以成为一个学习型组织。</p></li></ul><p>莱克的书中，不提精益，重回本名：丰田模式。沃迈克在后来的一本书，《十年观察》中采用了目的、流程、人的框架，也暗合了莱克的表述。</p><p>丰田模式的4P模型和14条原则，揭示了一种真北标准。</p><p>具备真北标准的企业具备三个特征：</p><h4 id="特征一、具备正义的目的。"><a href="#特征一、具备正义的目的。" class="headerlink" title="特征一、具备正义的目的。"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/#%E7%89%B9%E5%BE%81%E4%B8%80%E3%80%81%E5%85%B7%E5%A4%87%E6%AD%A3%E4%B9%89%E7%9A%84%E7%9B%AE%E7%9A%84%E3%80%82" title="特征一、具备正义的目的。"></a>特征一、具备正义的目的。</h4><p>正义的目的有两层含义，一是以客户价值为中心，二是以正义和不作恶的方式达成目的。</p><blockquote><p>海底捞的使命：服务至上、顾客至上，以创新为核心，提倡个性化的特色服务，致力于为顾客提供愉悦的用餐服务。</p><p>丰田父子传承的使命： 丰田佐吉临终前，将丰田喜一郎叫到眼前，给他留下了作为父亲的最后一句话：“我搞织布机，你搞汽车，你要和我一样，通过发明创造为国效力。”</p><p>谷歌不作恶使命： 组织全球信息，使人人皆可访问和使用。<br>不作恶口号的提出来自员工。由阿米特帕特尔于1999年提出，或者是由保罗·布克海特在2000年或是2001年初有关企业价值观的会议上提出。<br>这个口号被创始人采纳和推广。Google 2004年的首次公开募股的招股书（又名“S-1”），（Google创始人的一封信，后来被称为“不作恶的宣言”）：“不要作恶。我们坚信，作为一个为世界做好事的公司，从长远来看，我们会得到更好的回馈-即使我们放弃一些短期收益。”</p></blockquote><p>口号最重要不是拿来说和挂在墙上，而是相信自己的口号和拿来使用。在做产品时，如果会伤害用户的利益，虽然有短期收益，也可以根据这一价值观来否决，而且这个否决可以来自任何一个人。</p><h4 id="特征二、全员主动参与"><a href="#特征二、全员主动参与" class="headerlink" title="特征二、全员主动参与"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/#%E7%89%B9%E5%BE%81%E4%BA%8C%E3%80%81%E5%85%A8%E5%91%98%E4%B8%BB%E5%8A%A8%E5%8F%82%E4%B8%8E" title="特征二、全员主动参与"></a>特征二、全员主动参与</h4><p>海底捞在管理上，倡导双手改变命运的价值观，为员工创建公平公正的工作环境，实施人性化和亲情化管理理模式，提升员工价值。</p><p>每一个工会会员都必须明白一个基本道理，我们不是在执行公司命令去关心员工，而是真正意识到我们都是人，每个人都需要关心与被关心，而这个关心基于一种信念，那就是人生而平等。</p><p>海底捞的内刊上，有两行让人印象深刻的字：倡双手改变命运之理，树公司公平公正之风。在海底捞，员工可以享受一个特权：基层服务员可以享有打折、换菜甚至免单的权利，只要事后口头说明即可。</p><p>关于海底捞被人广为称道的细节服务，发圈、眼镜布等，最初只是一个个自发的想法。包丹袋就是这个想法的代表，这是一个防止顾客手机被溅湿的塑封袋子。由于是一名叫包丹的员工提出这个创意的，即用员工的名字命名。“这种命名的方式既能实现他的价值，也是对他的尊重，很多员工都有很多不错的创意，要给他们提供机会。”当包丹袋在其他店也开始使用时，这些店会给这位员工交纳一定的费用。</p><p>海底捞这种开放的平台还体现在培养员工的兴趣爱好上。一名员工在和外国顾客交流时，说起了流利的英语，随后公司为此举行了一次英语竞赛，并为优胜者请来了外语老师。“让员工能够发挥自己的特长，从而在工作中获得乐趣，使工作变得更有价值”。</p><blockquote><p>大野耐一：“没有人喜欢自己只是螺丝钉，工作一成不变，只是听命行事，不知道为何而忙，丰田做的事很简单，就是真正给员工思考的空间，引导出他们的智慧。员工奉献宝贵的时间给公司，如果不妥善运用他们的智慧，才是浪费。”</p></blockquote><p>丰田汽车提出“创意工夫提案制度”，对每个员工建议设置500日元到20万日元不等的奖金，优秀建言者的头像会被永久贴上丰田公司的“光荣走廊”。结果，丰田公司在40年间收到了超过2000万个提案，其中99%被采纳。</p><p>丰田的创意提案制度强调领导者的参与性和问题的精细化：首先，领导者要对员工进行培训，告诉他们什么是真正的问题；其次，提出的问题具有较强的可行性，员工不需要面对“怎样增支减收”之类的宏观问题，而是具体到“机器之间隔几米能使操作者少走路”“左手应该拿工具还是拿加工半成品”的实操问题；最后，员工不参与工资、考评等领域的建言，以免引起争论与攻击。</p><blockquote><p>谷歌认为，员工应该都成为创意精英（Smart Creatives），才能够使得这个组织产生赋能的效应。</p></blockquote><p>有一个周五下班前，拉里发现了某产品中一个严重的问题。他没有告诉任何人，而是写下了问题，及其影响。拉里把它贴在茶水间，就回家了。</p><p>周一早上五点钟，拉里和相关人员就收到一封邮件。邮件不是简单的附和创始人的想法，或是对要解决这个问题的不痛不痒虚张声势的呼吁。相反，邮件中包含了对这一问题根源的详细分析，及对多种方案中最优方案的选择，还有对这一方案的具体执行。而且，还提出了进一步想法，这一想法成了后来一个重大业务的基础。</p><p>邮件的发出人只是在周五下班前偶然看到了拉里的纸条，并且从组织架构上来说，他不属于出问题的这个产品。</p><p>这个故事的重点不在于是否提倡加班，工作是否需要计划。而在于：</p><ul><li>  每个人都明白公司的当务之急和价值取向。</li><li>  一种不急赏不惩罚不嫉妒的文化：这件事做成了，也不会有马上的奖赏。失败了，也不会被惩罚。成功了，也不会被嫉妒。</li></ul><p>这个例子，将谷歌文化的力量彰显的淋漓尽致。如果一个企业支持员工有发言权，那么持相同观点的人就会被吸引来，子曰：近者悦，远者来。在企业成立之初就认真考虑和确定你希望的企业文化，是明智之举。创始人是企业文化的源头，创始人为实现大计而物色并信赖的团队，是企业文化的最佳载体。问一下你的团队：我们重视什么？我们的信念是什么？我们想成为怎样的企业？</p><h4 id="特征三、形成一个具有持久生命力的系统。"><a href="#特征三、形成一个具有持久生命力的系统。" class="headerlink" title="特征三、形成一个具有持久生命力的系统。"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/#%E7%89%B9%E5%BE%81%E4%B8%89%E3%80%81%E5%BD%A2%E6%88%90%E4%B8%80%E4%B8%AA%E5%85%B7%E6%9C%89%E6%8C%81%E4%B9%85%E7%94%9F%E5%91%BD%E5%8A%9B%E7%9A%84%E7%B3%BB%E7%BB%9F%E3%80%82" title="特征三、形成一个具有持久生命力的系统。"></a>特征三、形成一个具有持久生命力的系统。</h4><p>勉强给企业真北标准下一个定义，大致是：企业有一套理念，这个理念把客户，员工，企业发展，甚至造福社会等各种要素组合在一起，充分考虑各方面的福祉，持续优化形成卓越运作，达到企业的基业长青和个人的幸福。</p><p>这样一种管理理念的主要思想是：管理决策的制定以最终的目的为前提，眼光放长远，有一套处理问题的步骤，通过培养员工来为企业增值，并且认同持续不断解决根本问题会促进整体学习的观念。</p><p>如果把上述各个流派的精益思想做个总结，可以概括为以下几点：</p><ul><li>  强调目的和价值</li><li>  强调领导者的作用</li><li>  强调对人的尊重</li><li>  强调流程</li><li>  强调问题解决和持续改善</li></ul><p>所有这些是精益的要点，也是敏捷的要点，而且所有这些点要有机结合，而不是孤立存在。企业要想通过敏捷转型获得竞争优势，需要对精益体系有完整的理解。这些都是精益和敏捷的元认知，敏捷教练可协助管理者理解。</p><h2 id="精益方法基础的重要基本概念"><a href="#精益方法基础的重要基本概念" class="headerlink" title="精益方法基础的重要基本概念"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/#%E7%B2%BE%E7%9B%8A%E6%96%B9%E6%B3%95%E5%9F%BA%E7%A1%80%E7%9A%84%E9%87%8D%E8%A6%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" title="精益方法基础的重要基本概念"></a>精益方法基础的重要基本概念</h2><h3 id="什么是价值？"><a href="#什么是价值？" class="headerlink" title="什么是价值？"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%B7%E5%80%BC%EF%BC%9F" title="什么是价值？"></a>什么是价值？</h3><ul><li>  客户愿意为之付钱。</li><li>  是一种产品或服务的形态发生改变的过程。</li><li>  这种改变必须无浪费地做对。</li></ul><h3 id="什么是问题？"><a href="#什么是问题？" class="headerlink" title="什么是问题？"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/#%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AE%E9%A2%98%EF%BC%9F" title="什么是问题？"></a>什么是问题？</h3><ul><li>  标准没有达到。</li><li>  旧的标准达到了，又提出了新的标准。</li><li>  标准没有稳定地达到，有时能达到，有时不能达到。</li></ul><h3 id="什么是浪费？"><a href="#什么是浪费？" class="headerlink" title="什么是浪费？"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%AA%E8%B4%B9%EF%BC%9F" title="什么是浪费？"></a>什么是浪费？</h3><p>TIM WOODS 八大浪费：</p><ul><li>  Transportation 运输的浪费。</li><li>  Inventory 库存的浪费。</li><li>  Motion 移动的浪费。</li><li>  Waiting 等待的浪费。</li><li>  Over production 过度生产。</li><li>  Over processing 过度加工。</li><li>  Defect 缺陷也是一种浪费。</li><li>  Skill unused 未使用的技能。</li></ul><p>从更高的视野看什么是浪费</p><p>3M：</p><ul><li>  Muda 无驮，就是一般所说的浪费。</li><li>  Muri 无理，比如说人或设备过载。</li><li>  Mura 无稳，比如说有时忙有时闲。</li></ul><p>浪费管理的基本思路，跟把大象请出冰箱一样简单。分两步：</p><ul><li>  识别浪费。</li><li>  消除浪费。</li></ul><p><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/%E7%B2%BE%E7%9B%8A%E6%96%B9%E6%B3%95%E5%9F%BA%E7%A1%80.jpg"><img src="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/%E7%B2%BE%E7%9B%8A%E6%96%B9%E6%B3%95%E5%9F%BA%E7%A1%80.jpg"></a></p><p>这些关于价值、浪费与问题的思想，都是非常深刻的认识，在敏捷当中也是同样适用的。敏捷教练可以把这些思想，运用到问题解决和持续改善中。</p><p>###把思想、方法论、解决方案（模式）、工具组合在一起：</p><h4 id="定义价值。可以使用："><a href="#定义价值。可以使用：" class="headerlink" title="定义价值。可以使用："></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/#%E5%AE%9A%E4%B9%89%E4%BB%B7%E5%80%BC%E3%80%82%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%EF%BC%9A" title="定义价值。可以使用："></a>定义价值。可以使用：</h4><ul><li>  增值工作</li><li>  八大浪费</li><li>  3M</li></ul><h4 id="观察整个价值流。可以使用："><a href="#观察整个价值流。可以使用：" class="headerlink" title="观察整个价值流。可以使用："></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/#%E8%A7%82%E5%AF%9F%E6%95%B4%E4%B8%AA%E4%BB%B7%E5%80%BC%E6%B5%81%E3%80%82%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%EF%BC%9A" title="观察整个价值流。可以使用："></a>观察整个价值流。可以使用：</h4><p>价值流图</p><h4 id="让增值步骤流动。可以使用："><a href="#让增值步骤流动。可以使用：" class="headerlink" title="让增值步骤流动。可以使用："></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/#%E8%AE%A9%E5%A2%9E%E5%80%BC%E6%AD%A5%E9%AA%A4%E6%B5%81%E5%8A%A8%E3%80%82%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%EF%BC%9A" title="让增值步骤流动。可以使用："></a>让增值步骤流动。可以使用：</h4><ul><li>  目视管理</li><li>  5S</li><li>  防呆法</li><li>  节拍时间</li><li>  标准工作</li><li>  连续流</li><li>  单元式布局</li><li>  产线均衡</li><li>  快速换模</li><li>  全员生产维护</li><li>  分层流程审计</li></ul><h4 id="让客户拉动。可以使用："><a href="#让客户拉动。可以使用：" class="headerlink" title="让客户拉动。可以使用："></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/#%E8%AE%A9%E5%AE%A2%E6%88%B7%E6%8B%89%E5%8A%A8%E3%80%82%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%EF%BC%9A" title="让客户拉动。可以使用："></a>让客户拉动。可以使用：</h4><p>看板</p><h4 id="持续重复前面的步骤。可以使用："><a href="#持续重复前面的步骤。可以使用：" class="headerlink" title="持续重复前面的步骤。可以使用："></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/#%E6%8C%81%E7%BB%AD%E9%87%8D%E5%A4%8D%E5%89%8D%E9%9D%A2%E7%9A%84%E6%AD%A5%E9%AA%A4%E3%80%82%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%EF%BC%9A" title="持续重复前面的步骤。可以使用："></a>持续重复前面的步骤。可以使用：</h4><ul><li>  反思</li><li>经验分享<br>  这个价值流分析，可以直接运用到软件开发的管理中，所使用的具体工具可以变通。David Anderson （《看板方法》）的重要基础就是价值流。</li></ul><h2 id="精益方法论"><a href="#精益方法论" class="headerlink" title="精益方法论"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/#%E7%B2%BE%E7%9B%8A%E6%96%B9%E6%B3%95%E8%AE%BA" title="精益方法论"></a>精益方法论</h2><p>方法论是解决问题的方法，重点介绍 TBP 或 A3 报告。</p><h3 id="TBP"><a href="#TBP" class="headerlink" title="TBP"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/#TBP" title="TBP"></a>TBP</h3><p>TBP：Toyota Business Practice，中文可以叫丰田问题解决法，是A3报告的一种逻辑框架。A3 报告参看在丰田工作过的精益大师 John Shook 的 &lt; Manage to Learn &gt;。</p><p>TBP 体现了质量大师戴明的 PDCA。美国人一般把这个方法叫做 Practical Problem Solving，即实践的问题解决法。</p><p>TPB 中的基本意识</p><ul><li>  客户至上</li><li>  经常自问自答“为什么”</li><li>  当事者意识</li><li>  可视化</li><li>  根据现场和事实判断</li><li>  彻底地思考和执行</li><li>  把握速度和时机</li><li>  诚实正直</li><li>  全员参与</li></ul><p>PDCA/TBP/A3/Practical Problem Sovling 为什么这么好？依然可以用 4P 解释：</p><ul><li>  Purpose：从目标出发。</li><li>  Process：是一步一步紧密相扣的闭环和螺旋式上升的问题解决方法。</li><li>  People：平等积极参与。</li><li>  Problem Solving：彻底的问题解决。</li></ul><h3 id="A3-在丰田就是一种尚方宝剑，可以穿越等级和部门墙。"><a href="#A3-在丰田就是一种尚方宝剑，可以穿越等级和部门墙。" class="headerlink" title="A3 在丰田就是一种尚方宝剑，可以穿越等级和部门墙。"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/#A3-%E5%9C%A8%E4%B8%B0%E7%94%B0%E5%B0%B1%E6%98%AF%E4%B8%80%E7%A7%8D%E5%B0%9A%E6%96%B9%E5%AE%9D%E5%89%91%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%A9%BF%E8%B6%8A%E7%AD%89%E7%BA%A7%E5%92%8C%E9%83%A8%E9%97%A8%E5%A2%99%E3%80%82" title="A3 在丰田就是一种尚方宝剑，可以穿越等级和部门墙。"></a>A3 在丰田就是一种尚方宝剑，可以穿越等级和部门墙。</h3><p>TBP 八步详解<br>PDCA 扩展为丰田八步问题解决法：</p><p>Plan 计划</p><ul><li>  第一步：澄清问题。</li><li>  第二步：分解问题。</li><li>  第三步：设定目标。</li><li>  第四步：分析根源。</li><li>  第五步：制定措施。</li></ul><p>Do 执行</p><ul><li><p>第六步：贯彻措施。<br>  Check 检查</p></li><li><p>第七步：评估结果。<br>  Act 行动</p></li><li><p>  第八步：标准化。</p></li></ul><p>下面我们来逐一解释一下。</p><p>第一步：澄清问题。</p><p>通过问 5W2H，形成清晰简洁脚踏实地的问题描述。注意这里的 5W2H 是从现象级来问，不是问原因。原因在后面，不要着急，慢就是快。</p><ul><li>  问题是什么？</li><li>  它是在哪里发生的？</li><li>  何时发生的？</li><li>  谁会受到影响？</li><li>  为什么这是一个问题?</li><li>  影响有多大？</li><li>  发生的频率如何？</li></ul><p>第二步：分解问题。</p><p>可以画一个流程图，按流程分。 可以按影响因素的重要程度分，参考二八原理和柏拉图。</p><p>第三步：设定目标。</p><p>重新回顾什么是问题：理想状态是什么，现状是什么，理想状态与现状的差距就是目标。目标的设定可以是更高目标，或稳定化的目标。</p><p>第四步：分析根源。</p><p>可以采用鱼骨图，五个为什，主效应图等。</p><p>第五步：制定对策。 对症下药。</p><p>第六步：执行对策。 坚持，不妥协。</p><p>第七步：评估效果。 可以采用控制图，箱体图（控制图的变种）等。</p><p>第八步：形成标准。</p><p>在敏捷当中，可以把 A3 方法作为一个问题解决工具来使用，以打造彻底解决问题，持续改善的学习型文化。</p><p>其他问题解决方法的简要描述如下：</p><p>DMAIC 方法：用于复杂问题</p><ul><li>  Define 定义</li><li>  Measure 度量</li><li>  Analyze 分析</li><li>  Improve 改善</li><li>  Control 控制</li></ul><p>DMADV 方法：用于创新问题</p><ul><li>  Define 定义</li><li>  Measure 度量</li><li>  Analyze 分析</li><li>  Design 设计</li><li>  Verify 验证</li></ul><p>8D 方法：用于质量问题</p><ul><li>  D1：定义问题</li><li>  D2：建立团队</li><li>  D3：抑制问题</li><li>  D4：调查与根源识别</li><li>  D5：纠正问题的措施</li><li>  D6：预防问题的措施</li><li>  D7：实施与评估</li><li>  D8：可持续性评估</li></ul><h1 id="精益工具"><a href="#精益工具" class="headerlink" title="精益工具"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/#%E7%B2%BE%E7%9B%8A%E5%B7%A5%E5%85%B7" title="精益工具"></a>精益工具</h1><p>工具是对事物的相对简单的抽象。工具可以被方法论调用。</p><p>精益工具主要有：</p><ul><li>  流图 Flow Chart</li><li>  柏拉图</li><li>  鱼骨图</li><li>  五个为什么</li><li>  控制图</li><li>  箱体图</li><li>  主效应图</li></ul><p>特别说一下五个为什么。问为什么的三个角度：</p><ul><li>  为什么故障会发生？</li><li>  为什么故障没有被检测到？</li><li>  系统中有什么漏洞？</li></ul><p>精益工具可以在敏捷软件开发中有选择的使用。</p><p>精益解决方案（模式）</p><p>模式是方法论的产物，是针对特定场景的解决方案。</p><p>5S</p><ul><li>  Sort 分类</li><li>  Set in order 排序</li><li>  Shine 清扫</li><li>  Standardize 标准化</li><li>  Sustain 持续</li></ul><p>目视化管理的三个层次</p><ul><li>  Visual order 可视化顺序。</li><li>  Visual display 可视化展示。</li><li>  Visual control 可视化控制。</li></ul><p>创建一件流的步骤</p><ul><li>  化身为物。</li><li>  让它流动。</li><li>  持续流动。</li></ul><p>标准化的原因：</p><ul><li>  不稳定制造了浪费，并且阻碍了改善。</li></ul><p>标准化在改善循环中的地位</p><ul><li>  标准化-〉暴露问题-〉解决问题-〉实施新方法</li></ul><p>节拍时间</p><ul><li>  有效工作时间/需求数量。</li></ul><p>标准工作三要素</p><ul><li>  周期时间</li><li>  工作顺序</li><li>  在制品数量</li></ul><p>防呆法</p><ul><li>  例如，能够使用下拉菜单的，就不要让用户填写。</li></ul><p>快速换模</p><ul><li>  持续构建是快速换模思想的体现。</li></ul><p>精益当中的解决方案或模式，并不能直接运用到软件开发中，但仍然可以给我们很多启示。</p><p>重温一下精益知识体系的四层：思想，方法，工具，模式。这种思维体系本身也与我们的敏捷教练基本功相一致：我们要掌握敏捷的核心思想，通过教练方法，调动教练工具，来生成和普及 Scrum 模式。</p><h1 id="精益三纲八目"><a href="#精益三纲八目" class="headerlink" title="精益三纲八目"></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/#%E7%B2%BE%E7%9B%8A%E4%B8%89%E7%BA%B2%E5%85%AB%E7%9B%AE" title="精益三纲八目"></a>精益三纲八目</h1><p><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/%E7%B2%BE%E7%9B%8A%E4%B8%89%E7%BA%B2%E5%85%AB%E7%9B%AE.jpg"><img src="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/%E7%B2%BE%E7%9B%8A%E4%B8%89%E7%BA%B2%E5%85%AB%E7%9B%AE.jpg"></a></p><p>最后，按照精益三纲八目的结构做一下总结。</p><h2 id="精益当中最重要的三条思想，成为精益三纲："><a href="#精益当中最重要的三条思想，成为精益三纲：" class="headerlink" title="精益当中最重要的三条思想，成为精益三纲："></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/#%E7%B2%BE%E7%9B%8A%E5%BD%93%E4%B8%AD%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E4%B8%89%E6%9D%A1%E6%80%9D%E6%83%B3%EF%BC%8C%E6%88%90%E4%B8%BA%E7%B2%BE%E7%9B%8A%E4%B8%89%E7%BA%B2%EF%BC%9A" title="精益当中最重要的三条思想，成为精益三纲："></a>精益当中最重要的三条思想，成为精益三纲：</h2><ul><li>  从内在的生存动机来说：适者生存，持续改善，更高标准</li><li>  从客户价值来说：专注价值，消除浪费</li><li>  从方法来说：身临现场，科学方法，快速反馈</li></ul><p>敏捷转型，需要企业上下对这三点有一致的认知。</p><h2 id="而实现这三条思想的具体方法，可归类为八种，成为八目："><a href="#而实现这三条思想的具体方法，可归类为八种，成为八目：" class="headerlink" title="而实现这三条思想的具体方法，可归类为八种，成为八目："></a><a href="https://www.expectfly.com/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/#%E8%80%8C%E5%AE%9E%E7%8E%B0%E8%BF%99%E4%B8%89%E6%9D%A1%E6%80%9D%E6%83%B3%E7%9A%84%E5%85%B7%E4%BD%93%E6%96%B9%E6%B3%95%EF%BC%8C%E5%8F%AF%E5%BD%92%E7%B1%BB%E4%B8%BA%E5%85%AB%E7%A7%8D%EF%BC%8C%E6%88%90%E4%B8%BA%E5%85%AB%E7%9B%AE%EF%BC%9A" title="而实现这三条思想的具体方法，可归类为八种，成为八目："></a>而实现这三条思想的具体方法，可归类为八种，成为八目：</h2><ul><li><p>  因业果关系：偏因的鱼骨图，五个为什么，柏拉图；偏果的关系图，箱体图，主效应图，控制图；偏解决方案的流图。</p></li><li><p>  结构化上升：PDCA，A3，DMAIC，DMADV</p></li><li><p>  可视化：价值流图</p></li><li><p>  简化：5S，防呆法，单元式布局，快速换模，全面生产维护，逐层过程审核，纸芝居</p></li><li><p>  流：价值流图，3M，八大浪费，一件流，看板，反思，分享</p></li><li><p>  均衡化：3M，产线均衡</p></li><li><p>  标准化：标准化，标准作业</p></li><li><p>  稳定化：节拍时间</p></li></ul><p>这八类方法的每一类，都体现着一种智慧。大部分都可以运用到敏捷中。</p><p>本文提供了两种理解精益的思路，思想-方法-工具-模式和三纲八目。这是对精益知识体系的完整概括。其中很多可以通过常识思考和理解运用。更深入的了解，参看第一章推荐的书目。</p></blockquote><blockquote><ul><li>  <strong>本文作者：</strong> joni@efbiz.org</li><li>  <strong>本文链接：</strong> <a href="https://github.com/efbiz/2018/05/14/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/">https://github.com/efbiz/2018/05/14/敏捷教练第05课-储备-精益体系精要/</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;精益是敏捷的重要来源，敏捷对精益作了继承和发扬。&lt;/p&gt;
&lt;p&gt;精益的体系浩繁，本文按4＊2的结构进行介绍，即从思想、方法、模式和工具四个层面对精益进行介绍，并在四个层面分别谈及在敏捷中的体现和运用。最后用三纲八目的结构，总结精益中最重要的三个思想</summary>
      
    
    
    
    <category term="Scrum" scheme="http://zhangyu.info/categories/Scrum/"/>
    
    
    <category term="Scrum" scheme="http://zhangyu.info/tags/Scrum/"/>
    
  </entry>
  
  <entry>
    <title>敏捷教练第08课-技巧-敏捷教练的六脉神剑（下）</title>
    <link href="http://zhangyu.info/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://zhangyu.info/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2022-04-11T16:00:00.000Z</published>
    <updated>2022-04-12T02:07:19.557Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>敏捷教练的六脉神剑针对敏捷团队的工作方式提供了六个不同的教练角度，前三剑针对的是更基本的场景，后三剑针对的是更特定的场景。敏捷教练需要对六个角度谙熟于胸，并针对不同的场景混合运用。大多数情况下，场景是可预测的，可以以六脉神剑为基础，制定自己的脚本和台词。在每一次的教练行为中，目的是第一位的，首先是确定目的，然后才是确定方法。除了每一次教练行为的设计，还要对团队完整工作周期的教练计划进行设计。敏捷基础与六脉神剑是设计的基石。</p><p><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91.jpg"><img src="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91.jpg"></a></p><p>对六脉神剑还可以做另一角度的分类理解，即主动型和应对型。主动型即主动主导的行为，应对型即当一个情况发生时的应对行为。从这个角度看，指导、协助、讲授和协作指挥更多是主动型的行为，问题解决和冲突导航更多是应对型的行为。但主动的行为也可能是由场景触发，而应对的行为也需要有预案和主动探询。主动的行为更多是前馈，应对的行为更多是反馈。主动的行为更多发生在正式的仪式中，应对的行为则更多在日常随机发生。主动和应对都需要计划和练习。</p><p>这一章的使用方法跟上一章的使用方法一样，提供的是凝聚了前人智慧的检查列表，可以作为我们大脑的扩展。使用时，首先是事先学习，设想在教练工作中可能遇到的场景，针对每一场景可以有什么样的预案。第二是，在每一活动前，根据这些检查列表，制定自己的剧本或脚本，以便在活动中使用。第三是事后回顾，在每一活动之后，再来阅读这些检查列表，什么事自己做得好，什么事还可以做得更好。经过反复演练这三步使用，把这些方法内化成自己的方法，并能进行扩展和创新。</p><h1 id="第四剑：问题解决"><a href="#第四剑：问题解决" class="headerlink" title="第四剑：问题解决"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/#%E7%AC%AC%E5%9B%9B%E5%89%91%EF%BC%9A%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3" title="第四剑：问题解决"></a>第四剑：问题解决</h1><p><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91.jpg"><img src="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91.jpg"></a></p><h2 id="敏捷问题解决规则"><a href="#敏捷问题解决规则" class="headerlink" title="敏捷问题解决规则"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/#%E6%95%8F%E6%8D%B7%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%A7%84%E5%88%99" title="敏捷问题解决规则"></a>敏捷问题解决规则</h2><ul><li>  一个问题引起了你的注意，或者你觉察到了一个问题。这个问题可能来自观察，也可能来自团队的反馈。</li><li>  暂停一下，思考该问题，把问题看清楚。问题的真相和本质是什么。</li><li>  团队拥有对问题的最多理解，并且对问题的解决负有责任，教练的责任是协助团队，把团队纳入问题解决和变成问题解决者。</li><li>  允许团队应对解决或者不应对。解决问题以及是否制定计划和采取行动是团队的决定和承诺。</li><li>  传授解决问题的框架，让团队成为解决问题者，是教练的目的。</li></ul><h2 id="发现与寻找问题"><a href="#发现与寻找问题" class="headerlink" title="发现与寻找问题"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/#%E5%8F%91%E7%8E%B0%E4%B8%8E%E5%AF%BB%E6%89%BE%E9%97%AE%E9%A2%98" title="发现与寻找问题"></a>发现与寻找问题</h2><ul><li>  要抵制立即解决问题的诱惑。除非人的基本尊严受到侵犯，对于其他情况，并不需要立即处理。</li><li>  识别是否是真实的问题。不为虚拟的问题进行虚拟的讨论。</li><li>  流程层面的问题：我们在敏捷方面做得如何？可以采用敏捷成熟度或健康度检查列表，推荐 Mike Cohn 的敏捷成熟度模型和 Spotify 的敏捷健康度检查。成熟度或健康检查中，对问题的评估只是个触发，团队的对话才是最有价值的部分。</li><li>  质量和绩效问题：团队如何可以做得更好？通过制定完成的定义，并在每个计划会上完善，在每个评审会上检查，来持续提升质量。</li><li>  团队的动态问题：团队如何可以变成一个更好的团队？</li></ul><h3 id="扩展：团队动态问题之艾伦-布劳恩的团队动态调查"><a href="#扩展：团队动态问题之艾伦-布劳恩的团队动态调查" class="headerlink" title="扩展：团队动态问题之艾伦-布劳恩的团队动态调查"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/#%E6%89%A9%E5%B1%95%EF%BC%9A%E5%9B%A2%E9%98%9F%E5%8A%A8%E6%80%81%E9%97%AE%E9%A2%98%E4%B9%8B%E8%89%BE%E4%BC%A6-%E5%B8%83%E5%8A%B3%E6%81%A9%E7%9A%84%E5%9B%A2%E9%98%9F%E5%8A%A8%E6%80%81%E8%B0%83%E6%9F%A5" title="扩展：团队动态问题之艾伦-布劳恩的团队动态调查"></a>扩展：团队动态问题之艾伦-布劳恩的团队动态调查</h3><ul><li>  在团队每天的交互中有多少幽默的成分？</li><li>  在出现困难和高压时，团队最初的行为是什么？</li><li>  团队成员出现抵触情绪有多么频繁？</li><li>  当团队成员有抵触情绪时，他们之间多久会进行一次充分的讨论？</li><li>  基于团队规范，在平常的交互中团队成员做出妥协有多频繁？</li><li>  任何一位团队成员向任何其他一位团队成员能提供什么样的反馈意见？</li><li>  任何一位团队成员向任何其他一位团队成员真正提出了什么样的反馈意见？</li><li>  一位团队成员与另一位团队成员讨论你的绩效和行为，而不是直接向你或者在第三方在场的情况下提供反馈意见，可能性有多大。</li><li>  就个人的职业目标而言，你从团队中得到了多大程度的支持？</li><li>  在处理一个工作问题时，需要承认有问题并需要请求团队成员帮助，这种情况有多少？</li><li>  当你向团队分享个人信息时，你感受到攻击的可能性有多大？</li><li>  当一个问题可能引发团队内部的冲突或争论时，团队有多大可能性把这个问题带到团队中讨论？</li><li>  当一个问题可能有很多个冲突点时，你有多大可能把这个问题带到团队中讨论？</li><li>  如果一个工作项可能引发很多不同的冲突，你把它带到了团队中，并且团队达成了可行的共识，这种可能性有多大？</li><li>  在过去两个工作日中，你能举一个例子说明你在团队中感受到温暖和包容吗？</li><li>  在过去两个工作日中，你能举一个例子说明你在团队中感受到被轻视或排斥吗？</li><li>  团队在多大程度上让你觉得你对自己的工作是负责的？</li></ul><h3 id="扩展：团队动态问题之-BART（边界、权力、角色、任务）分析"><a href="#扩展：团队动态问题之-BART（边界、权力、角色、任务）分析" class="headerlink" title="扩展：团队动态问题之 BART（边界、权力、角色、任务）分析"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/#%E6%89%A9%E5%B1%95%EF%BC%9A%E5%9B%A2%E9%98%9F%E5%8A%A8%E6%80%81%E9%97%AE%E9%A2%98%E4%B9%8B-BART%EF%BC%88%E8%BE%B9%E7%95%8C%E3%80%81%E6%9D%83%E5%8A%9B%E3%80%81%E8%A7%92%E8%89%B2%E3%80%81%E4%BB%BB%E5%8A%A1%EF%BC%89%E5%88%86%E6%9E%90" title="扩展：团队动态问题之 BART（边界、权力、角色、任务）分析"></a>扩展：团队动态问题之 BART（边界、权力、角色、任务）分析</h3><h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/#%E8%A7%92%E8%89%B2" title="角色"></a>角色</h4><ul><li>  在你的敏捷框架中，所有正式定义的角色都有人员各就其位吗？</li><li>  是否所有正式定义的角色都在角色边界之内运作良好？</li><li>  是否有人承担的正式角色多于一个？</li><li>  如果团队增加了额外的角色，这些角色的描述是否充分和清晰？</li></ul><h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/#%E4%BB%BB%E5%8A%A1" title="任务"></a>任务</h4><ul><li>  团队成员对于他们的团队目标是否清晰？</li><li>  是否有为了完成团队目标所需的所有不同任务？</li><li>  人们从先前相似的情况中引入了什么样的历史和过去的经验？</li></ul><h4 id="权力"><a href="#权力" class="headerlink" title="权力"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/#%E6%9D%83%E5%8A%9B" title="权力"></a>权力</h4><ul><li>  对于每一个角色，它的权力是否被清晰地制定，并被所有人理解和支持？</li><li>  团队成员是否在适当地行使权力？</li></ul><h4 id="边界"><a href="#边界" class="headerlink" title="边界"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/#%E8%BE%B9%E7%95%8C" title="边界"></a>边界</h4><ul><li>  人们是否在被赋予的敏捷角色的权力边界内工作？</li><li>  在迭代期间，团队成员如何赋予另一个团队成员获取任务的权力？</li><li>  在团队中各种各样势力的边界的什么？</li></ul><h2 id="清楚地看待与思考问题"><a href="#清楚地看待与思考问题" class="headerlink" title="清楚地看待与思考问题"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/#%E6%B8%85%E6%A5%9A%E5%9C%B0%E7%9C%8B%E5%BE%85%E4%B8%8E%E6%80%9D%E8%80%83%E9%97%AE%E9%A2%98" title="清楚地看待与思考问题"></a>清楚地看待与思考问题</h2><ul><li>  留到第二天解决：让脑子放轻松，看看第二天起床的时候是否已经有了答案，也许一些更深入的事情或者重现敏捷本质的事情会出现。</li><li>  向自己提问：如果在这个世界上我可以做任何事情，这个事情是什么？这里的风险是什么？如果这个情况已经很好地解决了，解决后的情况会是什么样的？</li><li>  与另一位教练结队：从一位旁观者的角度得到建议，或者一些挑战性的问题。</li><li>  直奔源头：复习敏捷宣言及其背后的十二条原则。</li></ul><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/#%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98" title="解决问题"></a>解决问题</h2><ul><li>  直接解决它：说出你看到的症状，抛出你的假设，询问团队，对于这个问题，他们想要做什么。</li><li>  重申敏捷的含义：例如，对于每个会议的目的和流程，重回 Scrum 指南。</li><li>  揭示体系本身：把团队比作一个生态体系而不是机器，通过观察和探究揭示这个系统本身，并向团队分享。</li><li>  善用回顾：让团队以不同的角度思考他们一起工作得如何。</li><li>  增加一种启示方法：例如，增加一面痛苦墙，让团队把遇到的痛苦记录下来。</li></ul><h1 id="第五剑：冲突领航"><a href="#第五剑：冲突领航" class="headerlink" title="第五剑：冲突领航"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/#%E7%AC%AC%E4%BA%94%E5%89%91%EF%BC%9A%E5%86%B2%E7%AA%81%E9%A2%86%E8%88%AA" title="第五剑：冲突领航"></a>第五剑：冲突领航</h1><h2 id="冲突中敏捷教练的角色"><a href="#冲突中敏捷教练的角色" class="headerlink" title="冲突中敏捷教练的角色"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/#%E5%86%B2%E7%AA%81%E4%B8%AD%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E8%A7%92%E8%89%B2" title="冲突中敏捷教练的角色"></a>冲突中敏捷教练的角色</h2><ul><li>  敏捷团队要长期在一起，冲突解决尤为重要。</li><li>  教练需要帮助团队排除冲突，提供解决冲突的方法、指南和框架。</li><li>  教练需认真决定是否要、何时及如何介入冲突管理。</li></ul><h2 id="冲突的五个级别："><a href="#冲突的五个级别：" class="headerlink" title="冲突的五个级别："></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/#%E5%86%B2%E7%AA%81%E7%9A%84%E4%BA%94%E4%B8%AA%E7%BA%A7%E5%88%AB%EF%BC%9A" title="冲突的五个级别："></a>冲突的五个级别：</h2><ul><li>  第一级，解决问题。人们有不同的意见，也许误解已经出现，目标与价值的冲突也可能存在，并且团队对于这种冲突的氛围感到焦虑。在这一级里，团队关注问题解决，信息分享和协作流畅，语言是开放和基于事实的。</li><li>  第二级，争执。自我保护变得跟解决问题一样重要。团队成员之间产生距离感，壁垒在强化。个人保护胜过协作，语言是戒备的但允许解释。</li><li>  第三级，争辩。在第三级，目标就是赢得胜利。多个问题汇聚成更大的问题，在这个存在误解的环境中出现派系。问题和人成了同义词，人们已经不能只对事不对人。胜利重于解决，语言中包含个人攻击。</li><li>  第四级，圣战。人们相信，唯一的选择就是让对手退出。保护自己的族群成了焦点，语言呈现出意识形态的特征，而不是针对具体的问题和实事。</li><li>  第五级，世界大战。毁灭是这一级的战斗宣言，胜利已经不够了，对手必须输。很少或没有语言交流，唯一的目的是摧毁对方。</li></ul><h2 id="确定团队的冲突级别"><a href="#确定团队的冲突级别" class="headerlink" title="确定团队的冲突级别"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/#%E7%A1%AE%E5%AE%9A%E5%9B%A2%E9%98%9F%E7%9A%84%E5%86%B2%E7%AA%81%E7%BA%A7%E5%88%AB" title="确定团队的冲突级别"></a>确定团队的冲突级别</h2><ul><li>  聆听抱怨：带着同情心去聆听，接受抱怨者所说的事情，让抱怨者知道你在关心他，并正在花时间了解冲突的方方面面。</li><li>  感受活力：大家是在充满活力地协作？还是彼此梳理漠视？团队的精气神是积极向上，还是消极冷漠？</li><li>  关注语言：通过大家说什么和如何说，判断团队的冲突级别。</li></ul><h3 id="扩展：冲突级别与语言"><a href="#扩展：冲突级别与语言" class="headerlink" title="扩展：冲突级别与语言"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/#%E6%89%A9%E5%B1%95%EF%BC%9A%E5%86%B2%E7%AA%81%E7%BA%A7%E5%88%AB%E4%B8%8E%E8%AF%AD%E8%A8%80" title="扩展：冲突级别与语言"></a>扩展：冲突级别与语言</h3><ul><li>  第一级，团队成员开放且建设性地参与冲突。语言例如：我听到你说了，但我认为你忘记了一个事实；我知道你的想法，但我不同意，因为。。。</li><li>  第二级，对话变得偏于自我保护。语言例如：是的，我是弄坏了这个构建，但在我们团队中有比这更严重的问题。</li><li>  第三级，扭曲的语言出现了。例如：他们总是走捷径，他经常控制每一次对话。</li><li>  第四级，变得更加主观。例如：他们永远不会改变，我们是对的。</li><li>  第五级，充满了斗争。例如：要么是我们，要么是你们，我们必须赢。</li></ul><h2 id="应对冲突"><a href="#应对冲突" class="headerlink" title="应对冲突"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/#%E5%BA%94%E5%AF%B9%E5%86%B2%E7%AA%81" title="应对冲突"></a>应对冲突</h2><ul><li>  首先，什么也不做。在决定干预之前，花一些时间观察团队的行为，看他们在处理冲突上是否有进步。</li><li>  分析和应对，考虑以下问题：冲突的级别是什么？问题是什么？作为 A 方，我该如何回应？作为 B 方，我该如何回应？有哪些分解冲突的选择？如果有什么我应该做的话，那会是什么？</li><li>  使用架构：使用敏捷的精髓如原则、价值观和角色定义来排除冲突。平衡任务导向和人际关系导向。</li><li>  揭示模型：揭示冲突层次模型，邀请团队加入对话，探讨如何降低冲突级别。</li></ul><h3 id="扩展：冲突应对模式"><a href="#扩展：冲突应对模式" class="headerlink" title="扩展：冲突应对模式"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/#%E6%89%A9%E5%B1%95%EF%BC%9A%E5%86%B2%E7%AA%81%E5%BA%94%E5%AF%B9%E6%A8%A1%E5%BC%8F" title="扩展：冲突应对模式"></a>扩展：冲突应对模式</h3><ul><li>  第一级，解决问题。协作寻求双赢，了解每位团队成员的想法，达成共识。</li><li>  第二级，争执。允许对方解决问题，任何事情以心理安全为基础。</li><li>  第三级，争辩。关系比问题本身更重要，先接受对方的观点。对于可以分解的问题，进行交涉。收集数据，建立事实。</li><li>  第四级，圣战。再次构建安全框架，居间传递想法，降低冲突级别。</li><li>  第五级，世界大战。做任何必要的事情防止大家受到伤害。</li></ul><h2 id="化解团队成员之间的抱怨"><a href="#化解团队成员之间的抱怨" class="headerlink" title="化解团队成员之间的抱怨"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/#%E5%8C%96%E8%A7%A3%E5%9B%A2%E9%98%9F%E6%88%90%E5%91%98%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8A%B1%E6%80%A8" title="化解团队成员之间的抱怨"></a>化解团队成员之间的抱怨</h2><ul><li>  第一，建议抱怨者跟被抱怨者直接提及顾虑和感受。</li><li>  第二，跟抱怨者一起找被抱怨者交流。</li><li>  第三，征得同意，居间转告抱怨。</li><li>  如果这三招都不灵的话，最后一招是：不再把它作为一个问题。</li></ul><h2 id="面对无法解决的冲突"><a href="#面对无法解决的冲突" class="headerlink" title="面对无法解决的冲突"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/#%E9%9D%A2%E5%AF%B9%E6%97%A0%E6%B3%95%E8%A7%A3%E5%86%B3%E7%9A%84%E5%86%B2%E7%AA%81" title="面对无法解决的冲突"></a>面对无法解决的冲突</h2><ul><li>  敏捷团队是亲密的。增加团队成员之间的良性互动，而不是关注于解开并解决问题。优秀团队中积极交互与消极交互的比例是三比一到五比一。</li><li>  避免误解形成。团队学习聆听和互相关注。</li><li>  确认允诺和共识。确认所有的声音都被听到，并显式确认允诺和共识。</li><li>  利用共享愿景：尽管团队通常是由经理们创建并通告团队的，团队在一起也没什么共同梦想，但团队依然可以围绕产品和项目生成共同愿景。</li></ul><h2 id="关于冲突的最后招式"><a href="#关于冲突的最后招式" class="headerlink" title="关于冲突的最后招式"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/#%E5%85%B3%E4%BA%8E%E5%86%B2%E7%AA%81%E7%9A%84%E6%9C%80%E5%90%8E%E6%8B%9B%E5%BC%8F" title="关于冲突的最后招式"></a>关于冲突的最后招式</h2><ul><li>  了解冲突框架，选择应对方式，处理抱怨和增加团队的积极性，这些技术自身并不能解决冲突。</li><li>  只有这些技能和思维方式在团队的行动中得到体现时，神奇才会发生。</li><li>  保持对话的基础存在，冲突才有被解决的可能。</li></ul><h1 id="第六剑：协作指挥"><a href="#第六剑：协作指挥" class="headerlink" title="第六剑：协作指挥"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/#%E7%AC%AC%E5%85%AD%E5%89%91%EF%BC%9A%E5%8D%8F%E4%BD%9C%E6%8C%87%E6%8C%A5" title="第六剑：协作指挥"></a>第六剑：协作指挥</h1><p><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/%E5%8D%8F%E4%BD%9C%E6%8C%87%E6%8C%A5.jpg"><img src="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/%E5%8D%8F%E4%BD%9C%E6%8C%87%E6%8C%A5.jpg"></a></p><h2 id="从合作到协作"><a href="#从合作到协作" class="headerlink" title="从合作到协作"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/#%E4%BB%8E%E5%90%88%E4%BD%9C%E5%88%B0%E5%8D%8F%E4%BD%9C" title="从合作到协作"></a>从合作到协作</h2><ul><li>  合作的效果是各个部分之和。而协作是整体大于个体之和。</li><li>  对于不需要创造性的活动，可以只合作不协作。</li><li>  协作是以合作为基础，但增加了产生创造性、突破性和意想不到结果的重要元素。</li><li>  在协作中，每个人都会在他人想法的基础上思考，敢于分享和评议，让那些更好的、个人无法独创的想法浮现。</li><li>  在协作之前先形成合作，每个人集中精力演奏好自己的乐器。</li><li>  教练作为协作指挥者，加入沉默的人员一方，消除高声音者的优势，鼓励每个人变得更自信。</li><li>  让团队通过不断练习，达到不需要指挥者的境界。</li></ul><h2 id="培养协作个体"><a href="#培养协作个体" class="headerlink" title="培养协作个体"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/#%E5%9F%B9%E5%85%BB%E5%8D%8F%E4%BD%9C%E4%B8%AA%E4%BD%93" title="培养协作个体"></a>培养协作个体</h2><ul><li>  传授他们合作技巧：建立响应能力，沉默即暗示同意，运用否决权，寻找其它方案，反思有意识意图与无意识意图，带着同情心说出真相。</li><li>  引导他们提前准备：在协作活动时提前做好准备，例如，在每日站会时身心都准时到达。</li><li>  鼓励他们表现自我：培养自我价值，但排除虚荣心。</li><li>  建立协作态度：对自己的生活环境负责，而不是把责任推给他人；不设防，而不是有保留地进行响应；坦然响应，而不是在需要响应时感到威胁；尝试双赢，而不是防御；寻找解决方法，而不是泾渭分明反应强烈；劝说而不是责备；坚定而不是对抗；既考虑长期也考虑短期；对他人观点感兴趣；欢迎反馈；把冲突看成人类环境的天然成分；平静而直接地谈论艰难的问题；为自己的行为后果负责；持续寻求更深层次的理解；传达关切的态度；寻求卓越；聆听。</li></ul><h2 id="培养团队的协作肌肉"><a href="#培养团队的协作肌肉" class="headerlink" title="培养团队的协作肌肉"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/#%E5%9F%B9%E5%85%BB%E5%9B%A2%E9%98%9F%E7%9A%84%E5%8D%8F%E4%BD%9C%E8%82%8C%E8%82%89" title="培养团队的协作肌肉"></a>培养团队的协作肌肉</h2><ul><li>  说出不能说的话：敢于暴露弱点，遇到困难时可以求助。</li><li>  建立而不是打压想法：对过失展示容忍，制止运用惩罚，讨论和接纳不同的观点产生合力。</li><li>  听所有的声音：提升安静的成员并抑制占优势的成员。</li><li>  培养协作中的亲密关系：团队成员能够感知其他人对新素材的理解程度，迅速介入澄清，使团队级别的理解更快地达成。</li><li>  一起认真做游戏：例如计划纸牌。</li><li>  不断提醒他们直到会用。</li></ul><h2 id="揭示协作的真谛"><a href="#揭示协作的真谛" class="headerlink" title="揭示协作的真谛"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/#%E6%8F%AD%E7%A4%BA%E5%8D%8F%E4%BD%9C%E7%9A%84%E7%9C%9F%E8%B0%9B" title="揭示协作的真谛"></a>揭示协作的真谛</h2><ul><li>  要创新，协作不是唯一的方法，但它是最直接的方法。</li><li>  协作发生在当下，只有当你这样做时，它才存在。</li><li>  要协作，必须了解你和你的协作同伴为汇聚带来了什么。</li><li>  对你的工作充满热情是协作的前提。</li><li>  如果你遇到一个问题，需要别人做出改变，那么你尚未真正了解你的问题。</li></ul></blockquote><blockquote><ul><li>  <strong>本文作者：</strong> joni@efbiz.org</li><li>  <strong>本文链接：</strong> <a href="https://github.com/efbiz/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89">https://github.com/efbiz/2018/05/23/敏捷教练第08课-技巧-敏捷教练的六脉神剑（下）</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;敏捷教练的六脉神剑针对敏捷团队的工作方式提供了六个不同的教练角度，前三剑针对的是更基本的场景，后三剑针对的是更特定的场景。敏捷教练需要对六个角度谙熟于胸，并针对不同的场景混合运用。大多数情况下，场景是可预测的，可以以六脉神剑为基础，制定自己的脚本和</summary>
      
    
    
    
    <category term="Scrum" scheme="http://zhangyu.info/categories/Scrum/"/>
    
    
    <category term="Scrum" scheme="http://zhangyu.info/tags/Scrum/"/>
    
  </entry>
  
  <entry>
    <title>敏捷教练第09课-技巧-敏捷教练的提升三式</title>
    <link href="http://zhangyu.info/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/"/>
    <id>http://zhangyu.info/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/</id>
    <published>2022-04-11T16:00:00.000Z</published>
    <updated>2022-04-12T02:19:55.574Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在经历了四种心法和六脉神剑的修炼之后，敏捷教练的路还要往前走。本文介绍敏捷教练的提升三式：</p><ul><li>  成败模式</li><li>  技能清单</li><li>  教练之旅</li></ul><p><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F.jpg"><img src="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F.jpg"></a></p><h1 id="提升第一式：成败模式"><a href="#提升第一式：成败模式" class="headerlink" title="提升第一式：成败模式"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/#%E6%8F%90%E5%8D%87%E7%AC%AC%E4%B8%80%E5%BC%8F%EF%BC%9A%E6%88%90%E8%B4%A5%E6%A8%A1%E5%BC%8F" title="提升第一式：成败模式"></a>提升第一式：成败模式</h1><p>本节介绍敏捷教练失败的种种陷阱，和成功的许多要素。注意在教练过程中的错误模式，并有意识地选择不掉进它的陷阱里。越少掉进失败模式的陷阱，你就越有时间注意到你在指导过程中出现的好的事情，即成功模式。</p><p><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/%E5%A4%B1%E8%B4%A5%E6%A8%A1%E5%BC%8F.jpg"><img src="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/%E5%A4%B1%E8%B4%A5%E6%A8%A1%E5%BC%8F.jpg"></a></p><h2 id="敏捷教练的失败模式"><a href="#敏捷教练的失败模式" class="headerlink" title="敏捷教练的失败模式"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/#%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%A4%B1%E8%B4%A5%E6%A8%A1%E5%BC%8F" title="敏捷教练的失败模式"></a>敏捷教练的失败模式</h2><ul><li>  侦探。花不多不少的时间观察团队，然后便生成并带着下次回顾会议的话题，消失在黑暗中。</li><li>  海鸥。猛然扎进站会中，用善意的观察和建议冲击整个团队，然后便飞走。</li><li>  武断者。经常表达各种观点，固执己见，不惜放弃指导团队进行有意义的讨论所需要的客观性。</li><li>  行政人员。通过充当不必要的会议后勤、访问权限申请和其他行政事务的中间人来削弱团队的自主权。</li><li>  轴心。充当团队成员间所有交流的中心，并进行任务层面的协调。</li><li>  蝴蝶。在一个个团队周围掠过，停留的时间仅够传授一滴慧珠或提出一个富于哲理的问题。</li><li>  专家。深入地进入团队工作的细节中，以致因为树太多而不见森林。</li><li>  唠叨者。好心地提醒团队开始站立会议、更新状态墙、按时完成承诺的任务等。</li></ul><h2 id="失败模式的来源"><a href="#失败模式的来源" class="headerlink" title="失败模式的来源"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/#%E5%A4%B1%E8%B4%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%9D%A5%E6%BA%90" title="失败模式的来源"></a>失败模式的来源</h2><ul><li>  失败模式起源于教练的自负或持续的局部关注。</li><li>  当以我为主的想法无节制地蔓延时，就会很容易地转化为以我为中心的状况。</li><li>  以我为中心，就不能给团队留出足够的空间来领会可能发生的变化、提出新的观点，让他们意识到能够真正做到多好。</li><li>  当敏捷教练指导多个团队或因为其他情况分散精力时，通常就会出现持续局部关注的现象。</li></ul><h2 id="从失败模式中恢复"><a href="#从失败模式中恢复" class="headerlink" title="从失败模式中恢复"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/#%E4%BB%8E%E5%A4%B1%E8%B4%A5%E6%A8%A1%E5%BC%8F%E4%B8%AD%E6%81%A2%E5%A4%8D" title="从失败模式中恢复"></a>从失败模式中恢复</h2><ul><li>  方法很简单：用信任取代担心。</li><li>  要对团队成员寄予信任，相信他们真正知道去做正确的事情。如果他们失败了，也会从中吸取教训并变得更强大。</li><li>  敏捷方法的框架中有各种内置的机制来帮助你拥有信任感，因为他们鼓励和容许犯错误。固定时长的短迭代确保大家不会失利得太远或者造成影响深远的后果。</li><li>  关注团队中真正发生的事情和试图发生的事情。</li><li>  信任加关注就是好的教练方法的基础。</li><li>  培养觉知。让头脑中的噪音沉寂，以便能够思考，和可以进行清楚的观察。为自己的头脑腾出一些空间，有意识地对自己进行调整，以了解团队所需的东西而不是自己内心发生的东西。</li><li>  保持好奇。对团队正在进行的事产生好奇，并产生清晰理解。</li><li>  拓展视角。在一个更大的时间轴和更宽的框架内看团队的当前状况，团队的缺陷就只是一片有趣多变的环境中闪现的一个略带瑕疵的小点。回到团队的共享愿景宣言：同饮同甘共苦之水。精神振奋，让不良片刻远离。</li><li>  结对合作。当你感觉到失败模式在控制你时，与同侪结对。他们协助你重申目标，牢记于心，把以自我为中心的想法抛到一边，聚焦于你的关注，并准备用信任的心态进行指导。</li><li>  练习成功。成功需要练习。自我提炼或借用他人的成功模式，不断练习，直到你对它们的感觉比失败模式还要自然。</li></ul><h2 id="敏捷教练的成功模式"><a href="#敏捷教练的成功模式" class="headerlink" title="敏捷教练的成功模式"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/#%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%88%90%E5%8A%9F%E6%A8%A1%E5%BC%8F" title="敏捷教练的成功模式"></a>敏捷教练的成功模式</h2><ul><li>  魔术师：问这样的问题，看看什么东西在那里，但刚才看不见。</li><li>  儿童型：诚恳又惊讶地问为什么，并对生活和其中的一切有永不满足的好奇心。</li><li>  长耳朵：听所有的东西，但不响应所有听到的，以给别人发展的空间。</li><li>  好质问者：以轻松有趣和稍微失衡的方式，把别人从自满中摇醒。</li><li>  大智若愚者：提出粗浅的问题来启发大家。</li><li>  蔓延的葡萄藤：通过团队基本感觉不到的小步移动，无情地将团队一点一点拉回敏捷的核心。</li><li>  梦想家：勇敢地说出未来可能创造出来的东西。</li><li>  扩音器：确保所有的声音都被听到，特别是被压抑的声音。</li></ul><h1 id="提升第二式：技能清单"><a href="#提升第二式：技能清单" class="headerlink" title="提升第二式：技能清单"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/#%E6%8F%90%E5%8D%87%E7%AC%AC%E4%BA%8C%E5%BC%8F%EF%BC%9A%E6%8A%80%E8%83%BD%E6%B8%85%E5%8D%95" title="提升第二式：技能清单"></a>提升第二式：技能清单</h1><p>敏捷教练之路没有终点。敏捷教练只是在不断学习并把各种新的技能汇集到我们的指导过程中，为我们团队的辉煌而努力。本节提供了一些线路标志来帮助你在敏捷教练之旅中确定方位。这些标志符即敏捷指导的技能和行为，可表明你仍然处于通向好的敏捷教练的诸多途径之上。</p><p><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/%E6%8A%80%E8%83%BD%E6%B8%85%E5%8D%95.jpg"><img src="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/%E6%8A%80%E8%83%BD%E6%B8%85%E5%8D%95.jpg"></a></p><h2 id="技能之缓慢地灌输敏捷实践"><a href="#技能之缓慢地灌输敏捷实践" class="headerlink" title="技能之缓慢地灌输敏捷实践"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/#%E6%8A%80%E8%83%BD%E4%B9%8B%E7%BC%93%E6%85%A2%E5%9C%B0%E7%81%8C%E8%BE%93%E6%95%8F%E6%8D%B7%E5%AE%9E%E8%B7%B5" title="技能之缓慢地灌输敏捷实践"></a>技能之缓慢地灌输敏捷实践</h2><ul><li>  帮助团队从敏捷实践中收到预期的收益。</li><li>  在考虑产品构造方案，决定其如何相互协作时，团队能够坚持从敏捷宣言价值观和原则出发。</li><li>  在改变敏捷实践时，确保敏捷宣言和检查调整环路完整无缺，并视之为团队至关重要的法宝。</li></ul><h2 id="技能之启动敏捷团队"><a href="#技能之启动敏捷团队" class="headerlink" title="技能之启动敏捷团队"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/#%E6%8A%80%E8%83%BD%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%95%8F%E6%8D%B7%E5%9B%A2%E9%98%9F" title="技能之启动敏捷团队"></a>技能之启动敏捷团队</h2><ul><li>  懂得启动团队的目标，并尝试用各种方法和活动来达到这些目标。</li><li>  目标包括计划和执行启动活动，并根据这些活动的结果调整后续活动的执行方法。</li><li>  需要知道如何实施团队启动才既符合敏捷特征又对团队有价值。</li></ul><h2 id="技能之一对一指导团队成员"><a href="#技能之一对一指导团队成员" class="headerlink" title="技能之一对一指导团队成员"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/#%E6%8A%80%E8%83%BD%E4%B9%8B%E4%B8%80%E5%AF%B9%E4%B8%80%E6%8C%87%E5%AF%BC%E5%9B%A2%E9%98%9F%E6%88%90%E5%91%98" title="技能之一对一指导团队成员"></a>技能之一对一指导团队成员</h2><ul><li>  能够轻松自如地进行一对一指导，并且被指导的成员感受到自身的变化。</li><li>  认识到每个成员处于敏捷转型的什么阶段。</li><li>  激发每个人为了成为优秀的敏捷开发人员而愿意采取行动。</li></ul><h2 id="技能之指导整个团队"><a href="#技能之指导整个团队" class="headerlink" title="技能之指导整个团队"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/#%E6%8A%80%E8%83%BD%E4%B9%8B%E6%8C%87%E5%AF%BC%E6%95%B4%E4%B8%AA%E5%9B%A2%E9%98%9F" title="技能之指导整个团队"></a>技能之指导整个团队</h2><ul><li>  把自己想象成敏捷的清道夫、领头羊、管家、质量和绩效的看护者。</li><li>  确保团队在一段时间内只专注于一个迭代目标。</li><li>  密切关注团队的日常交流，确保他们是在真正协作并朝最简单的方向努力。</li><li>  指出某个破坏性行为，使得这种行为下次出现时，其他人也有勇气指出来。</li><li>  当团队忘记他们的共享愿景时，进行提醒。</li><li>  帮助团队朝健康的敏捷团队方向前进，最终产生他们引以为荣的结果。</li></ul><h2 id="技能之指导产品负责人"><a href="#技能之指导产品负责人" class="headerlink" title="技能之指导产品负责人"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/#%E6%8A%80%E8%83%BD%E4%B9%8B%E6%8C%87%E5%AF%BC%E4%BA%A7%E5%93%81%E8%B4%9F%E8%B4%A3%E4%BA%BA" title="技能之指导产品负责人"></a>技能之指导产品负责人</h2><ul><li>  指导产品负责人与团队交互。鼓励产品负责人以正面的方式与团队交互，约束那些损害团队自组织的行为。</li><li>  指导产品负责人实践商业价值驱动的思维方法。确保团队只做那些用来创建优秀产品的事情。</li><li>  指导产品负责人创建、整理和使用产品列表。</li><li>  指导产品负责人帮助团队排出障碍。</li><li>  指导产品负责人管理干系人。产品负责人不断与干系人一道工作来了解他们的需求，将它们转化为唯一的明确的声音。</li></ul><h2 id="技能之指导团队外部干系人"><a href="#技能之指导团队外部干系人" class="headerlink" title="技能之指导团队外部干系人"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/#%E6%8A%80%E8%83%BD%E4%B9%8B%E6%8C%87%E5%AF%BC%E5%9B%A2%E9%98%9F%E5%A4%96%E9%83%A8%E5%B9%B2%E7%B3%BB%E4%BA%BA" title="技能之指导团队外部干系人"></a>技能之指导团队外部干系人</h2><ul><li>  与项目发起人、经理以及团队之外的干系人进行指导性交谈。</li><li>  为他们与团队可能发生的有用和有害的交互制定法规，帮助干系人了解他们如何能够最好地支持团队的动力和结果。</li><li>  教会他们如何利用敏捷来仅构造最本质和最有价值的东西以实现竞争优势。</li><li>  技能之在变化中指导团队</li><li>  帮助团队走出来自变化或处境艰难的失望，提出新的计划来恢复团队的技能和活力。</li><li>  当团队前进时，总会有事情把他们击退回来。</li><li>  通过运用敏捷原则、实践和价值观，给团队指明重新站稳脚跟的方法。</li></ul><h2 id="技能之激发通向高绩效的途径"><a href="#技能之激发通向高绩效的途径" class="headerlink" title="技能之激发通向高绩效的途径"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/#%E6%8A%80%E8%83%BD%E4%B9%8B%E6%BF%80%E5%8F%91%E9%80%9A%E5%90%91%E9%AB%98%E7%BB%A9%E6%95%88%E7%9A%84%E9%80%94%E5%BE%84" title="技能之激发通向高绩效的途径"></a>技能之激发通向高绩效的途径</h2><ul><li>  指导团队取得越来越高的绩效。</li><li>  在团队中激发出来一条通道，让团队把通往高绩效的旅途掌握在自己手中。</li><li>  为团队中的每个人，团队整体，他们构造的产品以及公司带来成果。</li></ul><h2 id="技能之接受团队比你更好的想法"><a href="#技能之接受团队比你更好的想法" class="headerlink" title="技能之接受团队比你更好的想法"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/#%E6%8A%80%E8%83%BD%E4%B9%8B%E6%8E%A5%E5%8F%97%E5%9B%A2%E9%98%9F%E6%AF%94%E4%BD%A0%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%83%B3%E6%B3%95" title="技能之接受团队比你更好的想法"></a>技能之接受团队比你更好的想法</h2><ul><li>  愿意让你的决定和观点屈从于团队的观点和决定。</li><li>  让团队掌握产生想法和决定的方法。</li><li>  走向自我管理，和对想法和决定的彻底执行。</li></ul><h2 id="技能之自我掌控"><a href="#技能之自我掌控" class="headerlink" title="技能之自我掌控"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/#%E6%8A%80%E8%83%BD%E4%B9%8B%E8%87%AA%E6%88%91%E6%8E%8C%E6%8E%A7" title="技能之自我掌控"></a>技能之自我掌控</h2><ul><li>  自己的行动是为了给团队带来所需的东西。</li><li>  不是为了自己的需要。</li><li>  为了团队而存在。</li></ul><h2 id="技能之成为敏捷价值观和原则的楷模"><a href="#技能之成为敏捷价值观和原则的楷模" class="headerlink" title="技能之成为敏捷价值观和原则的楷模"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/#%E6%8A%80%E8%83%BD%E4%B9%8B%E6%88%90%E4%B8%BA%E6%95%8F%E6%8D%B7%E4%BB%B7%E5%80%BC%E8%A7%82%E5%92%8C%E5%8E%9F%E5%88%99%E7%9A%84%E6%A5%B7%E6%A8%A1" title="技能之成为敏捷价值观和原则的楷模"></a>技能之成为敏捷价值观和原则的楷模</h2><ul><li>  被团队看作称职和成功的敏捷人员。</li><li>  让团队从你在各种情况下的处事方法和与他们相处的方式中看到敏捷的价值。</li><li>  让他们通过你的示范学会了如何很好地运用敏捷。</li><li>  让他们学习更深入的技能使自己能更完全地协作，并产生令人惊异的结果。</li></ul><h2 id="技能之驾驭冲突"><a href="#技能之驾驭冲突" class="headerlink" title="技能之驾驭冲突"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/#%E6%8A%80%E8%83%BD%E4%B9%8B%E9%A9%BE%E9%A9%AD%E5%86%B2%E7%AA%81" title="技能之驾驭冲突"></a>技能之驾驭冲突</h2><ul><li>  学会并运用至少一种冲突导航模式来帮助团队跨越冲突。</li><li>  在冲突未解决时能让相关方友善相处。</li><li>  有意识地选择时机和方式介入团队冲突，包括有意识地选择让冲突存在而不加干涉。</li><li>  最终达到让团队能完全由他们自己驾驭冲突。</li></ul><h2 id="技能之不断学习和成长"><a href="#技能之不断学习和成长" class="headerlink" title="技能之不断学习和成长"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/#%E6%8A%80%E8%83%BD%E4%B9%8B%E4%B8%8D%E6%96%AD%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%88%90%E9%95%BF" title="技能之不断学习和成长"></a>技能之不断学习和成长</h2><ul><li>  给自己灌输一种永不知足的学习渴望，以及见证团队和公司蓬勃发展的愿望。</li><li>  把新发现的知识融入到指导过程中，并在指导过程中注意自己技能的增长。</li><li>  腾出时间来学习新的技能，体验新的观念。</li><li>  不断反思自己的指导能力。</li></ul><h2 id="技能之分享回馈"><a href="#技能之分享回馈" class="headerlink" title="技能之分享回馈"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/#%E6%8A%80%E8%83%BD%E4%B9%8B%E5%88%86%E4%BA%AB%E5%9B%9E%E9%A6%88" title="技能之分享回馈"></a>技能之分享回馈</h2><ul><li>  分享自己在尝试和折磨过程中所获得的宝贵教训，及学到的新方法。</li><li>  参加敏捷社区和敏捷会议，在各种讨论中贡献自己的观点。</li><li>  在会议中提交和分享话题。</li></ul><h2 id="敏捷教练绩效度量标准"><a href="#敏捷教练绩效度量标准" class="headerlink" title="敏捷教练绩效度量标准"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/#%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%BB%A9%E6%95%88%E5%BA%A6%E9%87%8F%E6%A0%87%E5%87%86" title="敏捷教练绩效度量标准"></a>敏捷教练绩效度量标准</h2><ul><li><p>  不要驱使团队取得结果，不要命令式指导他人的工作。</p></li><li><p>  要含蓄地领导，创建一个自然的环境让团队交付好的结果，而不需要任何人来驱使他们。</p></li><li><p>  不要控制团队的工作来保证预测的准确性。</p></li><li><p>  要放开手脚让团队来完成他们选择的工作，并且支持他们对自己承诺的结果负责。</p></li><li><p>  不要遵从公司的规则。</p></li><li><p>  要发现当公司的规则限制了价值交付时，就挑战公司的规则。</p></li><li><p>  不要立即把问题提升到管理层。</p></li><li><p>  要与相关人员一起研究问题，直到问题完全解决，并继续向前进。</p></li><li><p>  不要偏爱已经验证的并且安全的选择。</p></li><li><p>  要给团队营造安全感来试验、失败并吸取教训。</p></li><li><p>  不要按计划交付产品。</p></li><li><p>  要允许团队根据他们的变化和逐步精确的计划来交付产品。把交付商业价值作为唯一的度量。</p></li><li><p>  不要遵从经受了时间考验的策略和过程。</p></li><li><p>  要培养创造性和提高团队能力，把每种情形当成全新的情形并提升产生全新结果的可能性，即使在熟悉的领域里。</p></li><li><p>  不要照本宣科地实施敏捷。</p></li><li><p>  要知道在什么时候照本宣科是最好的方法，什么时候需要舍弃最强有力的敏捷表述来换取再困境下至少一点点的改善。</p></li></ul><h3 id="敏捷教练每周价值清单（示例）："><a href="#敏捷教练每周价值清单（示例）：" class="headerlink" title="敏捷教练每周价值清单（示例）："></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/#%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E6%AF%8F%E5%91%A8%E4%BB%B7%E5%80%BC%E6%B8%85%E5%8D%95%EF%BC%88%E7%A4%BA%E4%BE%8B%EF%BC%89%EF%BC%9A" title="敏捷教练每周价值清单（示例）："></a>敏捷教练每周价值清单（示例）：</h3><ul><li>  帮助产品负责人和产品发起人保持一致，让他们给团队的指示与产品愿景一致。</li><li>  制作团队交付的东西对软件操作的影响的视图。</li><li>  帮助 PMO 采用敏捷团队的发布计划来创建他的总体进度表。</li><li>  指导 PO 和 Scrum Master 创建产品列表。</li><li>  启动一个新的团队。</li><li>  说服项目级变更管理团队与敏捷团队一道工作，而不是下达最后期限。</li><li>  让敏捷经理意识到自己以前太强势。</li></ul><h3 id="敏捷教练对一次指导的回顾（示例）："><a href="#敏捷教练对一次指导的回顾（示例）：" class="headerlink" title="敏捷教练对一次指导的回顾（示例）："></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/#%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AF%B9%E4%B8%80%E6%AC%A1%E6%8C%87%E5%AF%BC%E7%9A%84%E5%9B%9E%E9%A1%BE%EF%BC%88%E7%A4%BA%E4%BE%8B%EF%BC%89%EF%BC%9A" title="敏捷教练对一次指导的回顾（示例）："></a>敏捷教练对一次指导的回顾（示例）：</h3><ul><li>  团队发生了重大变化并被公司领导认可。经理们说，如果没有敏捷，他们很难按时交付。</li><li>  培养了强有力的 Scrum Master。</li><li>  两个团队成功地完成了产品负责人的更替。</li><li>  团队不断认识到浪费。</li><li>  影响新团队采用敏捷。</li><li>  帮助运营团队采用敏捷更快完成操作性工作。</li><li>  憎恨敏捷的团队愿意尝试敏捷。</li><li>  正向影响了三四个 PO 和 Scrum Master。</li><li>  选用了新工具协助回顾会议和团队协作。</li><li>  收到了正面反馈和肯定。</li><li>  有能力指导管理层。</li><li>  需要改善：帮助高层领导知道如何发掘敏捷团队的能力来更好地交付和应对变化。</li><li>  需要改善：协助新 PO 和 Scrum Master 与组织墙抗争。</li><li>  需要改善：让高层领导接受指导。</li></ul><h2 id="敏捷教练绩效考评"><a href="#敏捷教练绩效考评" class="headerlink" title="敏捷教练绩效考评"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/#%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%BB%A9%E6%95%88%E8%80%83%E8%AF%84" title="敏捷教练绩效考评"></a>敏捷教练绩效考评</h2><ul><li>  影响力：当你与团队交互并提出一个有洞察力或强有力的问题时，团队会提出更好的想法或转向行动吗？</li><li>  一对一指导时，注意他几天或几周后的变化。</li><li>  为你做得好的事情欢欣鼓舞，客观面对使你或他人失望的地方。</li><li>  只有你自己知道什么时候你做到了合格的敏捷教练。</li></ul><h1 id="提升第三式：教练之旅"><a href="#提升第三式：教练之旅" class="headerlink" title="提升第三式：教练之旅"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/#%E6%8F%90%E5%8D%87%E7%AC%AC%E4%B8%89%E5%BC%8F%EF%BC%9A%E6%95%99%E7%BB%83%E4%B9%8B%E6%97%85" title="提升第三式：教练之旅"></a>提升第三式：教练之旅</h1><p>每个敏捷教练都是沿着自己设计的旅途在前进。本节给出了八个敏捷教练的故事。他们的背景、经验和视角迥异，但他们热爱敏捷指导的原因都是，敏捷方法既体现了天然的工作方式，又能交付切实的商业结果。</p><p><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/%E6%95%99%E7%BB%83%E4%B9%8B%E6%97%85.jpg"><img src="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/%E6%95%99%E7%BB%83%E4%B9%8B%E6%97%85.jpg"></a></p><h2 id="作者-Rachel-Davies-的旅途：发现与倡导"><a href="#作者-Rachel-Davies-的旅途：发现与倡导" class="headerlink" title="作者 Rachel Davies 的旅途：发现与倡导"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/#%E4%BD%9C%E8%80%85-Rachel-Davies-%E7%9A%84%E6%97%85%E9%80%94%EF%BC%9A%E5%8F%91%E7%8E%B0%E4%B8%8E%E5%80%A1%E5%AF%BC" title=" 作者 Rachel Davies 的旅途：发现与倡导"></a>作者 Rachel Davies 的旅途：发现与倡导</h2><ul><li>  从开发人员：接到需求，再设计，再开发，再测试。当项目没有按时交付时，每个人的辛苦工作成果就被丢弃了。</li><li>  到开发经理：指挥团队工作。开始寻找一种尊重人同时也能使他们交付产品的方法。</li><li>  到 XP 开发者：结对编程，团队工作，测试驱动，每周都能交付软件。</li><li>  到敏捷教练：让团队驱动流程，以平和的步调工作。对于无意于敏捷的团队，需要理解变革需要时间，敏捷教练需要耐心，从简单的东西开始。随着时间的推移，花时间去听团队的想法并帮助他们找出可能采取的行动，而不是指挥他们去做什么。在与团队的互动和回顾中播下变化的种子，在种子变成绿芽之前需要时间，在结果之前不断施肥。</li></ul><h2 id="技术培训师丹的旅途：守破离进阶的反思"><a href="#技术培训师丹的旅途：守破离进阶的反思" class="headerlink" title="技术培训师丹的旅途：守破离进阶的反思"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/#%E6%8A%80%E6%9C%AF%E5%9F%B9%E8%AE%AD%E5%B8%88%E4%B8%B9%E7%9A%84%E6%97%85%E9%80%94%EF%BC%9A%E5%AE%88%E7%A0%B4%E7%A6%BB%E8%BF%9B%E9%98%B6%E7%9A%84%E5%8F%8D%E6%80%9D" title="技术培训师丹的旅途：守破离进阶的反思"></a>技术培训师丹的旅途：守破离进阶的反思</h2><ul><li>  守：参加认证 Scrum Master 培训，按照书本上的方式做事。</li><li>  破：敏捷团队的行动就像创业公司一样，都是通过观察来学习，对工作采用经验主义的做法。</li><li>  离：Scrum 是关于角色、权力和边界的定义。意识到有更多的东西要学。</li></ul><h2 id="的作者-Lyssa-Adkins-的旅途：弥补过失"><a href="#的作者-Lyssa-Adkins-的旅途：弥补过失" class="headerlink" title="的作者 Lyssa Adkins 的旅途：弥补过失"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/#%E7%9A%84%E4%BD%9C%E8%80%85-Lyssa-Adkins-%E7%9A%84%E6%97%85%E9%80%94%EF%BC%9A%E5%BC%A5%E8%A1%A5%E8%BF%87%E5%A4%B1" title=" 的作者 Lyssa Adkins 的旅途：弥补过失"></a>的作者 Lyssa Adkins 的旅途：弥补过失</h2><ul><li>  从项目经理：按计划做事情。项目一个接一个地按时、按量、按预算交付，但没有一个交付能够使客户满意。一长串的人们为这些项目伤害了他们的生活，因为他们的工作时间远远超出人的正常期望。</li><li>  到 Scrum Master：教授、辅导、协助、沉思、提高。大家在工作中专业、快速、具有质量头脑。团队真的知道如何正确地做要做的事。团队中最羞怯的成员开始大声说笑，并因为他的才气被大家认可。</li><li>  到工作/生活教练。学会了如何让团队对他们的日程负责。带给他们新的思考方法，给他们的生活带来欣喜的变化。</li><li>  到敏捷教练：团队确实知道什么是最好的，我只是帮助他们了解他们自己知道的。</li></ul><h2 id="认证-Scrum-培训师马丁·科恩的旅途：个人回顾"><a href="#认证-Scrum-培训师马丁·科恩的旅途：个人回顾" class="headerlink" title="认证 Scrum 培训师马丁·科恩的旅途：个人回顾"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/#%E8%AE%A4%E8%AF%81-Scrum-%E5%9F%B9%E8%AE%AD%E5%B8%88%E9%A9%AC%E4%B8%81%C2%B7%E7%A7%91%E6%81%A9%E7%9A%84%E6%97%85%E9%80%94%EF%BC%9A%E4%B8%AA%E4%BA%BA%E5%9B%9E%E9%A1%BE" title="认证 Scrum 培训师马丁·科恩的旅途：个人回顾"></a>认证 Scrum 培训师马丁·科恩的旅途：个人回顾</h2><ul><li>  从层级管理者：让下属执行我的方案。</li><li>  到 Scrum Master：我知道什么是最好的，教给他们做。</li><li>  到学习情商：在一个新的层次上理解人们的动机、表达和能动性。需要重视每个人自身，尊重他们的观点，更多地了解他们的个人目标和信仰。聆听和理解大家的感觉和想法，通过提问题来帮助所有人理解事情的缘由。尊重团队过去的经验，帮助他们开发他们的优势，建立起敏捷团队的观念和意识。</li><li>  到敏捷教练：让敏捷的好处永远伴随。帮助建立一个环境让每个团队成员充分发挥自己的才干，并创建非凡的方案来真正满足业务的需要。</li></ul><h2 id="凯西的旅途：学会指导"><a href="#凯西的旅途：学会指导" class="headerlink" title="凯西的旅途：学会指导"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/#%E5%87%AF%E8%A5%BF%E7%9A%84%E6%97%85%E9%80%94%EF%BC%9A%E5%AD%A6%E4%BC%9A%E6%8C%87%E5%AF%BC" title="凯西的旅途：学会指导"></a>凯西的旅途：学会指导</h2><ul><li>  从项目经理：你们开始编程吧，我去看看他们要的是什么。擅长动员团队，带领团队走向成功，与管理层沟通，使管理层满意。</li><li>  到 Scrum Master：发现团队难以管理，对 Scrum 会议没有兴趣。</li><li>  到生活教练：学习主动倾听，强有力地提问，增强意识，管理进度及责任感。采用指导风格而不是管理风格。</li><li>  到敏捷教练：指导团队作为一个专一的实体来驶向成功。帮助团队实现自管理。多提问而不是多给建议，承认团队具有成功所需要的知识，维持积极的前景和方法。观察团队成员如何行动、说话与交互，让他们发现哪种方法可行。介绍工具和技术来帮助他们，每次会问他们是否愿意采用这种技术，并遵从他们的决定。</li></ul><h2 id="敏捷教练-Glen-Wang-的旅途：寻求合理的管理"><a href="#敏捷教练-Glen-Wang-的旅途：寻求合理的管理" class="headerlink" title="敏捷教练 Glen Wang 的旅途：寻求合理的管理"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/#%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83-Glen-Wang-%E7%9A%84%E6%97%85%E9%80%94%EF%BC%9A%E5%AF%BB%E6%B1%82%E5%90%88%E7%90%86%E7%9A%84%E7%AE%A1%E7%90%86" title="敏捷教练 Glen Wang 的旅途：寻求合理的管理"></a>敏捷教练 Glen Wang 的旅途：寻求合理的管理</h2><ul><li>  从工程师：一线工作人员看不到大局，每天的工作被微指挥微管理，等级制度造成各种弊病，开始思考合理的组织和应该的管理是什么样子。</li><li>  到经理：开始在可控制的范围内自发地实践自组织自管理，设定团队愿景，让团队成员参与计划和管理，自由领取工作。</li><li>  到 Scrum Master：Scrum 就是要找的方法，运用 Scrum 之后，看见了更好的团队。团队产出更多，也更快乐。</li><li>  到敏捷教练：精通精益和敏捷体系，系统思考，注重内在品质和教练方法。致力于打造理想的组织。</li></ul><h2 id="敏捷教练虎头锤的旅途：保持探索之心"><a href="#敏捷教练虎头锤的旅途：保持探索之心" class="headerlink" title="敏捷教练虎头锤的旅途：保持探索之心"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/#%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E8%99%8E%E5%A4%B4%E9%94%A4%E7%9A%84%E6%97%85%E9%80%94%EF%BC%9A%E4%BF%9D%E6%8C%81%E6%8E%A2%E7%B4%A2%E4%B9%8B%E5%BF%83" title="敏捷教练虎头锤的旅途：保持探索之心"></a>敏捷教练虎头锤的旅途：保持探索之心</h2><ul><li>  从工程师：从瀑布到 CMMI，从学习敏捷理论，并参与到“四不像”的敏捷实践，总觉得摸到了敏捷的门，但是进不了敏捷的“道”。</li><li>  到 CSM：CSM 的培训被 Spotify 模式惊艳，开始尝试在公司内部进行敏捷培训，通过准备培训教材和多次培训，探索和总结过往的经验教训。</li><li>  到进入采用 Spotify 模式的公司：真正理解了敏捷怎样融入日常工作，如何用透明度传递信任。发现了可视化的种种好处，所以从绘画小白踏上了视觉引导之旅。</li></ul><p>您的旅途：未解之谜，意义之旅 ?</p><ul><li>  你曾经做过什么？学到什么？什么东西被你发现了并融入到你的敏捷指导方法中？</li><li>  指导敏捷团队对你来说，有什么重要意义？</li><li>  你以前在哪里，准备去哪里，有哪些让你走到今天的重要指导事件？</li><li>  你前面的路是什么，你下一个要到达的顶峰是什么？</li><li>  把你的旅途分享给他人，既能获得支持，也是给他人的启发和礼物。</li></ul></blockquote><blockquote><ul><li>  <strong>本文作者：</strong> joni@efbiz.org</li><li>  <strong>本文链接：</strong>  <a href="https://github.com/efbiz/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/">https://github.com/efbiz/2018/05/23/敏捷教练第09课-技巧-敏捷教练的提升三式/</a> </li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在经历了四种心法和六脉神剑的修炼之后，敏捷教练的路还要往前走。本文介绍敏捷教练的提升三式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;  成败模式&lt;/li&gt;
&lt;li&gt;  技能清单&lt;/li&gt;
&lt;li&gt;  教练之旅&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="Scrum" scheme="http://zhangyu.info/categories/Scrum/"/>
    
    
    <category term="Scrum" scheme="http://zhangyu.info/tags/Scrum/"/>
    
  </entry>
  
  <entry>
    <title>敏捷教练第10课-技巧-持续改善和系统思考方法</title>
    <link href="http://zhangyu.info/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC10%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%8C%81%E7%BB%AD%E6%94%B9%E5%96%84%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/"/>
    <id>http://zhangyu.info/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC10%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%8C%81%E7%BB%AD%E6%94%B9%E5%96%84%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/</id>
    <published>2022-04-11T16:00:00.000Z</published>
    <updated>2022-04-12T02:21:06.002Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>是什么让一个团队与另一个团队有所不同？是什么使得一个团队在敏捷教练离开后仍能保持提升？答案是一个团队内建的持续改善与系统思考能力，特别是 Scrum Master。一个具备持续改善和系统思考能力的 Scrum Master，就已经不是只顶着这个角色的 Scrum Master，而已经是个敏捷教练了。这与外在的角色和职位名称无关。</p><p>本文按以下这个大循环介绍持续改善与系统思考方法：</p><ul><li>  思想准备：组织的常青，教练的使命，敏捷的逻辑，工作生活的四层逻辑，追求高绩效</li><li>  技能准备：敏捷宣言，Scrum 框架，精益思想</li><li>  现场现物：GROW 模型-真实的问题，真实的目标，真实的方法</li><li>  识别问题：观察，交流</li><li>  解决问题：因果逻辑，PDCA，回顾会议</li><li>  固化成果：提炼和运用模式</li><li>  打磨逻辑，不断实践</li></ul><p><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC10%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%8C%81%E7%BB%AD%E6%94%B9%E5%96%84%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/%E6%8C%81%E7%BB%AD%E6%94%B9%E5%96%84%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95.jpg"><img src="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC10%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%8C%81%E7%BB%AD%E6%94%B9%E5%96%84%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/%E6%8C%81%E7%BB%AD%E6%94%B9%E5%96%84%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95.jpg"></a></p><p>本文介绍的思想会落实到下一章典型敏捷教练周期六步法当中，是六步法背后的思想和逻辑依据。作为敏捷教练，需要不断做两件事：一是不断打磨逻辑，二是不断在实践中实证。这两点，也是本课程的灵魂，和敏捷教练技能未来发展的基调。</p><h1 id="思想准备"><a href="#思想准备" class="headerlink" title="思想准备"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC10%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%8C%81%E7%BB%AD%E6%94%B9%E5%96%84%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/#%E6%80%9D%E6%83%B3%E5%87%86%E5%A4%87" title="思想准备"></a>思想准备</h1><p><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC10%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%8C%81%E7%BB%AD%E6%94%B9%E5%96%84%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/%E6%80%9D%E6%83%B3%E5%87%86%E5%A4%87.jpg"><img src="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC10%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%8C%81%E7%BB%AD%E6%94%B9%E5%96%84%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/%E6%80%9D%E6%83%B3%E5%87%86%E5%A4%87.jpg"></a></p><h2 id="组织的常青"><a href="#组织的常青" class="headerlink" title="组织的常青"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC10%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%8C%81%E7%BB%AD%E6%94%B9%E5%96%84%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/#%E7%BB%84%E7%BB%87%E7%9A%84%E5%B8%B8%E9%9D%92" title="组织的常青"></a>组织的常青</h2><p>在《基业常青》一书中，科林斯和波拉斯确定“高瞻远瞩”公司的标准是：处于所在行业中第一流的水准、广受企业人士崇敬、对世界有着不可磨灭的影响、已经历很多代的 CEO、已经历很多次产品生命周期且在1950年前创立。根据这六条标准，他们选出的公司有：美国运通公司、波音公司、花旗银行、沃尔玛、迪斯尼公司等共18家。</p><p>这些常青公司有以下一些特质：</p><ul><li>  “造钟，而不是报时”</li></ul><blockquote><p>科林斯指出，“伟大的公司的创办人，通常都是制造时钟的人，而不是报时的人。他们主要致力于建立一个时钟，而不只是找对时机，用一种适销对路的产品打入市 场；他们并非致力于领袖人物充满魅力的人格特质，而是致力于构建高瞻远瞩的公司组织特质，他们最大的创造物是公司本身及其代表的一切。”“造钟”就是建立一种机制，使得公司能够依靠组织的力量在市场中生存与发展，而不必依靠某位个人、某种产品或某个机会等偶然的东西。随着市场的进一步完善与规范，企业必须 越来越依靠一个好的机制，包括好的组织结构、好的评价考核体系、好的战略管理等。</p></blockquote><ul><li>  “利润之上的追求”与“教派般的文化”</li></ul><blockquote><p>所有伟大的公司都是“务实的理想主义者”。“利润是生存的必要条件，而且是达成更重要目的的手段，但对很多高瞻远瞩的公司而言，利润不是目的，利润就像人体需要的氧气、食物、水和血液一样，这些东西不是生命的目的。但是，没有它们，就没有生命。”利润之上的更高追求在伟大的公司里，更是被作为像“教派般的文化”那样所灌输。“利润之上的追求”如果不明确、不具体，就会是空洞的大口号。企业要意识到企业文化的重要作用，“教派般的文化”指的是卓越公司必须具有很强的共同价值观。</p></blockquote><ul><li>  “自家长成的经理人”</li></ul><blockquote><p>“18家伟大的公司在总共长达1700年的历史中，只有四位 CEO 来自于外部”。“自家长成”的经理人熟悉了解本公司文化，更易带领本公司进行变革。 其实，任何一个公司无论长盛不衰还是昙花一现，都有意无意地由一种理念所指引。</p></blockquote><p>这三个特质，跟我们在前文数次提到的作为精益和敏捷鼻祖的丰田 4P 完全吻合。</p><h2 id="教练的使命"><a href="#教练的使命" class="headerlink" title="教练的使命:"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC10%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%8C%81%E7%BB%AD%E6%94%B9%E5%96%84%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/#%E6%95%99%E7%BB%83%E7%9A%84%E4%BD%BF%E5%91%BD" title="教练的使命:"></a>教练的使命:</h2><p>要成为一家高瞻远瞩的公司，需要有一个像丰田 4P 那样的体系。体系的落实，需要教练。在丰田，经理就是教练，教练是一种管理职责。在丰田之外，经理与教练分离。教练需要在一定范围内取得组织授权，以便履行教练的职责：</p><ul><li><p>  贯彻敏捷的工作方式。</p></li><li><p>  打造被充分激励充分赋能的自组织团队。</p></li><li><p>以此创造价值实现目标。</p><h2 id="敏捷的逻辑"><a href="#敏捷的逻辑" class="headerlink" title="敏捷的逻辑:"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC10%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%8C%81%E7%BB%AD%E6%94%B9%E5%96%84%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/#%E6%95%8F%E6%8D%B7%E7%9A%84%E9%80%BB%E8%BE%91" title="敏捷的逻辑:"></a>敏捷的逻辑:</h2></li></ul><ol><li> 按照敏捷思想，采用一种方法，比如 Scrum。最起码在团队中取得形式上的共识和一致。</li><li> 团队自组织。以敏捷思想为指导，通过共识机制，持续改善与解决问题。</li><li> 以前两者为基础，取得好的业务成果。同时个人获得职业生涯和工作生活上长期全面的好处。</li></ol><p>第1点相对直观，第2点的逻辑基础是：好公司。</p><p>在非理想状态下，重点可以放在第1点，对第2点做有限度的追求。不管环境如何，我们依然可以有所作为。好与坏不是非黑即白，而是同一频谱上的两个点。我们能做的，是施加一点好的影响。</p><h2 id="好公司的标准"><a href="#好公司的标准" class="headerlink" title="好公司的标准"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC10%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%8C%81%E7%BB%AD%E6%94%B9%E5%96%84%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/#%E5%A5%BD%E5%85%AC%E5%8F%B8%E7%9A%84%E6%A0%87%E5%87%86" title="好公司的标准"></a>好公司的标准</h2><ul><li><p>  员工有相对体面的收入和足够的激励。</p></li><li><p>  有相对公平平等透明的制度。努力与结果之间有清晰的影响关系。</p></li><li><p>  经理与员工之间互相扶助的关系。</p></li><li><p>  公司有前途，有奔头。</p></li><li><p>  员工技能提升与发展。</p></li><li><p>  有明确的努力方向。</p></li><li><p>  晋升加薪的机会。</p></li><li><p>  以员工为中心，员工有机会参与和影响公司管理。</p></li><li><p>  工作环境和制度人性化。尊重人。</p></li><li><p>  流程合理，不会有很多阻滞，办事不难。</p></li><li><p>工作的稳定性和保障性。</p><p>  第1点和第2点的区别是，第1点是相对可以有形化和规定化，第2点需要大家的讨论和共识。没有共识，第1点也难以执行。而第2点也离不开敏捷思想的指导。自组织不是一个悬空的虚拟的概念的问题，而是一种持续改进的共识的共同的问题解决。自组织不是一种脱离内容的形式，而要以内容即工作组织和问题为出发点。</p><p>  在非理想情况下，打造自组织，可以采用的方法是，受限的共识，和受限的自组织，受限的好团队。不管环境多么恶劣，共识的空间是有的。共识与流动即知行合一。</p><h2 id="团队的发展阶段"><a href="#团队的发展阶段" class="headerlink" title="团队的发展阶段"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC10%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%8C%81%E7%BB%AD%E6%94%B9%E5%96%84%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/#%E5%9B%A2%E9%98%9F%E7%9A%84%E5%8F%91%E5%B1%95%E9%98%B6%E6%AE%B5" title="团队的发展阶段"></a>团队的发展阶段</h2></li><li><p>  无组织（各自为政，效率低下）</p></li><li><p>  被动的自运转（Scrum Master 驱动）</p></li><li><p>  自运转（自动按 Scrum 运作）</p></li><li><p>  受限的自组织（大环境不理想）</p></li><li><p>自组织（基业长青）</p><p>  找到一些问题（如跨职能团队，价值流优化，团队工作），推动团队达到哪怕是不完美的共识，和不完美的执行。</p><p>  团队的三个角色之外，也要把经理纳入共识的范围。问题的解决不用那么急迫。因为没有共识，急迫也没有用。大环境之下，团队之间差异的原因，如团队的构成，团队的年资等，也是值得思考的点。以逻辑的甘露，在理念和团队事实上，有步骤地把一团意大利面拉直成拉面。</p><h2 id="工作生活的四层逻辑"><a href="#工作生活的四层逻辑" class="headerlink" title="工作生活的四层逻辑"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC10%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%8C%81%E7%BB%AD%E6%94%B9%E5%96%84%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/#%E5%B7%A5%E4%BD%9C%E7%94%9F%E6%B4%BB%E7%9A%84%E5%9B%9B%E5%B1%82%E9%80%BB%E8%BE%91" title="工作生活的四层逻辑"></a>工作生活的四层逻辑</h2></li><li><p>  生产力，其逻辑是技能。工作方式是否能辅助大家的技能提升呢？</p></li><li><p>  生产关系，其逻辑是交易。如何影响分配的规则呢？</p></li><li><p>  五伦之外，其逻辑是合作。如何找出大家共同追求的东西呢？</p></li><li><p>  五伦之内，其逻辑是爱。如何激发人的善意呢？</p></li></ul><p>不管环境多么恶劣，合作还是可以存在的。合作既是敏捷的基础，也是敏捷的核心。</p><h2 id="追求高绩效"><a href="#追求高绩效" class="headerlink" title="追求高绩效"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC10%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%8C%81%E7%BB%AD%E6%94%B9%E5%96%84%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/#%E8%BF%BD%E6%B1%82%E9%AB%98%E7%BB%A9%E6%95%88" title="追求高绩效"></a>追求高绩效</h2><p>在一个组织中，大家有共同的目标，共同的规则，就可以追求高绩效了。</p><p>建立 One Team 的理念和实践。在一个团队中，可以就所有问题公开讨论，包括绩效管理，个人发展，技术，管理，业务，工作满意度，员工参与度等。</p><p>一个组织的形态，往往都是不够理想的。在这种情况下，我们心目中要有最终的理想，并根据情况，制定阶段性的理想。</p><h2 id="技能准备"><a href="#技能准备" class="headerlink" title="技能准备"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC10%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%8C%81%E7%BB%AD%E6%94%B9%E5%96%84%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/#%E6%8A%80%E8%83%BD%E5%87%86%E5%A4%87" title="技能准备"></a>技能准备</h2><p>技能准备的部分在本课程的前面部分已经涵盖，总结下来，包括：</p><ul><li>  敏捷宣言</li><li>  Scrum 框架</li><li>  精益思想</li><li>  技术实践</li><li>  教练方法</li><li>  自我提升</li><li>  对组织和团队发展阶段的认识</li><li>  本章的系统思考和持续改善</li></ul><p>有了思想和技能上的准备，就进入现场现物的了解问题。</p><h1 id="现场现物"><a href="#现场现物" class="headerlink" title="现场现物"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC10%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%8C%81%E7%BB%AD%E6%94%B9%E5%96%84%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/#%E7%8E%B0%E5%9C%BA%E7%8E%B0%E7%89%A9" title="现场现物"></a>现场现物</h1><p><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC10%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%8C%81%E7%BB%AD%E6%94%B9%E5%96%84%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/%E7%8E%B0%E5%9C%BA%E7%8E%B0%E7%89%A9.jpg"><img src="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC10%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%8C%81%E7%BB%AD%E6%94%B9%E5%96%84%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/%E7%8E%B0%E5%9C%BA%E7%8E%B0%E7%89%A9.jpg"></a></p><h2 id="了解问题可采用-GROW-模型："><a href="#了解问题可采用-GROW-模型：" class="headerlink" title="了解问题可采用 GROW 模型："></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC10%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%8C%81%E7%BB%AD%E6%94%B9%E5%96%84%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/#%E4%BA%86%E8%A7%A3%E9%97%AE%E9%A2%98%E5%8F%AF%E9%87%87%E7%94%A8-GROW-%E6%A8%A1%E5%9E%8B%EF%BC%9A" title="了解问题可采用 GROW 模型："></a>了解问题可采用 GROW 模型：</h2><ul><li>  Goal 目标：组织和团队的目标是什么？是速度提升吗？是质量提升吗？干系人对目标的共识程度如何？</li><li>  Reality 现状：现状是什么？现在采用的工作方式是什么？实际运作是怎样的？实际运作中有些什么问题？</li><li>  Opportunity 机会：是否存在提升的机会？各方干系人的支持程度如何？有什么不可克服的障碍？提升之后对团队意味着什么？</li><li>  Way 方法：具体可采用哪种敏捷方法？是一步到位还是阶段性的？</li></ul><h3 id="要注意三个真实"><a href="#要注意三个真实" class="headerlink" title="要注意三个真实"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC10%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%8C%81%E7%BB%AD%E6%94%B9%E5%96%84%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/#%E8%A6%81%E6%B3%A8%E6%84%8F%E4%B8%89%E4%B8%AA%E7%9C%9F%E5%AE%9E" title="要注意三个真实"></a>要注意三个真实</h3><p>真实的问题：亲自了解问题，而不是道听途说纸上谈兵。<br>真实的目标：各方共识的目标。<br>真实的方法：找到问题的根源再解决，而不只是一些形式上的措施，比如针对一个表象的问题搞一次形式上的培训。</p><h2 id="识别问题"><a href="#识别问题" class="headerlink" title="识别问题"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC10%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%8C%81%E7%BB%AD%E6%94%B9%E5%96%84%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/#%E8%AF%86%E5%88%AB%E9%97%AE%E9%A2%98" title="识别问题"></a>识别问题</h2><p>识别问题的途径包括：</p><ul><li>  观察：亲自去看团队的运作，特别是各种项目会议，日常交流，工作物件。有条件的话，可以看下团队实际的日常工作。</li><li>  交流：尽可能与所有团队成员和干系人一对一交流，了解他们观察到的现状，看法和建议。</li></ul><h1 id="解决问题："><a href="#解决问题：" class="headerlink" title="解决问题："></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC10%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%8C%81%E7%BB%AD%E6%94%B9%E5%96%84%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/#%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%EF%BC%9A" title="解决问题："></a>解决问题：</h1><p>解决问题可以采用的方法包括：</p><ul><li>  因果逻辑：对问题要找到原因，从源头上解决。了解团队运作的系统动力。如果只是做一些表象上的规定，根本无法落实和执行。</li><li>  PDCA：解决问题要有完整的循环，包括识别问题分析问题设定目标分析根源制定对策的计划阶段，贯彻对策的执行阶段，评估效果的检查阶段，和标准化的调整阶段。</li><li>  回顾会议：利用群体智慧，解决问题。</li></ul><h1 id="固化成果"><a href="#固化成果" class="headerlink" title="固化成果"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC10%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%8C%81%E7%BB%AD%E6%94%B9%E5%96%84%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/#%E5%9B%BA%E5%8C%96%E6%88%90%E6%9E%9C" title="固化成果"></a>固化成果</h1><p>从解决问题中学习，把解决问题的方法提炼成模式。</p><p>在模式一章已经介绍了一些模式。再补充一些如下：</p><ul><li>  在站会中，会观察到一些好模式，如细颗粒度的协作。当一位团队成员说他要启动一个任务，跟他的任务相关的其他团队成员会立即响应说他会同时启动那个相关的任务。把这种观察拿到回顾会议上讨论，让团队参与这种模式的提炼，并丰富细节，记录下来。因为模式是大家共同提炼的，可执行性更强。</li><li>  团队共同参与的庆祝成功也是一种模式。团队有共同的目标，经过努力，取得了值得一提的成功，大家就要庆祝一下。这种成功是属于大家的，并且成功能促进更多的未来成功。</li><li>  制度化客户反馈与产品想法的分享。产品负责人可以把向团队分享客户反馈和产品想法制度化，例如在产品列表精化会和迭代计划会分别固定一块时间拿来分享这类信息。目的是让团队更全面的了解客户，知道自己工作的意义。方式上可以打磨，产生一种花费时间最少又对所有人最有意义的形式。</li></ul><h1 id="打磨逻辑，不断实践"><a href="#打磨逻辑，不断实践" class="headerlink" title="打磨逻辑，不断实践"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC10%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%8C%81%E7%BB%AD%E6%94%B9%E5%96%84%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/#%E6%89%93%E7%A3%A8%E9%80%BB%E8%BE%91%EF%BC%8C%E4%B8%8D%E6%96%AD%E5%AE%9E%E8%B7%B5" title="打磨逻辑，不断实践"></a>打磨逻辑，不断实践</h1><p><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC10%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%8C%81%E7%BB%AD%E6%94%B9%E5%96%84%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/%E4%B8%8D%E6%96%AD%E5%AE%9E%E8%B7%B5.jpg"><img src="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC10%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%8C%81%E7%BB%AD%E6%94%B9%E5%96%84%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/%E4%B8%8D%E6%96%AD%E5%AE%9E%E8%B7%B5.jpg"></a></p><p>系统思考和持续改善并不是什么高深的东西，最后总结如下：</p><ul><li>  对于好的工作方式，心中要有标准，这个标准是我们追求的理想状态，也是问题的鉴别器。</li><li>  心中带着标准，去观察现状，去和干系人交流，了解真实的问题。</li><li>  制定改善目标和改善方案，并取得干系人的共识和支持。</li><li>  实施方案，评估效果。</li><li>  固化方法，固化成果。</li><li>  以迭代的方法重复上述步骤，以敏捷的方式做敏捷。</li><li>  逐步加深解决问题的深度。在解决问题的同时，深化共识和合作。</li><li>  始终不忘事件之间的因果逻辑，并持续躬身实践。</li></ul><p>唯晓成事之规律，方持不灭改善心。思考，就是想出事物当中的理所当然。改善，就是把理所当然的事做到极致。</p></blockquote><blockquote><ul><li>  <strong>本文作者：</strong> joni@efbiz.org</li><li>  <strong>本文链接：</strong>[<a href="https://github.com/efbiz/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC10%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%8C%81%E7%BB%AD%E6%94%B9%E5%96%84%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/">https://github.com/efbiz/2018/05/23/敏捷教练第10课-技巧-持续改善和系统思考方法/</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;是什么让一个团队与另一个团队有所不同？是什么使得一个团队在敏捷教练离开后仍能保持提升？答案是一个团队内建的持续改善与系统思考能力，特别是 Scrum Master。一个具备持续改善和系统思考能力的 Scrum Master，就已经不是只顶着这个角色</summary>
      
    
    
    
    <category term="Scrum" scheme="http://zhangyu.info/categories/Scrum/"/>
    
    
    <category term="Scrum" scheme="http://zhangyu.info/tags/Scrum/"/>
    
  </entry>
  
  <entry>
    <title>敏捷教练第11课-实战-敏捷教练实战周期V形六步法</title>
    <link href="http://zhangyu.info/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC11%E8%AF%BE-%E5%AE%9E%E6%88%98-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AE%9E%E6%88%98%E5%91%A8%E6%9C%9FV%E5%BD%A2%E5%85%AD%E6%AD%A5%E6%B3%95/"/>
    <id>http://zhangyu.info/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC11%E8%AF%BE-%E5%AE%9E%E6%88%98-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AE%9E%E6%88%98%E5%91%A8%E6%9C%9FV%E5%BD%A2%E5%85%AD%E6%AD%A5%E6%B3%95/</id>
    <published>2022-04-11T16:00:00.000Z</published>
    <updated>2022-04-12T02:23:00.968Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文按1-2-3-4-5-6的结构，对敏捷教练的基本功进行总结，并讲述敏捷教练的典型实战周期。</p><p>1-2-3-4-5-6指的是：</p><ul><li>  敏捷教练的1个目标。</li><li>  Scrum 的双翼。</li><li>  团队的3个阶段。</li><li>  敏捷教练的4个发力的角度。</li><li>  团队中的5种角色。</li><li>  教练周期的6个阶段。</li></ul><p><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC11%E8%AF%BE-%E5%AE%9E%E6%88%98-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AE%9E%E6%88%98%E5%91%A8%E6%9C%9FV%E5%BD%A2%E5%85%AD%E6%AD%A5%E6%B3%95/%E5%9F%BA%E6%9C%AC%E5%8A%9F%E6%80%BB%E7%BB%93.jpg"><img src="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC11%E8%AF%BE-%E5%AE%9E%E6%88%98-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AE%9E%E6%88%98%E5%91%A8%E6%9C%9FV%E5%BD%A2%E5%85%AD%E6%AD%A5%E6%B3%95/%E5%9F%BA%E6%9C%AC%E5%8A%9F%E6%80%BB%E7%BB%93.jpg"></a></p><h1 id="基本功"><a href="#基本功" class="headerlink" title="基本功"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC11%E8%AF%BE-%E5%AE%9E%E6%88%98-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AE%9E%E6%88%98%E5%91%A8%E6%9C%9FV%E5%BD%A2%E5%85%AD%E6%AD%A5%E6%B3%95/#%E5%9F%BA%E6%9C%AC%E5%8A%9F" title="基本功"></a>基本功</h1><h2 id="1个目标"><a href="#1个目标" class="headerlink" title="1个目标"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC11%E8%AF%BE-%E5%AE%9E%E6%88%98-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AE%9E%E6%88%98%E5%91%A8%E6%9C%9FV%E5%BD%A2%E5%85%AD%E6%AD%A5%E6%B3%95/#1%E4%B8%AA%E7%9B%AE%E6%A0%87" title="1个目标"></a>1个目标</h2><p>敏捷教练的目标是帮助组织做得更好。正如敏捷宣言所说：我们一直在实践中探寻更好的软件开发方法，身体力行的同时也帮助他人。</p><h2 id="Scrum-的双翼"><a href="#Scrum-的双翼" class="headerlink" title="Scrum 的双翼"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC11%E8%AF%BE-%E5%AE%9E%E6%88%98-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AE%9E%E6%88%98%E5%91%A8%E6%9C%9FV%E5%BD%A2%E5%85%AD%E6%AD%A5%E6%B3%95/#Scrum-%E7%9A%84%E5%8F%8C%E7%BF%BC" title="Scrum 的双翼"></a>Scrum 的双翼</h2><p>Scrum的双翼或两条轨道，一是关于人，即自组织团队，二是关于工作方式，即基于精益敏捷的Scrum框架的运用。掌握了这两个要点，即提纲挈领，纲举目张。</p><h2 id="团队的三个阶段"><a href="#团队的三个阶段" class="headerlink" title="团队的三个阶段"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC11%E8%AF%BE-%E5%AE%9E%E6%88%98-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AE%9E%E6%88%98%E5%91%A8%E6%9C%9FV%E5%BD%A2%E5%85%AD%E6%AD%A5%E6%B3%95/#%E5%9B%A2%E9%98%9F%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5" title="团队的三个阶段"></a>团队的三个阶段</h2><ul><li><p>  第一阶段是无组织。团队绩效不稳定且相对较低，团队成员呈现出一种各自为政的状态，团队活动从目的到流程都缺乏聚焦。</p></li><li><p>  第二阶段是自运转。团队绩效达到一个相对稳定的状态，各项团队活动目的明确，流程清晰，在 Scrum Master 不在的情况下也能自动运转起来。</p></li><li><p>  第三阶段是自组织。团队绩效会阶段性地持续提升，团队成员的互动达到一种高效快乐的状态，团队能够持续地从根本上解决问题，和持续改善。流程中的浪费越来越少，越来越流畅。目标的完成越来越好。</p></li></ul><p>敏捷运用就是把团队从无组织状态带到自运转状态，再带到自组织状态。</p><h2 id="敏捷教练的4个发力的角度"><a href="#敏捷教练的4个发力的角度" class="headerlink" title="敏捷教练的4个发力的角度"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC11%E8%AF%BE-%E5%AE%9E%E6%88%98-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AE%9E%E6%88%98%E5%91%A8%E6%9C%9FV%E5%BD%A2%E5%85%AD%E6%AD%A5%E6%B3%95/#%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%844%E4%B8%AA%E5%8F%91%E5%8A%9B%E7%9A%84%E8%A7%92%E5%BA%A6" title="敏捷教练的4个发力的角度"></a>敏捷教练的4个发力的角度</h2><ul><li>  流程导入：包括产品管理流程和团队迭代运作流程。</li><li>  问题解决：持续解决问题，打造解决问题和改善的文化，形成学习型组织。</li><li>  个人转变：让个人接收敏捷思维，探索更好的工作方式。</li><li>  团队建设：基于 Scrum，打造高效快乐的自组织团队。</li></ul><h2 id="团队中的5种角色"><a href="#团队中的5种角色" class="headerlink" title="团队中的5种角色"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC11%E8%AF%BE-%E5%AE%9E%E6%88%98-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AE%9E%E6%88%98%E5%91%A8%E6%9C%9FV%E5%BD%A2%E5%85%AD%E6%AD%A5%E6%B3%95/#%E5%9B%A2%E9%98%9F%E4%B8%AD%E7%9A%845%E7%A7%8D%E8%A7%92%E8%89%B2" title="团队中的5种角色"></a>团队中的5种角色</h2><ul><li>  产品负责人：产品负责人作为 Scrum 团队的掌舵人，对 Scrum 工作方式的成败至关重要。产品负责人可能有两种，一种是具备开放心态，一种并不理解但又排斥敏捷的价值。对于前者，可直接交流。对于后者，可以让他先观察，接受他先不行动。</li><li>  Scrum Master：Scrum Master 作为流程的化身，从另一个角度对 Scrum 的成败有举足轻重的影响。Scrum Master 要了解敏捷和 Scrum 的基础框架，要相信和支持自组织团队，要有持续改善的系统思维，并通过大量琐碎辛苦的工作来使 Scrum 的运作尽善尽美。Scrum Master 同样可能有两种。一种是主动把这个角色当成一个职业，并且主动投入去精益求精。另一种只是偶然被安排了这个职位。</li><li>  团队成员：通常来说 Scrum 不会直接影响团队成员的利益得失，大多数团队成员对于高效快乐的工作方式是不会反对的。有了产品负责人对 Backlog 的良好管理，和 Scrum Master 的有效引导，团队取得进步是自然而然的。</li><li>  非专职人员：非专职人员需要理解 Scrum 工作方式，并与团队成员有效配合。非专职人员与团队的合作方式，需要打磨出显式化可执行的规则。</li><li>  Team Leader：直接工作在 Scrum 团队内的 Team Leader 可能会受到 Scrum 工作方式的冲击。Team Leader 是否要受 Scrum 框架的制约，要根据组织的实际情况处理。</li></ul><h2 id="教练参与周期的6个阶段"><a href="#教练参与周期的6个阶段" class="headerlink" title="教练参与周期的6个阶段"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC11%E8%AF%BE-%E5%AE%9E%E6%88%98-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AE%9E%E6%88%98%E5%91%A8%E6%9C%9FV%E5%BD%A2%E5%85%AD%E6%AD%A5%E6%B3%95/#%E6%95%99%E7%BB%83%E5%8F%82%E4%B8%8E%E5%91%A8%E6%9C%9F%E7%9A%846%E4%B8%AA%E9%98%B6%E6%AE%B5" title="教练参与周期的6个阶段"></a>教练参与周期的6个阶段</h2><ul><li>  调查与方案：了解团队的目标，所面临的问题，制定敏捷导入方案。</li><li>  导入与反馈：导入敏捷，获得团队反馈。</li><li>  痛点与问题解决：了解团队的问题和痛点，协助问题解决。</li><li>  卓越驱动的系统改善，共识机制训练：制定改善架构，进行有系统的改善。</li><li>  深入的问题解决：发现和解决那些影响敏捷工作方式发挥作用的障碍。</li><li>  观察与拓展，发现好模式：观察团队中浮现出的好的模式，借鉴到其他团队。</li></ul><p>本文的剩余部分将会详细介绍这个敏捷教练周期的6阶段。</p><p>阅读敏捷教练周期的6个阶段时，有几个注意事项：</p><ul><li>  谨记教练的目标是打造按敏捷方式完美运作，并内建了持续改善能力的自组织团队。</li><li>  深入的敏捷实施涉及到工作方式与人两个维度。</li><li>  6个阶段包括其顺序都不是绝对的，需要根据团队实际情况定制。</li><li>  6个阶段，可能的话可以与迭代的节奏一致，即一个阶段对应一个迭代，但也不绝对。</li></ul><p><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC11%E8%AF%BE-%E5%AE%9E%E6%88%98-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AE%9E%E6%88%98%E5%91%A8%E6%9C%9FV%E5%BD%A2%E5%85%AD%E6%AD%A5%E6%B3%95/v%E5%9E%8B%E6%95%99%E7%BB%83.jpg"><img src="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC11%E8%AF%BE-%E5%AE%9E%E6%88%98-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AE%9E%E6%88%98%E5%91%A8%E6%9C%9FV%E5%BD%A2%E5%85%AD%E6%AD%A5%E6%B3%95/v%E5%9E%8B%E6%95%99%E7%BB%83.jpg"></a></p><h1 id="阶段1：调查与方案，诊断与对策"><a href="#阶段1：调查与方案，诊断与对策" class="headerlink" title="阶段1：调查与方案，诊断与对策"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC11%E8%AF%BE-%E5%AE%9E%E6%88%98-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AE%9E%E6%88%98%E5%91%A8%E6%9C%9FV%E5%BD%A2%E5%85%AD%E6%AD%A5%E6%B3%95/#%E9%98%B6%E6%AE%B51%EF%BC%9A%E8%B0%83%E6%9F%A5%E4%B8%8E%E6%96%B9%E6%A1%88%EF%BC%8C%E8%AF%8A%E6%96%AD%E4%B8%8E%E5%AF%B9%E7%AD%96" title="阶段1：调查与方案，诊断与对策"></a>阶段1：调查与方案，诊断与对策</h1><p>这个阶段的开始以收到教练需求邀请为标志，以制定出敏捷实施方案，并能够开始第一个迭代的敏捷导入为标志。这个阶段包括调查与方案两个环节。</p><p>在调查环节所要做的事情包括：</p><ul><li>  访谈关键干系人，包括部门经理、项目经理、产品负责人、Scrum Master、开发 Lead、测试 Lead、架构师和设计师等，了解团队的目标及面临的主要问题。</li><li>  参与团队的会议，现场了解团队现有的工作方式。</li></ul><h2 id="方案包含两部分"><a href="#方案包含两部分" class="headerlink" title="方案包含两部分"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC11%E8%AF%BE-%E5%AE%9E%E6%88%98-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AE%9E%E6%88%98%E5%91%A8%E6%9C%9FV%E5%BD%A2%E5%85%AD%E6%AD%A5%E6%B3%95/#%E6%96%B9%E6%A1%88%E5%8C%85%E5%90%AB%E4%B8%A4%E9%83%A8%E5%88%86" title="方案包含两部分"></a>方案包含两部分</h2><ul><li>  在启动第一个迭代前所要做的事。</li><li>  第一个迭代的启动计划。</li></ul><h2 id="在启动第一个迭代前所要做的事可能有"><a href="#在启动第一个迭代前所要做的事可能有" class="headerlink" title="在启动第一个迭代前所要做的事可能有"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC11%E8%AF%BE-%E5%AE%9E%E6%88%98-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AE%9E%E6%88%98%E5%91%A8%E6%9C%9FV%E5%BD%A2%E5%85%AD%E6%AD%A5%E6%B3%95/#%E5%9C%A8%E5%90%AF%E5%8A%A8%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%BF%AD%E4%BB%A3%E5%89%8D%E6%89%80%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B%E5%8F%AF%E8%83%BD%E6%9C%89" title="在启动第一个迭代前所要做的事可能有"></a>在启动第一个迭代前所要做的事可能有</h2><ul><li>  如果产品列表和用户故事的管理不能达到启动第一个迭代的条件，需要与产品负责人一起工作，打磨产品列表和用户故事，使之达到准备好的状态。</li><li>  如果团队规模和技能配备妨碍了团队自组织和跨职能工作，需要先解决这部分问题。</li><li>  如果 Scrum Master 对敏捷和 Scrum 的知识不够，需要先补足这部分知识。</li></ul><p>在调查和方案阶段，所使用的标准是 Scrum、用户故事和精益敏捷的基础知识，以此来识别问题，补足知识，和解决问题。所使用的技巧主要是讲授和问题解决，也包括一定的指导。</p><p>在这个阶段最开始，还有一件最重要的事，就是教练启动会议。没有教练的关系，就没有教练的行为。</p><p>经过第1阶段，就具备了开始第一个迭代的敏捷导入的条件。第一个迭代的启动计划在下一节谈及。</p><p><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC11%E8%AF%BE-%E5%AE%9E%E6%88%98-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AE%9E%E6%88%98%E5%91%A8%E6%9C%9FV%E5%BD%A2%E5%85%AD%E6%AD%A5%E6%B3%95/1%E9%98%B6%E6%AE%B5.jpg"><img src="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC11%E8%AF%BE-%E5%AE%9E%E6%88%98-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AE%9E%E6%88%98%E5%91%A8%E6%9C%9FV%E5%BD%A2%E5%85%AD%E6%AD%A5%E6%B3%95/1%E9%98%B6%E6%AE%B5.jpg"></a></p><h1 id="阶段2：实施变化，导入与反馈"><a href="#阶段2：实施变化，导入与反馈" class="headerlink" title="阶段2：实施变化，导入与反馈"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC11%E8%AF%BE-%E5%AE%9E%E6%88%98-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AE%9E%E6%88%98%E5%91%A8%E6%9C%9FV%E5%BD%A2%E5%85%AD%E6%AD%A5%E6%B3%95/#%E9%98%B6%E6%AE%B52%EF%BC%9A%E5%AE%9E%E6%96%BD%E5%8F%98%E5%8C%96%EF%BC%8C%E5%AF%BC%E5%85%A5%E4%B8%8E%E5%8F%8D%E9%A6%88" title="阶段2：实施变化，导入与反馈"></a>阶段2：实施变化，导入与反馈</h1><p>这一阶段的目标是进行敏捷和 Scrum 工作方式的首次导入，并获得团队的反馈。对于已经使用 Scrum 的团队，是一种重新导入。已经使用 Scrum 的团队，有可能受制于团队已有模式的影响，只是在形式上采用了 Scrum，而丢掉了本质和核心的东西，重新导入需要以正确的敏捷修正受到侵蚀的敏捷。</p><p>这个阶段如果有条件的话，可以做一个全体团队成员参与的一到两天的启动仪式：</p><ul><li>  与 Scrum 建立连接：探讨已有工作方法中好的地方，不好的地方，建立改善的愿望，把 Scrum 当作好的工作方法的载体，建立良好使用 Scrum 的决心。</li><li>  介绍精益敏捷、Scrum 和用户故事的核心和实践。</li><li>  让团队成员深入了解彼此，制定团队的价值观和团队规范。</li><li>  刷新产品愿景、路线图、发布计划和产品列表。</li></ul><p>如果不能进行一到两天的启动仪式，则可以在每个 Scrum 仪式前分别用10分钟左右时间介绍该仪式及相关物件：</p><ul><li>  在产品列表精化会前介绍产品列表精化的目的和流程。</li><li>  在迭代计划会前介绍计划的目的和流程，及每日站会。</li><li>  在迭代评审前介绍评审会议及回顾会议的目的和流程。</li><li>  在每个会议的介绍之后，协助该会议的进行。对于会议中偏离目的与流程的行为，进行指导。指导可以以在每个会议结束时发表评论的方式进行，可以在会后进行个别谈话，也可以拿到回顾会议讨论。</li></ul><p>在第一迭代进行到中间的时候，即可以开始了解团队对工作方式变化的反馈，因为这时工作方式的效果已经能发生了。了解反馈的目的是对工作方式进行修正。在第一迭代中间了解反馈还有一个好处是，鼓励团队把反馈和问题带到回顾会议讨论。内建团队的问题发现和解决能力是敏捷实施的重要目标，为了达到这一目标，敏捷教练要有意压制自己对观察到的问题的表达，而是把团队推到前面，帮助团队成长。</p><p>在导入和反馈阶段，讲授、协助和指导的技巧都会用到。问题解决和持续改善也会触及。协作指挥和冲突领航则是择机采用。</p><p>经过第2阶段，团队初步体会了完整的正确的敏捷，并为工作方式的变化提供了反馈，以帮助后续工作方式的调节。</p><p>通常来说，经过一个迭代按正确 Scrum 的运转，团队对更加清晰透明的工作方式会有正面反馈，迭代的完成率等结果指标也会有明显提升。</p><h1 id="第3阶段：痛点与问题解决"><a href="#第3阶段：痛点与问题解决" class="headerlink" title="第3阶段：痛点与问题解决"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC11%E8%AF%BE-%E5%AE%9E%E6%88%98-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AE%9E%E6%88%98%E5%91%A8%E6%9C%9FV%E5%BD%A2%E5%85%AD%E6%AD%A5%E6%B3%95/#%E7%AC%AC3%E9%98%B6%E6%AE%B5%EF%BC%9A%E7%97%9B%E7%82%B9%E4%B8%8E%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3" title="第3阶段：痛点与问题解决"></a>第3阶段：痛点与问题解决</h1><p>在这一阶段和后续阶段持续要做的事是，持续观察团队的 Scrum 仪式，发现其中违背正确敏捷实践的行为，以及发现团队工作中涌现出的好的模式。对于观察到的结果，可以在当时即每个仪式结束时现场提出来，可以在个别谈话中进行，也可以留到回顾会议。依然是两个原则：只要不影响团队运作的行为，尽量延迟到回顾会议进行；培养团队的问题解决能力重于问题解决本身。</p><p>这种观察、思考、反馈和调整会延续到整个教练周期，并且以打造按正确敏捷运作、具有自我改善能力的自组织团队为目标。</p><p>在这个阶段，除了观察、思考、反馈和调整之外，可以设定另一主题，那就是痛点与问题解决。具体的方式采用一对一谈话。谈话的对象包含产品负责人、Scrum Master、团队 Lead 和其他对工作方式有热情的人。整个教练计划可以公开给团队，可以发起一对一交流，也鼓励团队成员来发起一对一交流。</p><p>这一轮交流的三个主题是：</p><ul><li>  进一步获得他们对工作方式变化的反馈。</li><li>  探询他们的痛点和希望解决的问题。</li><li>  同时提供对他们本身的反馈。</li></ul><p>这种交流是一种一对一 Retrospective，其目的、边界和框架如下：</p><ul><li>  一对一 Retrospective 是对团队Retrospective 的鼓励和驯化。是为了帮助打磨团队Retrospective。</li><li>  一对一 Retrospective 是对团队Retrospective 的补充。即使团队 Retrospective 已经搞得很好了，也还需要一对一 Retrospective。</li><li>  一对一 Retrospective 可以由 Scrum Master 发起，也可以由任何人向任何人发起。</li><li>  一对一 Retrospective 的目的，是加强人与人之间的连接，传递改善的信念，和计划和执行改善。</li><li>  一对一 Retrospective 的边界，是围绕改善的基调，就与团队项目工作相关的事进行讨论。</li><li>  一对一 Retrospective 的框架，可以包含探询交流对象对工作方式的反馈、探询痛点和关注的问题，和以 Scrum 实践和角色要求为基准、以观察到的行为为依据向交流对象提供的反馈。还可以包含不同团队之间的经验传递、桥梁和延展。</li><li>  如果希望痛点和问题的探询更封闭一点，可以分解为几个角度：就团队项目工作的上下文而言，您的目标和期望的理想状态是什么？与现状的差距是什么？流程上有什么问题，或有什么妨碍理想状态的达到？团队合作方面呢？团队工作绩效和质量呢？任何其他方面？</li><li>  这个框架的运用要灵活。人的主动参与重于规则。如果人能主动参与改善事项的发掘、计划和行动，框架就可以放下。</li><li>  Scrum Master 日常有力的观察是 Retrospective 的重要输入。</li><li>  各个角色的普适标准：专业、尊重、坚持。</li><li>  改变的第一原则：一切改变基于自愿。改善的用意是改善系统，不是改变个人。</li></ul><p>这一阶段可能获得的问题有：</p><ul><li>  会议效率问题：在 Scrum 框架之下继续打磨提升，细致地进行会议每个环节的提升，包括会前准备、会中引导、会后跟踪。比如说在精化会前大家可以先熟悉一下故事，在评审会前需做好演示的准备。在会议中引导促进大家的互动。</li><li>  三个角色的职责问题：产品负责人负责与客户和产品有关的问题，Scrum Master 负责与沟通协调有关的问题，团队负责与技术相关的问题。</li><li>  提升团队的参与度和对完整故事的关注：通过提升透明性，在计划会和站会上更加清晰透明地呈现工作来提升团队的参与度，通过设置故事 owner 提升和训练对完整故事的关注。</li><li>  ：需要团队共创解决方法，比如说，一个原则是，开发优先做需要测试的任务。还可以设置开发任务的检查点。开发与测试结对工作。</li><li>  团队建设，心理安全与归属感问题：需要与管理者和团队讨论处理。建立产品团队的形态与心态。</li></ul><p>这些问题大致分布在流程与效率、角色职责、团队感和业务学习方面。</p><p>对于收到的问题的解决思路有：</p><ul><li>  按敏捷框架中的原则和实践解决。</li><li>  拿到回顾会议上，由团队讨论解决。</li><li>  对于深层次的组织问题，第一步是清晰的呈现问题，第二步是与有影响力的人交谈。</li><li>  鼓励学习其他团队的 Scrum 运作。</li></ul><p>在这个阶段，对于团队的 Scrum 仪式，依然会讲授、协助和指导。更多的是以团队为中心的立体双向反馈，了解团队的痛点和问题，并协助解决。</p><p>经过这一阶段，团队的敏捷运作已经达到了有意识的状态，虽然还不能完全自运转，但已经会发生一些有意识的提升和改变。另一方面，对于团队的问题也有了更深入的了解，为下一阶段的系统化的改善打下基础。</p><p><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC11%E8%AF%BE-%E5%AE%9E%E6%88%98-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AE%9E%E6%88%98%E5%91%A8%E6%9C%9FV%E5%BD%A2%E5%85%AD%E6%AD%A5%E6%B3%95/2%E9%98%B6%E6%AE%B5.jpg"><img src="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC11%E8%AF%BE-%E5%AE%9E%E6%88%98-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AE%9E%E6%88%98%E5%91%A8%E6%9C%9FV%E5%BD%A2%E5%85%AD%E6%AD%A5%E6%B3%95/2%E9%98%B6%E6%AE%B5.jpg"></a></p><h1 id="第4阶段：卓越驱动的系统改善，训练共识机制"><a href="#第4阶段：卓越驱动的系统改善，训练共识机制" class="headerlink" title="第4阶段：卓越驱动的系统改善，训练共识机制"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC11%E8%AF%BE-%E5%AE%9E%E6%88%98-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AE%9E%E6%88%98%E5%91%A8%E6%9C%9FV%E5%BD%A2%E5%85%AD%E6%AD%A5%E6%B3%95/#%E7%AC%AC4%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%8D%93%E8%B6%8A%E9%A9%B1%E5%8A%A8%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%94%B9%E5%96%84%EF%BC%8C%E8%AE%AD%E7%BB%83%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6" title="第4阶段：卓越驱动的系统改善，训练共识机制"></a>第4阶段：卓越驱动的系统改善，训练共识机制</h1><p>如上一阶段所说，对团队的观察、思考、反馈、调整还在持续进行。</p><p>此外，可以引入卓越驱动的系统改善。卓越驱动的系统改善即是：</p><ul><li>  团队定义一组卓越指标，即团队认为对于提升团队工作方式最有价值的东西。</li><li>  对于卓越指标，利用每一次回顾会议，进行评估和改善。</li><li>  以这一套卓越指标驱动系统化的改善。</li></ul><p>卓越指标示例：</p><h2 id="卓越指标1-跨职能团队"><a href="#卓越指标1-跨职能团队" class="headerlink" title="卓越指标1. 跨职能团队"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC11%E8%AF%BE-%E5%AE%9E%E6%88%98-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AE%9E%E6%88%98%E5%91%A8%E6%9C%9FV%E5%BD%A2%E5%85%AD%E6%AD%A5%E6%B3%95/#%E5%8D%93%E8%B6%8A%E6%8C%87%E6%A0%871-%E8%B7%A8%E8%81%8C%E8%83%BD%E5%9B%A2%E9%98%9F" title="卓越指标1. 跨职能团队"></a>卓越指标1. 跨职能团队</h2><p>定义：不要让技能不平衡成为障碍。</p><p>子条目：</p><ul><li>  定义人与技能矩阵，以及理想的技能配置。在理想情况下，每一所需的技能最好有至少两个人精通和一个人了解。找出现状矩阵与理想矩阵的差距。</li><li>  在迭代工作中，在团队容量容许的情况下，有意识地安排结对工作，以传播技能。结对工作所造成的团队速率下降以不超过10%为宜。</li><li>  跨职能与结对的安排需要考虑个人兴趣。</li><li>  制定长期的跨职能团队建设计划。</li></ul><h2 id="卓越指标2-价值流优化"><a href="#卓越指标2-价值流优化" class="headerlink" title="卓越指标2. 价值流优化"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC11%E8%AF%BE-%E5%AE%9E%E6%88%98-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AE%9E%E6%88%98%E5%91%A8%E6%9C%9FV%E5%BD%A2%E5%85%AD%E6%AD%A5%E6%B3%95/#%E5%8D%93%E8%B6%8A%E6%8C%87%E6%A0%872-%E4%BB%B7%E5%80%BC%E6%B5%81%E4%BC%98%E5%8C%96" title="卓越指标2. 价值流优化"></a>卓越指标2. 价值流优化</h2><p>定义：移除障碍，让团队所有的努力都指向对客户价值的贡献。</p><p>子条目：</p><ul><li>  制定 DoR 准备好的定义，形成高质量的迭代入口。</li><li>  制定 DoD 完成的定义，形成高质量的迭代出口。 -每迭代的故事分为承诺的故事和可选的故事，可选的故事可以在产品列表精化会或迭代计划会上产生。</li><li>  识别和移除障碍，帮助工作更好地流动。</li><li>  会议议程有清晰的结构，每一议程精确到十分钟的颗粒度。</li></ul><h2 id="卓越指标3-团队工作"><a href="#卓越指标3-团队工作" class="headerlink" title="卓越指标3. 团队工作"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC11%E8%AF%BE-%E5%AE%9E%E6%88%98-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AE%9E%E6%88%98%E5%91%A8%E6%9C%9FV%E5%BD%A2%E5%85%AD%E6%AD%A5%E6%B3%95/#%E5%8D%93%E8%B6%8A%E6%8C%87%E6%A0%873-%E5%9B%A2%E9%98%9F%E5%B7%A5%E4%BD%9C" title="卓越指标3. 团队工作"></a>卓越指标3. 团队工作</h2><p>定义：团队协作，以最大化团队产出。</p><p>子条目：</p><ul><li>  定期知识分享。</li><li>  经常庆祝成功。</li><li>  集体代码所有。</li><li>  交叉演示工作，例如 Tom 可以演示 Jerry 的工作。</li></ul><p>卓越指标的制定，要由团队一起完成。具体可采用团队会议与一对一交流相结合的形式。</p><p>经过阶段4，团队的协作和 Scrum 运作已经相对比较熟练了。但其中依然有大量可以改善的点。而这个卓越驱动的系统改善提供了一个结构，充当了一个面。日常点的观察，与卓越驱动的回顾会议的面的结合，让改善更深入地发生。</p><h1 id="阶段5：深入的问题解决"><a href="#阶段5：深入的问题解决" class="headerlink" title="阶段5：深入的问题解决"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC11%E8%AF%BE-%E5%AE%9E%E6%88%98-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AE%9E%E6%88%98%E5%91%A8%E6%9C%9FV%E5%BD%A2%E5%85%AD%E6%AD%A5%E6%B3%95/#%E9%98%B6%E6%AE%B55%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3" title="阶段5：深入的问题解决"></a>阶段5：深入的问题解决</h1><p>在这一阶段，观察与改善继续进行。</p><p>经过前面几个阶段，团队的 Scrum 运作得比较好了，也建立了改善系统和一定的改善能力，解决问题的意识也建立起来了。</p><p>下一步是发现和解决那些影响敏捷深化的问题。这一步所采用的方法主要有四个：</p><ul><li><p>  观察团队的 Scrum 运作。</p></li><li><p>  在回顾会上讨论需要改善的问题。</p></li><li><p>  一对一交流。</p></li><li><p>  团队的敏捷成熟度评估。</p></li></ul><p>在这一阶段所要解决的，可能是一些深层次的问题，例如：团队中存在层级结构，或者团队成员来自不同的部门，让团队无法真正自组织，产生高质量的互动。</p><p>在这一阶段，问题解决是采用的主要技巧。</p><p><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC11%E8%AF%BE-%E5%AE%9E%E6%88%98-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AE%9E%E6%88%98%E5%91%A8%E6%9C%9FV%E5%BD%A2%E5%85%AD%E6%AD%A5%E6%B3%95/3%E9%98%B6%E6%AE%B5.jpg"><img src="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC11%E8%AF%BE-%E5%AE%9E%E6%88%98-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AE%9E%E6%88%98%E5%91%A8%E6%9C%9FV%E5%BD%A2%E5%85%AD%E6%AD%A5%E6%B3%95/3%E9%98%B6%E6%AE%B5.jpg"></a></p><h1 id="阶段6：观察与扩展，发现好模式。"><a href="#阶段6：观察与扩展，发现好模式。" class="headerlink" title="阶段6：观察与扩展，发现好模式。"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC11%E8%AF%BE-%E5%AE%9E%E6%88%98-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AE%9E%E6%88%98%E5%91%A8%E6%9C%9FV%E5%BD%A2%E5%85%AD%E6%AD%A5%E6%B3%95/#%E9%98%B6%E6%AE%B56%EF%BC%9A%E8%A7%82%E5%AF%9F%E4%B8%8E%E6%89%A9%E5%B1%95%EF%BC%8C%E5%8F%91%E7%8E%B0%E5%A5%BD%E6%A8%A1%E5%BC%8F%E3%80%82" title="阶段6：观察与扩展，发现好模式。"></a>阶段6：观察与扩展，发现好模式。</h1><p>这一阶段主要有三个任务：</p><ul><li>  持续观察和改善。</li><li>  发现团队中涌现出的好的模式，并使之持久化，和扩展到其他团队。</li><li>  培养 Scrum Master 的系统观察和思考能力。</li></ul><p>改善是无止境的，改善之旅是没有终点的。唯晓成事之规律，方持不灭改善心。</p><p>最后用大野耐一对丰田生产方式两个支柱的解读帮助我们了解敏捷和 Scrum 最本质的东西：人，以及人的配合。</p><p>大野耐一在其所著的《丰田生产方式》一书中这样评价“准时化”和“自动化”之间的关系： “准时化”和“自动化”是丰田生产方式的两大支柱。如果用棒球比赛来打比方的话，那么准时化就相当于团队协作，也就是通过团队密切而巧妙地配合，将其实力发挥到极致。而自动化则是要求每一位选手的个人技术要越来越高超，并且进一步使得团队的整体实力在个人技术提高的基础上得到更充分的体现。准时化可以让问题明确化，自动化可以让解决问题的努力更有效。自动化——让每一个人提高自己的水平，整个团队也会因为每一位选手的高超技艺，相互之间的配合变得更加默契，战法也更加成熟和丰富起来。当然，由此带来的结果就是：比赛的成绩越来越好，也就是企业的经营业绩越来越优异。</p></blockquote><blockquote><ul><li>  <strong>本文作者：</strong> joni@efbiz.org</li><li>  <strong>本文链接：</strong> <a href="https://github.com/efbiz/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC11%E8%AF%BE-%E5%AE%9E%E6%88%98-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AE%9E%E6%88%98%E5%91%A8%E6%9C%9FV%E5%BD%A2%E5%85%AD%E6%AD%A5%E6%B3%95/">https://github.com/efbiz/2018/05/23/敏捷教练第11课-实战-敏捷教练实战周期V形六步法/</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文按1-2-3-4-5-6的结构，对敏捷教练的基本功进行总结，并讲述敏捷教练的典型实战周期。&lt;/p&gt;
&lt;p&gt;1-2-3-4-5-6指的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;  敏捷教练的1个目标。&lt;/li&gt;
&lt;li&gt;  Scrum 的双翼。&lt;/li&gt;
</summary>
      
    
    
    
    <category term="Scrum" scheme="http://zhangyu.info/categories/Scrum/"/>
    
    
    <category term="Scrum" scheme="http://zhangyu.info/tags/Scrum/"/>
    
  </entry>
  
  <entry>
    <title>敏捷教练第06课-技巧-敏捷教练的四种心法</title>
    <link href="http://zhangyu.info/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/"/>
    <id>http://zhangyu.info/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/</id>
    <published>2022-04-11T16:00:00.000Z</published>
    <updated>2022-04-12T02:04:19.889Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>敏捷教练的职责是帮助组织做得更好。为了履行这个职责，首先是做好前面几章介绍的知识储备。其次是运用这些知识影响组织，也就是下一章开始讲的教练的六种方法。在进行教练之前，敏捷教练需要做一些自身的在敏捷知识之上的内在准备，也就是四种心法：</p><ul><li>  内建能力</li><li>  更高标准</li><li>  自我掌控</li><li>  灵活变通</li></ul><p><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95.jpg"><img src="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95.jpg"></a></p><h1 id="心法一：内建能力"><a href="#心法一：内建能力" class="headerlink" title="心法一：内建能力"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/#%E5%BF%83%E6%B3%95%E4%B8%80%EF%BC%9A%E5%86%85%E5%BB%BA%E8%83%BD%E5%8A%9B" title="心法一：内建能力"></a>心法一：内建能力</h1><p>在敏捷开发指导过程中，对团队影响最大的其实是教练本人的内在品质和行为方式，而并非任何外在的具体的技术或者意见。教练的一言一行无不体现出其内在品质和对敏捷主要观念的理解。通过内在品质的体现，可以给个人、团队和组织带来深远而持久的影响，比照本宣科式刻板地执行敏捷思想中的具体的技术有更加深刻的意义。<br><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/%E5%86%85%E5%BB%BA%E8%83%BD%E5%8A%9B.jpg"><img src="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/%E5%86%85%E5%BB%BA%E8%83%BD%E5%8A%9B.jpg"></a></p><h2 id="敏捷教练的定位"><a href="#敏捷教练的定位" class="headerlink" title="敏捷教练的定位"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/#%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%AE%9A%E4%BD%8D" title="敏捷教练的定位"></a>敏捷教练的定位</h2><ul><li>  一个能够准确掌握敏捷开发实践和理论中深层次内容，并且能够帮助团队理解这些内容的人。</li><li>  一个面对过巨大挑战、内部阻力，并且能够在需要时为经理们或者其他团队的人员提供指导的人。</li><li>  一个能够帮助组织内各级管理层去深刻理解有效的敏捷开发能够为日常工作带来哪些好处的人。</li><li>  一个能够从专业辅导、冲突管理、矛盾调解、剧场表演等相关学科中引入新的观点和理论，从而让自己团队的表现不断提升的人。</li><li>  既关注在复杂而又变幻无穷的世界中创造出有意义的产品，也关注为参与创造的人们的职业生涯带来更多益处。</li></ul><h2 id="敏捷教练应该克服与改变的方面"><a href="#敏捷教练应该克服与改变的方面" class="headerlink" title="敏捷教练应该克服与改变的方面"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/#%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%BA%94%E8%AF%A5%E5%85%8B%E6%9C%8D%E4%B8%8E%E6%94%B9%E5%8F%98%E7%9A%84%E6%96%B9%E9%9D%A2" title="敏捷教练应该克服与改变的方面"></a>敏捷教练应该克服与改变的方面</h2><p>对照下面“应该做到的”一起看</p><ul><li>  协调个人对团队的贡献。</li><li>  做一个领域专家。</li><li>  把精力花在追求特定产出上。</li><li>  自己知道所有问题的答案。</li><li>  自己全权管理整个项目。</li><li>  推动。</li><li>  注重截止日期和技术路线的选择。</li><li>  注重行为的最优性。</li><li>  亲自解决问题。</li><li>  工作总能很好地计划，计划总能很好地被实施。</li><li>  项目三要素可以相互调剂和妥协，以应对未知的突发情况。</li><li>  随着需求、设计、开发、测试阶段的推进，可预测性越来越高。</li><li>  准时和在预算内完成目标就是成功。</li><li>  项目的范围可以事先锁定。</li><li>  从头到尾控制整个项目的进程。</li><li>  完成阶段性目标和任务是工作价值的度量。</li></ul><h2 id="敏捷教练应该做到的方面"><a href="#敏捷教练应该做到的方面" class="headerlink" title="敏捷教练应该做到的方面"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/#%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%BA%94%E8%AF%A5%E5%81%9A%E5%88%B0%E7%9A%84%E6%96%B9%E9%9D%A2" title="敏捷教练应该做到的方面"></a>敏捷教练应该做到的方面</h2><ul><li>  指导整个团队进行协作。</li><li>  充当团队的协助员。</li><li>  把精力花在提升团队的整体表现上。</li><li>  让团队自己寻找答案。</li><li>  让团队自己寻找途径。</li><li>  指导。</li><li>  注重商业价值的达成。</li><li>  注重于每时每刻都做有利于业务发展的事情。</li><li>  将问题交予团队。</li><li>  提前计划并不可少，但确定的计划并无用处。</li><li>  时间和预算不变，范围可变。</li><li>  随着时间推移，计划不断被修正，因而越来越准确。</li><li>  客户获得的商业价值是成功的标准。</li><li>  项目范围保持灵活，任何变化都可接受。</li><li>  以团队贯彻敏捷思想来控制进程。</li><li>  可工作的软件才是价值的度量。</li></ul><h2 id="敏捷教练的内在品质"><a href="#敏捷教练的内在品质" class="headerlink" title="敏捷教练的内在品质"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/#%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%86%85%E5%9C%A8%E5%93%81%E8%B4%A8" title="敏捷教练的内在品质"></a>敏捷教练的内在品质</h2><ul><li>  能够读懂一个房间的空气中蕴含的情绪，并判断出是否一切正常。</li><li>  关心人胜过关心产品，让团队成员感受到自己受到关心，自己的成长得到支持，进而团结一致，创造出卓越的产品。</li><li>  不断培养自己的好奇心，清楚地意识到自己的疑惑在那里，不会主观揣测他人在想什么，及情况形成的原因，而是会如实发问。</li><li>  相信人之初性本善，人的内心总有善良的一面，不过可能被客观情况耽误了，接受他们目前的状况，并尽可能帮助他们成长。</li><li>  不是固执地执行事先制订的计划，而是时刻与团队一起解决新出现的问题。</li><li>  有着学习的渴望，知道自己还需要不断成长和提高。</li><li>  相信只要给予一个大胆的目标和一个成长的环境，任何一组人都能把事情做好。更高的目标值的追求。</li><li>  不容忍人们为不求上进寻找的各种借口。例如：我们一直是这样做的。</li><li>  相信预期之外的情况一定是会出现的，而混乱只是达到更好情况的必经阶段，做好应对混乱的准备。</li><li>  愿意承担犯错的风险。承认错误，承担责任，但不会纠结于此。</li></ul><h2 id="形成个人特色"><a href="#形成个人特色" class="headerlink" title="形成个人特色"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/#%E5%BD%A2%E6%88%90%E4%B8%AA%E4%BA%BA%E7%89%B9%E8%89%B2" title="形成个人特色"></a>形成个人特色</h2><ul><li>  找到自己做敏捷教练的独特风格。</li><li>  不断实践和总结。</li><li>  把从本课程中学到的东西用自己的方式消化，然后指导团队。只有自己最熟悉自己周围的环境，也只有自己最了解自己。</li><li>  对环境和自己要充满信心，不偏安一隅，勇于挑战自己，通过指导敏捷开发团队的工作来实现自己的成长和成功。</li></ul><h1 id="心法二：更高标准"><a href="#心法二：更高标准" class="headerlink" title="心法二：更高标准"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/#%E5%BF%83%E6%B3%95%E4%BA%8C%EF%BC%9A%E6%9B%B4%E9%AB%98%E6%A0%87%E5%87%86" title="心法二：更高标准"></a>心法二：更高标准</h1><p>把高绩效作为自己的期望标准，并帮助团队去实现它，这些都能给你以重要而强大的动力。如果可以随时保持雄心勃勃，那么每个人都能获得最后的胜利。公司或组织不仅获得了更好的成果，还拥有了无所不能的团队。团队及每个成员则获得了更多自主权，掌握了高超的技能并实现了自己的目标。每个人都能从高绩效中受益。<br><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/%E6%9B%B4%E9%AB%98%E6%A0%87%E5%87%86.jpg"><img src="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/%E6%9B%B4%E9%AB%98%E6%A0%87%E5%87%86.jpg"></a></p><h2 id="设定高标准："><a href="#设定高标准：" class="headerlink" title="设定高标准："></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/#%E8%AE%BE%E5%AE%9A%E9%AB%98%E6%A0%87%E5%87%86%EF%BC%9A" title="设定高标准："></a>设定高标准：</h2><ul><li>  设定高绩效仅仅表明你相信高绩效是可以实现的，你相信团队能够实现这一目标。</li><li>  需要用自己的信心激励团队朝着能共同达到的愿景而努力奋斗。</li><li>  高绩效无关乎是否到达某一特定状态，而是一段通往更高目标的旅程。超越一切合理的期望，甚至对自己的进度感到惊讶，不断保持进步。</li><li>  为帮助团队开启通往高绩效的旅途，需要为团队设定将要实现的目标期望。</li><li>  接下来，指导他们迈出第一步，以及以后的每一步，并一步一步地朝着那鼓舞人心的高绩效的目标前进。</li><li>  你首先需要先让自己产生一种对这段旅途期待向往和兴奋的感觉，然后再把这种感觉传导到整个团队中去。</li><li>  高绩效是没有终点的旅途。</li><li>  一旦开启高绩效之旅，就会有各种各样的障碍出现，团队要为他们能够彻底地快速地从挫折中恢复过来感到自豪。让高绩效成为他们对自己的期望和信心，支撑他们挺过一个又一个难关。</li></ul><h2 id="高绩效的隐喻之高绩效树"><a href="#高绩效的隐喻之高绩效树" class="headerlink" title="高绩效的隐喻之高绩效树"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/#%E9%AB%98%E7%BB%A9%E6%95%88%E7%9A%84%E9%9A%90%E5%96%BB%E4%B9%8B%E9%AB%98%E7%BB%A9%E6%95%88%E6%A0%91" title="高绩效的隐喻之高绩效树"></a>高绩效的隐喻之高绩效树</h2><ul><li>  用高绩效树帮助团队描绘高绩效期望的愿景。</li><li>  当出现问题或不足时，将它作为一种研究问题的方法。</li></ul><h2 id="高绩效树的树根：Scrum-的价值观"><a href="#高绩效树的树根：Scrum-的价值观" class="headerlink" title="高绩效树的树根：Scrum 的价值观"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/#%E9%AB%98%E7%BB%A9%E6%95%88%E6%A0%91%E7%9A%84%E6%A0%91%E6%A0%B9%EF%BC%9AScrum-%E7%9A%84%E4%BB%B7%E5%80%BC%E8%A7%82" title="高绩效树的树根：Scrum 的价值观"></a>高绩效树的树根：Scrum 的价值观</h2><ul><li>  承诺：愿意对目标做出承诺，Scrum 会为人们提供兑现承诺所需的所有权限。</li><li>  专注：做好本职工作，把所有精力和技能都专注在自己承诺的工作上，而不要因为任何无关事情分心。</li><li>  公开：Scrum 中与项目有关的所有事情对大家都是公开透明的。</li><li>  尊重：不同的背景和经历塑造出不同的个体，但是有一点很重要，那就是，我们需要对团队中不同的人保持尊重。</li><li>  勇气：要有承诺的勇气、付诸行动的勇气、敞开心扉的勇气和期望得到别人尊重的勇气。</li></ul><h2 id="高绩效树的树根：还可以使用-XP-的价值观"><a href="#高绩效树的树根：还可以使用-XP-的价值观" class="headerlink" title="高绩效树的树根：还可以使用 XP 的价值观"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/#%E9%AB%98%E7%BB%A9%E6%95%88%E6%A0%91%E7%9A%84%E6%A0%91%E6%A0%B9%EF%BC%9A%E8%BF%98%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8-XP-%E7%9A%84%E4%BB%B7%E5%80%BC%E8%A7%82" title="高绩效树的树根：还可以使用 XP 的价值观"></a>高绩效树的树根：还可以使用 XP 的价值观</h2><ul><li>  沟通：只有通过很多实践才能保持正确的沟通，而这些实践又必须通过相互沟通才能完成。</li><li>  简单：做简单并且只需要稍微改动就可以重用的事情。</li><li>  反馈：对系统当前状态的真实地具体地反馈是非常宝贵的。</li><li>  勇气：有勇气去开发高质量的软件，即使这意味着需要删除原有的代码，改变原有的设计方案甚至是延长开发周期。</li></ul><h2 id="高绩效树的枝叶：高协作和高绩效团队的特征"><a href="#高绩效树的枝叶：高协作和高绩效团队的特征" class="headerlink" title="高绩效树的枝叶：高协作和高绩效团队的特征"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/#%E9%AB%98%E7%BB%A9%E6%95%88%E6%A0%91%E7%9A%84%E6%9E%9D%E5%8F%B6%EF%BC%9A%E9%AB%98%E5%8D%8F%E4%BD%9C%E5%92%8C%E9%AB%98%E7%BB%A9%E6%95%88%E5%9B%A2%E9%98%9F%E7%9A%84%E7%89%B9%E5%BE%81" title="高绩效树的枝叶：高协作和高绩效团队的特征"></a>高绩效树的枝叶：高协作和高绩效团队的特征</h2><ul><li>  他们是自我组织起来的，而不是根据角色和头衔来组织的。</li><li>  他们有权做出自己的决定。</li><li>  他们坚信，作为一个团队他们可以解决任何问题。</li><li>  他们致力于追求整个团队的成功，而不是为了个人利益不惜一切代价。</li><li>  他们对他们自己的决定和承诺负责。</li><li>  是信任而不是恐惧和愤怒在激励他们。</li><li>  他们是多数人意见驱动的，并做到求同存异。</li><li>  他们会不断提出富有建设性的反对意见。</li></ul><h2 id="高绩效树的果实"><a href="#高绩效树的果实" class="headerlink" title="高绩效树的果实"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/#%E9%AB%98%E7%BB%A9%E6%95%88%E6%A0%91%E7%9A%84%E6%9E%9C%E5%AE%9E" title="高绩效树的果实"></a>高绩效树的果实</h2><ul><li>  实现正确的商业价值。</li><li>  更快地实现商业价值。</li><li>  取得惊人的成果。</li><li>  无所不能的团队。</li><li>  团队和个人的成长空间。</li></ul><h2 id="高绩效树的用法"><a href="#高绩效树的用法" class="headerlink" title="高绩效树的用法"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/#%E9%AB%98%E7%BB%A9%E6%95%88%E6%A0%91%E7%9A%84%E7%94%A8%E6%B3%95" title="高绩效树的用法"></a>高绩效树的用法</h2><ul><li>  画在团队工作的地方，默默地提醒团队成员，高绩效是一件很自然的事。</li><li>  当团队遇到麻烦或墨守陈规的时候，指着它说，我们的根系薄弱在哪里？</li><li>  当具备了高绩效团队的特征，产品却不尽人意时，可以说，你们现在想收获什么果实？</li><li>  当以这种方式来使用这棵树时，你的问题就变成了他们的挑战。一旦团队接受了挑战，就离该绩效目标又近了一步。慢慢地，他们就会走出一条属于自己的路。</li><li>  如果一个团队对自己的工作质量感到不满，他们可能是没有做到多数人意见驱动，而过早地采用了第一个出现的可行方案。就在多数人意见驱动上画一个圈。</li><li>  当迭代目标没有完成时，可能是因为分心的事是团队忘记了承诺，团队可以约定，从现在开始，互相帮助，排除干扰，真正全身心投入，完成承诺的工作。</li><li>  最好是别为团队指出一条路，而是让他们去开创一条属于自己的路。</li><li>  当团队把高绩效树当作自己选择的通往高绩效目标的道路时，这棵树就已经在团队中落地生根了。</li></ul><h2 id="高绩效的另一比喻：打好基础"><a href="#高绩效的另一比喻：打好基础" class="headerlink" title="高绩效的另一比喻：打好基础"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/#%E9%AB%98%E7%BB%A9%E6%95%88%E7%9A%84%E5%8F%A6%E4%B8%80%E6%AF%94%E5%96%BB%EF%BC%9A%E6%89%93%E5%A5%BD%E5%9F%BA%E7%A1%80" title="高绩效的另一比喻：打好基础"></a>高绩效的另一比喻：打好基础</h2><ul><li>  经验论：从一系列短时间内发生的失败中汲取教训并最终取得成功。</li><li>  自我组织：最了解问题本质的人最清楚该如何解决问题。</li><li>  协作：培养一种“是的，然后呢？”的思维方式。</li><li>  优先级：专注，做优先级最高的那件事。</li><li>  节奏：深呼吸，然后顺其自然。</li></ul><h1 id="心法三：自我掌控"><a href="#心法三：自我掌控" class="headerlink" title="心法三：自我掌控"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/#%E5%BF%83%E6%B3%95%E4%B8%89%EF%BC%9A%E8%87%AA%E6%88%91%E6%8E%8C%E6%8E%A7" title="心法三：自我掌控"></a>心法三：自我掌控</h1><p>个人的自我调节可以促使你成为团队所需的那种教练，但这往往不是一天两天能够做到的事情，而是一个漫长的反复的过程。这里面需要持续的剖析实践和不断地提高改进。</p><p><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/%E8%87%AA%E6%88%91%E6%8E%8C%E6%8E%A7.jpg"><img src="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/%E8%87%AA%E6%88%91%E6%8E%8C%E6%8E%A7.jpg"></a></p><h2 id="从自我剖析开始"><a href="#从自我剖析开始" class="headerlink" title="从自我剖析开始"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/#%E4%BB%8E%E8%87%AA%E6%88%91%E5%89%96%E6%9E%90%E5%BC%80%E5%A7%8B" title="从自我剖析开始"></a>从自我剖析开始</h2><ul><li>  明白自己在一些特殊情形的自然反应以及自己的底线，有助于认识自身的现状和将来可能会变成什么样子。</li><li>  下一步是不断挑战自己的极限，不断找到和提升自己的短板。当你很紧张浑身不自在的时候，就是找到自己短板的时候了。</li><li>  在这些情形之下，要有意识和自觉地面对自己的缺点，多花些时间做自我剖析和反思。</li><li>  在这个过程中，还能认识到自己的本能行为，并有意识地在事情发生时选择自己本能或其他不一样的行为。</li></ul><h2 id="你本能的冲突应对模式是什么？"><a href="#你本能的冲突应对模式是什么？" class="headerlink" title="你本能的冲突应对模式是什么？"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/#%E4%BD%A0%E6%9C%AC%E8%83%BD%E7%9A%84%E5%86%B2%E7%AA%81%E5%BA%94%E5%AF%B9%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" title="你本能的冲突应对模式是什么？"></a>你本能的冲突应对模式是什么？</h2><ul><li>  竞争型：强硬且不配合。</li><li>  合作型：强硬但配合。</li><li>  妥协型：一般强硬和一般配合。</li><li>  顺应型：配合且不强硬。</li><li>  回避型：既不强硬也不配合。</li></ul><h2 id="你的沟通方式有多强硬？"><a href="#你的沟通方式有多强硬？" class="headerlink" title="你的沟通方式有多强硬？"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/#%E4%BD%A0%E7%9A%84%E6%B2%9F%E9%80%9A%E6%96%B9%E5%BC%8F%E6%9C%89%E5%A4%9A%E5%BC%BA%E7%A1%AC%EF%BC%9F" title="你的沟通方式有多强硬？"></a>你的沟通方式有多强硬？</h2><ul><li>  你是否每天会花些时间静下心来反思自己是如何和他人相处的？</li><li>  你是否记得所有人都有一样的需求？</li><li>  在你每次开口之前，你是否确认过把他人的需求和你的需求看得同等重要？</li><li>  当你让别人做事情时，你是否确认过自己是拜托的语气还是要求的语气？</li><li>  你是否倾向于告诉他人你希望他做的事情，而不是倾向于告诉他人你不希望他做的事情？</li><li>  你是否倾向于告诉他人你希望他采取什么样的行动来帮助他们完成目标，而不是仅仅告诉他人你希望他完成什么样的目标而已？</li><li>  你是否在提出同意或反对他人的意见前，尝试站在他人的立场换位思考一下他人的感受和需求？</li><li>  你是否在说不之前，想过是什么原因导致你不能说是？</li><li>  当你感到沮丧时，是否会问自己问题出在哪里，以及自己应该如何解决，而不是去怨天尤人？</li><li>  当别人做了件令你感到满意和高兴的事情时，你是否对别人表示感谢，且告之具体解决了你哪方面的需求，而不仅仅是一句简简单单的赞扬之辞？</li></ul><h2 id="你能做团队的公仆吗？"><a href="#你能做团队的公仆吗？" class="headerlink" title="你能做团队的公仆吗？"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/#%E4%BD%A0%E8%83%BD%E5%81%9A%E5%9B%A2%E9%98%9F%E7%9A%84%E5%85%AC%E4%BB%86%E5%90%97%EF%BC%9F" title="你能做团队的公仆吗？"></a>你能做团队的公仆吗？</h2><ul><li>  关于怎么培养自己的团队：定要确保优先满足团队成员的最高优先级的需求，你所提供的帮助和服务能够帮助团队成长和发展吗？</li><li>  关于倾听和给他人提意见的权利：自然地在回答任何问题之前先把别人的话听完。</li><li>  关于认可其他人：尊重团队并认可他们取得的每一点进步。</li><li>  服务型教练：帮助团队成员成长和进步，只有团队中的一个个个体变得强大了，整个团队才会强大起来，才会被激发出更多更好更有创意的想法。</li></ul><h2 id="你的应对方式聪明吗？"><a href="#你的应对方式聪明吗？" class="headerlink" title="你的应对方式聪明吗？"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/#%E4%BD%A0%E7%9A%84%E5%BA%94%E5%AF%B9%E6%96%B9%E5%BC%8F%E8%81%AA%E6%98%8E%E5%90%97%EF%BC%9F" title="你的应对方式聪明吗？"></a>你的应对方式聪明吗？</h2><ul><li>  你是如何应对矛盾冲突的</li><li>  如何和团队沟通</li><li>  是否做到了服务型教练</li><li>  如何控制自己的情绪反应</li></ul><h2 id="摒弃命令加控制的方式"><a href="#摒弃命令加控制的方式" class="headerlink" title="摒弃命令加控制的方式"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/#%E6%91%92%E5%BC%83%E5%91%BD%E4%BB%A4%E5%8A%A0%E6%8E%A7%E5%88%B6%E7%9A%84%E6%96%B9%E5%BC%8F" title="摒弃命令加控制的方式"></a>摒弃命令加控制的方式</h2><ul><li>  不要纠结于结果：给团队足够大的空间去提出最好的想法和开发出最好的产品。</li><li>  把问题留给团队：无论是产品本身还是团队合作上出了问题，解决问题的最佳人选都是团队。</li><li>  充当一面镜子：将自己所观察到的事情，以不夹杂个人意见的方式讲述给自己的团队。</li><li>  留意自己的用词和表情：学习说话时不附加自己的判断，学习无暴力沟通。</li><li>  习惯沉默：习惯那些不舒服的沉默和安静，让团队的其他人有说话的机会。</li><li>  学着不讲情面：不把向来是这么做当作正常。</li><li>  允许团队失败：一起经历失败，并一起从挫折中走出来的团队会比那些一直被保护着的团队更坚强和更高效。</li><li>  做团队最大的粉丝但要谨慎：团队表现得好是因为他们是一个团队，但不要做出空谈式的赞赏。</li></ul><h2 id="自我掌控的日常实践"><a href="#自我掌控的日常实践" class="headerlink" title="自我掌控的日常实践"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/#%E8%87%AA%E6%88%91%E6%8E%8C%E6%8E%A7%E7%9A%84%E6%97%A5%E5%B8%B8%E5%AE%9E%E8%B7%B5" title="自我掌控的日常实践"></a>自我掌控的日常实践</h2><ul><li>  听一些可以舒缓心情的音乐。</li><li>  读一些能带来灵感和启发的书、博客、名言警句。</li><li>  慢跑，然后静静聆听大自然的声音。</li><li>  写下三件你很感恩的事情。</li><li>  做做瑜珈或者伸伸懒腰并深呼吸。</li><li>  认可自己，享受当下生活的分分秒秒。</li><li>  将你的电脑密码和你的当下工作联系起来。</li></ul><h2 id="只关注你所关心的"><a href="#只关注你所关心的" class="headerlink" title="只关注你所关心的"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/#%E5%8F%AA%E5%85%B3%E6%B3%A8%E4%BD%A0%E6%89%80%E5%85%B3%E5%BF%83%E7%9A%84" title="只关注你所关心的"></a>只关注你所关心的</h2><ul><li>  只关心那些你真正关心的事，放下不必要的焦虑。</li><li>  如果你真正关心的是团队能否针对那些对他们自己有影响的事情发表看法，那么你要做的所有事情，就应该围绕着帮助团队去发表自己看法这个出发点。</li><li>  一个有效的方法帮你弄清楚你真正关心的事情到底是什么，就是寻找这个问题的答案：我怎么才能为团队做出最大的贡献呢？</li><li>  保持关注一件你所关心的事，舍弃很多无关紧要的事。如同产品列表，你只能选择一件你最关心的事作为紧急事项。</li><li>  时刻记住你真正关心的事情是什么，并保持对它的关注。</li></ul><h2 id="做好当下的事情"><a href="#做好当下的事情" class="headerlink" title="做好当下的事情"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/#%E5%81%9A%E5%A5%BD%E5%BD%93%E4%B8%8B%E7%9A%84%E4%BA%8B%E6%83%85" title="做好当下的事情"></a>做好当下的事情</h2><ul><li>  面对各种难题和不舒适的环境时，也要管理好自己的情绪，放开自己的心态，控制主观情感，选择最为恰当的应对方式。</li><li>  有时，团队需要你表现得更加直率，这样他们才能看清你对刚刚发生的事情的真实反应。</li><li>  你把团队看作日常工作中所不得不面对的障碍，还是和你一样有希望、梦想、恐惧和志向的人？</li><li>  只要一点点时间，我们就能分辨出我们是否受到敌视，被控制或者被愚弄。我们总能分辨出伪善。真实心意重于应用技巧。</li><li>  把你遇到的人当作活生生的人来看待，这样才能真正扩大自己对团队的影响力。</li><li>  多练习分辨自己对各种突发的自然反应，并熟练应对。通过学习特定的听、说和待人接物的方式，来锻炼自己这方面的技巧。</li><li>  将周围的人都当成活生生的人看待，辅以从这些练习中得来的技巧，你就能很好地控制自己当下的心态了。</li></ul><h2 id="练习倾听"><a href="#练习倾听" class="headerlink" title="练习倾听"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/#%E7%BB%83%E4%B9%A0%E5%80%BE%E5%90%AC" title="练习倾听"></a>练习倾听</h2><ul><li><p>  层次1：内心收听。非常认真地听着对方的话语，但是听到的每一句话其实都经过自己的重新解读。听到的每一句话其实都在回答自己心中的这个问题：这会如何影响到我自己。而这时回答问题时，往往会专注于展示自己的专业度，而错失了对真正问题的理解。</p></li><li><p>  层次2：专心收听。听者和说者已经建立了切实的联系。听者设身处地地为说话人着想，专注于话语本身。摆脱了自身利益的束缚之后，就能听到问题本身，并据此作出客观无我的回应。或者保持沉默，让说话人能够自由地表达自己的想法。不会主观臆断或者带着自己的利益去片面理解说者的话。保持好奇心，探询问者的情绪。</p></li><li><p>  层次3：全心收听。结合当时环境中的每个因素来真正收听每句话。在层次2中的切实联系仍然很强烈，再加上对每个细节的全面把握，就能对双方谈话的内容产生很多直觉层面的想法。双方都对所谈论的问题有了更深的理解。保持开放的态度，时刻提醒自己：你真的不知道他下一句是什么。</p></li></ul><h2 id="练习说话"><a href="#练习说话" class="headerlink" title="练习说话"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/#%E7%BB%83%E4%B9%A0%E8%AF%B4%E8%AF%9D" title="练习说话"></a>练习说话</h2><ul><li>  当你有想说话的冲动时，审视一下自己，你的立场在哪里。为什么你要在此时有这种想法。不要只是为了显示自己是一个聪明人或者希望在团队面前表现自己的价值。你的价值不在此。</li><li>  每次想说话时，确认自己的立场是基于为团队成员考虑。确保你每句话的目的,都是为了帮助他们成为一支更加优秀的团队。</li><li>  不要马上开口。先从1数到10，在数数的时候，密切留意是不是有人说出了与你相同的想法。如果每有人说出你想的，那么再等一会儿，判断一下自己的想法是否仍然和谈话有关，并且是有帮助的。如果是，就简单明了阐述自己的想法。你要相信，谈话总是会沿着参与人的真实需求往下发展的。</li><li>  缄口不言。当团队成员提问时，不要做第一个回答的人。用了这个技巧，你可能根本不用再回答了。当你是提问人时，如果无人回答，这个时候，你最恰当的方式是表现出你其实很安于这种令人不安的沉默。就大大方方坐在那里，不要求他们必须发言，但要维持眼神交流和邀请。总有人会说话。</li></ul><h2 id="练习融入团队"><a href="#练习融入团队" class="headerlink" title="练习融入团队"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/#%E7%BB%83%E4%B9%A0%E8%9E%8D%E5%85%A5%E5%9B%A2%E9%98%9F" title="练习融入团队"></a>练习融入团队</h2><ul><li>  让自己融入当下，并调整自己的立场。</li><li>  融入当下，意味着此时此刻，你全部的注意力和精力都集中在一处，对此时此刻完全专注，不畏过去，不畏将来。</li><li>  对各种现象不满的杂念极易让人分散精力，使我们偏离于融入团队现在的关注点。</li><li>  但真正融入当下时，就会发现团队当下真正的关注点在哪里，帮助他们用一种更加富有建设性和正面态度的方式成长。</li><li>  通过全神贯注，磨练心智，你会更加关注当下，而且对自我的认识也会更加深入。</li><li>  融入当下，你的立场会更加坚定鲜明。你的话语会清晰无误，你的每句话都会掷地有声。你的介入就能切实为团队作出贡献。</li><li>  融入当下也是团队成员需要发展的一项技能。完完全全关注此时此地，关注其他人，关注目前手上的工作。</li><li>  判断自己说的话是否对团队有益，适时调整立场，甚至撤回自己说的话。</li><li>  不断自我提升，自我修炼，做团队的榜样。</li></ul><h1 id="心法四：灵活变通"><a href="#心法四：灵活变通" class="headerlink" title="心法四：灵活变通"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/#%E5%BF%83%E6%B3%95%E5%9B%9B%EF%BC%9A%E7%81%B5%E6%B4%BB%E5%8F%98%E9%80%9A" title="心法四：灵活变通"></a>心法四：灵活变通</h1><p>随着时间的推移，我们会面临不同的环境和不同的团队发展阶段。针对团队的不同阶段，要有不同的做法。灵活变通是敏捷教练的必备。</p><p><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/%E7%81%B5%E6%B4%BB%E5%8F%98%E9%80%9A.jpg"><img src="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/%E7%81%B5%E6%B4%BB%E5%8F%98%E9%80%9A.jpg"></a></p><h2 id="敏捷团队的发展阶段"><a href="#敏捷团队的发展阶段" class="headerlink" title="敏捷团队的发展阶段"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/#%E6%95%8F%E6%8D%B7%E5%9B%A2%E9%98%9F%E7%9A%84%E5%8F%91%E5%B1%95%E9%98%B6%E6%AE%B5" title="敏捷团队的发展阶段"></a>敏捷团队的发展阶段</h2><ul><li>  守的阶段。原封不动地照搬老师所传授的那些招式，没有尝试去理解隐藏在里面的奥秘。一次又一次地反复对着规则模仿。</li><li>  破的阶段。掌握了基本功之后，花时间琢磨所有事情的本质和真相，对功夫有很深层面的理解，而不止是停留在单纯的重复练习上。这时候可以借助检查和调整来打破规则。</li><li>  离的阶段。招数已经融入学生的身体。可以抛开形式，但又不违背原则，甚至体现出更深层次的意义和作用。</li><li>  为了不断超越，我们必须首先完完全全地掌握所有规则，然后才能安全地打破规则，最后创造出新规则。这些新规则不仅遵循隐藏在旧规则里面的原则，还能展现出更深层的意义和作用。</li></ul><h2 id="不同阶段的教练风格"><a href="#不同阶段的教练风格" class="headerlink" title="不同阶段的教练风格"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/#%E4%B8%8D%E5%90%8C%E9%98%B6%E6%AE%B5%E7%9A%84%E6%95%99%E7%BB%83%E9%A3%8E%E6%A0%BC" title="不同阶段的教练风格"></a>不同阶段的教练风格</h2><ul><li>  守的阶段的教练风格：教学型。清楚了解团队的需要，保持坚定的立场和态度，为团队制定规则和纪律。</li><li>  破的阶段的教练风格：指导型。随着团队不断从实践中总结，并将实践转化为自己思想的一部分，就不再是被动地遵从规则。教练可以指导团队对既定规则作出修订。</li><li>  离的阶段的教练风格：顾问型。当团队能够将敏捷开发的实践、价值观和原则融会贯通时，就可以采用顾问型风格了。肯定团队的想法，鼓励他们善于听取别人的意见，善于交流彼此的想法，勇敢地面对各种困难，以及尽可能将事情简化。</li><li>  在每个阶段，都需要深入了解团队，了解每个团队成员，以及整个团队的情况，帮助他们找到适合自己的对敏捷思想的解读。</li></ul><h2 id="对团队守破离状态的判断"><a href="#对团队守破离状态的判断" class="headerlink" title="对团队守破离状态的判断"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/#%E5%AF%B9%E5%9B%A2%E9%98%9F%E5%AE%88%E7%A0%B4%E7%A6%BB%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%A4%E6%96%AD" title="对团队守破离状态的判断"></a>对团队守破离状态的判断</h2><ul><li>  团队对敏捷思想是否比较陌生？</li><li>  团队是否改变或干脆放弃了敏捷开发的实践行为模式，并忘记了这些模式背后所蕴含的思想？</li><li>  团队是否在刻板地照搬敏捷思想中的条目？他们是否能站在个人与集体、所开发产品、客户需求与不断应对变化的角度来思考问题？他们是否能顺畅地进行日常工作，并且从实践中不断获得自我提升？</li><li>  团队是否能够在保持敏捷思想核心价值观和原则的基础上，对自己的实践方式进行持续改进？他们是否能够冲破自己所在公司的某些既定障碍，来让自己的工作更加高效、更加快速地完成目标，获得更高的客户认可？他们是否具备了实现自我监控、自我修正所必需的技能和思想？</li></ul></blockquote><blockquote><ul><li>  <strong>本文作者：</strong> joni@efbiz.org</li><li>  <strong>本文链接：</strong> <a href="https://github.com/efbiz/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95">https://github.com/efbiz/2018/05/23/敏捷教练第06课-技巧-敏捷教练的四种心法</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;敏捷教练的职责是帮助组织做得更好。为了履行这个职责，首先是做好前面几章介绍的知识储备。其次是运用这些知识影响组织，也就是下一章开始讲的教练的六种方法。在进行教练之前，敏捷教练需要做一些自身的在敏捷知识之上的内在准备，也就是四种心法：&lt;/p&gt;
&lt;ul</summary>
      
    
    
    
    <category term="Scrum" scheme="http://zhangyu.info/categories/Scrum/"/>
    
    
    <category term="Scrum" scheme="http://zhangyu.info/tags/Scrum/"/>
    
  </entry>
  
  <entry>
    <title>敏捷教练第07课-技巧-敏捷教练的六脉神剑（上）</title>
    <link href="http://zhangyu.info/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://zhangyu.info/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2022-04-11T16:00:00.000Z</published>
    <updated>2022-04-12T02:05:19.796Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/">敏捷教练第07课-技巧-敏捷教练的六脉神剑（上） | EFbiz</a></p><blockquote><p>敏捷教练的六脉神剑，指的是敏捷教练在教练团队和组织时可以使用的六种方法。本章介绍其中的三种方法：指导、协助和讲授。这几种方法，既有不同的角度，有时候也交织在一起使用。我们既要明辨概念上的细微区别，在使用时也无需纠结使用的到底是哪一种方法。三种方法分开讲是为了讲解的方便和概念的提炼，实际使用时可以把三种方法中同一场景下的具体方法糅合在一起使用。</p><p><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91.jpg"><img src="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91.jpg"></a></p><p>在每一种方法之下，按一个一个场景，提供了一系列检查列表。每一个场景既相对独立，所有场景结合起来又构成了一个完整的全景。所以，在阅读时，要调动见木又见林，见全牛又见解牛的思维。既高屋建瓴，也在一事一物上磨，方能知行合一，唯精唯一，事竟功遂。为学之要，在博学之，审问之，慎思之，明辨之，笃行之。</p><p>对于检查列表，要辩证地看待。一方面，检查列表是前人和过去的经验总结，让我们在无所适从之际有个东西可以作为开始。另一方面，检查列表与实际情况之间一定有很深的代沟，使用者需根据情况，制定自己的检查列表。一个建议是，把本课程当成一个模板，直接在上面增删改查，形成自己的检查列表，并经常阅读、思考、聆听自己内心的声音，和不厌其烦不惧挫折地实践。完美来自实践和操练。按此方法坚持下去，三个月必见功效，小有所成。</p><h1 id="第一剑：指导"><a href="#第一剑：指导" class="headerlink" title="第一剑：指导"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/#%E7%AC%AC%E4%B8%80%E5%89%91%EF%BC%9A%E6%8C%87%E5%AF%BC" title="第一剑：指导"></a>第一剑：指导</h1><p><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/%E6%8C%87%E5%AF%BC.jpg"><img src="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/%E6%8C%87%E5%AF%BC.jpg"></a></p><h2 id="Sprint-开始阶段的指导"><a href="#Sprint-开始阶段的指导" class="headerlink" title="Sprint 开始阶段的指导"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/#Sprint-%E5%BC%80%E5%A7%8B%E9%98%B6%E6%AE%B5%E7%9A%84%E6%8C%87%E5%AF%BC" title="Sprint 开始阶段的指导"></a>Sprint 开始阶段的指导</h2><ul><li>  可以在团队成立初期，在第一个 Sprint 的开始阶段，或后续 Sprint 的开始阶段有不同程度的使用。指导的内容要根据具体的场景（比如说计划会是一个场景，也可以细分为几个子场景，计划会之前的准备和之后的跟进也是场景）事先设计，也要根据指导过程中获得的反馈调整。</li><li>  这个阶段教学型指导应占主导地位，比如帮助团队学习敏捷实践或教他们如何真正进入到各自的敏捷角色中。</li><li>  时刻铭记指导的目标：帮助整个团队了解敏捷是如何完美工作的。</li><li>  当一个可以教大家某个具体概念的绝佳机会出现时，要把握住并“大声地”指导他们。</li><li>  当团队需要时，可以安排一个讲座来介绍或加深某块具体的敏捷知识。</li><li>  一种做法是在每个会议之前，指导这个会议应该怎样运作。</li><li>  指导与培训的区别是微妙的，指导更多指的是指导的内容马上用起来。</li></ul><h2 id="Sprint-中间阶段的指导"><a href="#Sprint-中间阶段的指导" class="headerlink" title="Sprint 中间阶段的指导"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/#Sprint-%E4%B8%AD%E9%97%B4%E9%98%B6%E6%AE%B5%E7%9A%84%E6%8C%87%E5%AF%BC" title="Sprint 中间阶段的指导"></a>Sprint 中间阶段的指导</h2><ul><li>  只要团队工作进行得比较顺利，要减少整个团队级别的指导。</li><li>  只有当教练有意识地要发表对大家有非常大意义的见地时，才进行整个团队级别的指导，比如说当团队显著偏离了敏捷核心和实践时。</li><li>  询问团队，如果进行中期检查是否会有效，比如说当燃尽图形状不太好时，检查并进行适当的调整。</li><li>  如果中期检查引发 Sprint 中间的回顾，就要停下来。</li><li>  进行一对一指导，逐个解决每个团队成员的问题。</li><li>  不要影响团队的正常工作。</li><li>  如果两个成员之间有些矛盾，鼓励提出问题的成员与另一成员一对一地把问题解决掉。</li><li>  当有人做了特别有帮助或意义特别大的一件事时，要在整个团队面前讨论和鼓励这种行为。但也不要太过正式。</li><li>  教练的工作以观察、思考、聆听、响应为主。站会是团队工作方式的缩影，也是很好的观察场所。</li><li>  教练心中要有标准，标准是观察的取景框。</li></ul><h2 id="Sprint-收尾阶段的指导"><a href="#Sprint-收尾阶段的指导" class="headerlink" title="Sprint 收尾阶段的指导"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/#Sprint-%E6%94%B6%E5%B0%BE%E9%98%B6%E6%AE%B5%E7%9A%84%E6%8C%87%E5%AF%BC" title="Sprint 收尾阶段的指导"></a>Sprint 收尾阶段的指导</h2><ul><li>  在 Sprint 回顾时，要创造条件让大家积极讨论。回顾的形式多种多样，在网上可以找到海量资料。要点是让每个人都参与其中，有均等的发言机会，并且确保回顾产生的行动能够落实。</li><li>  要指导团队成长到团队成员懂得相互学习是多么美好的那种境界。可以策划知识分享活动。可以在回顾会中设置互相感谢环节。</li><li>  可以把 Sprint 收尾阶段和下个 Sprint 开始阶段的指导合二为一：向后的回顾和为将来的任务进行培训。</li></ul><h2 id="产品发布层面的指导"><a href="#产品发布层面的指导" class="headerlink" title="产品发布层面的指导"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/#%E4%BA%A7%E5%93%81%E5%8F%91%E5%B8%83%E5%B1%82%E9%9D%A2%E7%9A%84%E6%8C%87%E5%AF%BC" title="产品发布层面的指导"></a>产品发布层面的指导</h2><ul><li>  与 Sprint 层面的介入周期类似。</li><li>  在发布开始阶段进行教育。</li><li>  在发布收尾阶段进行回顾。</li><li>  在发布中间阶段进行整个团队的检查和对团队成员的一对一指导。</li><li>  在指导个人和指导团队之间找到一个平衡点，选择最有影响力而又干预最小的指导方式。</li></ul><p><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/%E5%80%BE%E5%90%AC.jpg"><img src="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/%E5%80%BE%E5%90%AC.jpg"></a></p><h2 id="指导的基调"><a href="#指导的基调" class="headerlink" title="指导的基调"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/#%E6%8C%87%E5%AF%BC%E7%9A%84%E5%9F%BA%E8%B0%83" title="指导的基调"></a>指导的基调</h2><ul><li>  爱心：爱，认可和支持他们成为更优秀的团队和个人。</li><li>  同情心：尊重他们的现在，帮助大家成为想要成为的那个人。</li><li>  永不妥协。不能偏离敏捷核心和实践。</li><li>  但不需要在工作场所表现的过于感情丰富。爱心和同情心必须是真实的，大家能从你的眼睛，听和说中感受到你的尊重。</li><li>  充满爱心和同情心会让你坚定信心不妥协。</li><li>  将这种对信念的坚持传递给他们，完全相信他们能成为自己想成为的人。强调每个人都具备不断提高自身敏捷能力的可能性和需求。</li><li>  不要期望团队成员的表现能够立即达到你的高要求，但不要容忍他们用折中去改变敏捷标准的定义。始终强调真正高效的敏捷应当如何运行。</li><li>  要了解，变得更好是一个历程。耐心和设身处地去了解每个人的实际处境，而不是去追求从概念世界推导出来的理想的完美。</li><li>  不要自卑和自怜于自己的人微言轻。教练是一种职业。跟其他职业一样，不是以权威，而是以你的专业度令人信服。记住帮助团队做得更好这个使命和目标。</li></ul><h2 id="一对一指导的前提"><a href="#一对一指导的前提" class="headerlink" title="一对一指导的前提"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/#%E4%B8%80%E5%AF%B9%E4%B8%80%E6%8C%87%E5%AF%BC%E7%9A%84%E5%89%8D%E6%8F%90" title="一对一指导的前提"></a>一对一指导的前提</h2><ul><li>  在超前半步的层次上进行指导：用心倾听每个人的内心，了解他们面临的矛盾和麻烦，了解他们在敏捷之路上处在哪个阶段，注意观察你的指导给他们带来的改变。</li><li>  置身于充满安全的环境：允许他们犯错，跌跌撞撞，抱怨。所有这些行为都不会受到绩效考核的影响。在团队内部发生的事就让它留在团队里。确保有足够的空间让彼此表现人性固有的一些弱点，并对团队内部发生的事情保密。但如果出现了极端情况，例如骚扰、歧视或暴力，就要打破保密的原则。</li><li>  与管理者们合作：直属经理会在显性（绩效考核）和隐性（日常谈话）的层面上影响团队。需要与管理者同步工作思路。</li><li>  创造一种积极的氛围：不要把人当作一个亟待解决的问题，而要看做一个有希望、有梦想、有需求的活生生的人。每个人都在通过自己的能力和拥有的资源尽全力来达到最好的结果。</li><li>  三个支点：专业，尊重，坚持不懈。</li></ul><h2 id="一对一指导谈话"><a href="#一对一指导谈话" class="headerlink" title="一对一指导谈话"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/#%E4%B8%80%E5%AF%B9%E4%B8%80%E6%8C%87%E5%AF%BC%E8%B0%88%E8%AF%9D" title="一对一指导谈话"></a>一对一指导谈话</h2><ul><li>  谈话首先要诚恳。</li><li>  然后要真实切实。不真实的谈话，对个人和公司来说都代价昂贵。</li><li>  一旦开始谈话，就要顺其自然。思考指导对象处在哪个阶段，应设定什么目标和路径。</li><li>  可以主动发起谈话，开场白可以是观察式（观察到了什么）或邀请式（邀请团队成员评估当前状态）。</li><li>  时刻记住你的目标：帮助每个队员在他们的敏捷之路上不断提高。</li><li>  在谈话的开始阶段，需要认认真真做一名倾听者，才能听到真实的问题。被指导对象开口，就是成功的一半。</li><li>  在谈话的中段，通过一些有影响力的问题来引起被指导对象的反思。要注意教练在谈话过程中要回避的事情：解决问题。只有被指导对象自由选择的结果才是最有意义的结果。</li><li>  在谈话结尾时，讨论下一步应该采取什么具体行动，帮助被指导对象更加可靠地完成今后的工作。这种可靠应当是自愿的，确保他切实承担自己应该承担的责任。</li><li>  不要显得教练的地位是高于被指导者的。在整个谈话的过程中，教练与被指导对象应该始终处在平等的地位。</li><li>  你不必非要是某个领域的专家才能指导在这个领域工作的队员，因为你的角色是一名教练，而不是代替他们直接去解决问题的人。</li><li>  教练要明白自己的界限，例如是否可以讨论工作之外的事，是否要对被指导对象的工作领域提供意见。</li><li>  对话的线索可以是优化流程和解决问题，并以此调动团队成员的积极参与。</li></ul><h2 id="指导产品负责人"><a href="#指导产品负责人" class="headerlink" title="指导产品负责人"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/#%E6%8C%87%E5%AF%BC%E4%BA%A7%E5%93%81%E8%B4%9F%E8%B4%A3%E4%BA%BA" title="指导产品负责人"></a>指导产品负责人</h2><ul><li>  教练与产品负责人之间谈话的唯一目的是为了确保团队的健康成长，而与个人恩怨和办公室政治毫无关系，这种专业精神和对自己角色内容的澄清能够赋予你更多的正式权力。</li><li>  指导产品负责人做好自己的本质工作。摆脱命令与控制的工作方式，专注于商业价值的达成，而不是去具体管理每个团队成员的下一步行动。</li><li>  帮助产品负责人建立以商业价值为导向的思想体系，请产品负责人以商业价值为导向，重新审视整个产品开发流程，并以商业价值作为他们制定每一个决策的基础依据，对优先级按商业价值排序。</li><li>  指导产品负责人成为为团队着想的优秀产品负责人。帮助团队和产品负责人从失败中学习，一起改正错误，然后变得更加强大。</li><li>  回归根本，参照 Scrum 指南和前面章节，理清产品负责人在 Scrum 中应有的职责和行为。</li><li>  指导产品负责人的时机，可以以 Scrum 流程为线索，在其中寻找产品负责人的发力点或乏力点。</li></ul><h2 id="指导敏捷教练和-Scrum-Master"><a href="#指导敏捷教练和-Scrum-Master" class="headerlink" title="指导敏捷教练和 Scrum Master"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/#%E6%8C%87%E5%AF%BC%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%92%8C-Scrum-Master" title="指导敏捷教练和 Scrum Master"></a>指导敏捷教练和 Scrum Master</h2><ul><li>  让他们观察和探索，你作为敏捷教练如何工作。让他们自己客观冷静地作出自己的决定。</li><li>  如果他们决心成为一名敏捷教练，开始教学。让他们了解敏捷教练这一角色的全部含义：指导整个团队、指导特定个人、教授敏捷思想、协助敏捷会议，以及通过谨言慎行来把握自己。</li><li>  然后逐步向这位新教练转移指导工作。第一个月让他看你怎么做，第二个月你看他怎么做，第三个月，你只指导这位新教练而不再干预团队。</li><li>  回归根本，参照 Scrum 指南和前面章节，理清 Scrum Master 在 Scrum 中应有的职责和行为。</li><li>  指导 Scrum Master 的时机，可以以 Scrum 流程为线索，在其中寻找 Scrum Master 的发力点或乏力点。</li></ul><h2 id="指导敏捷经理"><a href="#指导敏捷经理" class="headerlink" title="指导敏捷经理"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/#%E6%8C%87%E5%AF%BC%E6%95%8F%E6%8D%B7%E7%BB%8F%E7%90%86" title="指导敏捷经理"></a>指导敏捷经理</h2><ul><li>  在团队管理方面的指导：将团队的自组织能力和经理们的有效领导相结合。</li><li>  在投资管理方面的指导：让团队从以计划为导向的思维方式转化到以价值为导向的思维方式。</li><li>  在环境管理方面的指导：在由各种流程和外部资源组成的组织环境中，高效地审视组织内各流程的设计以消除各种对组织资源的浪费。</li><li>  依然以 Scrum 流程为线索，寻找与敏捷经理的交互点，进行指导。有问题就是契机，没问题反而无处下手。</li></ul><h1 id="第二剑：协助"><a href="#第二剑：协助" class="headerlink" title="第二剑：协助"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/#%E7%AC%AC%E4%BA%8C%E5%89%91%EF%BC%9A%E5%8D%8F%E5%8A%A9" title="第二剑：协助"></a>第二剑：协助</h1><p>本部分关于协助会议的检查列表，不是对会议基础知识的重复，而是假定您已经掌握了会议的基础知识之后，如何以运用基础知识为基础，把协助会议这件事做好。</p><p>您在协助每个会议之前，需要重温前面章节中会议的基础知识，加上本节的一些技巧，制定出自己的详尽完备的会议议程和脚本。这一点是关于功夫在会前。另一点是功夫在会外，会议日程的素材来自日常的观察和收集。运筹帷幄，才能把会开好。</p><p><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/%E5%8D%8F%E5%8A%A9.jpg"><img src="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/%E5%8D%8F%E5%8A%A9.jpg"></a></p><h2 id="协助每日站会"><a href="#协助每日站会" class="headerlink" title="协助每日站会"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/#%E5%8D%8F%E5%8A%A9%E6%AF%8F%E6%97%A5%E7%AB%99%E4%BC%9A" title="协助每日站会"></a>协助每日站会</h2><ul><li>  强调站会的规则：15分钟，三个问题，杜绝超长时间的讨论。</li><li>  强调规则之后，停止干预，重点放在观察上。</li><li>  在站会之后，征得团队同意，提供观察和见解。</li><li>  把一些轻微的违规行为留到回顾时再进行解决。</li><li>  训练让团队自己启动站会。比如说到了时间准时开始，不等人，让迟到的人感受到团队之车运转的压力而不再迟到。</li><li>  一旦15分钟到了，宣布站会结束。</li><li>  站会期望获得的效果：产生健康的同侪压力、细粒度的协作、同时聚焦少数任务、每位团队成员每天都需要对团队做出承诺、提出障碍。</li><li>  对于什么时候修正站会中的问题，什么时候不做任何处理，做出审慎的决定。当前做法是否影响到团队的自组织能力，是判断的基线。</li><li>  解决站会问题的方法之一是强调站会希望获得的效果。</li><li>  另一个方法是要求眼神支持，即当一个人在站会中发言时，其他团队成员都要直视发言的成员，进行眼神交流。一次一个焦点（任务、对话）。</li><li>  为团队创造空间并在回顾的时候把问题提出来，而不是马上寻找其他方法去解决问题。</li><li>  还可以采用一对一指导。</li><li>  找到低效的站会与付出的代价之间的因果关系，并让团队知道。</li><li>  要有耐心，并且坚持从多角度尝试。</li></ul><h2 id="协助迭代计划会议"><a href="#协助迭代计划会议" class="headerlink" title="协助迭代计划会议"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/#%E5%8D%8F%E5%8A%A9%E8%BF%AD%E4%BB%A3%E8%AE%A1%E5%88%92%E4%BC%9A%E8%AE%AE" title="协助迭代计划会议"></a>协助迭代计划会议</h2><ul><li>  当我们可以回答这些问题时，迭代计划就完成了：迭代目标是什么？团队构成是什么？总人力投入是多少？具有最高商业价值的待处理事项是什么？对于这些待处理事项的顾虑（技术的、政治的、文化的）是什么？团队还有什么其他顾虑？团队对本迭代的最终承诺是什么？</li><li>  当我们达到这些目标时，迭代计划就完成了：了解工作—理解它、选择它、把它任务化、志愿完成它，获得一个全新的开始，为共同目标做出承诺，创建重点和充裕感。</li><li>  为迭代计划做准备：确保 PO 已准备好待处理事项，Scrum Master 准备好会议结构。</li><li>  在迭代计划期间的协助：介绍会议的结构，包括会议的时间盒。</li><li>  在迭代计划会上可教授的时机和发力点：专注于交付的商业价值、强化 PO 作为产品愿景和决策的唯一声音、维护健康的角色边界、利用思维导图和静默任务分解改善会议的进程和共同的理解。</li></ul><h2 id="协助迭代评审"><a href="#协助迭代评审" class="headerlink" title="协助迭代评审"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/#%E5%8D%8F%E5%8A%A9%E8%BF%AD%E4%BB%A3%E8%AF%84%E5%AE%A1" title="协助迭代评审"></a>协助迭代评审</h2><ul><li>  在即将进行迭代评审前，提醒团队把做过的所有任务整合在一起，并演示当前迭代开发的真正产品。</li><li>  不需要完美展示，只需要真实展示。更多的时间花在真正的工作上，而不是让事情看起来更好看。</li><li>  评审的目标：展示承诺中什么完成了和什么没有完成，获得干系人和客户的直接反馈，介绍团队是如何一起工作、处理挑战和解决问题的，针对一些大的障碍向干系人寻求帮助。</li><li>  按价值第一的原则发言，一是先讲重要的事，二是要考虑为什么这个功能对用户有价值。</li><li>  教练以观察为主：团队是如何进行互动和互助的？团队与 PO、干系人、客户的互动是怎样的？PO 是否以产品待办列表作为管理需求的方式？有没有人被欺压或者被强制沉默？会议是否在同一时间有一个焦点并保持流畅？对话中有哪些对敏捷的误解和误用？</li><li>  跟团队分享你的观察。</li><li>  观察有两种：加强的观察即哪些行为加强了敏捷的理念和实践，深化的观察即揭示团队的内部工作方法的特质。</li></ul><h2 id="协助回顾会议"><a href="#协助回顾会议" class="headerlink" title="协助回顾会议"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/#%E5%8D%8F%E5%8A%A9%E5%9B%9E%E9%A1%BE%E4%BC%9A%E8%AE%AE" title="协助回顾会议"></a>协助回顾会议</h2><ul><li>  回顾的目的：检查并调整，回头看团队是如何一起把工作做完而不是产品怎么样，以及怎样才能下次做得更好。</li><li>  教练在日常观察到的问题，重要的问题可以即时提出，其他问题可以留到回顾会议时提出。</li><li>  教练在日常观察和思考的问题：团队是否使用敏捷框架来促进协同？团队正在忍耐什么？工作流是否顺畅？彼此的沟通协调关照关注和协作有什么不足的地方？出彩的瞬间是什么？哪里进展慢？整个迭代期间，团队的焦虑程度如何变化？大家是否全身心地参与进来？兴奋程度何时和如何变化？</li><li>  可以从对观察的提炼中找出回顾的主题，也可以事先通过与团队和 PO 沟通获得回顾的输入。</li><li>  议程的基调是关注重要的事情。</li><li>  回顾会议要遵守时间盒。</li><li>  一旦达成付诸实践的协议，就写下来，并张贴在显眼的位置。</li><li>  回顾会议之后，观察协议是否被执行，并为下一次回顾会议收集意见。</li><li>  分享因回顾而带来的收益。</li></ul><h2 id="协助团队对话"><a href="#协助团队对话" class="headerlink" title="协助团队对话"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/#%E5%8D%8F%E5%8A%A9%E5%9B%A2%E9%98%9F%E5%AF%B9%E8%AF%9D" title="协助团队对话"></a>协助团队对话</h2><ul><li>  教练的关注在对话的质量而不在对话的内容。</li><li>  在高质量的对话中，每人都发言，认真听其他人发言，从对话中涌现出许多想法，这些想法又互相催化产生一些新的想法，把每一个想法当作一个礼物并一直向前推进。</li><li>  教练在对话中强有力的观察：是不是每个想发言的人都得到了发言的机会？这些想法是高质量的吗？团队是不是尽可能采用简单的想法？团队是不是疲劳了？团队是不是很紧张？团队是否足够大胆而不墨守成规？他们是不是尽可能多地完成工作？是否以客户价值为中心？被卡住了吗？是否有新的视角？</li><li>  择机分享观察和思考。</li><li>  教练提出强有力的问题：还有什么地方不清楚？可能性是什么？想要探索的是什么？还有哪些角度可以考虑？如果可以自由选择，你会做什么？这件事的实质是什么？这会让你得到什么？你预想的是什么？对于类似情况，你最好的经验是什么？主要的障碍是什么？最大的顾虑是什么？机会和挑战是什么？</li><li>  教练提出强有力的挑战：放大他们的想法，带到一个全新的方向，高标准，打破局限。</li></ul><h1 id="第三剑：讲授"><a href="#第三剑：讲授" class="headerlink" title="第三剑：讲授"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/#%E7%AC%AC%E4%B8%89%E5%89%91%EF%BC%9A%E8%AE%B2%E6%8E%88" title="第三剑：讲授"></a>第三剑：讲授</h1><p>讲授、指导和协助三者的关系是：在团队启动或迭代启动时进行讲授，在会议和对话中进行协助，为了保证讲授的理论能够落实以及能够以贴合团队实际情况的方式落实，需要对团队和个人进行指导。通常来说，讲授会发生在迭代启动时，协助发生在每一次会议和对话，而指导会根据实际情况发生在任何时刻。</p><p>这一节还包括了对不同角色的教授，其内容是对不同角色基本职责的补充。教授的时机依然可以是以流程和解决问题驱动，在流程和解决问题的过程中寻找教授的时机。</p><p><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/%E6%95%99%E6%8E%88.jpg"><img src="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/%E6%95%99%E6%8E%88.jpg"></a></p><h2 id="在团队起步时的讲授"><a href="#在团队起步时的讲授" class="headerlink" title="在团队起步时的讲授"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/#%E5%9C%A8%E5%9B%A2%E9%98%9F%E8%B5%B7%E6%AD%A5%E6%97%B6%E7%9A%84%E8%AE%B2%E6%8E%88" title="在团队起步时的讲授"></a>在团队起步时的讲授</h2><ul><li>  这种时机只会出现一次，并且一去不复返。</li><li>  强有力的团队启动在一两天内就可以完成。</li><li>  启动期间要解决的问题：学习将要使用的流程，了解团队，了解将要做的工作，前进！</li><li>  在启动期间，重点关注面向任务而不是面向人的事情，更容易成功。也就是，更多时间放在学习流程和了解将要做的工作，较少时间放在了解团队。</li><li>  学习流程：对于从未接触过敏捷的团队，是真正意义上的新开始。对于已经用过敏捷的人，他们自认为了解敏捷，但可能受制于之前所在团队的模式和局限，实际上已远离敏捷，教练需要向他们刷新可信的敏捷，重回敏捷的核心。</li><li>  了解团队：从了解团队中的每一个人开始，然后创建一个共有的团队特征。</li><li>  作为个体相互了解：可以让每个人描绘自己的职业历程，画出来并分享；可以让每个人展示自己的技能，其他人提供我可以如何帮助你和你可以如何帮助我的反馈；可以以星座为载体让每个人陈述自己的偏好；可以让每个人从一组价值观中选取重要的，并进行交流。这些活动是为了在团队成员之间建立深刻的理解。</li><li>  创建共有的团队特征：创建共同的团队愿景；创建团队规范。</li><li>  了解将要做的工作：展望产品愿景，评审产品待办事项，创建第一个迭代的目标和计划。</li><li>  团队启动的三个层次：一是按上述框架设计启动议程，二是了解并满足主要合作者的目标，三是深入了解每个人的情况并设计有针对性的启动。</li></ul><h2 id="教授团队的新成员"><a href="#教授团队的新成员" class="headerlink" title="教授团队的新成员"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/#%E6%95%99%E6%8E%88%E5%9B%A2%E9%98%9F%E7%9A%84%E6%96%B0%E6%88%90%E5%91%98" title="教授团队的新成员"></a>教授团队的新成员</h2><ul><li>  有可能的话，保持团队稳定。</li><li>  当一位团队成员离开时，确保团队对他的贡献给予答谢。</li><li>  当一位成员加入时，向他介绍团队，团队规范，团队如何使用任务板合作完成迭代目标，团队的愿景。</li><li>  向新成员教授敏捷。</li><li>  让已有成员向新成员介绍产品。</li><li>  定期了解和跟进新成员在敏捷实践中的进展。</li></ul><h2 id="教授产品负责人"><a href="#教授产品负责人" class="headerlink" title="教授产品负责人"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/#%E6%95%99%E6%8E%88%E4%BA%A7%E5%93%81%E8%B4%9F%E8%B4%A3%E4%BA%BA" title="教授产品负责人"></a>教授产品负责人</h2><ul><li>  产品负责人是价值推动者。产品负责人的任何决定，都要考虑是否给公司带来最大价值。</li><li>  产品负责人要经常与团队在一起，以便在需要时作出日常决策。</li><li>  产品负责人是愿景管理者，要帮助团队了解愿景及确保每一个迭代都是朝愿景推进。</li><li>  产品负责人要保护团队免受外界的噪音和压力。</li><li>  产品负责人是最终责任人，为产品的业务成果负责。</li><li>  产品负责人要对工作作出承诺，并充分参与。</li><li>  产品负责人要得到项目发起人的授权。</li><li>  产品负责人要与各方协作。</li><li>  产品负责人要对所从事的领域有渊博的知识。</li><li>  了解并沟通团队对产品负责人的期望。</li><li>  定期与产品负责人交流，哪些方面做得好，哪些方面还可以提高。</li></ul><h2 id="教授敏捷经理"><a href="#教授敏捷经理" class="headerlink" title="教授敏捷经理"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/#%E6%95%99%E6%8E%88%E6%95%8F%E6%8D%B7%E7%BB%8F%E7%90%86" title="教授敏捷经理"></a>教授敏捷经理</h2><ul><li>  敏捷经理包括团队成员的职能经理、利益相关者和其他团队的经理。</li><li>  敏捷经理身受双重的挤压，一方面是团队自组织管理的挤压，另一方面是高层想要看到进度表和状态报告的挤压。</li><li>  当他们看到团队交付成果时，他们所受的挤压会被减轻。</li><li>  敏捷经理可以是组织变革家，引导组织对敏捷的采用。</li><li>  敏捷经理可以是边界管理家：强化健康的角色边界，包括团队内部和团队之间。</li><li>  敏捷经理是价值最大化的倡导者：管理项目组合。</li><li>  敏捷经理是精益管理者：使用精益思想来管理组织流程，加速流动，减少浪费。</li><li>  敏捷经理是组织障碍消除者：以坚忍不拔的勇气来消除根深蒂固的障碍。</li><li>  敏捷经理是团队拥护者：信任和支持团队，让他们发挥潜能。</li><li>  敏捷经理可以通过产品负责人把工作项加到待办列表。</li><li>  敏捷经理可以把观察到的问题交给敏捷教练。</li><li>  敏捷经理可以参加站会，但要保持安静。</li><li>  敏捷经理可以参加迭代评审并给出反馈。</li><li>  敏捷经理在得到请求时帮助移除障碍。</li></ul><h2 id="教授敏捷教练"><a href="#教授敏捷教练" class="headerlink" title="教授敏捷教练"></a><a href="https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/#%E6%95%99%E6%8E%88%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83" title="教授敏捷教练"></a>教授敏捷教练</h2><ul><li>  敏捷教练是清道夫，帮助移除障碍。</li><li>  敏捷教练是领头羊，引导团队回归敏捷的实践和本质。</li><li>  敏捷教练是服务型领导，帮助团队更好地工作。</li><li>  敏捷教练是质量和成果的监护者，检查并调整团队生产什么和如何生产。</li></ul></blockquote><blockquote><ul><li>  <strong>本文作者：</strong> joni@efbiz.org</li><li>  <strong>本文链接：</strong> <a href="https://github.com/efbiz/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89">https://github.com/efbiz/2018/05/23/敏捷教练第07课-技巧-敏捷教练的六脉神剑（上）</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.expectfly.com/2018/05/23/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D</summary>
      
    
    
    
    <category term="Scrum" scheme="http://zhangyu.info/categories/Scrum/"/>
    
    
    <category term="Scrum" scheme="http://zhangyu.info/tags/Scrum/"/>
    
  </entry>
  
  <entry>
    <title>云服务器ECS选购指南及省钱法宝</title>
    <link href="http://zhangyu.info/2022/03/08/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8ECS%E9%80%89%E8%B4%AD%E6%8C%87%E5%8D%97%E5%8F%8A%E7%9C%81%E9%92%B1%E6%B3%95%E5%AE%9D/"/>
    <id>http://zhangyu.info/2022/03/08/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8ECS%E9%80%89%E8%B4%AD%E6%8C%87%E5%8D%97%E5%8F%8A%E7%9C%81%E9%92%B1%E6%B3%95%E5%AE%9D/</id>
    <published>2022-03-07T16:00:00.000Z</published>
    <updated>2022-03-08T17:02:32.013Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 云服务器ECS选购指南及省钱法宝（强烈建议收藏） </p><p><strong>作者 | <strong>阿**</strong></strong>里云弹性计算产品专家 马小婷**</p><p><a href="https://developer.aliyun.com/article/872102">https://developer.aliyun.com/article/872102</a></p><p>今天给大家带来的分享是如何购买云服务器ECS以及怎么买更省钱，分为四个部分：</p><p>第一部分介绍云服务器ECS的基本概念，告诉大家购买ECS实例时看哪些参数。就像小书生要买一部手机，会关注内存大小、CPU频率、屏幕分辨率、相机参数等，选购ECS实例同样可以通过参数选择来满足自己的上云需求。</p><p>第二部分介绍接云服务器ECS实例规格族，详细介绍阿里云主要的ECS产品系列。（时间紧张的情况下可以跳到第三部分）</p><p>第三部分详细讲解<strong>ECS的选型技巧</strong>，具体讲解不同场景（如大数据/数据库等）下如何选择ECS实例，或者某个ECS实例适用于怎样的生产、工作场景，重点干货部分，不容错过。</p><p>第四部分介绍如何<strong>省钱省力的来使用ECS</strong>，在满足自己需要的前提下，让你上云省钱更经济。</p><h3 id="01-云服务器ECS基础概念"><a href="#01-云服务器ECS基础概念" class="headerlink" title="01 云服务器ECS基础概念"></a><em>01</em> 云服务器ECS基础概念</h3><p> <img src="https://ucc.alicdn.com/pic/developer-ecology/9fd8dc4675f94f29a650697d6d254890.jpg" alt="图1.jpg" title="图1.jpg"> </p><h4 id="云服务器的基础概念"><a href="#云服务器的基础概念" class="headerlink" title="云服务器的基础概念"></a>云服务器的基础概念</h4><p>第一部分会给大家介绍云服务器的一些基本概念。</p><p> <img src="https://ucc.alicdn.com/pic/developer-ecology/5f56e706e8b94112b7f30088ac385971.jpg" alt="图2.jpg" title="图2.jpg"> </p><p>在开始前，大家可以回想一下，我们自己购买笔记本电脑的时候会考虑哪些因素？我自己会先选择品牌，一般情况下在确定了品牌之后，接下来就会考虑硬件配置，主要是物理硬件的配置和软件的配置。</p><p>硬件配置上，我首先会考虑计算性能，像CPU和内存的大小、CPU的型号等；第二就是存储，笔记本电脑的磁盘有多大；第三部分就是网络能力，比如网卡有几个，对于玩游戏的同学来说，显卡配置也很重要。除了硬件配置外，我也会考虑电脑的操作系统是什么样的，比如Mac OS， windows或ubuntu等。而拿到电脑之后，我们首先会做一些基础应用软件的安装和配置，包括防火墙等保证我们整个应用环境的安全性。</p><p>这是我在现实生活中去购买一台物理电脑的流程，其实这些概念在云上也是适用的，比如说我们在选择一些物理硬件的参数的时候，选CPU和内存，对应在云上的话，就是选择ECS实例的 CPU 和内存大小以及 CPU 的型号。</p><p>存储这一块，磁盘在云上对应的概念就是块存储，在云上块存储其实是包含两个概念，一个概念是云盘，一个概念是本地盘。有一个跟我们现实生活中不太一样的点，是云上的块存储，我们在购买的过程中需要指定用作系统盘还是用作数据盘的。而现实生活中买了一个电脑里面是有一块磁盘，然后我们自己会把磁盘分成系统盘还是数据盘，但在云上的系统盘和数据盘是需要分开购买的，这是一点点区别。</p><p>在网络这一块其实也是类似的，云上提供弹性网卡，让用户通过访问云服务器就能够联通到网上。</p><p>除了这些物理硬件以外，要让一个云服务器真正的跑起来，跟现实生活一样，我们也需要去安装一个操作系统，这个操作系统在云上的概念就是镜像，阿里云提供多种不同的镜像版本供大家选择。</p><p>除此以外，云服务器还会有一些特殊的概念，比如安全组，本质上是通过一些规则来限定访问的流量，即被哪些应用可以访问。</p><p>我们在买一个电脑之后，这个物理机在手上，你想要什么时候使用就可以什么时候使用。在云上买完一个云服务器之后，因为这个服务器是在云端或者说在远端，我们访问云服务器的方式就跟我们平时打开一个电脑不太一样，我们需要通过阿里云的控制台或者通过远程连接的工具来登录到我们的云服务器上去。</p><p>还有一个小概念是云上的容灾备份能力，就是快照。现实生活中，如果我们的电脑磁盘出现了故障，数据出现了损坏就无能为力了，或者只能够找专业的人把数据能够找回来，但是不能够保证说所有的数据都能找回来。云上有快照这样一个概念，它的意思是说对云盘的某一个时间点的数据拍一张照，本质上就是会把磁盘上所有的数据记录下来，如果出现了问题，我们就可以通过快照，快速的回滚到某一个时间点的数据，这样能够保证在业务出现了问题的情况下，快速做灾备的恢复。</p><p> <img src="https://ucc.alicdn.com/pic/developer-ecology/e5984153d6e04affbd55d256bd042105.jpg" alt="图3.jpg" title="图3.jpg"> </p><p>整体介绍完云服务器的基本概念之后，接下详细介绍一下云服务器的存储和网络的概念。</p><h4 id="云上的三种存储方式"><a href="#云上的三种存储方式" class="headerlink" title="云上的三种存储方式"></a>云上的三种存储方式</h4><p>第一种是前面已经介绍的块存储的模式，用户创建了一个块存储之后，可以把块存储挂载到实例上，就跟自己使用笔记本电脑过程中，电脑自带的磁盘不够用了，去买移动硬盘来插上来类似。块存储有三种类型，包括普通的高效云盘，还有SSD云盘，以及超高性能超低延迟的ESSD云盘。</p><p>第二种存储方式是文件存储，每一个块存储只能够挂载到一个云服务器上，而每个文件存储可以被多台ECS使用。</p><p>第三种存储形态是对象存储形态OSS，这个就类似于百度云盘，使用这种存储的方式，更多的通过一个链接来做文件的读取。</p><h4 id="云上的网络"><a href="#云上的网络" class="headerlink" title="云上的网络"></a>云上的网络</h4><p>网络部分主要是两个概念，专有网络VPC和交换机。</p><p>第一个是专有网络VPC，专有网络是在云上为用户划分一个私有网络，用户通过创建VPC可以创建逻辑上彻底隔离的一个网络环境，每一个VPC都是由一个路由器以及一个以上的交换机组成的。用户一旦创建了一个VPC专有网络，阿里云会自动为用户创建一个对应的路由器，来完成VPC下所有网络的转发。同一个VPC下的实例之间的内网是互通的，即在同一个VPC下实例之间可以通过内网IP地址来互相访问。</p><p>第二个概念是交换机，前面已经介绍了，一个VPC至少有一个路由器。交换机是专有网络的基础网络设备，用来连接不同的实例资源，我们可以通过交换机，在每一个可用区创建多个交换机来划分子网，然后多个交换机之间是可以通过路由器来实现连接和转发。以上是存储和网络的一些基础的概念。</p><h4 id="云服务器ECS的使用流程"><a href="#云服务器ECS的使用流程" class="headerlink" title="云服务器ECS的使用流程"></a>云服务器ECS的使用流程</h4><p>下面我们介绍一下使用ECS的流程。</p><p> <img src="https://ucc.alicdn.com/pic/developer-ecology/4c54b22f8440429fb07e07add75bb064.jpg" alt="图4.jpg" title="图4.jpg"> </p><p>一个ECS的实例，我们可以把它理解成一台虚拟机，它包含内存、磁盘、网络和操作系统等软硬件。而一个ECS服务器实例是多大的规格，底层的物理硬件是什么样子的，是由对应的实例规格和实例规格族来决定的。实例规格族代表了实例适用的业务场景，它决定了CPU和内存配比，以及底层的物理硬件是什么样子的。实例规格代表的是实例的大小，比如说 CPU的数量是多少。</p><p>在确定了实例规格之后，我们还需要去选择对应的存储，因为只有CPU和内存的话，数据是没有办法存放的，所以就会有一个块存储。块存储有两种，一种是云盘，一种是本地盘。云盘其实是云上的一种三副本的存储形态，能够给用户提供高可用的能力。云盘主要用来做系统盘和数据盘，只需要像物理盘一样把它格式化就可以使用了，而本地盘可能更多的主要是用来做数据盘。</p><p>选择完了计算存储，我们接下来就要看对应的操作系统，云上的操作系统指的是镜像，目前阿里云提供多种镜像的来源，包括官方提供的这种公共镜像、第三方市场提供的镜像、用户自定义镜像，还允许不同的用户之间共享镜像。</p><p>网络方面阿里云会有一个网络带宽，用户可以直接指定。</p><p>我们把实例的计算、存储、网络以及操作系统等参数制定好之后，就可以创建一个跟我们物理的笔记本电脑一样的云服务器。</p><p>创建完之后，我们通过阿里云的控制台，或者是通过阿里云的APP，可以直接连接和访问已购买的云服务器。</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h3 id="02-ECS实例规格族介绍"><a href="#02-ECS实例规格族介绍" class="headerlink" title="02 ECS实例规格族介绍"></a><em>02</em> ECS实例规格族介绍</h3><p> <img src="https://ucc.alicdn.com/pic/developer-ecology/4a6fdd8f210c444e890f7f8534a7de82.jpg" alt="图5.jpg" title="图5.jpg"> </p><p>第二部分我会给大家介绍一下ECS实例的规格族是怎么命名的，大家可能在这一块会有比较多的疑问。目前阿里云提供几百种实例规格，所以在选择的过程中会眼花缭乱，其实只要理解了ECS的实例规格族的命名方式，和它的信息布局，我们就能够很好的选型了。</p><h4 id="实例的架构类型、规格分类与详细信息"><a href="#实例的架构类型、规格分类与详细信息" class="headerlink" title="实例的架构类型、规格分类与详细信息"></a>实例的架构类型、规格分类与详细信息</h4><p> <img src="https://ucc.alicdn.com/pic/developer-ecology/18e3c00f905e48658fa22093e110d4f7.jpg" alt="图6.jpg" title="图6.jpg"> </p><p>在阿里云控制台的购买页面上可以看到，实例规格族的选择上分成三大模块：架构、分类、具体信息。最上面就是我们的实例规格架构的类型，有三种架构类型，分别是通用的X86的架构、异构计算（像GPU或者是FPGA、NPU等）、阿里云自研的神龙裸金属架构。</p><p>在每种架构下面会有实例规格的分类，从上图可以看到在X86的这种计算型态下，分成了7大类实例规格，不同实例规格代表了不同的硬件配置，选择任何一个实例规格的分类之后，我们可以看到对应实例规格的详细信息，这些信息主要分为四部分：</p><blockquote><p><strong>第一个就是实例规格族的详细信息</strong>，包括对应的规格族和实例规格的代称，这里可以通过点击小问号，能够看到实例规格族的一些详细的描述。<br><strong>第二部分是 CPU和内存大小的信息</strong>，这里是大家在选型的过程中会比较关注的。<br><strong>第三部分是实例的网络能力信息</strong>，包括实例内网的带宽和收发包的能力。<br><strong>第四部分是CPU的处理型号的信息</strong>，包括处理器的主频和睿频这两部分信息。</p></blockquote><h4 id="企业级实例-VS-入门级实例"><a href="#企业级实例-VS-入门级实例" class="headerlink" title="企业级实例 VS 入门级实例"></a>企业级实例 VS 入门级实例</h4><p> <img src="https://ucc.alicdn.com/pic/developer-ecology/f83e0c35435a4c338ee6ebde4af94042.jpg" alt="图7.jpg" title="图7.jpg"> </p><p>在控制台的购买页面上可以看到，ECS的实例规格族特别多，单纯从CPU和内存是无法判断它们的区别，所以我们需要从宏观上来看。阿里云ECS的实例规格整体是分成两大类，一类是企业级实例，一类是入门级实例。</p><p>企业级实例是阿里云在2016年9月份才推出的，其特点是vCPU是独享的，也就意味着我们创建一个企业级实例的时候，实例vCPU与我们底层物理的 CPU是绑定了的，底层的物理CPU就不可能再分配给其他的实例了，所以企业级的实例不会出现资源的争抢，因此能保证性能稳定，并且企业级实例提供了非常严格的SLA性能保证。</p><p>而入门级实例就是vCPU跟底层的物理的CPU是不绑定的，意味着可能每个vCPU是随机分配到底层的空闲的一个物理CPU上，如果同一个物理的物理服务器上有多个共享入门级实例的话，不同的实例就会出现资源的争抢，导致CPU的性能不稳定。</p><p>因为入门级实例存在性能不稳定的特性，所以阿里云现在仅仅提供一种入门级实例，就是在X86架构中的共享型实例， 而X86架构中的其他实例规格，以及异构架构和神龙架构中的所有实例，都是属于企业级实例。</p><p>由于企业级实例性能稳定，并且有严格的SLA的保证，所以它比较适合于对业务稳定性有比较高的要求的场景。入门级实例由于不能够保证性能稳定性，所以价格相对便宜，比较适合于一些对性能没有严格要求，或者在某些时段下才会有性能突发要求的场景，比如有些轻负载的应用或者是微服务。</p><h4 id="共享型实例"><a href="#共享型实例" class="headerlink" title="共享型实例"></a>共享型实例</h4><p>在介绍完ECS实例大的分类之后，我们来看一下共享型实例的具体信息。</p><p> <img src="https://ucc.alicdn.com/pic/developer-ecology/07c571fcad1d4dc5b1e127309342a70b.jpg" alt="图8.jpg" title="图8.jpg"> </p><p>我们前面讲到了只有X86架构下的共享型实例才是入门级实例。这类实例比前面实例在四要素以外多出一个参数，即“平均基准的CPU计算性能”，基准性能即实例能够持续提供的CPU性能。</p><p>共享型实例也就是入门级实例，分成两大类，第一类是属于标准的共享型实例， CPU是不绑定的，只提供基准CPU性能，所以当出现资源的争抢，是否能超出基准性能是没有保障。</p><p>另外一种特殊的共享型实例，名为突发性能型的共享实例，它主要就是照顾到某些应用在绝大多数的时候CPU的使用率可能都不高，负载都不高，但是在某些时候可能会有临时的突发的高性能要求，所以阿里云会提供突发性能的参数，所以您在购买共享型实例的时候，能够通过突发性性能来获得高于平均基准CPU性能的能力。</p><p>突发性能型的共享实例，如果应用实际用量低于了平均的基准性能，会获得对应的CPU的积分，如果在某些场景下性能要求突然提升之后，比如实例对应的 CPU的使用率超过了20%，会消耗之前累积的CPU的积分，去提升计算性能，让计算性能不会受到影响，这个是突发性能的共享型实例独有的特性。</p><h4 id="两个特殊的实例规格"><a href="#两个特殊的实例规格" class="headerlink" title="两个特殊的实例规格"></a>两个特殊的实例规格</h4><p>除了共享型的入门级实例以外，阿里云还有两个实例规格比较特殊，就是大数据型和本地SSD。</p><p> <img src="https://ucc.alicdn.com/pic/developer-ecology/e9944b2c874e4857b7eb08e12c425253.jpg" alt="图9.jpg" title="图9.jpg"> </p><p>这两种实例规格会附带一个本地存储，大数据型实例的本地存储是HDD盘，本地SSD新增的本地存储是具有非常高I/O吞吐，并且有低延迟的本地SSD盘，具体的信息大家可以在阿里云控制台查看。</p><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><p>企业级实例规格家谱</p><p> <img src="https://ucc.alicdn.com/pic/developer-ecology/a73f20534b9f400b8fc66abf5f49db00.jpg" alt="图10.jpg" title="图10.jpg"> </p><p>下面介绍企业级实例规格的家谱，方便我们快速了解各个实例家族的“亲属”关系。企业级实例规格族分成三大块，第一大块是X86计算，除了共享型以外，包括通用、计算、内存、高主频、本地SSD和大数据型都属于我们的企业级实例，企业级实例每年都在不停地迭代，所以会分成不同的代系，我们在后面会详细介绍不同的代际之间的区别。异构计算里面所有的GPU和FPGA都是属于企业级的实例，裸金属和高性能计算也是一样的。</p><p> <img src="https://ucc.alicdn.com/pic/developer-ecology/d98d3889ae604987baac119f983ced17.jpg" alt="图11.jpg" title="图11.jpg"> </p><p>首先，我们来介绍X86的实例规格的命名方式，分成了5种：</p><p><strong>第一种实例规格是通用型，</strong>顾名思义就是什么场景都能够用，所以这种型号的代称是g系列，它的vCPU和内存的一个配比是1:4。</p><p><strong>第二种实例规格是计算型，</strong>顾名思义就是在某些场景下对CPU算力的要求会更高一点，所以它的vCPU和内存的配比是1:2，然后简称为c系列。</p><p><strong>第三种类型是内存型，</strong>提供更多的内存能力，所以它的CPU和内存的配比是1:8，也简称为r系列，r是RAM的简称</p><p><strong>第四种和第五种分别是大数据型和本地SSD型，</strong>这两种的CPU和内存的配比都是1:4，只是它们配的本地盘的类型是不一样的，导致它们的技能和适合的场景也是不一样的。所以大数据型的简称是d，本地SSD型简称是i。</p><p>在这5个基础的实例规格上面，我们会去做一些额外的能力提升，比如说在通用型、计算型和内存型这三种类型下，增加了一些高主频的能力，正常的 CPU的主频应该是2.5G赫兹，但是我们有一些可以是做到3.2G赫兹，这种加上高主频的能力就变成了高主频型，会在前面去加上一个hf这样的一个标识。</p><p>随着技术的演进，神龙架构的神龙卡也是在不断地迭代和改善，搭载了第三代的神龙卡可以整体提升通用型、计算型和内存型这三种实例规格的性能，所以就会出现一个平衡增强型。对于大数据型的话，做了计算和存储的分离，形成了大数据存储型，简称为d2，而 d2s是在大数据的基础上，做了一些网络能力的增强，就变成了一个网络增强型。</p><h4 id="实例规格的命名方式和规律"><a href="#实例规格的命名方式和规律" class="headerlink" title="实例规格的命名方式和规律"></a>实例规格的命名方式和规律</h4><p>大家通过下图能够看到阿里云实例规格的命名方式和规律。</p><p> <img src="https://ucc.alicdn.com/pic/developer-ecology/c31b3eacfb824b849b786f025514090b.jpg" alt="图12.jpg" title="图12.jpg"> </p><p>普通的X86实例规格名称是分成了三段，第一部分表示的是产品名称，ECS是阿里云的产品；第二部分表示了实例的规格和代系，前面已经讲过hfg表示是在通用型的基础上增加了高主频的能力，然后6代表的是什么？其实它代表的是我们产品的代系，可以根据产品的代系推算对应的产品的一个新旧，比如说6代表第6代，5代表的是第5代，这个数字越大代表它是更新的一个代系，它底层的物理硬件也会越新，它的性价比相对而言也会越高。</p><p>最后一部分是实例的规格，表示的是实例的vCPU的核数，large代表2个vCPU， xlarge代表4个 vCPU，2xlarge代表的是8个vCPU，以此类推。</p><p>了解了以上命名规律，就能通过实例规格族的名称推断出来当前这个实例的CPU是什么型号、它的是什么样的代系，以及它的 CPU的数量是多少。</p><p> <img src="https://ucc.alicdn.com/pic/developer-ecology/e215844161f8482ba2f9f2a1efa73852.jpg" alt="图13.jpg" title="图13.jpg"> </p><p>GPU命名规则也是类似的，只有一个不一样的点，GPU名称的的中间这一部分会提供CPU和GPU的的配比关系，因为 GPU是除了CPU以外还会提供一个额外的GPU的卡。所以我们也是直接可以通过它的规格族的格式，能够去推断出来它底层的物理的配置。</p><h3 id="03-ECS实例选型实战"><a href="#03-ECS实例选型实战" class="headerlink" title="03 ECS实例选型实战"></a><em>03</em> ECS实例选型实战</h3><p> <img src="https://ucc.alicdn.com/pic/developer-ecology/6bd19f98419148c097f10384d76113c2.jpg" alt="图14.jpg" title="图14.jpg"> </p><p>第三部分给大家实战讲一下如何做云服务器ECS的选型。</p><h4 id="简述各种规格实例的适用场景"><a href="#简述各种规格实例的适用场景" class="headerlink" title="简述各种规格实例的适用场景"></a>简述各种规格实例的适用场景</h4><p> <img src="https://ucc.alicdn.com/pic/developer-ecology/45267e4f1ecf4d429293fc6c4b5b2905.jpg" alt="图15.jpg" title="图15.jpg"> </p><p>X86计算:</p><blockquote><p>• X86的通用型、计算型和存储型三种实例，CPU和内存的配比比较一致，所以比较适合做一些中小型的数据库，或者是一些数据处理的任务。<br>• c系列的话，主要是计算型，所以比较适合于做一些计算要求比较多的，比如说做一些外部应用，或者做一些批量计算，或者是一些高性能的科学计算类的。<br>• r系列的话，因为它的内存比较多，所以比较适合于做一些数据库或者数据分析的应用。<br>• 高主频实例规格也是比较适合于对CPU的主频有比较高要求的高性能科学计算。<br>• 本地SSD类型，更多的适合于做一些关系型数据库或者是NoSQL数据库的<br>• 而D系列的大数据型，可能更适合于做一些大数据集群的一个场景，比如说像这种Map Reduce这种。</p></blockquote><p>在异构这一块，分成了两大类:</p><blockquote><p>• GPU比较适合于做深度学习或者是图像视频的可视化的处理;<br>• FPGA就比较适合于做图像的转码，或者音视频的解码。</p></blockquote><p>裸金属和高性能计算:</p><blockquote><p>• 更垂直和性能要求更高的一些场景，像一些高性能的数据库或者高性能科学计算场景。</p></blockquote><p>下面我们举几个例子详细介绍一下选型方法。</p><h4 id="X86实例选型推荐"><a href="#X86实例选型推荐" class="headerlink" title="X86实例选型推荐"></a>X86实例选型推荐</h4><p> <img src="https://ucc.alicdn.com/pic/developer-ecology/289bafc772d5448f99ad7ba9c9d2fb9a.jpg" alt="图16.jpg" title="图16.jpg"> </p><p>我们可以把一个web应用分成以下几个层次，每个层次做对应的推荐：</p><blockquote><p>• 对于Apache和Nginx的web服务器，，因为它主要做一些计算处理，所以推荐是使用一些计算型的，比如说c5、c6这样的；<br>• 对于像 spring cloud或者说MQ这样的中间件的话，它是属于对于计算和存储的诉求都比较正常的，所以我们是推荐一些通用性的，比如说g6这样的实例规格；<br>• 而应用型因为是属于比较通用的场景，所以G6系列就能够满足；<br>• Redis和Memcache这种缓存应用，对内存的要求是比较高的，所以我们推荐使用内存型的，像r系列；<br>• 对于关系型数据库，我们是可以直接使用内存型，比如说r系列配上我们的SSD云盘；<br>• 对于NoSQL，我们推荐本地SSD型的，比如I系列；<br>• 对于大数据的话，类似于HDFS或spark的这种，我们也有专门的大数据型的，像d系列这种的来处理;<br>• 对于最底层的机器学习的，比如MXNet这种训练框架，会有对应的专门的GPU计算型。</p></blockquote><h4 id="GPU实例选型推荐"><a href="#GPU实例选型推荐" class="headerlink" title="GPU实例选型推荐"></a>GPU实例选型推荐</h4><p>GPU云服务器的场景主要分成两大类，第一大类是人工智能，或者叫机器学习，第二块是图形图像的处理。在机器学习里面也会分成两个场景，一个是训练，一个是推理。所以对于不同细分的垂直领域，我们给了一些规格的推荐，具体可见下图。</p><p> <img src="https://ucc.alicdn.com/pic/developer-ecology/f0033eee56684edc9270e85eba9a8446.jpg" alt="图17.jpg" title="图17.jpg"> </p><p>下面我们介绍两个相对而言比较复杂的选型场景。</p><h4 id="大数据场景实例选型实战"><a href="#大数据场景实例选型实战" class="headerlink" title="大数据场景实例选型实战"></a>大数据场景实例选型实战</h4><p> <img src="https://ucc.alicdn.com/pic/developer-ecology/9f77c7342d7e494f9f6be23cae355a05.jpg" alt="图18.jpg" title="图18.jpg"> </p><p>第一个复杂场景是大数据的场景，类似于Hadoop、Spark这种大数据集群搭建的时候，如果我们自己手动做搭建，会把过程分成三大块：第一大块就是集群的管理节点的实例规格选型，第二块是集群的计算节点的选型，第三块是集群的数据节点的选型。</p><blockquote><p>• 管理节点是比较通用的场景，所以直接选择g系列就能够很好地处理管理的任务；<br>• 计算节点更多的是属于比较偏正常的业务负载，所以可以把g系列作为主要的选择，搭配SSD云盘；<br>• 数据节点对存储的吞吐和网络的吞吐有比较高的要求，所以推荐使用 d系列，搭配对应的本地盘，能够完成这种数据的读取量；</p></blockquote><p>所以整体来说，在同样一个大数据的集群里面，不同的任务有不同的特征，所以会选择不同的实例规格。</p><h4 id="数据库场景实例选型实战"><a href="#数据库场景实例选型实战" class="headerlink" title="数据库场景实例选型实战"></a>数据库场景实例选型实战</h4><p> <img src="https://ucc.alicdn.com/pic/developer-ecology/d486f2ae916f49e08fd1f080aeb95515.jpg" alt="图19.jpg" title="图19.jpg"> </p><p>第二个复杂场景是关于数据库选型的：</p><blockquote><p>• 对于普通的业务，负载比较轻的数据库，有专门的通用型g系列，或者内存型r系列搭配高效云盘和SSD云盘就能处理，性价比会比较高。因为g系列和本地盘或者本地SSD比起来，价格还是很有优势的。高效云盘和SSD云盘的整体性能，其实也是能够满足日常数据库的场景的。<br>• 对于业务负载要求非常高的集群，推荐本地SSD的 i 系列搭载NVMe SSD的云盘，能够实现存储的高IOPS和低延时，能够满足重载数据库的性能要求。</p></blockquote><h4 id="X86-第6代vs第5代-实例价格对比"><a href="#X86-第6代vs第5代-实例价格对比" class="headerlink" title="X86 第6代vs第5代 实例价格对比"></a>X86 第6代vs第5代 实例价格对比</h4><p>除了性能以外，大家也会关注价格，这里有一个X86里面第6代和第5代的一个价格的对比。</p><p> <img src="https://ucc.alicdn.com/pic/developer-ecology/994835ade191495997fc4db11710ad76.jpg" alt="图20.jpg" title="图20.jpg"> </p><p>可以看到除了计算型的实例在某些区域下，第6代实例会比第5代10实例的价格会略高4%以外，通用通用型和内存型的包月价格，第6代普遍比第5代要便宜2%-12%，所以整体来说的话，第6代不仅仅是性能有20%的提升，而且绝大多数的产品会更便宜。</p><p>而按量付费的话，第6代的价格比第5代的价格会低37%-47%，这其实是一个非常大的让利的空间。所以在选择按量去购买ECS的时候，选择第6代会比第5代要便宜的要便宜的更多。</p><h4 id="选型实战总结"><a href="#选型实战总结" class="headerlink" title="选型实战总结"></a>选型实战总结</h4><p>总结选型方法，有三个法则，大家可以记在心里面，在选型的过程中运用。</p><p> <img src="https://ucc.alicdn.com/pic/developer-ecology/dfb454598d244a5c89a89a8fa7747538.jpg" alt="图21.jpg" title="图21.jpg"> </p><p>第一个法则是相同大小的企业级的实例比入门级的实例性能更稳定，但是入门级的实例性价比更高，因为企业级的实例它是独占了vCPU，不存在一个资源的争抢，有性能的保障，但是对于一些个人或者中小网站的应用，如果对性能的诉求并不是那么强的话，选择入门级的实例其实是一个更好的选择。</p><p>第二个法则是在相同的实例规格下，新一代的实例规格比老一代的实例规格性价比更高，这是因为新一代的实例规格，做了很多技术的演进和更新换代，能够给公有云用户释放更多的技术红利。</p><p>第三个法则是选型时不仅仅要选择合适的实例规格，而且还需要搭载合适的块存储，才能够让云上的应用达到预期的性能。云上会提供4种不同的块存储，包括高效云盘、SSD云盘、ESSD云盘和本地盘，不同的类型盘的IOPS和吞吐是不一样的，所以不仅仅要选合适的实例规格，还要选择合适的块存储，才能够形成合力，达到最佳的性能。</p><h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1><h3 id="04-ECS省钱省力之道"><a href="#04-ECS省钱省力之道" class="headerlink" title="04 ECS省钱省力之道"></a><em>04</em> ECS省钱省力之道</h3><p> <img src="https://ucc.alicdn.com/pic/developer-ecology/83e745ca5d174a58a086d3f8c31124da.jpg" alt="图22.jpg" title="图22.jpg"> </p><p>在购买云服务器的时候，除了要做实例规格的选型，让选择的实例规格和业务的匹配度更高以外，我们还需要去考虑能不能更便宜，能不能够快速完成资源的交付，所以最后一部分给大家介绍一下ECS省钱省力的技巧。</p><p> <img src="https://ucc.alicdn.com/pic/developer-ecology/e35d8d97c17240db8de63fb455a1b4b2.jpg" alt="图23.jpg" title="图23.jpg"> </p><h4 id="省钱大法"><a href="#省钱大法" class="headerlink" title="省钱大法"></a>省钱大法</h4><p>第一个是省钱大法，省钱大法意思是选好了实例规格，还需要选择最适合的付费方式，才能够得到更好优化成本。阿里云目前提供7种付费方式，例如节省计划（Saving Plan）、包年包月、预留实例券、按量付费、抢占式实例等。</p><p> <img src="https://ucc.alicdn.com/pic/developer-ecology/cba5f34bc6224020bc85b70d290b21e1.jpg" alt="图24.jpg" title="图24.jpg"> </p><p>如何选择合适的付费方式呢？有一个攻略，就是我们需要根据业务的稳定性和峰谷的波动情况，来选择最适合的付费方式。像节省计划、包年包月、预留实例券就比较适合于稳定的业务负载；有状态并且是动态变化的业务负载的话，可以使用按量付费；而对于完全没有状态，并且具有很高的容灾能力的，可以使用抢占式的实例来交付，因为抢占式实例的价格是可以做到按量付费实例的10% 的。</p><h4 id="省力之道"><a href="#省力之道" class="headerlink" title="省力之道"></a>省力之道</h4><p>第二个是省力之道。在云上购买资源的时候，有时候会批量购买，阿里云会提供多种自动化的资源交付模式和工具，能够实现一次配置重复使用，从而提升整个云上部署的速度和效率。</p><p> <img src="https://ucc.alicdn.com/pic/developer-ecology/a1e5f6b6ab7f4548831e1022d9902c55.jpg" alt="图25.jpg" title="图25.jpg"> </p><p>比如通过控制台做批量的交付；通过部署集可以完成底层具有容灾能力的算力集群的交付；通过弹性伸缩和弹性供应，能自动化地完成资源的交付；而通过资源编排，可以把多种不同的资源组合交付。</p><h4 id="上云选型四步走"><a href="#上云选型四步走" class="headerlink" title="上云选型四步走"></a>上云选型四步走</h4><p> <img src="https://ucc.alicdn.com/pic/developer-ecology/87ccb51047404e39b7d37a29455bc9cb.jpg" alt="图26.jpg" title="图26.jpg"> </p><p>总结一下，上云的过程中，我们需要走好四步：</p><blockquote><p>第一步：对自己的业务特征做一些分析，包括对性能的要求，对网络的要求，形成一个基本的判断；<br>第二步：针对业务特征来选择对应的ECS实例规格；<br>第三步：选择对应的一个付费方式，只有选择最合适的付费方式，才能够实现云上的成本最优；<br>第四步：选择合适的交付方式，帮我们省时省力地完成资源的交付。</p></blockquote><p>省钱法宝的更多分享，请参考：<a href="https://developer.aliyun.com/article/849731?spm=a2c6h.12873581.0.0.55cc472djPP6l6&groupCode=ecs">阿里云万郁香：多样付费选择构筑成本最优的弹性体验</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt; 云服务器ECS选购指南及省钱法宝（强烈建议收藏） &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作者 | &lt;strong&gt;阿**&lt;/strong&gt;&lt;/strong&gt;里云弹性计算产品专家 马小婷**&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://develop</summary>
      
    
    
    
    <category term="阿里云" scheme="http://zhangyu.info/categories/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
    
    <category term="ECS" scheme="http://zhangyu.info/tags/ECS/"/>
    
  </entry>
  
  <entry>
    <title>阿里云弹性计算研发团队如何从0到1自建SRE体系</title>
    <link href="http://zhangyu.info/2022/03/08/%E9%98%BF%E9%87%8C%E4%BA%91%E5%BC%B9%E6%80%A7%E8%AE%A1%E7%AE%97%E7%A0%94%E5%8F%91%E5%9B%A2%E9%98%9F%E5%A6%82%E4%BD%95%E4%BB%8E0%E5%88%B01%E8%87%AA%E5%BB%BASRE%E4%BD%93%E7%B3%BB/"/>
    <id>http://zhangyu.info/2022/03/08/%E9%98%BF%E9%87%8C%E4%BA%91%E5%BC%B9%E6%80%A7%E8%AE%A1%E7%AE%97%E7%A0%94%E5%8F%91%E5%9B%A2%E9%98%9F%E5%A6%82%E4%BD%95%E4%BB%8E0%E5%88%B01%E8%87%AA%E5%BB%BASRE%E4%BD%93%E7%B3%BB/</id>
    <published>2022-03-07T16:00:00.000Z</published>
    <updated>2022-03-08T17:16:40.322Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://blog.csdn.net/weixin_46593167/article/details/117708269">https://blog.csdn.net/weixin_46593167/article/details/117708269</a> </p></blockquote><blockquote><p>SRE 最早在十多年前 Google 提出并应用，近几年随着DevOps的发展，SRE 开始被大家熟知。而在国内，非常多的 SRE 部门与传统运维部门职责类似，本质来说负责的是互联网服务背后的技术运维工作。构建区别于传统运维的 SRE、如何在业务研发团队落地SRE，是许多企业都在攻克的难题。</p><p>本届全球运维大会 GOPS 上，阿里云弹性计算团队技术专家杨泽强以《大型研发团队SRE 探索与实践》为题，分享了在 SRE 体系建设上的思考和落地实践。</p><p><strong>本文为演讲内容整理，将从以下三部分进行介绍：</strong></p><ul><li><p>  阿里云弹性计算（ECS）自建 SRE 体系的原因；</p></li><li><p>  ECS 建设 SRE 体系的探索与实践；</p></li><li><p>  以弹性计算 SRE 体系建设的四年经验为例分享对 SRE 未来的看法。</p></li></ul><h2 id="为什么ECS要自建SRE体系？"><a href="#为什么ECS要自建SRE体系？" class="headerlink" title="为什么ECS要自建SRE体系？"></a>为什么ECS要自建SRE体系？</h2><p>ECS 团队之所以会单独建 SRE，与产品业务特性以及组织层面上的背景有关。</p><p>下图展示了 ECS 的业务特点：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/81af794d217f300c5bfb8b2f9017c2c8.png" alt="图片"></p><p>首先，从产品业务来看，ECS 是阿里云最大最核心的云产品。ECS 作为阿里巴巴经济体的以及其它部署在 ECS 上的云产品的底座，也支撑了国内外非常多的业务。阿里云全球份额排名第三，其中 ECS 的贡献毫无悬念是排名第一的，ECS 作为基础设施底座，稳定性要求特别高。</p><p>其次，由于阿里内部的经济体上云和整个云计算普及，ECS 对外的 OpenAPI 调用量每年都出现数倍增长，这意味着系统的容量每年都会面临新的挑战。</p><p>而与此同时，阿里云弹性计算启动了去 PE 的组织调整，即业务团队没有专职的运维工程师以及系统工程师，这将意味着运维类的事情、系统架构规划与横向产品需要有团队来承接。</p><h2 id="ECS-建设-SRE-体系的探索与实践"><a href="#ECS-建设-SRE-体系的探索与实践" class="headerlink" title="ECS 建设 SRE 体系的探索与实践"></a>ECS 建设 SRE 体系的探索与实践</h2><p>从 2018 年刚开始建设至今，在一路的摸索中，ECS 的 SRE 体系建设借鉴了 Google 和Netflix 的做法，并结合团队和业务的特性，最终 SRE 体系可以简单概况为下图的五个层次：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/31bcfff7174cdd149c0297d089bea526.png" alt="图片"></p><ul><li><p>  <strong>打基础。</strong>阿里云的文化主张里有一句话是“基础不牢，地动山摇”。在团队里具体的事情就是全链路稳定性治理体系以及性能容量工程，也是重要的基础。</p></li><li><p>  <strong>定标准。</strong>这在一个大型研发团队里非常重要， ECS团队主要从软件的生命完整生命周期来看，从设计-&gt;编码-&gt;CR-&gt;测试-&gt;部署-&gt;运维-&gt;下线，各个环节定义了标准。通过定期的技术培训和定期运营，先在意识上给大家普及，同时会通过小团队的试运行来看效果，如果符合预期就想办法自动化掉。</p></li><li><p>  <strong>建平台。</strong>通过建设自动化平台来不断释放SRE的人肉工作。</p></li><li><p>  <strong>做赋能。</strong>业务团队的SRE除了做好横向的基础组件和自动化平台外，还要做很多推广和协助业务研发的事情；同时SRE每天都要处理非常多的预警响应，线上问题排障以及故障响应，如何把SRE的价值最大化，我觉得最核心的是赋能。</p></li><li><p>  <strong>建团队。</strong>最后我将以弹性计算为例介绍一下SRE团队的职责，文化理念以及如何成为一名合格的SRE。</p></li></ul><h3 id="打基础"><a href="#打基础" class="headerlink" title="打基础"></a>打基础</h3><p><strong>基础框架建设与性能调优</strong></p><p>弹性计算的核心业务都是 Java 技术栈，还有少部分 golang 和 python，本质上是一个Java 研发大型分布式系统。在内部为了支撑业务规模和尽可能的抽象整合，我们自研了一系列基础框架给业务同学使用，包括轻量bpm框架、幂等框架、缓存框架、数据清理框架等，其中每个框架的抽象和设计我们都考虑了规模化容量的支撑以及小型化的输出，以工作流框架为例，我们支持了每天数亿工作流的创建运行，框架调度开销做到了5ms级别。</p><p>除了基础框架，在性能优化上针对 JVM 进行了一系列调优，比如针对IO密集型的应用开启了wisp协程，以及针对每个核心应用JVM进行调优，减少STW的时间。</p><p>另外，从服务性能角度，数据层，我们对全网超过100ms的慢SQL进行了调优；应用层，我们针对核心链路提供了多级缓存方案，可以保障最热的数据可以从内存里最快的返回；业务层，我们通过提供批量API以及异步化改造。</p><p><strong>全链路稳定性治理</strong></p><p>上图罗列了几个比较典型的点，比如预警治理，普遍问题是预警量太大了，信噪比又不高，预警能提供的信息非常有限，对于排查排障帮助比较局限。</p><p>早年间，我们也面临同样的问题，分享<strong>预警治理的两个真实故事：</strong></p><ol><li><p> 一个核心应用的数据库在晚上down了，但预警配置的通知渠道是email和旺旺，并且接收人不是当前应用owner，导致owner在发现故障问题的时候花了非常长时间定位到是数据库问题。</p></li><li><p> 之前发生了一起全链路连锁反应的故障，故障发生的起因是其中某一个业务导致的，当时我们花了两个小时来定位和恢复问题，在事后复盘才发现故障开始前5分钟，已经有相关报警，但该报警接收同学的预警量太大，漏掉了重要预警。</p></li></ol><p>所以，稳定性治理很重要的一部分就是预警治理，主要治理的方法就是监控分层、统一预警配置平台、统一预警优化配置策略，比如预警的接收人、通知方式等。</p><p>数据库稳定性治理</p><p>数据库是应用的命脉，发生在数据库上的故障往往非常致命。不论是数据的准确性或者数据的可用性受损，给业务带来的灾难通常是毁灭性的。</p><p><strong>两个难题：慢SQL和大表</strong></p><p>当在使用MySQL做数据存储的时候，最高频遇到的场景就是慢SQL和大表这两个难题。慢SQL会导致业务变慢甚至产生全链路的连锁反应导致雪崩，而大表问题和慢SQL通常也分不开，当表的数据量大到一定程度，MySQL的优化器在做索引选择的时候也会遇到一些奇怪的问题，所以在数据库的治理上基本围绕慢SQL和大表。</p><p><strong>针对慢SQL的治理方案</strong></p><p>大致的解法是把采集的慢SQL同步到SLS上，通过SLS做近实时的慢SQL分析，然后通过库表信息把慢SQL分给指定团队来修复，这个过程SRE同学会给出优化方案以及通用的基础组件，比如针对大页查询的提供bigcache以及nexttoken方案，针对热点数据的common cache以及读写分离降级能力。</p><p><strong>针对大表的治理方案</strong></p><p>针对大表问题，业界通常的解决方案是分库分表，但是其带来的研发和运维成本很高，我们内部一般业务更常用的方式是通过历史数据归档来做，在这里SRE也有统一的基础框架提供，业务方只需要给出数据归档条件以及触发频率，框架会自动将历史数据归档到离线库并把业务库数据做物理删除，这样通过腾挪数据空洞来达到空间的一定复用，保障有限的数据空间不扩容的前提来支撑业务的发展。</p><p><strong>高可用体系</strong></p><p>分布式系统的高可用可以分四个层次来看。从最底层的部署层，由下至上分别是运行时、数据层、业务层，我们的高可用体系也是按照四个层次来划分的。</p><ol><li><p> 部署层，作为ECS的研发我们对外推荐的最佳实践都是多可用区部署，理由很简单，因为容灾性更好、更柔性。</p></li><li><p> 数据层，如前面提到的数据库稳定性治理，我们数据层一方面的工作就围绕像慢SQL、热点SQL和大表的持续治理，另外一方面就是从技术架构上我们做了多读和读写自动降级框架，可以将一些大表查询自动降级到只读库，同时可以保障读写库异常情况，核心API仍然可以通过只读库提供服务，进而来保障数据库整体的高可用。</p></li><li><p> 业务层的高可用体系，一个复杂的分布式系统，难题之一就是解决依赖的复杂性，如何在依赖方不稳定的情况下仍然保障或者有损保障自身的核心业务可以玩转，这是分布式业务系统非常有挑战与有意义的一件事情。</p></li></ol><p><strong>故障案例</strong></p><p>我们曾经出过一个故障，一个核心系统被一个非常不起眼的边缘业务场景搞到雪崩。核心系统里引入了一个三方系统依赖，当依赖方服务RT变慢的时候，我们所有的HTTP请求由于设置的超时时间不合理全部阻塞，进而导致所有线程都block在等待该服务返回，结果就是所有服务RT变长，直至不再响应。</p><p>要知道在庞大的分布式系统里，没有绝对可靠的授信链，我们的设计理念就是Design For Failure，以及Failure as a service。</p><p>可参考以下思路：</p><ul><li><p>  在设计阶段时定义该依赖的性质，是强依赖还是弱依赖</p></li><li><p>  对方提供的SLO/SLA是什么，依赖方可能会出现什么问题以及对我们服务的影响是什么？</p></li><li><p>如果依赖方出现了预期/非预期的异常，我们的策略是什么？</p><p>  如何保障我们服务的最大可用性。</p><p>  最大可用性，意味着做出的响应可能有损，比如对端是弱依赖，我们可能会直接降级，返回一个mock结果，如果对端是强依赖，我们可能采取的是隔离或者熔断策略，快速失败部分请求，并尽可能记录更多信息，方便后续通过离线方式进行补偿。</p></li></ul><h3 id="定标准"><a href="#定标准" class="headerlink" title="定标准"></a>定标准</h3><p>弹性计算的研发人员大概是百人以上规模，同时还会有一些兄弟团队以及外包人员一起参与研发，自SRE建设的第一天我们就开始逐步建立各种研发标准和流程。</p><p>以UT标准案例为例，UT缺失导致的故障占比高；难度是量大，研发不重视，实际没办法收敛。解法是通过建立UT标准，和CI自动化体系，量化指标来持续改进。效果是UT缺失导致的故障大幅降低，从占比30%降低至不到0.3%。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/1472a8ba350b1292063ba8729f670cd6.png" alt="图片"></p><p><strong>研发流程体系</strong></p><p>我们从设计到发布几乎各个环境都定义了一套标准。</p><p><strong>1.设计阶段。</strong>我们统一定义了一套设计文档模版来规范和约束研发人员。从软件工程角度来看，越早引入问题带来的成本越低，所以我们的研发原则之一也是重设计。一个好的设计不仅要从业务上定义清楚问题，定义清楚UserStory和UserCase以及约束，从技术角度也要清楚的讲清楚技术方案的tradeoff以及Design for failre如何实现、如何灰度、监控回滚等等。我们希望研发多在设计阶段下功夫，少在中途返工或者发布后打补丁。同时我们的评审机制也从线下大团队评审转变为小团队线下+大团队直播方式进行，尽可能少开会，节约大家时间。</p><p><strong>2.研发阶段。</strong>我们的研发流程类似git-flow。是多feature并行开发，开发测试后合并进入develop分支，每天会有统一的流程基于develop进行daily deploy，我们基于阿里集团的Java规约做了扩展，加入了自定义的静态扫描规则，同时统一的UT框架，实现了CR后自动运行规约扫描执行静态检查，同时运行CI产出UT运行报告，只有静态扫描，CI结果主要是UT成功率和行增量覆盖率以及代码点赞数同时满足条件MR才会被合并，进入下次发布list。</p><p><strong>3.测试阶段。</strong>主要分日常测试，预发测试以及上线前的功能测试以及灰度期间的回归测试。<strong>大规模研发团队大家面临的难题就是环境怎么搞？</strong>这么快速复制以及隔离？以往模式下我们只有一套日常和预发，经常出现某个人代码问题或者多人代码冲突导致测试特别耗时。后来我们做了项目环境，简单功能可以通过容器方式快速复制全链路项目环境。针对有全链路联调需求的case，我们扩展了多套预发环境，可以做到每个业务研发团队一套预发，大家互相不争抢，这样预发的问题就解决了。</p><p>上线前的功能测试主要是针对daily deploy的，我们会在每天晚上11点自动从develop拉取分支，并部署到预发环境，同时这个时候会自动运行全量的功能测试用例来保障发布的可靠性，在日常发布如果FVT非预期失败，会导致发布取消。</p><p>最后一个测试流程是灰度期间自动回归core fvt，我们的发布是滚动发布模式，通常会灰度一个地域来做灰度验证，core fvt就是做这个的，当core fvt运行通过后可以进行后续批次发布，反之判断是否回滚。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d1de45871ad39d9ced95f6a4f089f978.png" alt="图片"></p><p><strong>变更流程体系</strong></p><p>在SRE建设的时候，我们特意规划了变更管控流程。针对当前的变更类型做了不同的标准要求，比如数据库变更checklist+review机制，日常发布/hotfix/回滚的批次以及暂停时长，还有就是中间件的配置规范以及黑屏变更等。</p><p>有了变更流程和规范只是第一步，接着我们针对高频率的运维操作做了工具化建设，其中有部分和现有的DevOps平台合作，游离在现DevOps之外的部分我们都自己做了研发支持，比如日志清理以及进程自动重启，并开发了自动化工具可以自动化清理大文件以及重启故障进程。</p><p>举一个例子就是数据订正，数据都是通过异步编排来实现最终一致性，所以数据订正会是一个特别高频的变更，简单的一条订正SQL蕴藏的威力有时候超过我们的想象，我们之前有一个故障就是因为一条数据订正错误导致，影响非常严重，排障过程也非常困难。</p><h3 id="建平台"><a href="#建平台" class="headerlink" title="建平台"></a>建平台</h3><p><strong>SRE 自动化平台</strong></p><p>我们做SRE自动化平台就是为了将标准通过自动化方式来实现，比如研发阶段的高可用体系里的读写降级，限流等。我们在提供框架能力的同时，提供了运维接口和白屏化工具，帮助研发实现自动化/半自动化的高可用能力。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d940d4864e25ccd5d45a522de4bbce3a.png" alt="图片"></p><p><strong>弹性计算团队的1-5-10指标</strong></p><p>后面的变更、监控、预警、诊断、恢复，对应的就是MTTR的各个细分阶段，在阿里集团有个1-5-10的指标，意思就是分钟发现问题，5分钟定位问题，和10分钟恢复问题，这是一个非常难达到的高标准。</p><p>弹性计算团队为了满足提升1-5-10指标，建立了自己的监控平台和预警平台。我们做的是预警能力的二次消费，将所有的基础监控包括系统指标cpu和mem、JVM监控以及各种中间件监控，还有非常多的业务监控做了分层，而每一个预警都会囊括各种meta信息，比如归属团队、重要性、关联的诊断场景、快恢策略，以及推荐的变更等。</p><p>这就闭环了变更、预警、诊断、快恢整个过程。当一条预警出现的时候可以自动根据TraceID分析全链路寻找局点，同时推荐相关变更，并生成影响面比如多少API、用户是哪些，以及该预警推荐的解决方案是什么，同时提供一个hook可以执行快恢动作。</p><p>举个例子，有位同学订正了一条业务，sql写的问题有问题，导致线上几个大客户的服务异常，在sql执行完的几秒内我们的监控系统就识别出了业务异常，并产生了预警信息以及预警的stack和影响面分析，同时关联的数据库变更信息也被推荐了出来，这些信息组合在一起的1分钟内我们就定位到了问题，并立马执行了回滚，业务很快就恢复了。当然该平台目前仍然有局限性，我们今年规划会做更多智能预警和诊断的事情。</p><p>最后，必须要提一下演练，即混沌工程 Chaos engineering，最早由Netflix提出。在过去的两年里，我们通过故障演练，故障注入的方式多次回放了历史故障，同时对发现线上问题也非常有帮助，故障演练现在已经作为一个常态化的事情融入到了日常。</p><p>分享完我们的SRE自动化平台体系，有了平台之后，非常重要的一个事情就是赋能。</p><p>我认为业务团队SRE最大的价值就是赋能，通过赋能来使众人行。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/4054c5851dc8155913da6fb22e531a94.png" alt="图片"></p><h3 id="做赋能"><a href="#做赋能" class="headerlink" title="做赋能"></a>做赋能</h3><p><strong>全链路SLO量化体系</strong></p><p>ECS的上下游依赖方众多，任何一个环境出现不稳定都会影响ECS出口服务的稳定性。</p><p>举个例子ECS向下对接的是虚拟化和块存储，只要虚拟化和快存储慢了体现用户层面就是ECS实例启动慢了，而这个快慢究竟如何评定呢？可能对于我们做分布式服务来说可能觉得5ms已经很慢了，但是对于虚拟化来说他认为我这个接口1s都是正常的，这个时候就需要SLA了。</p><p>做SRE的第二年，我们梳理了全链路数十个依赖以及数百个核心API与各个业务方选择最关心的指标也就是SLI，针对不同的置信空间设置了SLO值，并且建设了统一的量化平台，通过实时与离线方式持续跟进起来。通过SLO体系建立到持续运营的一年多时间，我们的依赖方可用性和时延的SLO达标率从最初的40%多治理到98%以上。这个直接产生的业务就是我们对用户API成功率的提升，用户的体感更加好了。</p><p><strong>落地SLO的四个阶段</strong></p><ol><li><p> 选取SLI，即和你的依赖方确定哪些指标是需要关注的，比如通常都关心的可用性和时延；</p></li><li><p> 和依赖方约定SLO，即明确某个API某个SLI的目标值 P99、P999分别是什么；</p></li><li><p> 计算SLO，通常的方式都是通过记录日志，将日志采集到SLS，通过数据清洗再加工计算出指标值。</p></li><li><p> 可视化，通过将SLO做成实时/离线的实时报表，来做持续跟进。</p></li></ol><p><strong>知识库</strong></p><p>SRE 很大的一部分职责在于故障排查和疑难问题处理，同时我们做了一系列框架和工具，还要非常多的运维手册以及故障复盘的资料，这些我们都按照统一模版沉淀下来，可以用来指导研发同学日常问题排查和变更使用，其中部分文档我们还共享给了阿里云其它产品。</p><p>通过知识库我们也赋能了非常多的兄弟团队，另外我们研发过程中的很多业务基础组件像工作流、幂等、缓存、降级、Dataclean 等框架也都有阿里云其它团队在使用。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/2cc02fa2048db0f75cfa99c1db7ef784.png" alt="图片"></p><p><strong>稳定性文化建设</strong></p><p>SRE 是稳定性的捍卫者，也是布道师。只有人人都意识到稳定性的重要性，我们的系统才可能真正的稳定。我们从建设 SRE 团队的第一天就开始建流程，团队内通过日报，周报，月报以及不定期的线上直播以及线下培训来宣传稳定性文化。逐步在团队形成我们特有的稳定性文化，比如 Code Review 文化，安全生产文化和事后故障复盘文化。</p><p><strong>故障复盘实践</strong></p><p>在 SRE 初期，我们开始推行故障复盘。我们对于故障的定义是所有有损业务或者人效的异常 case 都是故障。一开始，故障复盘由 SRE 主导，由业务团队配合，但整个过程非常不愉快。</p><p>随着后面 SRE 的一些自动化工具以及一些流程真正帮助了研发避免故障，以及在故障复盘过程中 SRE 的一些见解给到了研发正向反馈，慢慢故障复盘的文化在团队开始慢慢被接受，各个业务自己会写故障复盘报告，并开直播分享，其它团队的同学也会非常积极地给反馈。文化真正的深入人心后，产生的会是非常好的良性循环。</p><h3 id="建团队"><a href="#建团队" class="headerlink" title="建团队"></a>建团队</h3><p>最后分享一下SRE团队组建主要注意的几个方面。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d098216f8aa7790967a99ef7850e2504.png" alt="图片"></p><p><strong>人</strong></p><p>在弹性计算团队，我们对 SRE 的要求是T型人才，要一专多能。</p><ul><li><p>  精通一门编程语言</p></li><li><p>  两个基本能力：抽象能力、标准化能力</p></li><li><p>  拥有全局视野，具备赋能意识</p></li></ul><p><strong>事</strong></p><p>事，基本上即是前面提到的建标准、建自动化平台、做基础服务和赋能业务团队，还有on-call支持等日常工作。</p><p>同时，我们需要在团队中建立几个共同的核心理念，我个人认为SRE几条最核心的理念：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c4533259386b0bcaae7316fdf0e36099.png" alt="图片"></p><ul><li><p>  稳定性就是产品，稳定性不是一锤子买卖。SRE 要做的是赋予稳定性产品的灵魂，要按照产品一样去养育，去不断迭代，去持续演进。</p></li><li><p>  软件工程的方法论解决生产系统稳定性问题。SRE 区别于业务研发和运维的很大一点是，SRE 解决的是生产环境的稳定性问题，是通过软件工程的方法论来重新定义运维模型。</p></li><li><p>  自动化一切耗费团队的事情。SRE 的精髓在于软件工程定义运维，通过自动化以及赋能业务来最大化价值。</p></li></ul><h2 id="SRE-建设的回顾与个人展望"><a href="#SRE-建设的回顾与个人展望" class="headerlink" title="SRE 建设的回顾与个人展望"></a>SRE 建设的回顾与个人展望</h2><p>简单概括下弹性计算团队四年的 SRE 发展历程就是，<strong>建体系-量化-自动化-智能化。</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/dfe9ab6dd26a901c0018d865d6dd4fdd.png" alt="图片"></p><p><strong>第一年：体系化探索</strong></p><p>这一年主要的工作就是从0-1结合当前业务和团队的现状把SRE体系建设起来，比如基础框架的统一建设，稳定性治理体系。</p><p><strong>第二年：SLO体系</strong></p><p>第二年的重点主要是针对全链路数十个系统依赖，以及内部系统的核心功能定义了SLO（service level object，SLO）量化体系，并跨BU完成了整个链路的SLO量化体系建设。同时开始重点建设稳定性运营体系，以及自己的数据运营平台，将内外部核心依赖的核心API的可用性，时延的数据全部量化并持续跟进治理起来。</p><p><strong>第三年：自动化</strong></p><p>我们把研发过程中从设计、编码、测试、部署到上线后的预警响应等所有需要人工参与的事情都做了尽可能的自动化。比如在CR阶段加入UT覆盖率卡点，不符合标准的CR会自动拦截。在发布阶段接入了无人值守，根据发布期错误日志的情况来进行发布拦截，当然这里更好的方式可能是通过灰度机器的服务SLA等综合指标来判断。另外，在灰度地域发布暂停期间，我们会自动化运行corefvt来回归核心测试用例验证发布的可靠性，异常情况会自动拦截灰度，并推荐一键回滚操作。</p><p><strong>第四年：智能心智</strong></p><p>今年我们正在做的一些事情是高度自动化，比如无人发布值守，还有自动化预警根因分析等。当我布式系统规模足够大，应用复杂度足够高的时候，靠人的判断是非常困难的。所以，SRE要建设的自动化平台要有智能心智，通过系统化的能力来代替甚至超越人。</p><p><strong>对SRE未来发展的个人看法：</strong></p><ul><li><p>  稳定性即产品，我们真正是需要把稳定性当作产品来看待的，做产品意味着我们要清楚的定义问题，并产生解决方案，并且持续的迭代演讲，这不是一锤子买卖，是需要养育的。</p></li><li><p>  我觉得随着云计算的普及，SRE的技能会倾向于研发技能，当然系统工程的能力也是必须的，因为云计算作为基础设施会帮助我们屏蔽掉非常多的机房、网络、OS层面的问题，这样SRE的重点就在于用软件工程的方法论来重新定义运维，使用自动化来提高效能。</p></li><li><p>Netflix提出了一个CORE SRE的概念，NetFlix是这样解读CORE的，C就是Cloud，我们都知道Netflix是run on AWS，Cloud是基础。</p><p>  Operation就是运维了，Reliability和Enginering就不多说了。</p><p>  而我对CORE SRE的另一个解读是少量核心的SRE人员支撑并保障大规模服务的稳定性。</p></li><li><p>  少量的SRE支撑大规模服务背后的最核心理念我觉得是自动化，尽可能最大化一切可以自动化的事情，并且要智能的自动化。</p></li></ul><p>总结下稳定性就是，产品 + Dev的比重会增大 + CORE SRE + 自动化一切。</p><p>以上就是我今天想要和大家分享的内容，谢谢大家的聆听。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_46593167/article/details/117708269&quot;&gt;https://blog.csdn.net/weixin_46593167/article/deta</summary>
      
    
    
    
    <category term="SRE" scheme="http://zhangyu.info/categories/SRE/"/>
    
    
    <category term="SRE" scheme="http://zhangyu.info/tags/SRE/"/>
    
  </entry>
  
  <entry>
    <title>云上资源自动化部署新模式</title>
    <link href="http://zhangyu.info/2022/03/08/%E4%BA%91%E4%B8%8A%E8%B5%84%E6%BA%90%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E6%96%B0%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zhangyu.info/2022/03/08/%E4%BA%91%E4%B8%8A%E8%B5%84%E6%BA%90%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E6%96%B0%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-03-07T16:00:00.000Z</published>
    <updated>2022-03-08T17:15:38.066Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>从原子操作走向模板部署，详解云上资源自动化部署新模式<br><a href="https://blog.csdn.net/bjchenxu/article/details/117794680">https://blog.csdn.net/bjchenxu/article/details/117794680</a></p></blockquote><blockquote><p>5 月 29 日，阿里[云开发]者大会的《应用开发的基础设施云上优化》分论坛上，阿里云技术专家王斌鑫发表了主题为《云上资源自动化部署新模式》的分享，详细阐述了云上资源自动化部署新模式——基于资源编排、Terraform托管、ROS CDK的自动化部署最佳实践。 </p><p>本文为根据王斌鑫的演讲整理成文。</p><p><strong>当前云上资源部署模式</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/24b9fc89a519dc332fe03e0b28385183.png"></p><p> <strong><img src="https://img-blog.csdnimg.cn/img_convert/7e4c9dadd6be2d88862ad013689be882.png"> 云上资源传统部署模式的挑战</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/c23409c9c64b612469505d70ec996224.png"></p><p>大部分用户一般是通过控制台/API/SDK等传统模式进行云上资源的部署，这种部署模式会面临规模、效率、规范和成本四个方面的挑战：</p><p>1. 规模上，随着业务的发展需要管理的资源规模不断上升，部署和管理种类繁多的资源带来挑战。</p><p>2. 效率上，随着规模上升，手动批量部署变得难以为继。</p><p>3. 规范上，如何确保对基础设施的变更均符合组织管理规范。</p><p>4. 成本上，手动部署的方式无法极致地利用云上弹性能力，其成本仍有优化空间。</p><p><strong>阿里云自动化部署模式</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/9df336d655e3cdf6f5b9ab8a8246db39.png"></p><p> <strong><img src="https://img-blog.csdnimg.cn/img_convert/c522f57920978ac9dc843a0bce5e3eda.png"> 资源编排服务（ROS）的核心价值</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/540b08d8eddbc42017d33fcf59dea10a.png"></p><p>面对传统部署模式的挑战，我们在想是否能够帮助客户对云上资源进行自动化部署？因此有了阿里云资源编排服务（ROS），它基于基础设施即代码（IaC）的理念，让开发者和管理员使用模版的方式，编排云上的多种资源，进行自动化部署。</p><p>对比手动部署，使用资源编排服务ROS进行自动化部署会带来如下好处：</p><p>• 效率提升，针对诸如SAP这样复杂的解决方案能有效提升部署效率，也能够帮助MSP、ISV、onECS服务提升部署效率；</p><p>• 架构优化，ROS提供了种类丰富的阿里云最佳实践模板，用户无需丰富的架构经验即可部署解决方案级别的架构；</p><p>• 流程管控，由IT管理员统一管理基础设施以避免各类风险，且可基于模板进行审核再进一步结合CI/CD以规范化IT管理流程；</p><p>• 节省成本，自动化部署方式可以按需部署和释放资源，从而极致地使用云上弹性能力来降低成本。</p><p> <strong><img src="https://img-blog.csdnimg.cn/img_convert/709d01bc7735abb89a16fe4a2fdb11d0.png"> ROS 的使用流程和核心功能</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/15eef602c39d93cad3e2c7884843db03.png"></p><p>使用 ROS 进行自动化部署的过程非常简单：</p><p>1. 按照ROS 模板语法编写模板，定义想要创建的各类云上资源。</p><p>2. 在 ROS 控制台 使用模板创建资源栈，以执行部署。其中，资源栈是一组资源的集合，这些资源均是模板中定义的资源。</p><p>3. 在 ROS 控制台 查看资源栈，可以查看栈中各种资源的创建情况，并可以跳转到对应资源的控制台。</p><p>值得一提的是，ROS 服务本身完全免费，集成了身份认证和安全审计的功能，资源创建结果是可视化的，且能够进行多账号跨地域地部署，支持资源栈和实际资源的差异检测并进行修正。</p><p>除了直接使用 ROS 模板来做自动化部署，是否还有别的方式呢？</p><p><strong>新模式一：Terraform 托管</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/e796ee7e140d7f9826418a65889d1dbe.png"></p><p> <strong><img src="https://img-blog.csdnimg.cn/img_convert/289bdc006e85574c97571e01220f9ba8.png"> Terraform 是什么</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/286749609a5e7f83db5e76e1f6d01ea1.png"></p><p>Terraform 同 ROS 一样，也是基于基础设施即代码（IaC）的理念的自动化编排工具。它使用一种特定的配置语言（HCL, Hashicorp Configuration Language）来描述基础设施资源，语法样例如上图所示。</p><p> <strong><img src="https://img-blog.csdnimg.cn/img_convert/067e98d9e2b4e79a91f95602126a4abc.png"> Terraform &amp; ROS</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/d678cab3d14ea3784164e49ca49627bb.png"></p><p>既然 Terraform 和 ROS 都是基于相同的理念的自动化编排工具，那它们的目标也是一致的，都是为用户打造良好的云上部署体验。</p><p>两者有很多相同之处，比方说 Terraform 的配置文件相当于ROS的模板，Terraform 的状态相当于 ROS 的资源栈，Terraform 的 CLI 程序则相当于 ROS 的编排引擎。</p><p>两者也各有优势，Terraform 的语法更简洁，对多云支持地很完善；而 ROS 则提供免费的服务托管，且有云原生的鉴权和审计能力。</p><p>那么是否能够将两者的优势结合呢？因此就有了 Terraform 托管能力。</p><p> <strong><img src="https://img-blog.csdnimg.cn/img_convert/52542d43be98a0f5958dae5799770642.png"> Terraform 托管</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/7960f35892c01e3e993aa75558933106.png"></p><p>用户直接在本地使用 Terraform 时，需要根据当前的操作系统下载对应的 Terraform CLI，编写模板，管理所使用的各类 Provider 的版本，且要管理状态等文件。</p><p>而使用 Terraform 托管功能时，只需在 ROS 的控制台编写 Terraform 模板便可直接部署，后续则通过资源栈来管理模板中定义的资源。底层的各类管理都交给 ROS。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/22080bda7054cfb486c535ad80afed77.png"></p><p>在使用原理上，ROS 控制台会将 Terraform 模板组合成符合 ROS 语法规范的模板，ROS 服务端会其进行语法校验，生成租户信息，调度到 ROS 的 Terraform 服务进行资源的部署。</p><p> <strong><img src="https://img-blog.csdnimg.cn/img_convert/193c29ec55cac1a44dbd923e0241a89d.png"> 定时与多云场景实践</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/4f3f8f74e52ef3ec3329b65cf7508075.png"></p><p>我们可以在很多场景中使用 Terraform 托管的功能。</p><p><strong>场景一：定时部署资源</strong></p><p>假设我们需要通过 Terraform 定时部署资源，传统方式下需要本地创建定时任务，执行 Terraform CLI 来做。而在云上，我们可以：</p><p>• 事先编写一个 Terraform 模板，声明想要部署的云资源；</p><p>• 事先编写一个 OOS 运维模板来声明由它调用 ROS 进行资源部署；</p><p>• 在 OOS 中设置为定时执行，OOS 会定时触发 ROS，ROS 则会使用 Terraform 托管功能进行资源部署。</p><p><strong>场景二：多云管理</strong></p><p>如果我们既想要对多种云平台（如阿里云、AWS等）的资源进行部署，又想有可视化的结果反馈，可以直接编写 Terraform 的模板来声明各个云上资源，并使用 ROS 的 Terraform 托管功能来进行部署。</p><p> <strong><img src="https://img-blog.csdnimg.cn/img_convert/e961a4ee3bc4582eb6dd00476c896e80.png"> Terraofrm 托管总结</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/ca11506c44b156269ba51e99f688de95.png"></p><p>Terraform 托管功能能让用户在云上直接使用 Terraform，和直接使用 ROS 模板部署有一致的控制台体验，且兼容了 ROS 原生的API，同时兼备了统一的身份认证和权限控制。相比于本地使用 Terraform，不再需要管理多种 Provider 和多个 Terraform CLI版本。</p><p><strong>新模式二：ROS CDK</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/8b8488afd1dc0fa0018d4beb74361a98.png"></p><p>现有资源定义方式的不足</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e0a8043d524e99c41110ddd35e69cd3b.png"></p><p>事实上，通过直接编写 ROS 模板，或者通过可视化编辑器生成模板，然后进行资源部署的方式是能够大大提升资源的部署效率的，但是也有一些不足之处：</p><p>• 缺少对过程式的支持</p><p>• 复杂场景的编写效率较低</p><p>• 对程序的友好性较低</p><p>• 动态性支持较差</p><p>针对这些问题，是否可以更进一步，在模板之上解决这些不足呢？</p><p> <strong><img src="https://img-blog.csdnimg.cn/img_convert/999d4c3c955c789527cdc10294611ca2.png"> ROS CDK 是什么</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/8b24a382fda35494e2fef14ed9cf4454.png"></p><p>ROS CDK 是资源编排（ROS）提供的一种命令行工具和多语言SDK，利用面向对象的高级抽象模式对云资源进行标准定义，从而快速构建云资源。</p><p>ROS CDK 以应用作为资源管理的入口，一个应用管理多个资源栈，而每个资源栈中则可以有多个构件。构件可以理解为云上资源的组件，能包含一个或多个资源。</p><p>我们可以选择自己熟悉的编程语言（TypeScript/JavaScript/Java/Python/C#）编写应用代码声明想要部署的资源，ROS CDK 会将项目代码转换成 ROS 模板，然后使用该模板进行自动化部署。</p><p> <strong><img src="https://img-blog.csdnimg.cn/img_convert/1a673c55b4faed9d2766520819c42994.png"> 使用步骤和项目生命周期</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/51ef8420238d988a392751231fd1c8e9.png"></p><p>ROS CDK 的使用步骤也很简单：</p><p>1. 首先，就是初始化项目，配置阿里云的访问凭证（AccessKey）</p><p>2. 其次，就是编写资源代码和测试用例进行本地测试</p><p>3. 最后，通过CDK CLI或者直接程序进行资源部署，并管理资源栈</p><p>在进行部署的阶段，CDK会根据用户编写的资源代码进行构造，实例化出各种资源对象；然后在准备阶段做终态前的调整（通常由框架自动完成）；进而验证各种资源属性，确保能够正确部署；最终合成出一个 ROS 模板，并使用该模板部署为资源栈。</p><p> <strong><img src="https://img-blog.csdnimg.cn/img_convert/8b263adbeff900ebd508a06ae6b62a03.png"> 代码、模板示例</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/2fcc1dca6a8b2b40013a900e91a0613d.png"></p><p>上图中，左边是 ROS CDK的资源代码，其中声明了一个 VPC，并使用循环动态生成3个 VSwitch。而右边则是由 ROS CDK 生成的 ROS 模板。由此可以看出针对动态生成的场景，ROS CDK 可以大大简化模板编写的复杂度。</p><p> <strong><img src="https://img-blog.csdnimg.cn/img_convert/43a6ae4020d382aeb6b588a46daf5dc4.png"> 应用程序集成CDK实现持续部署场景</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/79917e2930ff3965e3005a46c6629938.png"></p><p>假设我们需要实现一个CI/CD系统，能够部署这样的资源架构：使用API网关中提供API，使用函数计算的函数提供业务逻辑，要分别部署测试、预发、线上环境的资源，并且支持从测试发布到预发，从预发部署到线上。</p><p>针对这样的资源架构，在直接使用 ROS 模板的方式中，需要分别为三个环境准备三个模板，而环境间的部署则还需要动态拼接模板，对应用程序来说并不友好。这里就建议使用ROS CDK，这样应用程序可以根据环境的不同指定对应的变量，生产对应的资源，从而满足环境的动态性部署。</p><p> <strong><img src="https://img-blog.csdnimg.cn/img_convert/c14256d12bb210176c8d641ceedded8b.png"> ROS CDK 总结</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/e04fd164b14ab98cf4009335a379b47b.png"></p><p>相较于直接使用 ROS 模板部署，使用 ROS CDK 允许开发者选择自己熟悉的编程语言，并能借助其动态特性来实现复杂的编排效果。ROS CDK 能够非常容易地集成到应用程序中，从而能够方便地在程序中进行资源部署。</p><p><strong>总结</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/a3f31815d8657df380b9e7a311e445ae.png"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/98abf46ef0f4214e97696676528d1f32.png"></p><p>企业上云规模逐渐增大，企业云上资源的部署方式从人工开始走向自动，从单云走向多云，从<a href="https://so.csdn.net/so/search?q=%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C&spm=1001.2101.3001.7020">原子操作</a>走向模板部署。随着基础设施即代码的理念而兴起，资源的部署模式也因场景的不同而不同，总体来说有以下四个部署模式的建议：</p><p>1. 作为入门级用户，只需管理有限几个资源，直接使用控制台的方式是最为简单直观的；</p><p>2. 作为企业IT管理员，需管理规模较大的云上资源，使用 ROS 模板管理基础设施会是最有效率的选择；</p><p>3. 作为运维研发人员，需要在业务系统中实现资源部署逻辑，那么 ROS CDK 会是最佳选择；</p><p>4. 作为多云管理员，需可视化管理阿里云、AWS、Azure等多种云的资源，使用 ROS Terraform 托管功能是不二之选。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;从原子操作走向模板部署，详解云上资源自动化部署新模式&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/bjchenxu/article/details/117794680&quot;&gt;https://blog.csdn.net/bjche</summary>
      
    
    
    
    <category term="SRE" scheme="http://zhangyu.info/categories/SRE/"/>
    
    
    <category term="SRE" scheme="http://zhangyu.info/tags/SRE/"/>
    
  </entry>
  
  <entry>
    <title>开启shareProcessNamespace后容器异常</title>
    <link href="http://zhangyu.info/2021/05/31/cotainer-init/"/>
    <id>http://zhangyu.info/2021/05/31/cotainer-init/</id>
    <published>2021-05-30T16:00:00.000Z</published>
    <updated>2021-05-31T12:41:15.290Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://qingwave.github.io/cotainer-init/">https://qingwave.github.io/cotainer-init/</a></p><blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>目前k8s不支持容器启动顺序，部分业务通过开启<code>shareProcessNamespace</code>监控某些进程状态。当开启共享pid后，有用户反馈某个容器主进程退出，但是容器并没有重启，执行<code>exec</code>会卡住，现象参考<a href="https://qingwave.github.io/cotainer-init/3">issue</a></p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a><a href="https://qingwave.github.io/cotainer-init/#%E5%A4%8D%E7%8E%B0" title="复现"></a>复现</h2><ol><li> 创建deployment</li></ol><ul><li><p>apiVersion: apps/v1<br>  kind: Deployment<br>  metadata:<br>   labels:<br>   app: nginx<br>   name: nginx<br>  spec:<br>   selector:<br>   matchLabels:<br>   app: nginx<br>   template:<br>   metadata:<br>   labels:<br>   app: nginx<br>   name: nginx<br>   spec:<br>   shareProcessNamespace: true<br>   containers:  </p><ul><li>image: nginx:alpine<br>name: nginx  </li></ul></li><li><p>查看进程信息<br>  由于开启了<code>shareProcessNamespace</code>, <code>pause</code>变为<code>pid 1</code>, <code>nginx daemon</code>pid为<code>6</code>, ppid为<code>containerd-shim</code></p></li><li><p># 查看容器内进程<br>  / # ps -efo “pid,ppid,comm,args”<br>  PID   PPID  COMMAND          COMMAND<br>   1     0 pause            /pause<br>   6     0 nginx            nginx: master process nginx -g daemon off;<br>   11     6 nginx            nginx: worker process<br>   12     6 nginx            nginx: worker process<br>   13     6 nginx            nginx: worker process<br>   14     6 nginx            nginx: worker process<br>   15     0 sh               sh<br>   47    15 ps               ps -efo pid,ppid,comm,args  </p></li><li><p>删除主进程<br>  子进程被<code>pid 1</code>回收, 有时也会被<code>containerd-shim</code>回收</p></li></ul><ol><li><p>/ # kill -9 6<br> / #<br> / # ps -efo “pid,ppid,comm,args”<br> PID   PPID  COMMAND          COMMAND<br>  1     0 pause            /pause<br>  11     1 nginx            nginx: worker process<br>  12     1 nginx            nginx: worker process<br>  13     1 nginx            nginx: worker process<br>  14     1 nginx            nginx: worker process<br>  15     0 sh               sh<br>  48    15 ps               ps -efo pid,ppid,comm,args  </p></li><li><p>docker hang<br> 此时对此容器执行docker命令(<code>inspect, logs, exec</code>)将卡住， 同样通过<code>kubectl</code>执行会超时。</p></li></ol><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a><a href="https://qingwave.github.io/cotainer-init/#%E5%88%86%E6%9E%90" title="分析"></a>分析</h2><p>在未开启<code>shareProcessNamespace</code>的容器中，主进程退出<code>pid 1</code>, 此pid namespace销毁，系统会<code>kill</code>其下的所有进程。开启后，<code>pid 1</code>为<code>pause</code>进程，容器主进程退出，由于共享pid namespace，其他进程没有退出变成孤儿进程。此时调用docker相关接口去操作容器，docker首先去找主进程，但主进程已经不存在了，导致异常(待确认)。</p><p>清理掉这些孤儿进程容器便会正常退出，可以<code>kill</code>掉这些进程或者<code>kill</code>pause进程，即可恢复。</p><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a><a href="https://qingwave.github.io/cotainer-init/#%E6%96%B9%E6%A1%88" title="方案"></a>方案</h2><p>有没有优雅的方式解决此种问题，如果主进程退出子进程也一起退出便符合预期，这就需要进程管理工具来实现，在宿主机中有<code>systemd</code>、<code>god</code>，容器中也有类似的工具即<code>init进程</code>(传递信息，回收子进程)，常见的有</p><ol><li> <code>docker init</code>, docker自带的init进程(即<code>tini</code>)</li><li> <a href="https://github.com/krallin/tini"><code>tini</code></a>, 可回收孤儿进程/僵尸进程，<code>kill</code>进程组等</li><li> <a href="https://github.com/Yelp/dumb-init"><code>dumb-init</code></a>, 可管理进程，重写信号等</li></ol><p>经过测试，<code>tini</code>进程只能回收前台程序，对于后台程序则无能为力(例如<code>nohup</code>, <code>&amp;</code>启动的程序)，<code>dumb-init</code>在主进程退出时，会传递信号给子进程，符合预期。</p><p>开启<code>dumb-init</code>进程的<code>dockerfile</code>如下，<code>tini</code>也类似  </p><p>FROM nginx:alpine  </p><p># tini<br># RUN apk add –no-cache tini<br># ENTRYPOINT [“/sbin/tini”, “-s”, “-g”, “–”]  </p><p># dumb-init<br>RUN wget -O /usr/bin/dumb-init <a href="https://github.com/Yelp/dumb-init/releases/download/v1.2.2/dumb-init/_1.2.2/_amd64">https://github.com/Yelp/dumb-init/releases/download/v1.2.2/dumb-init\_1.2.2\_amd64</a><br>RUN chmod +x /usr/bin/dumb-init<br>ENTRYPOINT [“/usr/bin/dumb-init”, “-v”, “–”]  </p><p>CMD [“nginx”, “-g”, “daemon off;”]  </p><p>init方式对于此问题是一种临时的解决方案，需要docker从根本上解决此种情况。容器推荐单进程运行，但某些情况必须要运行多进程，如果不想处理处理传递回收进程等，可以通过<code>init</code>进程，无需更改代码即可实现。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><a href="https://qingwave.github.io/cotainer-init/#%E5%8F%82%E8%80%83" title="参考"></a>参考</h2><p>[1] <a href="https://github.com/Yelp/dumb-init">https://github.com/Yelp/dumb-init</a><br>[2] <a href="https://github.com/krallin/tini">https://github.com/krallin/tini</a><br>[3] <a href="https://github.com/kubernetes/kubernetes/issues/92214">https://github.com/kubernetes/kubernetes/issues/92214</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://qingwave.github.io/cotainer-init/&quot;&gt;https://qingwave.github.io/cotainer-init/&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="Kubernetes" scheme="http://zhangyu.info/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="http://zhangyu.info/tags/Kubernetes/"/>
    
  </entry>
  
</feed>
