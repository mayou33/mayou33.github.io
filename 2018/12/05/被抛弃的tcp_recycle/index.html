<!doctype html>
<html lang="zh-CN">
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta content="yes" name="apple-mobile-web-app-capable">
  <meta content="black" name="apple-mobile-web-app-status-bar-style">
  <meta content="telephone=no" name="format-detection">
  <meta name="keywords" content="undefined">
  <meta name="description" content="互联网技术">
  <meta name="author" content="zhangyu">

  
  <title>被抛弃的tcp_recycle</title>
  

  <link rel="canonical" href="http://zhangyu8.me/2018/12/05/被抛弃的tcp_recycle/index.html">
  <link rel="shortcut icon" href="/img/favicon.ico">
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="undefined">
  <link rel="stylesheet" href="/font.css">
</head>


  <body>
    <aside class="aside">
  <nav class="aside-menu">
    <ul class="aside-list">
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-wendang"></i><a href="/index.html" class="aside-menu-link" title="首页">首页</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-wendang1"></i><a href="/archives/index.html" class="aside-menu-link" title="所有文章">所有文章</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-biaoqian1"></i><a href="/tags/index.html" class="aside-menu-link" title="分类标签">分类标签</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-lianjie"></i><a href="/links/index.html" class="aside-menu-link" title="友情链接">友情链接</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-guanyu"></i><a href="/about/index.html" class="aside-menu-link" title="关于">关于</a></li>
        
      
    </ul>
  </nav>

  <article class="aside-show">
    
    <div class="aside-show-wrapper">
      <figure class="aside-avatar">
        <img src="/img/avatar.png" alt="avatar" class="aside-avatar-img">
        <figcaption class="aside-avatar-caption">
          大雨哥
          
          <strong class="aside-avatar-STRONG">个人博客</strong>
          
        </figcaption>
      </figure>
      <p class="aside-show-description">互联网技术/架构/团队</p>
    </div>
  </article>
</aside>


    <article class="main" id="main">
      <article class="post min-height">
  
  <header class="post-header">
    
    <h1 class="post-title">被抛弃的tcp_recycle</h1>
    <p class="post-meta">
      <span class="post-time">2018-12-05</span>
      
      <a href="/categories/内核/" title="内核" class="post-categories">内核</a>
      
      
      <a href="/tags/内核/" " title="内核" class="post-tags"><i class="post-tags-icon iconfont icon-biaoqian"></i>内核</a>
      
    </p>
    
  </header>
  <div class="post-content"><p>原创： SRE 小米运维<br><a href="https://mp.weixin.qq.com/s/uwykopNnkcRL5JXTVufyBw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/uwykopNnkcRL5JXTVufyBw</a></p>
<p> 1</p>
<p> 背景</p>
<p> 最近准备搭建一个新的kubernetes集群，将内核从3.18更新到了4.14版本，并执行一些常规的优化操作。在执行sysctl -p操作时突然报错如下：</p>
<pre><code>sysctl: cannot stat /proc/sys/net/ipv4/tcp_tw_recycle: No such file or directory
</code></pre><p> 2</p>
<p> 问题原因</p>
<p> Linux 从4.12内核版本开始移除了 tcp_tw_recycle 配置。</p>
<p> 参考：[1]_tcp:remove tcp_tw_recycle 4396e460_</p>
<p> 移除sysctl.conf中关于net.ipv4.tcp_tw_recycle的配置内容，再次尝试sysctl -p就不再提示报错了。</p>
<p> 3</p>
<p> 深入解析</p>
<p> tcp_tw_recycle通常会和tcp_tw_reuse参数一起使用，用于解决服务器TIME_WAIT状态连接过多的问题。</p>
<p> 3.1</p>
<p> <strong>TIME_WAIT状态出现原因与查看</strong></p>
<p> 让我们回顾一下四次挥手的流程：</p>
<p> <img src="http://img01.store.sogou.com/net/a/04/link?appid=100520029&amp;url=https://mmbiz.qpic.cn/mmbiz_jpg/Re4KW51oYRqZFnOjFRDiaOHz3WztCtNDncIialDaHtqKfRIy8I2KibjuZMwT6SKr13T2QIGpbCQ78rIK9LaooJiagw/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt></p>
<p> TIME_WAIT永远是出现在主动发送断开连接请求的一方(下文中我们称之为客户)，划重点：这一点面试的时候经常会被问到。  </p>
<p> 客户在收到服务器端发送的FIN(表示”我们也要断开连接了”)后发送ACK报文，并且进入TIME_WAIT状态，等待2MSL(MaximumSegmentLifetime 最大报文生存时间)。对于Linux，字段为TCP_TIMEWAIT_LEN硬编码为30秒，对于windows为2分钟(可自行调整)。</p>
<p> 为什么客户端不直接进入CLOSED状态，而是要在TIME_WAIT等待那么久呢，基于如下考虑：</p>
<p> 1.确保远程端处于关闭状态。也就是说需要确保客户端发出的最后一个ACK报文能够到达服务器。由于网络不可靠，有可能最后一个ACK报文丢失，如果服务器没有收到客户端的ACK，则会重新发送FIN报文，客户端就可以在2MSL时间段内收到这个这个重发的报文，并且重发ACK报文。但如果客户端跳过TIME_WAIT阶段进入了CLOSED，服务端始终无法得到响应，就会处于LAST-ACK状态，此时假如客户端发起了一个新连接，则会以失败告终。</p>
<p> 异常流程如下：</p>
<p> <img src="http://img01.store.sogou.com/net/a/04/link?appid=100520029&amp;url=https://mmbiz.qpic.cn/mmbiz_png/Re4KW51oYRqZFnOjFRDiaOHz3WztCtNDnektVT22fqXfgIXK9H6ZJpyC3gHGG2RTd98JLefRCicRX4Ucb5n8YAFQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt></p>
<p> 2.防止上一次连接中的包，迷路后重新出现，影响新连接(经过2MSL,上一次连接中所有的重复包都会消失)，这一点和为啥要执行三次握手而不是两次的原因是一样的。</p>
<p> 异常流程如下：</p>
<p> <img src="http://img01.store.sogou.com/net/a/04/link?appid=100520029&amp;url=https://mmbiz.qpic.cn/mmbiz_png/Re4KW51oYRqZFnOjFRDiaOHz3WztCtNDn06zNjGmAGkn2S1HS3iabJVy8gZGu6gMogsh83KnN1vjmWwvF7rEI0oA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt></p>
<p> 查看方式有两种：</p>
<p> （1）ss -tan state time-wait|wc -l</p>
<p> （2）netstat -n | awk ‘/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}’</p>
<p> 3.2</p>
<p> <strong>TIME_WAIT的危害</strong></p>
<p> 对于一个处理大量连接的处理器TIME_WAIT是有危害的，表现如下：  </p>
<p> 1.占用连接资源</p>
<p> TIME_WAIT占用的1分钟时间内，相同四元组(源地址，源端口，目标地址，目标端口)的连接无法创建，通常一个ip可以开启的端口为net.ipv4.ip_local_port_range指定的32768-61000，如果TIME_WAIT状态过多，会导致无法创建新连接。</p>
<p> 2.占用内存资源</p>
<p> 这个占用资源并不是很多，可以不用担心。</p>
<p> 3.3</p>
<p> <strong>TIME_WAIT的解决</strong></p>
<p> 可以考虑如下方式：  </p>
<p> 1.修改为长连接，代价较大，长连接对服务器性能有影响。</p>
<p> 2.增加可用端口范围(修改net.ipv4.ip_local_port_range); 增加服务端口，比如采用80，81等多个端口提供服务; 增加客户端ip(适用于负载均衡，比如nginx，采用多个ip连接后端服务器); 增加服务端ip; 这些方式治标不治本，只能缓解问题。</p>
<p> 3.将net.ipv4.tcp_max_tw_buckets设置为很小的值(默认是18000). 当TIME_WAIT连接数量达到给定的值时，所有的TIME_WAIT连接会被立刻清除，并打印警告信息。但这种粗暴的清理掉所有的连接，意味着有些连接并没有成功等待2MSL，就会造成通讯异常。</p>
<p> 4.修改TCP_TIMEWAIT_LEN值，减少等待时间，但这个需要修改内核并重新编译。</p>
<p> 5.打开tcp_tw_recycle和tcp_timestamps选项。</p>
<p> 6.打开tcp_tw_reuse和tcp_timestamps选项。</p>
<p> 3.4</p>
<p> <strong>net.ipv4.tcp_tw_{reuse,recycle}</strong></p>
<p> 需要明确两个点：  </p>
<p> 解决方式已经给出，那我们需要了解一下net.ipv4.tcp_tw_reuse和net.ipv4.tcp_tw_recycle有啥区别</p>
<p> 1.两个选项都需要打开对TCP时间戳的支持，即net.ipv4.tcp_timestamps=1(默认即为1)。</p>
<p> RFC 1323中实现了TCP拓展规范，以便保证网络繁忙的情况下的高可用。并定义了一个新的TCP选项-两个四字节的timestamp字段，第一个是TCP发送方的当前时钟时间戳，第二个是从远程主机接收到的最新时间戳。</p>
<p> 2.两个选项默认都是关闭状态，即等于0。</p>
<p> 3.4.1 - net.ipv4.tcp_tw_reuse：更安全的设置</p>
<p> 将处于TIME_WAIT状态的socket用于新的TCP连接，影响连出的连接。</p>
<p> [2]<em>kernel sysctl 官方指南</em>中是这么写的：</p>
<p> Allow to reuse TIME-WAIT sockets for new connections when it is safe from protocol viewpoint. Default value is 0.</p>
<p> It should not be changed without advice/request of technical experts.</p>
<p> 协议安全主要指的是两点：</p>
<p> 1.只适用于客户端(连接发起方)</p>
<p> <strong>net/ipv4/inet_hashtables.c</strong></p>
<pre><code>static int __inet_check_established(struct inet_timewait_death_row *death_row,
                    struct sock *sk, __u16 lport,
                    struct inet_timewait_sock **twp){    /* ……省略…… */
    sk_nulls_for_each(sk2, node, &amp;head-chain) {            if (sk2-sk_hash != hash)                        continue;                                    if (likely(INET_MATCH(sk2, net, acookie,
                    saddr, daddr, ports, dif))) {                        if (sk2-sk_state == TCP_TIME_WAIT) {
                            tw = inet_twsk(sk2);                            if (twsk_unique(sk, sk2, twp))                                break;
            }
            goto not_unique;
        }
    }    /* ……省略…… */}
</code></pre><p> 2.TIME_WAIT创建时间超过1秒才可以被复用</p>
<p> <strong>net/ipv4/tcp_ipv4.c</strong></p>
<pre><code>int tcp_twsk_unique(struct sock *sk, struct sock *sktw, void *twp){    /* ……省略…… */
    if (tcptw-tw_ts_recent_stamp &amp;&amp;
        (!twp || (sock_net(sk)-ipv4.sysctl_tcp_tw_reuse &amp;&amp;
         get_seconds() - tcptw-tw_ts_recent_stamp  1))) {         /* ……省略…… */
         return 1;    }    return 0;
}
</code></pre><p> 满足以上两个条件才会被认为是”safe from protocol viewpoint”的状况。启用net.ipv4.tcp_tw_reuse后，如果新的时间戳比之前存储的时间戳更大，那么Linux将会从TIME-WAIT状态的存活连接中选取一个，重新分配给新的连接出去的的TCP连接，这种情况下，TIME-WAIT的连接相当于只需要1秒就可以被复用了。</p>
<p> 重新回顾为什么要引入TIME-WAIT：</p>
<p> 第一个作用就是避免新连接接收到重复的数据包，由于使用了时间戳，重复的数据包会因为时间戳过期被丢弃。</p>
<p> 第二个作用是确保远端不是处于LAST-ACK状态，如果ACK包丢失，远端没有成功获取到最后一个ACK包，则会重发FIN包。直到：</p>
<p> 1.放弃(连接断开)</p>
<p> 2.收到ACK包</p>
<p> 3.收到RST包</p>
<p> 如果FIN包被及时接收到，并且本地端仍然是TIME-WAIT状态，那ACK包会被发送，此时就是正常的四次挥手流程。</p>
<p> 如果TIME-WAIT的条目已经被新连接所复用，则新连接的SYN包会被忽略掉，并且会收到FIN包的重传，本地会回复一个RST包(因为此时本地连接为SYN-SENT状态)，这会让远程端跳出LAST-ACK状态，最初的SYN包也会在1秒后重新发送，然后完成连接的建立，整个过程不会中断，只是有轻微的延迟。流程如下:</p>
<p> <img src="http://img01.store.sogou.com/net/a/04/link?appid=100520029&amp;url=https://mmbiz.qpic.cn/mmbiz_png/Re4KW51oYRqZFnOjFRDiaOHz3WztCtNDnXqUciblrAiaWZeVicfHRNNGJ5cW2YnP9GFxH1vFPjl0PUu6YhJcG2mpmg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt></p>
<p> 需要注意，连接被复用后，TWrecycled计数器会增加(/proc/net/netstat中TWrecycled值)</p>
<p> 3.4.2 - net.ipv4.tcp_tw_recycle：更激进的设置</p>
<p> 启用TIME_WAIT 状态的sockets的快速回收，影响所有连入和连出的连接</p>
<p> [3]_kernel sysctl 官方指南 _是这么写的</p>
<p> Enable fast recycling TIME-WAIT sockets. Default value is 0. It should not be changed without advice/request of technical experts.</p>
<p> 这次表述的更加模糊，继续翻看源码：</p>
<p> <strong>net/ipv4/tcp_input.c</strong></p>
<p> int tcp_conn_request(struct request_sock_ops <em>rsk_ops,<br>             const struct tcp_request_sock_ops </em>af_ops,<br>             struct sock *sk, struct sk_buff *skb)<br> {<br>   /* ……省略…… <em>/  if (!want_cookie &amp;&amp; !isn) { /\</em> ……省略…… */<br>  if (net-ipv4.tcp_death_row.sysctl_tw_recycle) {<br>          bool strict;</p>
<p> dst = af_ops-route_req(sk, &amp;fl, req, &amp;strict); if (dst &amp;&amp; strict &amp;&amp;<br>               !tcp_peer_is_proven(req, dst, true,<br>                       tmp_opt.saw_tstamp)) {<br>               NET_INC_STATS(sock_net(sk), LINUX_MIB_PAWSPASSIVEREJECTED);<br>               goto drop_and_release;<br>        }<br>      }<br>  /* ……省略…… <em>/ isn = af_ops-init_seq(skb, &amp;tcp_rsk(req)-ts_off);<br>    }/\</em> ……省略…… */  </p>
<p> drop_and_release:<br>             dst_release(dst);<br>        drop_and_free:<br>             reqsk_free(req);<br>        drop:<br>             tcp_listendrop(sk);<br>             return  0;<br> }</p>
<p> 简单来说就是，Linux会丢弃所有来自远端的timestramp时间戳小于上次记录的时间戳(由同一个远端发送的)的任何数据包。也就是说要使用该选项，则必须保证数据包的时间戳是单调递增的。</p>
<p> 问题在于，此处的时间戳并不是我们通常意义上面的绝对时间，而是一个相对时间。很多情况下，我们是没法保证时间戳单调递增的，比如使用了nat，lvs等情况。</p>
<p> 而这也是很多优化文章中并没有提及的一点，大部分文章都是简单的推荐将net.ipv4.tcp_tw_recycle设置为1，却忽略了该选项的局限性，最终造成严重的后果(比如我们之前就遇到过部署在nat后端的业务网站有的用户访问没有问题，但有的用户就是打不开网页)。</p>
<p> 3.5</p>
<p> <strong>被抛弃的tcp_tw_recycle</strong></p>
<p> 如果说之前内核中tcp_tw_recycle仅仅不适用于nat和lvs环境，那么从4.10内核开始，官方修改了时间戳的生成机制。</p>
<p> 参考：[4] <em>tcp: randomize tcp timestamp offsets for each connection 95a22ca</em></p>
<p> 在这种情况下，无论任何时候，tcp_tw_recycle都不应该开启。故被抛弃也是理所应当的了。</p>
<p> 4</p>
<p> 总结</p>
<ul>
<li><p>tcp_tw_recycle 选项在4.10内核之前还只是不适用于NAT/LB的情况(其他情况下，我们也非常不推荐开启该选项)，但4.10内核后彻底没有了用武之地，并且在4.12内核中被移除.</p>
</li>
<li><p>tcp_tw_reuse 选项仍然可用。在服务器上面，启用该选项对于连入的TCP连接来说不起作用，但是对于客户端(比如服务器上面某个服务以客户端形式运行，比如nginx反向代理)等是一个可以考虑的方案。</p>
</li>
<li><p>修改TCP_TIMEWAIT_LEN是非常不建议的行为。</p>
</li>
</ul>
<p> 5<br> 参考链接</p>
<p> [1]<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=4396e46187ca5070219b81773c4e65088dac50cc" target="_blank" rel="noopener">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=4396e46187ca5070219b81773c4e65088dac50cc</a></p>
<p> [2]<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/networking/ip-sysctl.txt?h=v4.11#n648" target="_blank" rel="noopener">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/networking/ip-sysctl.txt?h=v4.11#n648</a></p>
<p> [3]<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/networking/ip-sysctl.txt?h=v4.11#n643" target="_blank" rel="noopener">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/networking/ip-sysctl.txt?h=v4.11#n643</a></p>
<p> [4]<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=95a22caee396cef0bb2ca8fafdd82966a49367bb" target="_blank" rel="noopener">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=95a22caee396cef0bb2ca8fafdd82966a49367bb</a>  </p>
<p> [5]Coping with the TCP TIME-WAIT state on busy Linux servers：<a href="https://vincent.bernat.ch/en/blog/2014-tcp-time-wait-state-linux" target="_blank" rel="noopener">https://vincent.bernat.ch/en/blog/2014-tcp-time-wait-state-linux</a></p>
<p> [6]net.ipv4.tcp_tw_recycle は廃止されました ― その危険性を理解する：<a href="https://qiita.com/tmshn/items/b49f1b51bfc472968b30" target="_blank" rel="noopener">https://qiita.com/tmshn/items/b49f1b51bfc472968b30</a></p>
<p> [7]tcp_tw_reuse、tcp_tw_recycle 使用场景及注意事项：<a href="https://www.cnblogs.com/lulu/p/4149312.html" target="_blank" rel="noopener">https://www.cnblogs.com/lulu/p/4149312.html</a></p>
</div>
    
      
      <div class="toc-wrapper">
        <div class="toc-scroll">
          <div class="toc-middle">
            
          </div>
        </div>
      </div>
    
  
</article>

      <footer class="footer">
  <p class="footer-text"></p>
</footer>

    </article>

    <script src="/js/to-top.js"></script>
    <script src="/js/search.js"></script>
  </body>
</html>
