<!doctype html>
<html lang="zh-CN">
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta content="yes" name="apple-mobile-web-app-capable">
  <meta content="black" name="apple-mobile-web-app-status-bar-style">
  <meta content="telephone=no" name="format-detection">
  <meta name="keywords" content="undefined">
  <meta name="description" content="互联网技术">
  <meta name="author" content="zhangyu">

  
  <title>彻底弄懂 HTTP 缓存机制 —— 基于缓存策略三要素分解法</title>
  

  <link rel="canonical" href="http://zhangyu8.me/2017/01/09/743/index.html">
  <link rel="shortcut icon" href="/img/favicon.ico">
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="undefined">
  <link rel="stylesheet" href="/font.css">
</head>


  <body>
    <aside class="aside">
  <nav class="aside-menu">
    <ul class="aside-list">
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-wendang"></i><a href="/index.html" class="aside-menu-link" title="首页">首页</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-wendang1"></i><a href="/archives/index.html" class="aside-menu-link" title="所有文章">所有文章</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-biaoqian1"></i><a href="/tags/index.html" class="aside-menu-link" title="分类标签">分类标签</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-lianjie"></i><a href="/links/index.html" class="aside-menu-link" title="友情链接">友情链接</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-guanyu"></i><a href="/about/index.html" class="aside-menu-link" title="关于">关于</a></li>
        
      
    </ul>
  </nav>

  <article class="aside-show">
    
      <form class="search-from" id="search-from">
  <input class="search-text" id="search-text" type="text" name="searchText" value autocomplete="off">
  <button class="search-btn" id="search-btn" type="button"><i class="search-btn-icon iconfont icon-sousuo-sousuo"></i></button>
</form>

      <article class="search-data" id="search-data">
  <button class="search-close" id="search-close"><i class="search-close-icon iconfont icon-houdongfangiconfont10"></i></button>

  <div class="search-wrapper" id="search-wrapper"></div>
</article>

    
    <div class="aside-show-wrapper">
      <figure class="aside-avatar">
        <img src="/img/avatar.png" alt="avatar" class="aside-avatar-img">
        <figcaption class="aside-avatar-caption">
          大雨哥
          
          <strong class="aside-avatar-STRONG">个人博客</strong>
          
        </figcaption>
      </figure>
      <p class="aside-show-description">互联网技术/架构/团队</p>
    </div>
  </article>
</aside>


    <article class="main" id="main">
      <article class="post min-height">
  
  <header class="post-header">
    
    <h1 class="post-title">彻底弄懂 HTTP 缓存机制 —— 基于缓存策略三要素分解法</h1>
    <p class="post-meta">
      <span class="post-time">2017-01-09</span>
      
      <a href="/categories/web/" title="web" class="post-categories">web</a>
      
      
      <a href="/tags/web/" " title="web" class="post-tags"><i class="post-tags-icon iconfont icon-biaoqian"></i>web</a>
      
    </p>
    
  </header>
  <div class="post-content"><div style="font: 14px/21px 微软雅黑; text-align: left; color: rgb(0, 0, 0); text-transform: none; text-indent: 0px; letter-spacing: normal; word-spacing: 0px; white-space: normal; font-size-adjust: none; font-stretch: normal; background-color: rgb(255, 255, 255); -webkit-text-stroke-width: 0px;"><br>    <a href="http://geek.csdn.net/news/detail/131318" target="_blank" rel="noopener"><span style="text-align: justify; color: rgb(51, 51, 51); font-family: &quot;microsoft yahei&quot;, arial; font-size: 14px; font-style: normal; font-weight: normal; background-color: rgb(247, 247, 247);">原文地址：</span></a><a href="https://mp.weixin.qq.com/s/qOMO0LIdA47j3RjhbCWUEQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/qOMO0LIdA47j3RjhbCWUEQ</a><span style="text-align: justify; color: rgb(51, 51, 51); font-family: &quot;microsoft yahei&quot;, arial; font-size: 14px; font-style: normal; font-weight: normal; background-color: rgb(247, 247, 247);"><span style="background-color: inherit;">&nbsp;</span></span><br></div>

<pre><code>**下面我贴出2道题，大家可以尝试解答下：**

以下为 **page.html** 内容：
</code></pre><pre class="prettyprint" style="margin: 0px 0px 10px; padding: 9.5px; border-radius: 0px; border: 1px solid rgba(128, 128, 128, 0.074509); border-image: none; text-align: justify; color: rgb(51, 51, 51); text-transform: none; line-height: 1.45; text-indent: 0px; letter-spacing: normal; overflow: auto; font-family: &quot;Source Code Pro&quot;, monospace; font-size: 13px; font-style: normal; font-weight: normal; word-spacing: 0px; display: block; -ms-word-break: break-all; -ms-word-wrap: break-word; box-sizing: border-box; orphans: 2; widows: 2; background-color: rgb(248, 249, 250); font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px;">
`<span class="hljs-doctype" style="color: rgb(102, 0, 102); box-sizing: border-box;">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag" style="color: rgb(0, 102, 102); box-sizing: border-box;">&lt;<span class="hljs-title" style="color: rgb(0, 0, 136); box-sizing: border-box;">html</span> <span class="hljs-attribute" style="color: rgb(102, 0, 102); box-sizing: border-box;">xmlns</span>=<span class="hljs-value" style="color: rgb(0, 136, 0); box-sizing: border-box;">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span>
<span class="hljs-tag" style="color: rgb(0, 102, 102); box-sizing: border-box;">&lt;<span class="hljs-title" style="color: rgb(0, 0, 136); box-sizing: border-box;">head</span>&gt;</span>
    <span class="hljs-tag" style="color: rgb(0, 102, 102); box-sizing: border-box;">&lt;<span class="hljs-title" style="color: rgb(0, 0, 136); box-sizing: border-box;">meta</span> <span class="hljs-attribute" style="color: rgb(102, 0, 102); box-sizing: border-box;">http-equiv</span>=<span class="hljs-value" style="color: rgb(0, 136, 0); box-sizing: border-box;">&quot;Content-Type&quot;</span> <span class="hljs-attribute" style="color: rgb(102, 0, 102); box-sizing: border-box;">content</span>=<span class="hljs-value" style="color: rgb(0, 136, 0); box-sizing: border-box;">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span>
    <span class="hljs-tag" style="color: rgb(0, 102, 102); box-sizing: border-box;">&lt;<span class="hljs-title" style="color: rgb(0, 0, 136); box-sizing: border-box;">title</span>&gt;</span>page页<span class="hljs-tag" style="color: rgb(0, 102, 102); box-sizing: border-box;">&lt;/<span class="hljs-title" style="color: rgb(0, 0, 136); box-sizing: border-box;">title</span>&gt;</span>
<span class="hljs-tag" style="color: rgb(0, 102, 102); box-sizing: border-box;">&lt;/<span class="hljs-title" style="color: rgb(0, 0, 136); box-sizing: border-box;">head</span>&gt;</span>
<span class="hljs-tag" style="color: rgb(0, 102, 102); box-sizing: border-box;">&lt;<span class="hljs-title" style="color: rgb(0, 0, 136); box-sizing: border-box;">body</span>&gt;</span>
    <span class="hljs-tag" style="color: rgb(0, 102, 102); box-sizing: border-box;">&lt;<span class="hljs-title" style="color: rgb(0, 0, 136); box-sizing: border-box;">img</span> <span class="hljs-attribute" style="color: rgb(102, 0, 102); box-sizing: border-box;">src</span>=<span class="hljs-value" style="color: rgb(0, 136, 0); box-sizing: border-box;">&quot;images/head.png&quot;</span> /&gt;</span>
    <span class="hljs-tag" style="color: rgb(0, 102, 102); box-sizing: border-box;">&lt;<span class="hljs-title" style="color: rgb(0, 0, 136); box-sizing: border-box;">a</span> <span class="hljs-attribute" style="color: rgb(102, 0, 102); box-sizing: border-box;">href</span>=<span class="hljs-value" style="color: rgb(0, 136, 0); box-sizing: border-box;">&quot;page.html&quot;</span>&gt;</span>重新访问page页<span class="hljs-tag" style="color: rgb(0, 102, 102); box-sizing: border-box;">&lt;/<span class="hljs-title" style="color: rgb(0, 0, 136); box-sizing: border-box;">a</span>&gt;</span>
<span class="hljs-tag" style="color: rgb(0, 102, 102); box-sizing: border-box;">&lt;/<span class="hljs-title" style="color: rgb(0, 0, 136); box-sizing: border-box;">body</span>&gt;</span>
<span class="hljs-tag" style="color: rgb(0, 102, 102); box-sizing: border-box;">&lt;/<span class="hljs-title" style="color: rgb(0, 0, 136); box-sizing: border-box;">html</span>&gt;</span>`</pre>

<pre><code>首次访问该页面，页面中 **head.png** 响应头信息如下：
</code></pre><pre class="prettyprint" style="margin: 0px 0px 10px; padding: 9.5px; border-radius: 0px; border: 1px solid rgba(128, 128, 128, 0.074509); border-image: none; text-align: justify; color: rgb(51, 51, 51); text-transform: none; line-height: 1.45; text-indent: 0px; letter-spacing: normal; overflow: auto; font-family: &quot;Source Code Pro&quot;, monospace; font-size: 13px; font-style: normal; font-weight: normal; word-spacing: 0px; display: block; -ms-word-break: break-all; -ms-word-wrap: break-word; box-sizing: border-box; orphans: 2; widows: 2; background-color: rgb(248, 249, 250); font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px;">
`HTTP/1.1 200 OK
Cache-Control: no-cache
Content-Type: image/png
Last-Modified: Tue, 08 Nov 2016 06:59:00 GMT
Accept-Ranges: bytes
Date: Thu, 10 Nov 2016 02:48:50 GMT
Content-Length: 3534`</pre>

<ul>
<li><p><strong>问题1</strong>：请问当点击&ldquo;重新访问 page 页&rdquo;链接重新加载该页面后， head.png 如何二次加载？</p>
</li>
<li><p><strong>问题2</strong>：如果将上述信息中的 Cache-Control 设置为 private，那么结果又会如何呢？</p>
<p>以上2道题，如果你能全部答对（哈哈，还请仔细确认下 why，以防歪打正着），那么恭喜你，你已对这些知识理解非常透彻了，我后面讲的内容你可以忽略，否则还请继续陪我往下唠唠吧！</p>
<p>首先回到开篇提到很多小伙伴（包括我）在解答 HTTP 缓存题目时栽跟头的问题，我觉得出现这种现象的根本原因在于我们吸收的知识还不够体系化，平时我们在学习这些知识时多半将其当作知识点来记，什么这个缓存头作什么、那个缓存头作什么用的，但实际中缓存头往往是多个之间相互配合协同工作的，有一套完整的工作体系。</p>
<p>今天我将按自己的理解，从系统体系化角度来讲讲 HTTP 缓存头是如何协同工作的（不正确的地方还请指正，但请不要喷我哦）：</p>
</li>
</ul>
<p>##<br>    HTTP 缓存体系</p>
<pre><code>首先我将 HTTP 缓存体系分为以下三个部分：

&amp;nbsp;

&amp;nbsp;

&amp;nbsp;
</code></pre><center style="color: rgb(51, 51, 51); text-transform: none; text-indent: 0px; letter-spacing: normal; font-family: &quot;microsoft yahei&quot;, arial; font-size: 16px; font-style: normal; font-weight: normal; word-spacing: 0px; white-space: normal; box-sizing: border-box; orphans: 2; widows: 2; background-color: rgb(255, 255, 255); font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px;"><br><br>    <img src="http://oa5504rxk.bkt.clouddn.com/week25_http/http/1.png" alt><br></center>

<pre><code>&amp;nbsp;

&amp;nbsp;

&amp;nbsp;
</code></pre><p>###<br>    1. 缓存存储策略</p>
<pre><code>用来确定 HTTP 响应内容是否可以被客户端缓存，以及可以被哪些客户端缓存。

**这个策略的作用只有一个，用于决定 HTTP 响应内容是否可缓存到客户端**

对于 Cache-Control 头里的 Public、Private、no-cache、max-age 、no-store 他们都是用来指明响应内容是否可以被客户端存储的，其中前4个都会缓存文件数据（关于 no-cache 应理解为&amp;ldquo;不建议使用本地缓存&amp;rdquo;，其仍然会缓存数据到本地），后者 no-store 则不会在客户端缓存任何响应数据。另关于 no-cache 和 max-age 有点特别，我认为它是一种混合体，下面我会讲到。

通过 Cache-Control：Public 设置我们可以将 HTTP 响应数据存储到本地，但此时并不意味着后续浏览器会直接从缓存中读取数据并使用，为啥？因为它无法确定本地缓存的数据是否可用（可能已经失效），还必须借助一套鉴别机制来确认才行， 这就是我们下面要讲到的&amp;ldquo;缓存过期策略&amp;rdquo;。
</code></pre><p>###<br>    2. 缓存过期策略</p>
<pre><code>客户端用来确认存储在本地的缓存数据是否已过期，进而决定是否要发请求到服务端获取数据

**这个策略的作用也只有一个，那就是决定客户端是否可直接从本地缓存数据中加载数据并展示（否则就发请求到服务端获取）**

刚上面我们已经阐述了数据缓存到了本地后还需要经过判断才能使用，那么浏览器通过什么条件来判断呢？ 答案是：Expires，Expires 指名了缓存数据有效的绝对时间，告诉客户端到了这个时间点（比照客户端时间点）后本地缓存就作废了，在这个时间点内客户端可以认为缓存数据有效，可直接从缓存中加载展示。

不过 HTTP 缓存头设计并没有想象的那么规矩，像上面提到的 Cache-Control（这个头是在HTTP1.1里加进来的）头里的 no-cache 和 max-age 就是特例，它们既包含缓存存储策略也包含缓存过期策略，以 max-age 为例，它实际上相当于：
</code></pre><pre class="prettyprint" style="margin: 0px 0px 10px; padding: 9.5px; border-radius: 0px; border: 1px solid rgba(128, 128, 128, 0.074509); border-image: none; text-align: justify; color: rgb(51, 51, 51); text-transform: none; line-height: 1.45; text-indent: 0px; letter-spacing: normal; overflow: auto; font-family: &quot;Source Code Pro&quot;, monospace; font-size: 13px; font-style: normal; font-weight: normal; word-spacing: 0px; display: block; -ms-word-break: break-all; -ms-word-wrap: break-word; box-sizing: border-box; orphans: 2; widows: 2; background-color: rgb(248, 249, 250); font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px;">
`Cache-Control：public/private（这里不太确定具体哪个）
Expires：当前客户端时间 + maxAge 。     `</pre>

<pre><code>而 Cache-Control：no-cache 和 Cache-Control：max-age=0 （单位是秒）相当

**这里需要注意的是：**
</code></pre><ol>
<li>Cache-Control 中指定的缓存过期策略优先级高于 Expires，当它们同时存在的时候，后者会被覆盖掉。</li>
<li>缓存数据标记为已过期只是告诉客户端不能再直接从本地读取缓存了，需要再发一次请求到服务器去确认，并不等同于本地缓存数据从此就没用了，有些情况下即使过期了还是会被再次用到，具体下面会讲到。</li>
</ol>
<p>###<br>    3. 缓存对比策略</p>
<pre><code>将缓存在客户端的数据标识发往服务端，服务端通过标识来判断客户端 缓存数据是否仍有效，进而决定是否要重发数据。

客户端检测到数据过期或浏览器刷新后，往往会重新发起一个 http 请求到服务器，服务器此时并不急于返回数据，而是看请求头有没有带标识（ If-Modified-Since、If-None-Match）过来，如果判断标识仍然有效，则返回304告诉客户端取本地缓存数据来用即可（这里要注意的是你必须要在首次响应时输出相应的头信息（Last-Modified、ETags）到客户端）。至此我们就明白了上面所说的本地缓存数据即使被认为过期，并不等于数据从此就没用了的道理了。

关于 Last-Modified，这个响应头使用要注意，可能会影响到缓存过期策略，具体原因，后面我会通过解答开篇提到的2道题来作说明。

**以上就是我所认识的缓存策略，下面我将缓存策略三要素和常用的几个缓存头（项）结合一起，让大家更清晰的认识到它们之间的关系：**

&amp;nbsp;

&amp;nbsp;

&amp;nbsp;
</code></pre><center style="color: rgb(51, 51, 51); text-transform: none; text-indent: 0px; letter-spacing: normal; font-family: &quot;microsoft yahei&quot;, arial; font-size: 16px; font-style: normal; font-weight: normal; word-spacing: 0px; white-space: normal; box-sizing: border-box; orphans: 2; widows: 2; background-color: rgb(255, 255, 255); font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px;"><br><br>    <img src="http://oa5504rxk.bkt.clouddn.com/week25_http/http/2.png" alt><br></center>

<pre><code>&amp;nbsp;

&amp;nbsp;

&amp;nbsp;

通过上图我可以清晰的看到各缓存项分别属于哪个缓存策略范畴，这其中有部分重叠，它表明这些缓存项具有多重缓存策略，所以实际在分析缓存头的时候，除了常规的头外，我们还需要将这些具有双重缓存策略的项分解开来。

最后我们回到最开始提到的2道题目，我们来一起分解下：

**第一道题：**
</code></pre><pre class="prettyprint" style="margin: 0px 0px 10px; padding: 9.5px; border-radius: 0px; border: 1px solid rgba(128, 128, 128, 0.074509); border-image: none; text-align: justify; color: rgb(51, 51, 51); text-transform: none; line-height: 1.45; text-indent: 0px; letter-spacing: normal; overflow: auto; font-family: &quot;Source Code Pro&quot;, monospace; font-size: 13px; font-style: normal; font-weight: normal; word-spacing: 0px; display: block; -ms-word-break: break-all; -ms-word-wrap: break-word; box-sizing: border-box; orphans: 2; widows: 2; background-color: rgb(248, 249, 250); font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px;">
`HTTP/1.1 200 OK
Cache-Control: no-cache
Content-Type: image/png
Last-Modified: Tue, 08 Nov 2016 06:59:00 GMT
Accept-Ranges: bytes
Date: Thu, 10 Nov 2016 02:48:50 GMT
Content-Length: 3534`</pre>

<pre><code>分析上述 HTTP 响应头发现有以下两项与缓存相关：
</code></pre><pre class="prettyprint" style="margin: 0px 0px 10px; padding: 9.5px; border-radius: 0px; border: 1px solid rgba(128, 128, 128, 0.074509); border-image: none; text-align: justify; color: rgb(51, 51, 51); text-transform: none; line-height: 1.45; text-indent: 0px; letter-spacing: normal; overflow: auto; font-family: &quot;Source Code Pro&quot;, monospace; font-size: 13px; font-style: normal; font-weight: normal; word-spacing: 0px; display: block; -ms-word-break: break-all; -ms-word-wrap: break-word; box-sizing: border-box; orphans: 2; widows: 2; background-color: rgb(248, 249, 250); font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px;">
`Cache-Control: no-cache 
Last-Modified: Tue, 08 Nov 2016 06:59:00 GMT`</pre>

<pre><code>我们上面讲到了 Cache-Control: no-cache 相当于 Cache-Control: max-age=0，且他们都是多重策略头，我们需将其分解：

Cache-Control: no-cache 等于 Cache-Control: max-age=0，

接着 Cache-Control: max-age=0 又可分解成：
</code></pre><pre class="prettyprint" style="margin: 0px 0px 10px; padding: 9.5px; border-radius: 0px; border: 1px solid rgba(128, 128, 128, 0.074509); border-image: none; text-align: justify; color: rgb(51, 51, 51); text-transform: none; line-height: 1.45; text-indent: 0px; letter-spacing: normal; overflow: auto; font-family: &quot;Source Code Pro&quot;, monospace; font-size: 13px; font-style: normal; font-weight: normal; word-spacing: 0px; display: block; -ms-word-break: break-all; -ms-word-wrap: break-word; box-sizing: border-box; orphans: 2; widows: 2; background-color: rgb(248, 249, 250); font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px;">
`Cache-Control: public/private （不确定是二者中的哪一个）
Expires: 当前时间`</pre>

<pre><code>**最终我们得到了以下完整的缓存策略三要素：**

&amp;nbsp;

&amp;nbsp;

&amp;nbsp;
</code></pre><center style="color: rgb(51, 51, 51); text-transform: none; text-indent: 0px; letter-spacing: normal; font-family: &quot;microsoft yahei&quot;, arial; font-size: 16px; font-style: normal; font-weight: normal; word-spacing: 0px; white-space: normal; box-sizing: border-box; orphans: 2; widows: 2; background-color: rgb(255, 255, 255); font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px;"><br><br>    <img src="http://oa5504rxk.bkt.clouddn.com/week25_http/http/3.png" alt><br></center>

<pre><code>&amp;nbsp;

&amp;nbsp;

&amp;nbsp;

所以最终结果是：浏览器会再次请求服务端，并携带上 Last-Modified 指定的时间去服务器对比：
</code></pre><ul>
<li><strong>对比失败</strong>：服务器返回200并重发数据，客户端接收到数据后展示，并刷新本地缓存。</li>
<li><p><strong>对比成功</strong>：服务器返回304且不重发数据，客户端收到304状态码后从本地读取缓存数据。以下为模拟此种情况下请求后的抓包情况：</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
</li>
</ul>
<center style="color: rgb(51, 51, 51); text-transform: none; text-indent: 0px; letter-spacing: normal; font-family: &quot;microsoft yahei&quot;, arial; font-size: 16px; font-style: normal; font-weight: normal; word-spacing: 0px; white-space: normal; box-sizing: border-box; orphans: 2; widows: 2; background-color: rgb(255, 255, 255); font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px;"><br><br>    <img src="http://oa5504rxk.bkt.clouddn.com/week25_http/http/4.png" alt><br></center>

<pre><code>&amp;nbsp;

&amp;nbsp;

&amp;nbsp;

这道题本身不难，但若认为 no-cache 不会缓存数据到本地，那么你理解起来就会很矛盾，因为如果文件数据没有被本地缓存，服务器返回304后将会无法展示出图片内容，但实际上它是能正常展示的。这道题很好的证明了 no-cache 也会缓存数据到本地这一说法。

**第二道题：**
</code></pre><pre class="prettyprint" style="margin: 0px 0px 10px; padding: 9.5px; border-radius: 0px; border: 1px solid rgba(128, 128, 128, 0.074509); border-image: none; text-align: justify; color: rgb(51, 51, 51); text-transform: none; line-height: 1.45; text-indent: 0px; letter-spacing: normal; overflow: auto; font-family: &quot;Source Code Pro&quot;, monospace; font-size: 13px; font-style: normal; font-weight: normal; word-spacing: 0px; display: block; -ms-word-break: break-all; -ms-word-wrap: break-word; box-sizing: border-box; orphans: 2; widows: 2; background-color: rgb(248, 249, 250); font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px;">
`HTTP/1.1 200 OK
Cache-Control: private
Content-Type: image/png
Last-Modified: Tue, 08 Nov 2016 06:59:00 GMT
Accept-Ranges: bytes
Date: Thu, 10 Nov 2016 02:48:50 GMT
Content-Length: 3534`</pre>

<pre><code>解题思路和上题一样，首先先找到缓存相关项：
</code></pre><pre class="prettyprint" style="margin: 0px 0px 10px; padding: 9.5px; border-radius: 0px; border: 1px solid rgba(128, 128, 128, 0.074509); border-image: none; text-align: justify; color: rgb(51, 51, 51); text-transform: none; line-height: 1.45; text-indent: 0px; letter-spacing: normal; overflow: auto; font-family: &quot;Source Code Pro&quot;, monospace; font-size: 13px; font-style: normal; font-weight: normal; word-spacing: 0px; display: block; -ms-word-break: break-all; -ms-word-wrap: break-word; box-sizing: border-box; orphans: 2; widows: 2; background-color: rgb(248, 249, 250); font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px;">
`Cache-Control: private     
Last-Modified: Tue, 08 Nov 2016 06:59:00 GMT`</pre>

<pre><code>这时我们会发现根本找不到缓存过期策略项，那答案会不会和上面一样？ 一时半会也分析不出答案，那只能实际测试下了：

&amp;nbsp;

&amp;nbsp;

&amp;nbsp;
</code></pre><center style="color: rgb(51, 51, 51); text-transform: none; text-indent: 0px; letter-spacing: normal; font-family: &quot;microsoft yahei&quot;, arial; font-size: 16px; font-style: normal; font-weight: normal; word-spacing: 0px; white-space: normal; box-sizing: border-box; orphans: 2; widows: 2; background-color: rgb(255, 255, 255); font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px;"><br><br>    <img src="http://oa5504rxk.bkt.clouddn.com/week25_http/http/5.png" alt><br></center>

<pre><code>&amp;nbsp;

&amp;nbsp;

&amp;nbsp;

再看看 Chrome 浏览器下抓包：

&amp;nbsp;

&amp;nbsp;

&amp;nbsp;
</code></pre><center style="color: rgb(51, 51, 51); text-transform: none; text-indent: 0px; letter-spacing: normal; font-family: &quot;microsoft yahei&quot;, arial; font-size: 16px; font-style: normal; font-weight: normal; word-spacing: 0px; white-space: normal; box-sizing: border-box; orphans: 2; widows: 2; background-color: rgb(255, 255, 255); font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px;"><br><br>    <img src="http://oa5504rxk.bkt.clouddn.com/week25_http/http/6.png" alt><br></center>

<pre><code>&amp;nbsp;

&amp;nbsp;

&amp;nbsp;

可以看到，浏览器后续请求都直接取的本地缓存，看来的确存在某种缓存过期策略（根据我上面的缓存过期策略理论，浏览器如果直接从本地加载缓存数据，说明它相信本地缓存数据有效，那一定存在某种缓存过期判断条件）。这个问题百思不得其解，困扰了我好久，直到一次偶然的机会我在 Fiddler 响应信息面板里的 Caching 选项卡中找到了答案：

&amp;nbsp;

&amp;nbsp;

&amp;nbsp;
</code></pre><center style="color: rgb(51, 51, 51); text-transform: none; text-indent: 0px; letter-spacing: normal; font-family: &quot;microsoft yahei&quot;, arial; font-size: 16px; font-style: normal; font-weight: normal; word-spacing: 0px; white-space: normal; box-sizing: border-box; orphans: 2; widows: 2; background-color: rgb(255, 255, 255); font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px;"><br><br>    <img src="http://oa5504rxk.bkt.clouddn.com/week25_http/http/7.png" alt><br></center>

<pre><code>&amp;nbsp;

&amp;nbsp;

&amp;nbsp;

原来，在没有提供任何浏览器缓存过期策略的情况下，浏览器遵循一个启发式缓存过期策略：

**根据响应头中2个时间字段 Date 和 Last-Modified 之间的时间差值，取其值的10%作为缓存时间周期。**

贴一下 Caching 面板里的描述，英语好的同学可以精准翻译下：
</code></pre><pre class="prettyprint" style="margin: 0px 0px 10px; padding: 9.5px; border-radius: 0px; border: 1px solid rgba(128, 128, 128, 0.074509); border-image: none; text-align: justify; color: rgb(51, 51, 51); text-transform: none; line-height: 1.45; text-indent: 0px; letter-spacing: normal; overflow: auto; font-family: &quot;Source Code Pro&quot;, monospace; font-size: 13px; font-style: normal; font-weight: normal; word-spacing: 0px; display: block; -ms-word-break: break-all; -ms-word-wrap: break-word; box-sizing: border-box; orphans: 2; widows: 2; background-color: rgb(248, 249, 250); font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px;">
`HTTP/<span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">1.1</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">Cache</span><span class="hljs-attribute" style="box-sizing: border-box;">-Control</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">Header</span> is present: <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span>
HTTP Last<span class="hljs-attribute" style="box-sizing: border-box;">-Modified</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">Header</span> is present: Tue, <span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">08</span> Nov <span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">2016</span> <span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">06</span>:<span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">59</span>:<span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">00</span> GMT
No explicit HTTP <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">Cache</span> Lifetime information was provided<span class="hljs-built_in" style="color: rgb(102, 0, 102); box-sizing: border-box;">.</span>
Heuristic expiration policies suggest defaulting <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">to</span>: <span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">10</span><span class="hljs-subst" style="color: rgb(0, 0, 0); box-sizing: border-box;">%</span> of the delta between Last<span class="hljs-attribute" style="box-sizing: border-box;">-Modified</span> <span class="hljs-literal" style="color: rgb(0, 102, 102); box-sizing: border-box;">and</span> <span class="hljs-built_in" style="color: rgb(102, 0, 102); box-sizing: border-box;">Date</span><span class="hljs-built_in" style="color: rgb(102, 0, 102); box-sizing: border-box;">.</span>
That<span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">&#39;s &#39;</span><span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">05</span>:<span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">15</span>:<span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">02</span><span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">&#39; so this response will heuristically expire 2016/11/11 0:46:01.</span>`</pre>

<pre><code>**最终我们得到了以下完整的缓存策略三要素：**

&amp;nbsp;

&amp;nbsp;

&amp;nbsp;
</code></pre><center style="color: rgb(51, 51, 51); text-transform: none; text-indent: 0px; letter-spacing: normal; font-family: &quot;microsoft yahei&quot;, arial; font-size: 16px; font-style: normal; font-weight: normal; word-spacing: 0px; white-space: normal; box-sizing: border-box; orphans: 2; widows: 2; background-color: rgb(255, 255, 255); font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px;"><br><br>    <img src="http://oa5504rxk.bkt.clouddn.com/week25_http/http/8.png" alt><br></center>

<pre><code>&amp;nbsp;

&amp;nbsp;

&amp;nbsp;
</code></pre><p>###<br>    最终结果</p>
<pre><code>&lt;span style=&quot;color: rgb(255, 0, 0);&quot;&gt;浏览器会根据 Date 和 Last-Modified 之间的时间差值缓存一段时间，这段时间内会直接使用本地缓存数据而不会再去请求服务器（强制请求除外），缓存过期后，会再次请求服务端，并携带上 Last-Modified 指定的时间去服务器对比并根据服务端的响应状态决定是否要从本地加载缓存数据。&lt;/span&gt;
</code></pre><p>##<br>    总结</p>
<pre><code>HTTP 缓存设置起来并不复杂，但却容易被轻视， 今天这篇文章结合2道题目，通过分析、解剖相关缓存头，从系统化角度对 HTTP 缓存机制做了一个较完整的剖析：HTTP 缓存机制实际上是 HTTP 缓存策略三个要素（纬度）相互作用的集合，所以在分析和设置 HTTP 报文缓存头时，只要能从中精准的分解出缓存三要素，我们就能非常准确的预判到缓存设置最终能达到的效果。
</code></pre></div>
    
      
      <div class="toc-wrapper">
        <div class="toc-scroll">
          <div class="toc-middle">
            
          </div>
        </div>
      </div>
    
  
</article>

      <footer class="footer">
  <p class="footer-text"></p>
</footer>

    </article>

    <script src="/js/to-top.js"></script>
    <script src="/js/search.js"></script>
  </body>
</html>
