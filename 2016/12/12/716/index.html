<!doctype html>
<html lang="zh-CN">
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta content="yes" name="apple-mobile-web-app-capable">
  <meta content="black" name="apple-mobile-web-app-status-bar-style">
  <meta content="telephone=no" name="format-detection">
  <meta name="keywords" content="undefined">
  <meta name="description" content="互联网技术">
  <meta name="author" content="zhangyu">

  
  <title>Linux-3.14.12内存管理笔记【SLUB分配算法（1）】</title>
  

  <link rel="canonical" href="http://zhangyu33.com/2016/12/12/716/index.html">
  <link rel="shortcut icon" href="/">
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="undefined">
  <link rel="stylesheet" href="/font.css">
</head>


  <body>
    <aside class="aside">
  <nav class="aside-menu">
    <ul class="aside-list">
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-wendang"></i><a href="/index.html" class="aside-menu-link" title="首页">首页</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-wendang1"></i><a href="/archives/index.html" class="aside-menu-link" title="所有文章">所有文章</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-biaoqian1"></i><a href="/tags/index.html" class="aside-menu-link" title="分类标签">分类标签</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-lianjie"></i><a href="/links/index.html" class="aside-menu-link" title="友情链接">友情链接</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-guanyu"></i><a href="/about/index.html" class="aside-menu-link" title="关于">关于</a></li>
        
      
    </ul>
  </nav>

  <article class="aside-show">
    
      <form class="search-from" id="search-from">
  <input class="search-text" id="search-text" type="text" name="searchText" value autocomplete="off">
  <button class="search-btn" id="search-btn" type="button"><i class="search-btn-icon iconfont icon-sousuo-sousuo"></i></button>
</form>

      <article class="search-data" id="search-data">
  <button class="search-close" id="search-close"><i class="search-close-icon iconfont icon-houdongfangiconfont10"></i></button>

  <div class="search-wrapper" id="search-wrapper"></div>
</article>

    
    <div class="aside-show-wrapper">
      <figure class="aside-avatar">
        <img src="/img/avatar.png" alt="avatar" class="aside-avatar-img">
        <figcaption class="aside-avatar-caption">
          大雨哥
          
          <strong class="aside-avatar-STRONG">个人博客</strong>
          
        </figcaption>
      </figure>
      <p class="aside-show-description">互联网技术/架构/团队</p>
    </div>
  </article>
</aside>


    <article class="main" id="main">
      <article class="post min-height">
  
  <header class="post-header">
    
    <h1 class="post-title">Linux-3.14.12内存管理笔记【SLUB分配算法（1）】</h1>
    <p class="post-meta">
      <span class="post-time">2016-12-12</span>
      
      <a href="/categories/Linux-3-14-12内存管理笔记/" title="Linux-3.14.12内存管理笔记" class="post-categories">Linux-3.14.12内存管理笔记</a>
      
      
      <a href="/tags/内核/" " title="内核" class="post-tags"><i class="post-tags-icon iconfont icon-biaoqian"></i>内核</a>
      
      <a href="/tags/内存/" " title="内存" class="post-tags"><i class="post-tags-icon iconfont icon-biaoqian"></i>内存</a>
      
    </p>
    
  </header>
  <div class="post-content"><p><a href="http://blog.chinaunix.net/uid-26859697-id-5472929.html" target="_blank" rel="noopener"><font color="#0066cc">http://blog.chinaunix.net/uid-26859697-id-5472929.html</font></a></p>
<pre><code>前面主要分析了以页为最小单位进行内存分配的伙伴管理算法，这对于内核对内存的管理比较简单，同时较大程度上避免了内存碎片的问题。而实际上对内存的申请却不是每次都申请一个页面的，通常是不规则的，大小不一的，并且远小于一个内存页面的大小，此外更可能会频繁地申请释放这些内存。

明显每次分配小于一个页面的都统一分配一个页面的空间是过于浪费且不切实际的，因此必须充分利用未被使用的空闲空间，同时也要避免过多地访问操作页面分配。基于该问题的考虑，内核需要一个缓冲池对小块内存进行有效的管理起来，于是就有了&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;slab&lt;/span&gt;内存分配算法。每次小块内存的分配优先来自于该内存分配器，小块内存的释放也是先缓存至该内存分配器，留作下次申请时进行分配，避免了频繁分配和释放小块内存所带来的额外负载。而这些被管理的小块内存在管理算法中被视之为&amp;ldquo;对象&amp;rdquo;。

Slab内存分配算法是最先出现的；后来被改进适用于嵌入式设备，以满足内存较少的情况下的使用，该改进后的算法占用资源极少，其被称之为&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;slob&lt;/span&gt;内存分配算法；再后来由于&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;slab&lt;/span&gt;内存分配算法的管理结构较大且设计复杂，再一次被改进简化，而该简化改进的算法称之为&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;slub&lt;/span&gt;内存分配算法。当前&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;linux&lt;/span&gt;内核中对该三种算法是都提供的，但是在编译内核的时候仅可以选择其一进行编译，鉴于&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;slub&lt;/span&gt;比&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;slab&lt;/span&gt;分配算法更为简洁和便于调试，在&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;linux 2.6.22&lt;/span&gt;版本中，&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;slub&lt;/span&gt;分配算法替代了&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;slab&lt;/span&gt;内存管理算法的代码。此外，虽然该三种算法的实现存在差异，但是其对外提供的&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;API&lt;/span&gt;接口都是一样的。

创建一个&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;slab&lt;/span&gt;的&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;API&lt;/span&gt;为：

struct kmem_cache *kmem_cache_create(const char *name, size_t size, size_t align,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp; unsigned long flags, void (*ctor)(void *))

_&amp;mdash;&amp;mdash;其中&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;name&lt;/span&gt;为&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;slab&lt;/span&gt;的名称，&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;size&lt;/span&gt;为&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;slab&lt;/span&gt;中每个对象的大小，&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;align&lt;/span&gt;为内存对齐基值，&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;flags&lt;/span&gt;为使用的标志，而&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;ctor&lt;/span&gt;为构造函数；_

销毁&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;slab&lt;/span&gt;的&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;API&lt;/span&gt;为：

void kmem_cache_destroy(struct kmem_cache *s)

从分配算法中分配一个对象：

void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)

将对象释放到分配算法中：

void kmem_cache_free(struct kmem_cache *cachep, void *objp)

除此之外，该分配算法还内建了一些&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;slab&lt;/span&gt;（&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;2^KMALLOC_SHIFT_LOW &amp;ndash; 2^KMALLOC_SHIFT_HIGH&lt;/span&gt;）用于不需要特殊处理的对象分配。除了上面列举的分配和释放对象的接口，实际上对用户可见的接口为&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;kmalloc&lt;/span&gt;及&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;kfree&lt;/span&gt;。鉴于&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;slub&lt;/span&gt;分配算法的优势，接下来则不对&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;slab&lt;/span&gt;进行深入分析，主要分析&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;slub&lt;/span&gt;分配算法。

首先鸟瞰全局，由下图进行入手分析&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;slub&lt;/span&gt;内存分配算法的管理框架：

&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;![](http://blog.chinaunix.net/attachment/201511/17/26859697_14477753059O4F.png)&lt;/span&gt;

&amp;nbsp;

沿用&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;slab&lt;/span&gt;算法对对象及对象缓冲区的称呼，一个&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;slab&lt;/span&gt;表示某个特定大小空间的缓冲片区，而片区里面的一个特定大小的空间则称之为对象。

Slub内存分配算法中，每种&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;slab&lt;/span&gt;的类型都是由&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;kmem_cache&lt;/span&gt;类型的数据结构来描述的。该结构的定义为：
</code></pre><div class="codeText" id="codeText" style="background: rgb(255, 255, 255); font: 12px/normal Consolas, monospace; margin: 0px 0px 1.1em; padding: 0px; border: 1px solid rgb(221, 221, 221); border-image: none; width: 1252.19px; text-align: left; color: rgb(102, 102, 102); text-transform: none; text-indent: 0px; letter-spacing: 0.1px; overflow: auto; word-spacing: 0px; white-space: normal; -ms-word-break: break-all; -ms-word-wrap: break-word; orphans: 2; widows: 2; font-size-adjust: none; font-stretch: normal; -webkit-text-stroke-width: 0px;"><br><br>1.  <span style="color: rgb(0, 0, 0); -ms-word-wrap: break-word;">【file<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">:</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span>include<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span>linux<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span>slub_def<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">.</span>h】</span><br>2.  <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span><br>3.  &nbsp;<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span> Slab cache management<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">.</span><br>4.  &nbsp;<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>5.  struct kmem_cache <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">{</span><br>6.  &nbsp;&nbsp;&nbsp;&nbsp;struct kmem_cache_cpu __percpu <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span>cpu_slab<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span>每CPU的结构，用于各个CPU的缓存管理<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>7.  &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span> Used <span style="color: rgb(0, 0, 255); -ms-word-wrap: break-word;">for</span> retriving partial slabs etc <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>8.  &nbsp;&nbsp;&nbsp;&nbsp;unsigned long flags<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span>描述标识，描述缓冲区属性的标识<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>9.  &nbsp;&nbsp;&nbsp;&nbsp;unsigned long min_partial<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>10.  &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 0, 0); -ms-word-wrap: break-word;">int</span> size<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span> The size of an object including meta data <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span>对象大小，包括元数据大小<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>11.  &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 0, 0); -ms-word-wrap: break-word;">int</span> object_size<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span> The size of an object without meta data <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span>slab对象纯大小<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>12.  &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 0, 0); -ms-word-wrap: break-word;">int</span> offset<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span> Free pointer offset<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">.</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span>空闲对象的指针偏移<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>13.  &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 0, 0); -ms-word-wrap: break-word;">int</span> cpu_partial<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span> Number of per cpu partial objects <span style="color: rgb(0, 0, 255); -ms-word-wrap: break-word;">to</span> keep around <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span>每CPU持有量<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>14.  &nbsp;&nbsp;&nbsp;&nbsp;struct kmem_cache_order_objects oo<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span>存放分配给slab的页框的阶数<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">(</span>高16位<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">)</span>和<br>15.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slab中的对象数量<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">(</span>低16位<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">)</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>16.  &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span> Allocation <span style="color: rgb(0, 0, 255); -ms-word-wrap: break-word;">and</span> freeing of slabs <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>17.  &nbsp;&nbsp;&nbsp;&nbsp;struct kmem_cache_order_objects max<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span><br>18.  &nbsp;&nbsp;&nbsp;&nbsp;struct kmem_cache_order_objects min<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span>存储单对象所需的页框阶数及该阶数下可容纳的对象数<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>19.  &nbsp;&nbsp;&nbsp;&nbsp;gfp_t allocflags<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span> gfp flags <span style="color: rgb(0, 0, 255); -ms-word-wrap: break-word;">to</span> use <span style="color: rgb(0, 0, 255); -ms-word-wrap: break-word;">on</span> <span style="color: rgb(0, 0, 255); -ms-word-wrap: break-word;">each</span> alloc <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span>申请页面时使用的GFP标识<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>20.  &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 0, 0); -ms-word-wrap: break-word;">int</span> refcount<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span> Refcount <span style="color: rgb(0, 0, 255); -ms-word-wrap: break-word;">for</span> slab cache destroy <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span>缓冲区计数器，当用户请求创建新的缓冲区时，SLUB分配器重用已创建的相似大小的缓冲区，从而减少缓冲区个数<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>21.  &nbsp;&nbsp;&nbsp;&nbsp;void <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">(</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span>ctor<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">)</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">(</span>void <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">)</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span>创建对象的回调函数<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>22.  &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 0, 0); -ms-word-wrap: break-word;">int</span> inuse<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span> Offset <span style="color: rgb(0, 0, 255); -ms-word-wrap: break-word;">to</span> metadata <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span>元数据偏移量<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>23.  &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 0, 0); -ms-word-wrap: break-word;">int</span> align<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span> Alignment <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span>对齐值<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>24.  &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 0, 0); -ms-word-wrap: break-word;">int</span> reserved<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span> Reserved bytes at the <span style="color: rgb(0, 0, 255); -ms-word-wrap: break-word;">end</span> of slabs <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>25.  &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(0, 0, 255); -ms-word-wrap: break-word;">const</span> char <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span>name<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span> Name <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">(</span>only <span style="color: rgb(0, 0, 255); -ms-word-wrap: break-word;">for</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span>slab缓存名称<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>26.  &nbsp;&nbsp;&nbsp;&nbsp;struct list_head list<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span> List of slab caches <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span>用于slab cache管理的链表<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>27.  #ifdef CONFIG_SYSFS<br>28.  &nbsp;&nbsp;&nbsp;&nbsp;struct kobject kobj<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span> <span style="color: rgb(0, 0, 255); -ms-word-wrap: break-word;">For</span> sysfs <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>29.  #endif<br>30.  #ifdef CONFIG_MEMCG_KMEM<br>31.  &nbsp;&nbsp;&nbsp;&nbsp;struct memcg_cache_params <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span>memcg_params<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span><br>32.  &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 0, 0); -ms-word-wrap: break-word;">int</span> max_attr_size<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span> <span style="color: rgb(0, 0, 255); -ms-word-wrap: break-word;">for</span> propagation<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">,</span> maximum size of a stored attr <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>33.  #endif<br>34.  &nbsp;<br>35.  #ifdef CONFIG_NUMA<br>36.  &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span><br>37.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span> Defragmentation by allocating from a remote node<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">.</span><br>38.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>39.  &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 0, 0); -ms-word-wrap: break-word;">int</span> remote_node_defrag_ratio<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span>远端节点的反碎片率，值越小则越倾向从本节点中分配对象<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>40.  #endif<br>41.  &nbsp;&nbsp;&nbsp;&nbsp;struct kmem_cache_node <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span>node<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">[</span>MAX_NUMNODES<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">]</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span>各个内存管理节点的slub信息<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>42.  <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">}</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span><br></div>

<pre><code>&amp;nbsp;

上面各个成员的意义，可以参考里面的注释，而这里主要关注的是&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;cpu_slab&lt;/span&gt;和&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;node&lt;/span&gt;成员。

其中&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;cpu_slab&lt;/span&gt;的结构类型是&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;kmem_cache_cpu&lt;/span&gt;，是每&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;CPU&lt;/span&gt;类型数据，各个&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;CPU&lt;/span&gt;都有自己独立的一个结构，用于管理本地的对象缓存。具体的结构定义如下：
</code></pre><div class="codeText" id="codeText" style="background: rgb(255, 255, 255); font: 12px/normal Consolas, monospace; margin: 0px 0px 1.1em; padding: 0px; border: 1px solid rgb(221, 221, 221); border-image: none; width: 1252.19px; text-align: left; color: rgb(102, 102, 102); text-transform: none; text-indent: 0px; letter-spacing: 0.1px; overflow: auto; word-spacing: 0px; white-space: normal; -ms-word-break: break-all; -ms-word-wrap: break-word; orphans: 2; widows: 2; font-size-adjust: none; font-stretch: normal; -webkit-text-stroke-width: 0px;"><br><br>1.  <span style="color: rgb(0, 0, 0); -ms-word-wrap: break-word;">【file<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">:</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span>include<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span>linux<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span>slub_def<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">.</span>h】</span><br>2.  struct kmem_cache_cpu <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">{</span><br>3.  &nbsp;&nbsp;&nbsp;&nbsp;void <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span>freelist<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span> Pointer <span style="color: rgb(0, 0, 255); -ms-word-wrap: break-word;">to</span> <span style="color: rgb(0, 0, 255); -ms-word-wrap: break-word;">next</span> available object <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span> 空闲对象队列的指针 <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>4.  &nbsp;&nbsp;&nbsp;&nbsp;unsigned long tid<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span> Globally unique transaction id <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span> 用于保证cmpxchg_double计算发生在正确的CPU上，并且可作为一个锁保证不会同时申请这个kmem_cache_cpu的对象 <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>5.  &nbsp;&nbsp;&nbsp;&nbsp;struct page <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span>page<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span> The slab from which we are allocating <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span> 指向slab对象来源的内存页面 <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>6.  &nbsp;&nbsp;&nbsp;&nbsp;struct page <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span>partial<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span> Partially allocated frozen slabs <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span> 指向曾分配完所有的对象，但当前已回收至少一个对象的page <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>7.  #ifdef CONFIG_SLUB_STATS<br>8.  &nbsp;&nbsp;&nbsp;&nbsp;unsigned stat<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">[</span>NR_SLUB_STAT_ITEMS<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">]</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span><br>9.  #endif<br>10.  <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">}</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span><br></div>

<pre><code>&amp;nbsp;

至于&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;kmem_cache_node&lt;/span&gt;结构：
</code></pre><div class="codeText" id="codeText" style="background: rgb(255, 255, 255); font: 12px/normal Consolas, monospace; margin: 0px 0px 1.1em; padding: 0px; border: 1px solid rgb(221, 221, 221); border-image: none; width: 1252.19px; text-align: left; color: rgb(102, 102, 102); text-transform: none; text-indent: 0px; letter-spacing: 0.1px; overflow: auto; word-spacing: 0px; white-space: normal; -ms-word-break: break-all; -ms-word-wrap: break-word; orphans: 2; widows: 2; font-size-adjust: none; font-stretch: normal; -webkit-text-stroke-width: 0px;"><br><br>1.  <span style="color: rgb(0, 0, 0); -ms-word-wrap: break-word;">【file<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">:</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span>mm<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span>slab<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">.</span>h】</span><br>2.  <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span><br>3.  &nbsp;<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span> The slab lists <span style="color: rgb(0, 0, 255); -ms-word-wrap: break-word;">for</span> all objects<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">.</span><br>4.  &nbsp;<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>5.  struct kmem_cache_node <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">{</span><br>6.  &nbsp;&nbsp;&nbsp;&nbsp;spinlock_t list_lock<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span>保护结构内数据的自旋锁<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>7.  &nbsp;<br>8.  #ifdef CONFIG_SLAB<br>9.  &nbsp;&nbsp;&nbsp;&nbsp;struct list_head slabs_partial<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span> partial list first<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">,</span> better asm code <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>10.  &nbsp;&nbsp;&nbsp;&nbsp;struct list_head slabs_full<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span><br>11.  &nbsp;&nbsp;&nbsp;&nbsp;struct list_head slabs_free<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span><br>12.  &nbsp;&nbsp;&nbsp;&nbsp;unsigned long free_objects<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span><br>13.  &nbsp;&nbsp;&nbsp;&nbsp;unsigned <span style="color: rgb(255, 0, 0); -ms-word-wrap: break-word;">int</span> free_limit<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span><br>14.  &nbsp;&nbsp;&nbsp;&nbsp;unsigned <span style="color: rgb(255, 0, 0); -ms-word-wrap: break-word;">int</span> colour_next<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span> Per<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">-</span>node cache coloring <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>15.  &nbsp;&nbsp;&nbsp;&nbsp;struct array_cache <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span>shared<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span> shared per node <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>16.  &nbsp;&nbsp;&nbsp;&nbsp;struct array_cache <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span>alien<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span> <span style="color: rgb(0, 0, 255); -ms-word-wrap: break-word;">on</span> other nodes <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>17.  &nbsp;&nbsp;&nbsp;&nbsp;unsigned long next_reap<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span> updated without locking <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>18.  &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 0, 0); -ms-word-wrap: break-word;">int</span> free_touched<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span> updated without locking <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>19.  #endif<br>20.  &nbsp;<br>21.  #ifdef CONFIG_SLUB<br>22.  &nbsp;&nbsp;&nbsp;&nbsp;unsigned long nr_partial<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span>本节点的Partial slab的数目<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>23.  &nbsp;&nbsp;&nbsp;&nbsp;struct list_head partial<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span> <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"><em></em></span>Partial slab的双向循环队列<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;"></span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">/</span><br>24.  #ifdef CONFIG_SLUB_DEBUG<br>25.  &nbsp;&nbsp;&nbsp;&nbsp;atomic_long_t nr_slabs<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span><br>26.  &nbsp;&nbsp;&nbsp;&nbsp;atomic_long_t total_objects<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span><br>27.  &nbsp;&nbsp;&nbsp;&nbsp;struct list_head full<span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span><br>28.  #endif<br>29.  #endif<br>30.  &nbsp;<br>31.  <span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">}</span><span style="color: rgb(0, 0, 204); -ms-word-wrap: break-word;">;</span><br></div>

<pre><code>&amp;nbsp;

该结构是每个&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;node&lt;/span&gt;节点都会有的一个结构，主要是用于管理&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;node&lt;/span&gt;节点的&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;slab&lt;/span&gt;缓存区。

Slub分配管理中，每个&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;CPU&lt;/span&gt;都有自己的缓存管理，也就是&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;kmem_cache_cpu&lt;/span&gt;数据结构管理；而每个&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;node&lt;/span&gt;节点也有自己的缓存管理，也就是&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;kmem_cache_node&lt;/span&gt;数据结构管理。

对象分配时：

1、 当前&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;CPU&lt;/span&gt;缓存有满足申请要求的对象时，将会首先从&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;kmem_cache_cpu&lt;/span&gt;的空闲链表&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;freelist&lt;/span&gt;将对象分配出去；

2、 如果对象不够时，将会向伙伴管理算法中申请内存页面，申请来的页面将会先填充到&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;node&lt;/span&gt;节点中，然后从&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;node&lt;/span&gt;节点取出对象到&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;CPU&lt;/span&gt;的缓存空闲链表中；

3、 如果原来申请的&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;node&lt;/span&gt;节点&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;A&lt;/span&gt;的对象，现在改为申请&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;node&lt;/span&gt;节点&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;B&lt;/span&gt;的，那么将会把&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;node&lt;/span&gt;节点&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;A&lt;/span&gt;的对象释放后再申请。

对象释放时：

1、 会先将对象释放到&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;CPU&lt;/span&gt;上面，如果释放的对象恰好与&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;CPU&lt;/span&gt;的缓存来自相同的页面，则直接添加到列表中；

2、 如果释放的对象不是当前&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;CPU&lt;/span&gt;缓存的页面，则会吧当前的&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;CPU&lt;/span&gt;的缓存对象放到&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;node&lt;/span&gt;上面，然后再把该对象释放到本地的&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;cache&lt;/span&gt;中。

为了避免过多的空闲对象缓存在管理框架中，&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;slub&lt;/span&gt;设置了阀值，如果空闲对象个数达到了一个峰值，将会把当前缓存释放到&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;node&lt;/span&gt;节点中，当&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;node&lt;/span&gt;节点也过了阀值，将会把&lt;span style=&quot;-ms-word-wrap: break-word;&quot;&gt;node&lt;/span&gt;节点的对象释放到伙伴管理算法中。

这里只是做了简单的概要说明，而实际上由于面对的场景复杂，所以实现上有更多值得品味的处理细节。
</code></pre></div>
    
      
      <div class="toc-wrapper">
        <div class="toc-scroll">
          <div class="toc-middle">
            
          </div>
        </div>
      </div>
    
  
</article>

      <footer class="footer">
  <p class="footer-text"></p>
</footer>

    </article>

    <script src="/js/to-top.js"></script>
    <script src="/js/search.js"></script>
  </body>
</html>
