<!doctype html>
<html lang="zh-CN">
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta content="yes" name="apple-mobile-web-app-capable">
  <meta content="black" name="apple-mobile-web-app-status-bar-style">
  <meta content="telephone=no" name="format-detection">
  <meta name="keywords" content="undefined">
  <meta name="description" content="互联网技术">
  <meta name="author" content="zhangyu">

  
  <title>Linux-3.14.12内存管理笔记【X86内存映射小结（1）】</title>
  

  <link rel="canonical" href="http://zhangyu33.com/2016/12/12/678/index.html">
  <link rel="shortcut icon" href="/">
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="undefined">
  <link rel="stylesheet" href="/font.css">
</head>


  <body>
    <aside class="aside">
  <nav class="aside-menu">
    <ul class="aside-list">
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-wendang"></i><a href="/index.html" class="aside-menu-link" title="首页">首页</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-wendang1"></i><a href="/archives/index.html" class="aside-menu-link" title="所有文章">所有文章</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-biaoqian1"></i><a href="/tags/index.html" class="aside-menu-link" title="分类标签">分类标签</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-lianjie"></i><a href="/links/index.html" class="aside-menu-link" title="友情链接">友情链接</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-guanyu"></i><a href="/about/index.html" class="aside-menu-link" title="关于">关于</a></li>
        
      
    </ul>
  </nav>

  <article class="aside-show">
    
      <form class="search-from" id="search-from">
  <input class="search-text" id="search-text" type="text" name="searchText" value autocomplete="off">
  <button class="search-btn" id="search-btn" type="button"><i class="search-btn-icon iconfont icon-sousuo-sousuo"></i></button>
</form>

      <article class="search-data" id="search-data">
  <button class="search-close" id="search-close"><i class="search-close-icon iconfont icon-houdongfangiconfont10"></i></button>

  <div class="search-wrapper" id="search-wrapper"></div>
</article>

    
    <div class="aside-show-wrapper">
      <figure class="aside-avatar">
        <img src="/img/avatar.png" alt="avatar" class="aside-avatar-img">
        <figcaption class="aside-avatar-caption">
          大雨哥
          
          <strong class="aside-avatar-STRONG">个人博客</strong>
          
        </figcaption>
      </figure>
      <p class="aside-show-description">互联网技术/架构/团队</p>
    </div>
  </article>
</aside>


    <article class="main" id="main">
      <article class="post min-height">
  
  <header class="post-header">
    
    <h1 class="post-title">Linux-3.14.12内存管理笔记【X86内存映射小结（1）】</h1>
    <p class="post-meta">
      <span class="post-time">2016-12-12</span>
      
      <a href="/categories/Linux-3-14-12内存管理笔记/" title="Linux-3.14.12内存管理笔记" class="post-categories">Linux-3.14.12内存管理笔记</a>
      
      
      <a href="/tags/内核/" " title="内核" class="post-tags"><i class="post-tags-icon iconfont icon-biaoqian"></i>内核</a>
      
      <a href="/tags/内存/" " title="内存" class="post-tags"><i class="post-tags-icon iconfont icon-biaoqian"></i>内存</a>
      
    </p>
    
  </header>
  <div class="post-content"><div class="Blog_wz1" style="text-align: left; color: rgb(102, 102, 102); text-transform: none; text-indent: 0px; letter-spacing: normal; font-family: 宋体, Arial; font-size: 16px; font-style: normal; font-weight: normal; word-spacing: 0px; white-space: normal; -ms-word-wrap: break-word; orphans: 2; widows: 2; background-color: rgb(255, 255, 255); font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px;"><br><br>        前面分析了<span style="-ms-word-wrap: break-word;">linux</span>内核如何开启保护模式和启用段页映射模式，也都分析了段式映射和段页式映射的一个概况。不过前面的分析只是侧重地讲解了<span style="-ms-word-wrap: break-word;">x86 32</span>位环境<span style="-ms-word-wrap: break-word;">4Kbytes</span>页面大小的情况，但是实际上<span style="-ms-word-wrap: break-word;">x86</span>可支持的分页映射模式远不止于此。所以特地总结一下。<br><br>        &nbsp; &nbsp;&nbsp;<span style="line-height: 1.5; -ms-word-wrap: break-word;">这里先基于保护模式下</span><span style="line-height: 1.5; -ms-word-wrap: break-word;">Intel IA-32</span><span style="line-height: 1.5; -ms-word-wrap: break-word;">架构处理器非</span><span style="line-height: 1.5; -ms-word-wrap: break-word;">PAE</span><span style="line-height: 1.5; -ms-word-wrap: break-word;">下</span><span style="line-height: 1.5; -ms-word-wrap: break-word;">4kbytes</span><span style="line-height: 1.5; -ms-word-wrap: break-word;">页面映射的环境分析一下内存映射的整个过程，后面再分析</span><span style="line-height: 1.5; -ms-word-wrap: break-word;">x86</span><span style="line-height: 1.5; -ms-word-wrap: break-word;">环境说支持的映射差异。</span><br><br>        &nbsp; &nbsp;&nbsp;<span style="line-height: 1.5; -ms-word-wrap: break-word;">首先了解一下几个基本概念：</span><br><br>        <strong>&nbsp; &nbsp;&nbsp;逻辑地址（<span style="-ms-word-wrap: break-word;">logical address</span>）</strong><br><br>        &nbsp; &nbsp;&nbsp;逻辑地址是机器语言指令中用来指定一个操作数或者一条指令的地址，它是由<span style="-ms-word-wrap: break-word;">16bit</span>的段选择符和<span style="-ms-word-wrap: break-word;">32bit</span>的偏移量构成的，其中段选择符标明了段信息（也就是段描述符）的位置，而偏移量则标明了从段开始的地方（也就是段基地址）到实际地址之间的距离。通常记录为<span style="-ms-word-wrap: break-word;">[</span>段选择符：偏移量<span style="-ms-word-wrap: break-word;">]</span>（即<span style="-ms-word-wrap: break-word;">[Segment Selector</span>：<span style="-ms-word-wrap: break-word;">Offset]</span>）。<br><br>        <strong>&nbsp; &nbsp;&nbsp;线性地址（<span style="-ms-word-wrap: break-word;">linear address</span>）（也成为虚拟地址<span style="-ms-word-wrap: break-word;">virtual address</span>）</strong><br><br>        &nbsp; &nbsp;&nbsp;线性地址是一个<span style="-ms-word-wrap: break-word;">32bit</span>无符号整数，表示的是处理器将逻辑地址转后用于表示处理器线性地址空间的<span style="-ms-word-wrap: break-word;">32bit</span>地址。类似于物理地址空间，线性地址空间是平坦的，无分段的，<span style="-ms-word-wrap: break-word;">2<sup style="-ms-word-wrap: break-word;">32</sup>byte</span>的地址空间（也就是<span style="-ms-word-wrap: break-word;">4G</span>大小的空间），地址范围自<span style="-ms-word-wrap: break-word;">0x0</span>到<span style="-ms-word-wrap: break-word;">0xFFFFFFFF</span>。线性地址空间包含了所有系统定义的段描述符表和页表等。<br><br>        <strong>&nbsp; &nbsp;&nbsp;物理地址（<span style="-ms-word-wrap: break-word;">physical address</span>）</strong><br><br>        &nbsp; &nbsp;&nbsp;用于内存芯片级内存单元寻址，也就是指处理器可通过其地址总线直接访问和操作的内存空间的地址了，是地址转换的最终结果。在保护模式下，<span style="-ms-word-wrap: break-word;">IA-32</span>架构提供了<span style="-ms-word-wrap: break-word;">4G</span>（<span style="-ms-word-wrap: break-word;">2<sup style="-ms-word-wrap: break-word;">32</sup>byte</span>）大小的物理地址空间，该地址空间是平坦无分段的，且地址自<span style="-ms-word-wrap: break-word;">0</span>到<span style="-ms-word-wrap: break-word;">FFFFFFFFH</span>连续。物理地址空间可以被映射到可读写存储器、只读存储器和存储器映射<span style="-ms-word-wrap: break-word;">I/O</span>。<br><br>        &nbsp; &nbsp;&nbsp;都悉知<span style="-ms-word-wrap: break-word;">x86</span>内存映射是这么一个流程图：<br><br>    &gt; <span style="-ms-word-wrap: break-word;"><img src="http://blog.chinaunix.net/attachment/201409/14/26859697_141066776111vQ.jpg" alt></span><br><br>        &nbsp;<br><br>        &nbsp; &nbsp;&nbsp;也就是：<br><br>        &nbsp; &nbsp;&nbsp;逻辑地址&mdash;&mdash;（段映射）&mdash;&mdash;<span style="-ms-word-wrap: break-word;">&gt;</span>线性地址&mdash;&mdash;（页映射）&mdash;&mdash;<span style="-ms-word-wrap: break-word;">&gt;</span>物理地址<br><br>        &nbsp; &nbsp;&nbsp;整个流程很明了，但是往往很容易出现几个问题：逻辑地址转换到线性地址所需要的段描述符在哪里？是的，通过<span style="-ms-word-wrap: break-word;">GDTR/LDTR</span>里面的基地址结合段选择符找到，那么这个基地址是线性地址还是物理地址？再往后，线性地址转换为物理地址所需的页全局目录在哪里？通过<span style="-ms-word-wrap: break-word;">CR3</span>寄存器找到，那么这个寄存器存的值是线性地址还是物理地址？那么还有页表呢？<br><br>        &nbsp; &nbsp;&nbsp;确实很容易出现疑问，那么现在还是回到整个地址翻译过程来分析和解答上面的问题。先来看一张图：<br><br>    &gt; &nbsp;<img src="http://blog.chinaunix.net/attachment/201409/14/26859697_1410667811kL0l.jpg" alt><br><br>        &nbsp; &nbsp;&nbsp;整个内存映射流程补全就是上面的这么一种情况了。接下来文字说明一下：<br><br>        <strong>(一)&nbsp;&nbsp;&nbsp; </strong>逻辑地址<span style="-ms-word-wrap: break-word;">[Seg.Selector</span>：<span style="-ms-word-wrap: break-word;">Offset]</span>由段选择符（<span style="-ms-word-wrap: break-word;">Seg.Selector</span>，通常是段寄存器）和偏移量构成，而段选择符格式为：<br><br>        <span style="-ms-word-wrap: break-word;"><img src="http://blog.chinaunix.net/attachment/201409/14/26859697_14106678255Gjm.jpg" alt></span><br><br>        &nbsp;<br><br>        其中<span style="-ms-word-wrap: break-word;">RPL</span>和<span style="-ms-word-wrap: break-word;">TI</span>是表示属性信息，<span style="-ms-word-wrap: break-word;">RPL</span>（<span style="-ms-word-wrap: break-word;">Requested Privilege Level</span>）表示特权级；<span style="-ms-word-wrap: break-word;">TI</span>（<span style="-ms-word-wrap: break-word;">Table Indicator</span>）表示指定描述符表，为<span style="-ms-word-wrap: break-word;">0</span>时表示使用<span style="-ms-word-wrap: break-word;">GDT</span>（全局描述符表），为<span style="-ms-word-wrap: break-word;">1</span>时表示使用<span style="-ms-word-wrap: break-word;">LDT</span>（局部描述符表）。而<span style="-ms-word-wrap: break-word;">Index</span>才为描述符索引。通过段选择符可以知道的信息：<span style="-ms-word-wrap: break-word;">1</span>、使用<span style="-ms-word-wrap: break-word;">GDT</span>还是<span style="-ms-word-wrap: break-word;">LDT</span>；<span style="-ms-word-wrap: break-word;">2</span>、描述符索引；<span style="-ms-word-wrap: break-word;">3</span>、特权级。段选择符的特权级较少使用，这里就不分析了。接下来的内存翻译需要段描述符里面的信息，段描述符根据<span style="-ms-word-wrap: break-word;">TI</span>的指定来自<span style="-ms-word-wrap: break-word;">GDT</span>还是<span style="-ms-word-wrap: break-word;">LDT</span>，<span style="-ms-word-wrap: break-word;">GDT</span>的位置可以通过<span style="-ms-word-wrap: break-word;">GDTR</span>来找到，而<span style="-ms-word-wrap: break-word;">LDT</span>却不如此。所以这里需要分开说明一下。<br><br>        <strong>(二)&nbsp;&nbsp;&nbsp; </strong>优先分析一下<span style="-ms-word-wrap: break-word;">GDT</span>的物理内存定位。<span style="-ms-word-wrap: break-word;">GDT</span>是通过<span style="-ms-word-wrap: break-word;">GDTR</span>寄存器里面的信息来确定位置的，<span style="-ms-word-wrap: break-word;">GDTR</span>的格式如下图：<br><br>        <span style="-ms-word-wrap: break-word;"><img src="http://blog.chinaunix.net/attachment/201409/14/26859697_1410667848xx6A.jpg" alt></span><br><br>        &nbsp;<br><br>        它是一个<span style="-ms-word-wrap: break-word;">48bit</span>的数据，由<span style="-ms-word-wrap: break-word;">32bit</span>的线性地址（高<span style="-ms-word-wrap: break-word;">32bit</span>）和<span style="-ms-word-wrap: break-word;">16bit</span>的全局描述符表大小（低<span style="-ms-word-wrap: break-word;">16bit</span>）构成。既然是线性地址，那么在开启段页式映射的环境，它必然需要经过一个页式转换。页式转换详情稍后有描述，这里仅需要知道即可。经过页式转换后，就可以找到<span style="-ms-word-wrap: break-word;">GDT</span>所在的物理内存了，该内存里面有需要的段描述符。<br><br>        <strong>(三)&nbsp;&nbsp;&nbsp; </strong>通过段选择符里面的描述符索引可以找到目标段描述符，运算公式：<span style="-ms-word-wrap: break-word;">Index <em> 8 + Linear Base Address</em></span>（每项段描述符的大小为<span style="-ms-word-wrap: break-word;">8</span>，所以乘<span style="-ms-word-wrap: break-word;">8</span>）。接下来再看一下段描述符的格式：<br><br>        <span style="-ms-word-wrap: break-word;"><img src="http://blog.chinaunix.net/attachment/201409/14/26859697_141066786360nr.jpg" alt></span><br><br>        &nbsp;<br><br>        段描述符是一个<span style="-ms-word-wrap: break-word;">64bit</span>的数据（<span style="-ms-word-wrap: break-word;">8bytes</span>），包含了段基地址、段限长以及各项段属性。段基地址并不是连续的，而是被拆分开来的，它由描述符的<span style="-ms-word-wrap: break-word;">63-56</span>和<span style="-ms-word-wrap: break-word;">39-16</span>位数据构成（如下图的黄色部分）。而段限长亦如此，由<span style="-ms-word-wrap: break-word;">51-48</span>和<span style="-ms-word-wrap: break-word;">15-0</span>位数据构成（绿色部分）。<br><br>        <span style="-ms-word-wrap: break-word;"><img src="http://blog.chinaunix.net/attachment/201409/14/26859697_14106678786AdT.jpg" alt></span><br><br>        &nbsp;<br><br>        组合形式：<br><br>        <span style="-ms-word-wrap: break-word;"><img src="http://blog.chinaunix.net/attachment/201409/14/26859697_1410667892TPmd.jpg" alt></span><br><br>        &nbsp;<br><br>        人工分析映射的时候，尤其需要注意这点，另外留意一下段描述符中存在着<span style="-ms-word-wrap: break-word;">S</span>位（即：<span style="-ms-word-wrap: break-word;">Descriptor type</span>），稍后用到。<br><br>        <strong>(四)&nbsp;&nbsp;&nbsp; </strong>现在已知段基地址（<span style="-ms-word-wrap: break-word;">Base Address</span>），那么目标操作数据的线性地址则为：<span style="-ms-word-wrap: break-word;">Base Address+Offset</span>，段基地址和逻辑地址中的偏移量相加的和值。至此，段式映射已经转换完毕，这个和值就是逻辑地址转换后的线性地址。接下来页式映射，这个线性地址将会拆分为<span style="-ms-word-wrap: break-word;">3</span>部分：页全局目录索引（前<span style="-ms-word-wrap: break-word;">10bit</span>）、页表索引（中<span style="-ms-word-wrap: break-word;">10bit</span>）和页偏移量（尾<span style="-ms-word-wrap: break-word;">12bit</span>）。页式转换首先通过<span style="-ms-word-wrap: break-word;">CR3</span>寄存器找到全局页目录所在位置（注：<span style="-ms-word-wrap: break-word;">CR3</span>存放的是页全局目录的物理地址），通过页全局目录索引，可以找到对应的<span style="-ms-word-wrap: break-word;">PDE</span>（页全局目录项）；页全局目录项的里面附带的信息有页表基地址和页表属性，如图：<br><br>        <span style="-ms-word-wrap: break-word;"><img src="http://blog.chinaunix.net/attachment/201409/14/26859697_1410667908pltZ.jpg" alt></span><br><br>        &nbsp;<br><br>        页表基地址是<span style="-ms-word-wrap: break-word;">32bit</span>的数据，也就是将读取出来的<span style="-ms-word-wrap: break-word;">PDE</span>末尾属性标示位清<span style="-ms-word-wrap: break-word;">0</span>即可得到该基地址（该基地址是物理地址），基地址结合页表索引就可以得到<span style="-ms-word-wrap: break-word;">PTE</span>（页表项）；页表项的内容类似于<span style="-ms-word-wrap: break-word;">PDE</span>，如图：<br><br>        <span style="-ms-word-wrap: break-word;"><img src="http://blog.chinaunix.net/attachment/201409/14/26859697_1410667921q22n.jpg" alt></span><br><br>        &nbsp;<br><br>        将<span style="-ms-word-wrap: break-word;">PTE</span>的属性标示位清<span style="-ms-word-wrap: break-word;">0</span>即可得到<span style="-ms-word-wrap: break-word;">4Kbytes</span>的物理页面的基地址了（物理地址），该基地址加上页偏移量，就得到了最终的物理地址。至此，线性地址转换物理地址完毕，相关流程如下图：<br><br>        <span style="-ms-word-wrap: break-word;"><img src="http://blog.chinaunix.net/attachment/201409/14/26859697_1410667934xm46.jpg" alt></span><br><br>        &nbsp;<br><br>        使用<span style="-ms-word-wrap: break-word;">GDT</span>将逻辑地址转换物理地址的过程就此结束。<br><br>        <strong>(五)&nbsp;&nbsp;&nbsp; </strong>再绕回来讲一下前面遗留的，关于<span style="-ms-word-wrap: break-word;">LDT</span>的物理内存定位。先了解一下<span style="-ms-word-wrap: break-word;">LDTR</span>寄存器的情况：<br><br>        <span style="-ms-word-wrap: break-word;"><img src="http://blog.chinaunix.net/attachment/201409/14/26859697_1410667959wfNE.jpg" alt></span><br><br>        &nbsp;<br><br>        LDTR和段寄存器类似，对程序员可见的仅是前面的<span style="-ms-word-wrap: break-word;">16bit</span>大小的段选择部分而已，后面的<span style="-ms-word-wrap: break-word;">32bit</span>的段基地址、段限长以及属性信息都是不可见的描述符高速缓冲部分。操作加载<span style="-ms-word-wrap: break-word;">LDTR</span>的时候，仅需将段选择符加载上去即可，后面的描述符部分将会自动根据段选择符从<span style="-ms-word-wrap: break-word;">LDT</span>中找到对应的描述符并加载。既然知道<span style="-ms-word-wrap: break-word;">LDTR</span>存放的也是一个段选择符，那么这个段选择符用在哪里呢？它用在<span style="-ms-word-wrap: break-word;">GDT</span>表中定位。那么整个<span style="-ms-word-wrap: break-word;">LDT </span>表的定位就是：<span style="-ms-word-wrap: break-word;">1</span>、根据<span style="-ms-word-wrap: break-word;">LDTR</span>寄存器的段选择符信息，查找<span style="-ms-word-wrap: break-word;">GDT</span>表，将会在<span style="-ms-word-wrap: break-word;">GDT</span>中查找到一个<span style="-ms-word-wrap: break-word;">LDT</span>描述符；<span style="-ms-word-wrap: break-word;">2</span>、根据描述符中的基地址信息和段限长，由于基地址是线性地址，所以仍需要页式转换，就可以定位到<span style="-ms-word-wrap: break-word;">LDT</span>局部描述符表了。貌似这么一来一去，挺麻烦的，不过由于<span style="-ms-word-wrap: break-word;">LDTR</span>有描述符高速缓冲区，再加上<span style="-ms-word-wrap: break-word;">TLB</span>的配合，实际上真正需要这么累赘去定位物理页面的机会不太多。而且<span style="-ms-word-wrap: break-word;">GDT</span>和<span style="-ms-word-wrap: break-word;">LDT</span>在本质上是没区别的，也可以理解为：<span style="-ms-word-wrap: break-word;">GDT</span>是一级描述符表，<span style="-ms-word-wrap: break-word;">LDT</span>是二级描述符表。于是如此设计有了更好的扩展性。顺带提一下，<span style="-ms-word-wrap: break-word;">LDT</span>描述符表和普通的段描述符表的差异在于哪里，就在于下面标红的<span style="-ms-word-wrap: break-word;">S</span>位，也就是<span style="-ms-word-wrap: break-word;">Descriptor type</span>，为<span style="-ms-word-wrap: break-word;">0</span>的时候，表示为系统段描述符（<span style="-ms-word-wrap: break-word;">LDT</span>描述符是系统段描述符的一种），为<span style="-ms-word-wrap: break-word;">1</span>的时候就表示代码段或者数据段了。<br><br>        <span style="-ms-word-wrap: break-word;">&nbsp;<img src="http://blog.chinaunix.net/attachment/201409/14/26859697_1410667988xid1.jpg" alt></span><br><br>        <span style="line-height: 1.5; text-indent: 0cm; -ms-word-wrap: break-word;">再啰嗦一下，虽然</span><span style="line-height: 1.5; text-indent: 0cm; -ms-word-wrap: break-word;">Intel</span><span style="line-height: 1.5; text-indent: 0cm; -ms-word-wrap: break-word;">如此设计，功能强大，可谓用心良苦，不过这个也在某些方面给程序员新增了负担，毕竟如此设计在其他处理器上面是没有的，就本人接触的</span><span style="line-height: 1.5; text-indent: 0cm; -ms-word-wrap: break-word;">PPC</span><span style="line-height: 1.5; text-indent: 0cm; -ms-word-wrap: break-word;">、</span><span style="line-height: 1.5; text-indent: 0cm; -ms-word-wrap: break-word;">MIPS</span><span style="line-height: 1.5; text-indent: 0cm; -ms-word-wrap: break-word;">、</span><span style="line-height: 1.5; text-indent: 0cm; -ms-word-wrap: break-word;">ARM</span><span style="line-height: 1.5; text-indent: 0cm; -ms-word-wrap: break-word;">处理器都没听说过有分段的做法，如果真心使用了</span><span style="line-height: 1.5; text-indent: 0cm; -ms-word-wrap: break-word;">Intel</span><span style="line-height: 1.5; text-indent: 0cm; -ms-word-wrap: break-word;">的这些功能，真不敢想象环境移植的时候，会有多痛苦。所以</span><span style="line-height: 1.5; text-indent: 0cm; -ms-word-wrap: break-word;">Linux</span><span style="line-height: 1.5; text-indent: 0cm; -ms-word-wrap: break-word;">设计开发的时候，往往是不使用这些功能的，详细的以后再说明。</span><br><br>        <em>*(六)&nbsp;&nbsp;&nbsp; </em>既然定位到<span style="-ms-word-wrap: break-word;">LDT</span>了，那么再往后的内存地址转换就是根据逻辑地址的段选择符定位<span style="-ms-word-wrap: break-word;">LDT</span>中的段描述符，通过描述符中的基地址信息加上逻辑地址的偏移量，最终的和值得到了使用<span style="-ms-word-wrap: break-word;">LDT</span>转换后的线性地址了。不可避免的就是线性地址再经过页式转换，最后定位到具体的物理内存。<br><br>        &nbsp;<br><br>        &nbsp; &nbsp;&nbsp;整个内存映射基本就这样了，至于<span style="-ms-word-wrap: break-word;">4KBytes</span>、<span style="-ms-word-wrap: break-word;">2Mbytes</span>和<span style="-ms-word-wrap: break-word;">4Mbytes</span>的页面映射，其实也只是线性地址转换物理地址存在差异罢了，至于逻辑地址转换线性地址上面是不存在什么差异的。再者就是几个控制寄存器的功能标志位设置上面的差异。这些差异后续再统一列举分析。<br><br></div>

<div class="Blog_con2_1 Blog_con3_2" style="text-align: left; color: rgb(102, 102, 102); text-transform: none; line-height: 22px; text-indent: 0px; letter-spacing: normal; font-family: 宋体, Arial; font-size: 12px; font-style: normal; font-weight: normal; margin-top: 50px; word-spacing: 0px; white-space: normal; position: relative; -ms-word-wrap: break-word; orphans: 2; widows: 2; background-color: rgb(255, 255, 255); font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px;"><br>    <div style="height: 30px; -ms-word-wrap: break-word;"><br>        <a href="http://blog.chinaunix.net/uid-26859697-id-4470758.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-26859697-id-4470758.html</a><br>    </div><br></div></div>
    
      
      <div class="toc-wrapper">
        <div class="toc-scroll">
          <div class="toc-middle">
            
          </div>
        </div>
      </div>
    
  
</article>

      <footer class="footer">
  <p class="footer-text"></p>
</footer>

    </article>

    <script src="/js/to-top.js"></script>
    <script src="/js/search.js"></script>
  </body>
</html>
