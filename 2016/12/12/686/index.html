<!doctype html>
<html lang="zh-CN">
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta content="yes" name="apple-mobile-web-app-capable">
  <meta content="black" name="apple-mobile-web-app-status-bar-style">
  <meta content="telephone=no" name="format-detection">
  <meta name="keywords" content="undefined">
  <meta name="description" content="互联网技术">
  <meta name="author" content="zhangyu">

  
  <title>Linux-3.14.12内存管理笔记【建立内核页表（2）】</title>
  

  <link rel="canonical" href="http://zhangyu33.com/2016/12/12/686/index.html">
  <link rel="shortcut icon" href="/">
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="undefined">
  <link rel="stylesheet" href="/font.css">
</head>


  <body>
    <aside class="aside">
  <nav class="aside-menu">
    <ul class="aside-list">
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-wendang"></i><a href="/index.html" class="aside-menu-link" title="首页">首页</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-wendang1"></i><a href="/archives/index.html" class="aside-menu-link" title="所有文章">所有文章</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-biaoqian1"></i><a href="/tags/index.html" class="aside-menu-link" title="分类标签">分类标签</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-lianjie"></i><a href="/links/index.html" class="aside-menu-link" title="友情链接">友情链接</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-guanyu"></i><a href="/about/index.html" class="aside-menu-link" title="关于">关于</a></li>
        
      
    </ul>
  </nav>

  <article class="aside-show">
    
      <form class="search-from" id="search-from">
  <input class="search-text" id="search-text" type="text" name="searchText" value="" autocomplete="off">
  <button class="search-btn" id="search-btn" type="button"><i class="search-btn-icon iconfont icon-sousuo-sousuo"></i></button>
</form>

      <article class="search-data" id="search-data">
  <button class="search-close" id="search-close"><i class="search-close-icon iconfont icon-houdongfangiconfont10"></i></button>

  <div class="search-wrapper" id="search-wrapper"></div>
</article>

    
    <div class="aside-show-wrapper">
      <figure class="aside-avatar">
        <img src="/img/avatar.png" alt="avatar" class="aside-avatar-img">
        <figcaption class="aside-avatar-caption">
          大雨哥
          
          <strong class="aside-avatar-STRONG">个人博客</strong>
          
        </figcaption>
      </figure>
      <p class="aside-show-description">互联网技术/架构/团队</p>
    </div>
  </article>
</aside>


    <article class="main" id="main">
      <article class="post min-height">
  
  <header class="post-header">
    
    <h1 class="post-title">Linux-3.14.12内存管理笔记【建立内核页表（2）】</h1>
    <p class="post-meta">
      <span class="post-time">2016-12-12</span>
      
      <a href="/categories/Linux-3-14-12内存管理笔记/" title="Linux-3.14.12内存管理笔记" class="post-categories">Linux-3.14.12内存管理笔记</a>
      
      
      <a href="/tags/内核/"" title="内核" class="post-tags"><i class="post-tags-icon iconfont icon-biaoqian"></i>内核</a>
      
      <a href="/tags/内存/"" title="内存" class="post-tags"><i class="post-tags-icon iconfont icon-biaoqian"></i>内存</a>
      
    </p>
    
  </header>
  <div class="post-content"><p>前面的前奏已经分析介绍了建立内核页表相关变量的设置准备，接下来转入正题分析内核页表的建立。</p>
<pre><code>&amp;nbsp; &amp;nbsp;&amp;nbsp;建立内核页表的关键函数init_mem_mapping()：
</code></pre><div id="codeText"><br><br>1.  【file：/arch/x86/mm/init.c】<br>2.  void <strong>init init_mem_mapping(void)<br>3.  {<br>4.  &nbsp;&nbsp;&nbsp;&nbsp;unsigned long end;<br>5.  &nbsp;<br>6.  &nbsp;&nbsp;&nbsp;&nbsp;probe_page_size_mask();<br>7.  &nbsp;<br>8.  #ifdef CONFIG_X86_64<br>9.  &nbsp;&nbsp;&nbsp;&nbsp;end = max_pfn &lt;&lt; PAGE_SHIFT;<br>10.  #else<br>11.  &nbsp;&nbsp;&nbsp;&nbsp;end = max_low_pfn &lt;&lt; PAGE_SHIFT;<br>12.  #endif<br>13.  &nbsp;<br>14.  &nbsp;&nbsp;&nbsp;&nbsp;/<em> the ISA range is always mapped regardless of memory holes </em>/<br>15.  &nbsp;&nbsp;&nbsp;&nbsp;init_memory_mapping(0, ISA_END_ADDRESS);<br>16.  &nbsp;<br>17.  &nbsp;&nbsp;&nbsp;&nbsp;/<em><br>18.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em> If the allocation is in bottom-up direction, we setup direct mapping<br>19.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em> in bottom-up, otherwise we setup direct mapping in top-down.<br>20.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em>/<br>21.  &nbsp;&nbsp;&nbsp;&nbsp;if (memblock_bottom_up()) {<br>22.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned long kernel_end = </strong>pa_symbol(_end);<br>23.  &nbsp;<br>24.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/<em><br>25.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em> we need two separate calls here. This is because we want to<br>26.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em> allocate page tables above the kernel. So we first map<br>27.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em> [kernel_end, end) to make memory above the kernel be mapped<br>28.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em> as soon as possible. And then use page tables allocated above<br>29.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em> the kernel to map [ISA_END_ADDRESS, kernel_end).<br>30.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>/<br>31.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memory_map_bottom_up(kernel_end, end);<br>32.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memory_map_bottom_up(ISA_END_ADDRESS, kernel_end);<br>33.  &nbsp;&nbsp;&nbsp;&nbsp;} else {<br>34.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memory_map_top_down(ISA_END_ADDRESS, end);<br>35.  &nbsp;&nbsp;&nbsp;&nbsp;}<br>36.  &nbsp;<br>37.  #ifdef CONFIG_X86_64<br>38.  &nbsp;&nbsp;&nbsp;&nbsp;if (max_pfn &gt; max_low_pfn) {<br>39.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/</em> can we preseve max_low_pfn ?*/<br>40.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_low_pfn = max_pfn;<br>41.  &nbsp;&nbsp;&nbsp;&nbsp;}<br>42.  #else<br>43.  &nbsp;&nbsp;&nbsp;&nbsp;early_ioremap_page_table_range_init();<br>44.  #endif<br>45.  &nbsp;<br>46.  &nbsp;&nbsp;&nbsp;&nbsp;load_cr3(swapper_pg_dir);<br>47.  &nbsp;&nbsp;&nbsp;&nbsp;__flush_tlb_all();<br>48.  &nbsp;<br>49.  &nbsp;&nbsp;&nbsp;&nbsp;early_memtest(0, max_pfn_mapped &lt;&lt; PAGE_SHIFT);<br>50.  }<br></div>

<pre><code>&amp;nbsp; &amp;nbsp;&amp;nbsp;其中probe_page_size_mask()实现：
</code></pre><div id="codeText"><br><br>1.  【file：/arch/x86/mm/init.c】<br>2.  static void <strong>init probe_page_size_mask(void)<br>3.  {<br>4.  &nbsp;&nbsp;&nbsp;&nbsp;init_gbpages();<br>5.  &nbsp;<br>6.  #if !defined(CONFIG_DEBUG_PAGEALLOC) &amp;&amp; !defined(CONFIG_KMEMCHECK)<br>7.  &nbsp;&nbsp;&nbsp;&nbsp;/<em><br>8.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em> For CONFIG_DEBUG_PAGEALLOC, identity mapping will use small pages.<br>9.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em> This will simplify cpa(), which otherwise needs to support splitting<br>10.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em> large pages into small in interrupt context, etc.<br>11.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>/<br>12.  &nbsp;&nbsp;&nbsp;&nbsp;if (direct_gbpages)<br>13.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;page_size_mask |= 1 &lt;&lt; PG_LEVEL_1G;<br>14.  &nbsp;&nbsp;&nbsp;&nbsp;if (cpu_has_pse)<br>15.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;page_size_mask |= 1 &lt;&lt; PG_LEVEL_2M;<br>16.  #endif<br>17.  &nbsp;<br>18.  &nbsp;&nbsp;&nbsp;&nbsp;/</em> Enable PSE if available <em>/<br>19.  &nbsp;&nbsp;&nbsp;&nbsp;if (cpu_has_pse)<br>20.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_in_cr4(X86_CR4_PSE);<br>21.  &nbsp;<br>22.  &nbsp;&nbsp;&nbsp;&nbsp;/</em> Enable PGE if available */<br>23.  &nbsp;&nbsp;&nbsp;&nbsp;if (cpu_has_pge) {<br>24.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_in_cr4(X86_CR4_PGE);<br>25.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>supported_pte_mask |= _PAGE_GLOBAL;<br>26.  &nbsp;&nbsp;&nbsp;&nbsp;}<br>27.  }<br></div>

<pre><code>&amp;nbsp;

&amp;nbsp; &amp;nbsp;&amp;nbsp;probe_page_size_mask()主要作用是初始化直接映射变量（在init_gbpages()里面）和对page_size_mask变量进行设置，以及根据配置来控制CR4寄存器的置位，用于后面分页时的页面大小情况判定。

&amp;nbsp; &amp;nbsp;&amp;nbsp;回到init_mem_mapping()继续往下走，接着是init_memory_mapping()，其中入参ISA_END_ADDRESS表示ISA总线上设备的地址末尾。

&amp;nbsp; &amp;nbsp;&amp;nbsp;init_mem_mapping()实现：
</code></pre><div id="codeText"><br><br>1.  【file：/arch/x86/mm/init.c】<br>2.  /<em><br>3.  &nbsp;</em> Setup the direct mapping of the physical memory at PAGE_OFFSET.<br>4.  &nbsp;<em> This runs before bootmem is initialized and gets pages directly from<br>5.  &nbsp;</em> the physical memory. To access them they are temporarily mapped.<br>6.  &nbsp;*/<br>7.  unsigned long __init_refok init_memory_mapping(unsigned long start,<br>8.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned long end)<br>9.  {<br>10.  &nbsp;&nbsp;&nbsp;&nbsp;struct map_range mr[NR_RANGE_MR];<br>11.  &nbsp;&nbsp;&nbsp;&nbsp;unsigned long ret = 0;<br>12.  &nbsp;&nbsp;&nbsp;&nbsp;int nr_range, i;<br>13.  &nbsp;<br>14.  &nbsp;&nbsp;&nbsp;&nbsp;pr_info(&quot;init_memory_mapping: [mem %#010lx-%#010lx]\n&quot;,<br>15.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start, end - 1);<br>16.  &nbsp;<br>17.  &nbsp;&nbsp;&nbsp;&nbsp;memset(mr, 0, sizeof(mr));<br>18.  &nbsp;&nbsp;&nbsp;&nbsp;nr_range = split_mem_range(mr, 0, start, end);<br>19.  &nbsp;<br>20.  &nbsp;&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; nr_range; i++)<br>21.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = kernel_physical_mapping_init(mr[i].start, mr[i].end,<br>22.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mr[i].page_size_mask);<br>23.  &nbsp;<br>24.  &nbsp;&nbsp;&nbsp;&nbsp;add_pfn_range_mapped(start &gt;&gt; PAGE_SHIFT, ret &gt;&gt; PAGE_SHIFT);<br>25.  &nbsp;<br>26.  &nbsp;&nbsp;&nbsp;&nbsp;return ret &gt;&gt; PAGE_SHIFT;<br>27.  }<br></div>

<pre><code>&amp;nbsp;

&amp;nbsp; &amp;nbsp;&amp;nbsp;init_mem_mapping()里面关键操作有三个split_mem_range()、kernel_physical_mapping_init()和add_pfn_range_mapped()函数。

&amp;nbsp; &amp;nbsp;&amp;nbsp;首先分析一下split_mem_range()：
</code></pre><div id="codeText"><br><br>1.  【file：/arch/x86/mm/init.c】<br>2.  static int __meminit split_mem_range(struct map_range <em>mr, int nr_range,<br>3.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned long start,<br>4.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned long end)<br>5.  {<br>6.  &nbsp;&nbsp;&nbsp;&nbsp;unsigned long start_pfn, end_pfn, limit_pfn;<br>7.  &nbsp;&nbsp;&nbsp;&nbsp;unsigned long pfn;<br>8.  &nbsp;&nbsp;&nbsp;&nbsp;int i;<br>9.  &nbsp;<br>10.  &nbsp;&nbsp;&nbsp;&nbsp;limit_pfn = PFN_DOWN(end);<br>11.  &nbsp;<br>12.  &nbsp;&nbsp;&nbsp;&nbsp;/</em> head if not big page alignment ? <em>/<br>13.  &nbsp;&nbsp;&nbsp;&nbsp;pfn = start_pfn = PFN_DOWN(start);<br>14.  #ifdef CONFIG_X86_32<br>15.  &nbsp;&nbsp;&nbsp;&nbsp;/</em><br>16.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em> Don&#39;t use a large page for the first 2/4MB of memory<br>17.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em> because there are often fixed size MTRRs in there<br>18.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em> and overlapping MTRRs into large pages can cause<br>19.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em> slowdowns.<br>20.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>/<br>21.  &nbsp;&nbsp;&nbsp;&nbsp;if (pfn == 0)<br>22.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end_pfn = PFN_DOWN(PMD_SIZE);<br>23.  &nbsp;&nbsp;&nbsp;&nbsp;else<br>24.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end_pfn = round_up(pfn, PFN_DOWN(PMD_SIZE));<br>25.  #else /</em> CONFIG_X86_64 <em>/<br>26.  &nbsp;&nbsp;&nbsp;&nbsp;end_pfn = round_up(pfn, PFN_DOWN(PMD_SIZE));<br>27.  #endif<br>28.  &nbsp;&nbsp;&nbsp;&nbsp;if (end_pfn &gt; limit_pfn)<br>29.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end_pfn = limit_pfn;<br>30.  &nbsp;&nbsp;&nbsp;&nbsp;if (start_pfn &lt; end_pfn) {<br>31.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nr_range = save_mr(mr, nr_range, start_pfn, end_pfn, 0);<br>32.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pfn = end_pfn;<br>33.  &nbsp;&nbsp;&nbsp;&nbsp;}<br>34.  &nbsp;<br>35.  &nbsp;&nbsp;&nbsp;&nbsp;/</em> big page (2M) range <em>/<br>36.  &nbsp;&nbsp;&nbsp;&nbsp;start_pfn = round_up(pfn, PFN_DOWN(PMD_SIZE));<br>37.  #ifdef CONFIG_X86_32<br>38.  &nbsp;&nbsp;&nbsp;&nbsp;end_pfn = round_down(limit_pfn, PFN_DOWN(PMD_SIZE));<br>39.  #else /</em> CONFIG_X86_64 <em>/<br>40.  &nbsp;&nbsp;&nbsp;&nbsp;end_pfn = round_up(pfn, PFN_DOWN(PUD_SIZE));<br>41.  &nbsp;&nbsp;&nbsp;&nbsp;if (end_pfn &gt; round_down(limit_pfn, PFN_DOWN(PMD_SIZE)))<br>42.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end_pfn = round_down(limit_pfn, PFN_DOWN(PMD_SIZE));<br>43.  #endif<br>44.  &nbsp;<br>45.  &nbsp;&nbsp;&nbsp;&nbsp;if (start_pfn &lt; end_pfn) {<br>46.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nr_range = save_mr(mr, nr_range, start_pfn, end_pfn,<br>47.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;page_size_mask &amp; (1&lt;&lt;PG_LEVEL_2M));<br>48.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pfn = end_pfn;<br>49.  &nbsp;&nbsp;&nbsp;&nbsp;}<br>50.  &nbsp;<br>51.  #ifdef CONFIG_X86_64<br>52.  &nbsp;&nbsp;&nbsp;&nbsp;/</em> big page (1G) range <em>/<br>53.  &nbsp;&nbsp;&nbsp;&nbsp;start_pfn = round_up(pfn, PFN_DOWN(PUD_SIZE));<br>54.  &nbsp;&nbsp;&nbsp;&nbsp;end_pfn = round_down(limit_pfn, PFN_DOWN(PUD_SIZE));<br>55.  &nbsp;&nbsp;&nbsp;&nbsp;if (start_pfn &lt; end_pfn) {<br>56.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nr_range = save_mr(mr, nr_range, start_pfn, end_pfn,<br>57.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;page_size_mask &amp;<br>58.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((1&lt;&lt;PG_LEVEL_2M)|(1&lt;&lt;PG_LEVEL_1G)));<br>59.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pfn = end_pfn;<br>60.  &nbsp;&nbsp;&nbsp;&nbsp;}<br>61.  &nbsp;<br>62.  &nbsp;&nbsp;&nbsp;&nbsp;/</em> tail is not big page (1G) alignment <em>/<br>63.  &nbsp;&nbsp;&nbsp;&nbsp;start_pfn = round_up(pfn, PFN_DOWN(PMD_SIZE));<br>64.  &nbsp;&nbsp;&nbsp;&nbsp;end_pfn = round_down(limit_pfn, PFN_DOWN(PMD_SIZE));<br>65.  &nbsp;&nbsp;&nbsp;&nbsp;if (start_pfn &lt; end_pfn) {<br>66.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nr_range = save_mr(mr, nr_range, start_pfn, end_pfn,<br>67.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;page_size_mask &amp; (1&lt;&lt;PG_LEVEL_2M));<br>68.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pfn = end_pfn;<br>69.  &nbsp;&nbsp;&nbsp;&nbsp;}<br>70.  #endif<br>71.  &nbsp;<br>72.  &nbsp;&nbsp;&nbsp;&nbsp;/</em> tail is not big page (2M) alignment <em>/<br>73.  &nbsp;&nbsp;&nbsp;&nbsp;start_pfn = pfn;<br>74.  &nbsp;&nbsp;&nbsp;&nbsp;end_pfn = limit_pfn;<br>75.  &nbsp;&nbsp;&nbsp;&nbsp;nr_range = save_mr(mr, nr_range, start_pfn, end_pfn, 0);<br>76.  &nbsp;<br>77.  &nbsp;&nbsp;&nbsp;&nbsp;if (!after_bootmem)<br>78.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adjust_range_page_size_mask(mr, nr_range);<br>79.  &nbsp;<br>80.  &nbsp;&nbsp;&nbsp;&nbsp;/</em> try to merge same page size and continuous <em>/<br>81.  &nbsp;&nbsp;&nbsp;&nbsp;for (i = 0; nr_range &gt; 1 &amp;&amp; i &lt; nr_range - 1; i++) {<br>82.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned long old_start;<br>83.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mr[i].end != mr[i+1].start ||<br>84.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mr[i].page_size_mask != mr[i+1].page_size_mask)<br>85.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>86.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/</em> move it <em>/<br>87.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old_start = mr[i].start;<br>88.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memmove(&amp;mr[i], &amp;mr[i+1],<br>89.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(nr_range - 1 - i) </em> sizeof(struct map_range));<br>90.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mr[i–].start = old_start;<br>91.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nr_range–;<br>92.  &nbsp;&nbsp;&nbsp;&nbsp;}<br>93.  &nbsp;<br>94.  &nbsp;&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; nr_range; i++)<br>95.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printk(KERN_DEBUG &quot; [mem %#010lx-%#010lx] page %s\n&quot;,<br>96.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mr[i].start, mr[i].end - 1,<br>97.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(mr[i].page_size_mask &amp; (1&lt;&lt;PG_LEVEL_1G))?&quot;1G&quot;:(<br>98.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(mr[i].page_size_mask &amp; (1&lt;&lt;PG_LEVEL_2M))?&quot;2M&quot;:&quot;4k&quot;));<br>99.  &nbsp;<br>100.  &nbsp;&nbsp;&nbsp;&nbsp;return nr_range;<br>101.  }<br></div>

<pre><code>&amp;nbsp;

&amp;nbsp; &amp;nbsp;&amp;nbsp;split_mem_range()根据传入的内存start和end做四舍五入的对齐操作（即round_up和round_down），并根据对齐的情况，把开始、末尾的不对齐部分及中间部分分成了三段，使用save_mr()将其存放在init_mem_mapping()的局部变量数组mr中。划分开来主要是为了允许各部分可以映射不同页面大小，然后如果各划分开来的部分是连续的，映射页面大小也是一致的，则将其合并。最后将映射的情况打印出来，在shell上使用dmesg命令可以看到该打印信息，样例：
</code></pre><blockquote>
<p><img src="http://blog.chinaunix.net/attachment/201411/2/26859697_1414916755XAzx.png" alt=""></p>
</blockquote>
<pre><code>&amp;nbsp;

&amp;nbsp; &amp;nbsp;&amp;nbsp;接下来看kernel_physical_mapping_init():
</code></pre><div id="codeText"><br><br>1.  【file：/arch/x86/mm/init.c】<br>2.  /<em><br>3.  &nbsp;</em> This maps the physical memory to kernel virtual address space, a total<br>4.  &nbsp;<em> of max_low_pfn pages, by creating page tables starting from address<br>5.  &nbsp;</em> PAGE_OFFSET:<br>6.  &nbsp;<em>/<br>7.  unsigned long __init<br>8.  kernel_physical_mapping_init(unsigned long start,<br>9.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned long end,<br>10.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned long page_size_mask)<br>11.  {<br>12.  &nbsp;&nbsp;&nbsp;&nbsp;int use_pse = page_size_mask == (1&lt;&lt;PG_LEVEL_2M);<br>13.  &nbsp;&nbsp;&nbsp;&nbsp;unsigned long last_map_addr = end;<br>14.  &nbsp;&nbsp;&nbsp;&nbsp;unsigned long start_pfn, end_pfn;<br>15.  &nbsp;&nbsp;&nbsp;&nbsp;pgd_t </em>pgd_base = swapper_pg_dir;<br>16.  &nbsp;&nbsp;&nbsp;&nbsp;int pgd_idx, pmd_idx, pte_ofs;<br>17.  &nbsp;&nbsp;&nbsp;&nbsp;unsigned long pfn;<br>18.  &nbsp;&nbsp;&nbsp;&nbsp;pgd_t <em>pgd;<br>19.  &nbsp;&nbsp;&nbsp;&nbsp;pmd_t </em>pmd;<br>20.  &nbsp;&nbsp;&nbsp;&nbsp;pte_t <em>pte;<br>21.  &nbsp;&nbsp;&nbsp;&nbsp;unsigned pages_2m, pages_4k;<br>22.  &nbsp;&nbsp;&nbsp;&nbsp;int mapping_iter;<br>23.  &nbsp;<br>24.  &nbsp;&nbsp;&nbsp;&nbsp;start_pfn = start &gt;&gt; PAGE_SHIFT;<br>25.  &nbsp;&nbsp;&nbsp;&nbsp;end_pfn = end &gt;&gt; PAGE_SHIFT;<br>26.  &nbsp;<br>27.  &nbsp;&nbsp;&nbsp;&nbsp;/</em><br>28.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em> First iteration will setup identity mapping using large/small pages<br>29.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em> based on use_pse, with other attributes same as set by<br>30.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em> the early code in head_32.S<br>31.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em><br>32.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em> Second iteration will setup the appropriate attributes (NX, GLOBAL..)<br>33.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em> as desired for the kernel identity mapping.<br>34.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em><br>35.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em> This two pass mechanism conforms to the TLB app note which says:<br>36.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em><br>37.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em> &quot;Software should not write to a paging-structure entry in a way<br>38.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em> that would change, for any linear address, both the page size<br>39.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em> and either the page frame or attributes.&quot;<br>40.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>/<br>41.  &nbsp;&nbsp;&nbsp;&nbsp;mapping_iter = 1;<br>42.  &nbsp;<br>43.  &nbsp;&nbsp;&nbsp;&nbsp;if (!cpu_has_pse)<br>44.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use_pse = 0;<br>45.  &nbsp;<br>46.  repeat:<br>47.  &nbsp;&nbsp;&nbsp;&nbsp;pages_2m = pages_4k = 0;<br>48.  &nbsp;&nbsp;&nbsp;&nbsp;pfn = start_pfn;<br>49.  &nbsp;&nbsp;&nbsp;&nbsp;pgd_idx = pgd_index((pfn&lt;&lt;PAGE_SHIFT) + PAGE_OFFSET);<br>50.  &nbsp;&nbsp;&nbsp;&nbsp;pgd = pgd_base + pgd_idx;<br>51.  &nbsp;&nbsp;&nbsp;&nbsp;for (; pgd_idx &lt; PTRS_PER_PGD; pgd++, pgd_idx++) {<br>52.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pmd = one_md_table_init(pgd);<br>53.  &nbsp;<br>54.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pfn &gt;= end_pfn)<br>55.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>56.  #ifdef CONFIG_X86_PAE<br>57.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pmd_idx = pmd_index((pfn&lt;&lt;PAGE_SHIFT) + PAGE_OFFSET);<br>58.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pmd += pmd_idx;<br>59.  #else<br>60.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pmd_idx = 0;<br>61.  #endif<br>62.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (; pmd_idx &lt; PTRS_PER_PMD &amp;&amp; pfn &lt; end_pfn;<br>63.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pmd++, pmd_idx++) {<br>64.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int addr = pfn </em> PAGE_SIZE + PAGE_OFFSET;<br>65.  &nbsp;<br>66.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/<em><br>67.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em> Map with big pages if possible, otherwise<br>68.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em> create normal page tables:<br>69.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em>/<br>70.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (use_pse) {<br>71.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int addr2;<br>72.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pgprot_t prot = PAGE_KERNEL_LARGE;<br>73.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/<em><br>74.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em> first pass will use the same initial<br>75.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em> identity mapping attribute + _PAGE_PSE.<br>76.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em>/<br>77.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pgprot_t init_prot =<br>78.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>pgprot(PTE_IDENT_ATTR |<br>79.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_PAGE_PSE);<br>80.  &nbsp;<br>81.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pfn &amp;= PMD_MASK &gt;&gt; PAGE_SHIFT;<br>82.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addr2 = (pfn + PTRS_PER_PTE-1) <em> PAGE_SIZE +<br>83.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PAGE_OFFSET + PAGE_SIZE-1;<br>84.  &nbsp;<br>85.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (is_kernel_text(addr) ||<br>86.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is_kernel_text(addr2))<br>87.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prot = PAGE_KERNEL_LARGE_EXEC;<br>88.  &nbsp;<br>89.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pages_2m++;<br>90.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mapping_iter == 1)<br>91.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_pmd(pmd, pfn_pmd(pfn, init_prot));<br>92.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>93.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_pmd(pmd, pfn_pmd(pfn, prot));<br>94.  &nbsp;<br>95.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pfn += PTRS_PER_PTE;<br>96.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>97.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>98.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pte = one_page_table_init(pmd);<br>99.  &nbsp;<br>100.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pte_ofs = pte_index((pfn&lt;&lt;PAGE_SHIFT) + PAGE_OFFSET);<br>101.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pte += pte_ofs;<br>102.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (; pte_ofs &lt; PTRS_PER_PTE &amp;&amp; pfn &lt; end_pfn;<br>103.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pte++, pfn++, pte_ofs++, addr += PAGE_SIZE) {<br>104.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pgprot_t prot = PAGE_KERNEL;<br>105.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/</em><br>106.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em> first pass will use the same initial<br>107.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em> identity mapping attribute.<br>108.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/<br>109.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pgprot_t init_prot = </strong>pgprot(PTE_IDENT_ATTR);<br>110.  &nbsp;<br>111.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (is_kernel_text(addr))<br>112.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prot = PAGE_KERNEL_EXEC;<br>113.  &nbsp;<br>114.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pages_4k++;<br>115.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mapping_iter == 1) {<br>116.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_pte(pte, pfn_pte(pfn, init_prot));<br>117.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;last_map_addr = (pfn &lt;&lt; PAGE_SHIFT) + PAGE_SIZE;<br>118.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else<br>119.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_pte(pte, pfn_pte(pfn, prot));<br>120.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>121.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>122.  &nbsp;&nbsp;&nbsp;&nbsp;}<br>123.  &nbsp;&nbsp;&nbsp;&nbsp;if (mapping_iter == 1) {<br>124.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/<em><br>125.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em> update direct mapping page count only in the first<br>126.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em> iteration.<br>127.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em>/<br>128.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;update_page_count(PG_LEVEL_2M, pages_2m);<br>129.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;update_page_count(PG_LEVEL_4K, pages_4k);<br>130.  &nbsp;<br>131.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/<em><br>132.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em> local global flush tlb, which will flush the previous<br>133.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em> mappings present in both small and large page TLB&#39;s.<br>134.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em>/<br>135.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__flush_tlb_all();<br>136.  &nbsp;<br>137.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/<em><br>138.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em> Second iteration will set the actual desired PTE attributes.<br>139.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/<br>140.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapping_iter = 2;<br>141.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goto repeat;<br>142.  &nbsp;&nbsp;&nbsp;&nbsp;}<br>143.  &nbsp;&nbsp;&nbsp;&nbsp;return last_map_addr;<br>144.  }<br></div>

<pre><code>&amp;nbsp;

&amp;nbsp; &amp;nbsp;&amp;nbsp;kernel_physical_mapping_init()是建立内核页表的一个关键函数，就是它负责处理物理内存的映射。swapper_pg_dir（来自于/arch/x86/kernel/head_32.s）就是页全局目录的空间了。而页表目录的空间则来自于调用one_page_table_init()申请而得，而one_page_table_init()则是通过调用关系：one_page_table_init()-&amp;gt;alloc_low_page()-&amp;gt;alloc_low_pages()-&amp;gt;memblock_reserve()最后申请而得，同时页全局目录项的熟悉也在这里设置完毕，详细代码这里就不分析了。回到kernel_physical_mapping_init()代码中，该函数里面有个标签repeat，通过mapping_iter结合goto语句的控制，该标签下的代码将会执行两次。第一次执行时，内存映射设置如同head_32.s里面的一样，将页面属性设置为PTE_IDENT_ATTR；第二次执行时，会根据内核的情况设置具体的页面属性，默认是设置为PAGE_KERNEL，但如果经过is_kernel_text判断为内核代码空间，则设置为PAGE_KERNEL_EXEC。最终建立内核页表的同时，完成内存映射。

&amp;nbsp; &amp;nbsp; &amp;nbsp;继续init_memory_mapping()的最后一个关键调用函数add_pfn_range_mapped()：
</code></pre><div id="codeText"><br><br>1.  【file：/arch/x86/mm/init.c】<br>2.  struct range pfn_mapped[E820_X_MAX];<br>3.  int nr_pfn_mapped;<br>4.  &nbsp;<br>5.  static void add_pfn_range_mapped(unsigned long start_pfn, unsigned long end_pfn)<br>6.  {<br>7.  &nbsp;&nbsp;&nbsp;&nbsp;nr_pfn_mapped = add_range_with_merge(pfn_mapped, E820_X_MAX,<br>8.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nr_pfn_mapped, start_pfn, end_pfn);<br>9.  &nbsp;&nbsp;&nbsp;&nbsp;nr_pfn_mapped = clean_sort_range(pfn_mapped, E820_X_MAX);<br>10.  &nbsp;<br>11.  &nbsp;&nbsp;&nbsp;&nbsp;max_pfn_mapped = max(max_pfn_mapped, end_pfn);<br>12.  &nbsp;<br>13.  &nbsp;&nbsp;&nbsp;&nbsp;if (start_pfn &lt; (1UL&lt;&lt;(32-PAGE_SHIFT)))<br>14.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_low_pfn_mapped = max(max_low_pfn_mapped,<br>15.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min(end_pfn, 1UL&lt;&lt;(32-PAGE_SHIFT)));<br>16.  }<br></div>

<pre><code>&amp;nbsp;

&amp;nbsp; &amp;nbsp;&amp;nbsp;该函数主要是将新增内存映射的物理页框范围加入到全局数组pfn_mapped中，其中nr_pfn_mapped用于表示数组中的有效项数量。由此一来，则可以通过内核函数pfn_range_is_mapped来判断指定的物理内存是否被映射，避免了重复映射的情况。

&amp;nbsp; &amp;nbsp;&amp;nbsp;回到init_mem_mapping()继续往下，此时memblock_bottom_up()返回的memblock.bottom_up值仍为false，所以接着走的是else分支，调用memory_map_top_down()，入参为ISA_END_ADDRESS和end。其中end则是通过max_low_pfn &amp;lt;&amp;lt; PAGE_SHIFT被设置为内核直接映射的最后页框所对应的地址。

&amp;nbsp; &amp;nbsp;&amp;nbsp;memory_map_top_down()代码实现：
</code></pre><div id="codeText"><br><br>1.  【file：/arch/x86/mm/init.c】<br>2.  /<em>*<br>3.  &nbsp;</em> memory_map_top_down - Map [map_start, map_end) top down<br>4.  &nbsp;<em> @map_start: start address of the target memory range<br>5.  &nbsp;</em> @map_end: end address of the target memory range<br>6.  &nbsp;<em><br>7.  &nbsp;</em> This function will setup direct mapping for memory range<br>8.  &nbsp;<em> [map_start, map_end) in top-down. That said, the page tables<br>9.  &nbsp;</em> will be allocated at the end of the memory, and we map the<br>10.  &nbsp;<em> memory in top-down.<br>11.  &nbsp;</em>/<br>12.  static void __init memory_map_top_down(unsigned long map_start,<br>13.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned long map_end)<br>14.  {<br>15.  &nbsp;&nbsp;&nbsp;&nbsp;unsigned long real_end, start, last_start;<br>16.  &nbsp;&nbsp;&nbsp;&nbsp;unsigned long step_size;<br>17.  &nbsp;&nbsp;&nbsp;&nbsp;unsigned long addr;<br>18.  &nbsp;&nbsp;&nbsp;&nbsp;unsigned long mapped_ram_size = 0;<br>19.  &nbsp;&nbsp;&nbsp;&nbsp;unsigned long new_mapped_ram_size;<br>20.  &nbsp;<br>21.  &nbsp;&nbsp;&nbsp;&nbsp;/<em> xen has big range in reserved near end of ram, skip it at first.</em>/<br>22.  &nbsp;&nbsp;&nbsp;&nbsp;addr = memblock_find_in_range(map_start, map_end, PMD_SIZE, PMD_SIZE);<br>23.  &nbsp;&nbsp;&nbsp;&nbsp;real_end = addr + PMD_SIZE;<br>24.  &nbsp;<br>25.  &nbsp;&nbsp;&nbsp;&nbsp;/<em> step_size need to be small so pgt_buf from BRK could cover it </em>/<br>26.  &nbsp;&nbsp;&nbsp;&nbsp;step_size = PMD_SIZE;<br>27.  &nbsp;&nbsp;&nbsp;&nbsp;max_pfn_mapped = 0; /<em> will get exact value next </em>/<br>28.  &nbsp;&nbsp;&nbsp;&nbsp;min_pfn_mapped = real_end &gt;&gt; PAGE_SHIFT;<br>29.  &nbsp;&nbsp;&nbsp;&nbsp;last_start = start = real_end;<br>30.  &nbsp;<br>31.  &nbsp;&nbsp;&nbsp;&nbsp;/<em><br>32.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em> We start from the top (end of memory) and go to the bottom.<br>33.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em> The memblock_find_in_range() gets us a block of RAM from the<br>34.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em> end of RAM in [min_pfn_mapped, max_pfn_mapped) used as new pages<br>35.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em> for page table.<br>36.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em>/<br>37.  &nbsp;&nbsp;&nbsp;&nbsp;while (last_start &gt; map_start) {<br>38.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (last_start &gt; step_size) {<br>39.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start = round_down(last_start - 1, step_size);<br>40.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (start &lt; map_start)<br>41.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start = map_start;<br>42.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else<br>43.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start = map_start;<br>44.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_mapped_ram_size = init_range_memory_mapping(start,<br>45.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;last_start);<br>46.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;last_start = start;<br>47.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min_pfn_mapped = last_start &gt;&gt; PAGE_SHIFT;<br>48.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/<em> only increase step_size after big range get mapped </em>/<br>49.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (new_mapped_ram_size &gt; mapped_ram_size)<br>50.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;step_size = get_new_step_size(step_size);<br>51.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapped_ram_size += new_mapped_ram_size;<br>52.  &nbsp;&nbsp;&nbsp;&nbsp;}<br>53.  &nbsp;<br>54.  &nbsp;&nbsp;&nbsp;&nbsp;if (real_end &lt; map_end)<br>55.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init_range_memory_mapping(real_end, map_end);<br>56.  }<br></div>

<pre><code>&amp;nbsp;

&amp;nbsp; &amp;nbsp;&amp;nbsp;memory_map_top_down()首先使用memblock_find_in_range尝试查找内存，PMD_SIZE大小的内存（4M），确认建立页表的空间足够，然后开始建立页表，其关键函数是init_range_memory_mapping()，该函数的实现：
</code></pre><div id="codeText"><br><br>1.  【file：/arch/x86/mm/init.c】<br>2.  /<em><br>3.  &nbsp;</em> We need to iterate through the E820 memory map and create direct mappings<br>4.  &nbsp;<em> for only E820_RAM and E820_KERN_RESERVED regions. We cannot simply<br>5.  &nbsp;</em> create direct mappings for all pfns from [0 to max_low_pfn) and<br>6.  &nbsp;<em> [4GB to max_pfn) because of possible memory holes in high addresses<br>7.  &nbsp;</em> that cannot be marked as UC by fixed/variable range MTRRs.<br>8.  &nbsp;<em> Depending on the alignment of E820 ranges, this may possibly result<br>9.  &nbsp;</em> in using smaller size (i.e. 4K instead of 2M or 1G) page tables.<br>10.  &nbsp;<em><br>11.  &nbsp;</em> init_mem_mapping() calls init_range_memory_mapping() with big range.<br>12.  &nbsp;<em> That range would have hole in the middle or ends, and only ram parts<br>13.  &nbsp;</em> will be mapped in init_range_memory_mapping().<br>14.  &nbsp;<em>/<br>15.  static unsigned long __init init_range_memory_mapping(<br>16.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned long r_start,<br>17.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned long r_end)<br>18.  {<br>19.  &nbsp;&nbsp;&nbsp;&nbsp;unsigned long start_pfn, end_pfn;<br>20.  &nbsp;&nbsp;&nbsp;&nbsp;unsigned long mapped_ram_size = 0;<br>21.  &nbsp;&nbsp;&nbsp;&nbsp;int i;<br>22.  &nbsp;<br>23.  &nbsp;&nbsp;&nbsp;&nbsp;for_each_mem_pfn_range(i, MAX_NUMNODES, &amp;start_pfn, &amp;end_pfn, NULL) {<br>24.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u64 start = clamp_val(PFN_PHYS(start_pfn), r_start, r_end);<br>25.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u64 end = clamp_val(PFN_PHYS(end_pfn), r_start, r_end);<br>26.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (start &gt;= end)<br>27.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>28.  &nbsp;<br>29.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/</em><br>30.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em> if it is overlapping with brk pgt, we need to<br>31.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em> alloc pgt buf from memblock instead.<br>32.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/<br>33.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;can_use_brk_pgt = max(start, (u64)pgt_buf_end&lt;&lt;PAGE_SHIFT) &gt;=<br>34.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min(end, (u64)pgt_buf_top&lt;&lt;PAGE_SHIFT);<br>35.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init_memory_mapping(start, end);<br>36.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapped_ram_size += end - start;<br>37.  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;can_use_brk_pgt = true;<br>38.  &nbsp;&nbsp;&nbsp;&nbsp;}<br>39.  &nbsp;<br>40.  &nbsp;&nbsp;&nbsp;&nbsp;return mapped_ram_size;<br>41.  }<br></div>

<pre><code>&amp;nbsp;

&amp;nbsp; &amp;nbsp;&amp;nbsp;可以看到init_range_memory_mapping()调用了前面刚分析的init_memory_mapping()函数，由此可知，它将完成内核直接映射区（低端内存）的页表建立。此外可以注意到pgt_buf_end和pgt_buf_top的使用，在init_memory_mapping()函数调用前，变量can_use_brk_pgt的设置主要是为了避免内存空间重叠，仍然使用页表缓冲区空间。不过这只是64bit系统上才会出现的情况，而32bit系统上面则没有，因为32bit系统的kernel_physical_mapping_init()并不使用alloc_low_page()申请内存，所以不涉及。

&amp;nbsp; &amp;nbsp;&amp;nbsp;至此，内核低端内存页表建立完毕。

[http://blog.chinaunix.net/uid-26859697-id-4592327.html](http://blog.chinaunix.net/uid-26859697-id-4592327.html)
</code></pre></div>
    
      
      <div class="toc-wrapper">
        <div class="toc-scroll">
          <div class="toc-middle">
            
          </div>
        </div>
      </div>
    
  
</article>

      <footer class="footer">
  <p class="footer-text"></p>
</footer>

    </article>

    <script src="/js/to-top.js"></script>
    <script src="/js/search.js"></script>
  </body>
</html>
