<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>打造一套客户端功能最全的APM监控系统 | 张天师</title>
  <meta name="keywords" content=" 监控 ">
  <meta name="description" content="打造一套客户端功能最全的APM监控系统 | 张天师">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="本博客hexo主题基于hexo-theme-3-hexo 修改而来 https:&#x2F;&#x2F;github.com&#x2F;yelog&#x2F;hexo-theme-3-hexo">
<meta property="og:type" content="website">
<meta property="og:title" content="about">
<meta property="og:url" content="http://zhangyu.info/about/index.html">
<meta property="og:site_name" content="张天师">
<meta property="og:description" content="本博客hexo主题基于hexo-theme-3-hexo 修改而来 https:&#x2F;&#x2F;github.com&#x2F;yelog&#x2F;hexo-theme-3-hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-15T13:48:47.000Z">
<meta property="article:modified_time" content="2021-03-15T15:05:42.638Z">
<meta property="article:author" content="张天师">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/favicon.ico">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="张天师" type="application/atom+xml">
</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>张天师</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/mayou33"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(49)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="linux">
                        
                        linux
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="架构">
                        
                        架构
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="监控">
                        
                        监控
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="nginx">
                        
                        nginx
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="API网关">
                        
                        API网关
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="containerd">
                        
                        containerd
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="Ingress">
                        
                        Ingress
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="k8s">
                        
                        k8s
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="Kubernetes">
                        
                        Kubernetes
                        <small>(9)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="nacos">
                        
                        nacos
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="PaaS">
                        
                        PaaS
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="Scrum">
                        
                        Scrum
                        <small>(11)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="SpringBoot">
                        
                        SpringBoot
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="SRE">
                        
                        SRE
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="优化">
                        
                        优化
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="公有云">
                        
                        公有云
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="微服务">
                        
                        微服务
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="我假装讲，你假装看">
                        
                        我假装讲，你假装看
                        <small>(3)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="日志">
                        
                        日志
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="消息系统">
                        
                        消息系统
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="职业发展">
                        
                        职业发展
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="49">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="https://blog.csdn.net/shaochenshuo">数据库shao</a></li>
            
            <li><a target="_blank" href="https://blog.huoding.com/">火丁笔记</a></li>
            
            <li><a target="_blank" href="https://canon88.github.io/">网络安全canon</a></li>
            
            <li><a target="_blank" href="https://www.tecmint.com/">linux学习</a></li>
            
            <li><a target="_blank" href="https://www.makelinux.net/reference/">linux技术参考</a></li>
            
            <li><a target="_blank" href="https://coolshell.cn">酷壳CoolShell</a></li>
            
            <li><a target="_blank" href="http://www.brendangregg.com/">Systems-Performance</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>API网关</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Cilium</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>containerd</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>flannel</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Ingress</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>k8s</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Kubernetes</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>linux</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>nacos</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>nginx</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>PaaS</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Pulsar</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Scrum</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>SpringBoot</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>SRE</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>优化</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>公有云</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>微服务</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>性能</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>我假装讲，你假装看</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>日志</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>架构</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>监控</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>职业发展</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        <a  class="全部文章 微服务 "
           href="/2022/05/28/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"
           data-tag="微服务"
           data-author="" >
            <span class="post-title" title="云原生微服务最佳实践">云原生微服务最佳实践</span>
            <span class="post-date" title="2022-05-28 00:00:00">2022/05/28</span>
        </a>
        
        <a  class="全部文章 微服务 "
           href="/2022/05/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E4%BD%B3%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F/"
           data-tag="微服务"
           data-author="" >
            <span class="post-title" title="微服务之间的最佳调用方式">微服务之间的最佳调用方式</span>
            <span class="post-date" title="2022-05-28 00:00:00">2022/05/28</span>
        </a>
        
        <a  class="全部文章 nacos "
           href="/2022/05/01/%E8%A7%A3%E5%86%B3gateway%E4%BD%BF%E7%94%A8nacos%E9%87%8D%E5%90%AF%E6%8A%A5503ServiceUnavailable%E9%97%AE%E9%A2%98/"
           data-tag="nacos"
           data-author="" >
            <span class="post-title" title="解决gateway使用nacos重启报503ServiceUnavailable问题">解决gateway使用nacos重启报503ServiceUnavailable问题</span>
            <span class="post-date" title="2022-05-01 00:00:00">2022/05/01</span>
        </a>
        
        <a  class="全部文章 监控 "
           href="/2022/05/01/%E4%BB%8E%E7%9B%91%E6%8E%A7%E5%88%B0%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7%EF%BC%8C%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E3%80%81%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E3%80%81%E8%81%8C%E8%B4%A3%E5%88%86%E5%B7%A5%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%98%E5%8C%96/"
           data-tag="监控"
           data-author="" >
            <span class="post-title" title="从监控到可观测性，设计思想、技术选型、职责分工都有哪些变化">从监控到可观测性，设计思想、技术选型、职责分工都有哪些变化</span>
            <span class="post-date" title="2022-05-01 00:00:00">2022/05/01</span>
        </a>
        
        <a  class="全部文章 SpringBoot "
           href="/2022/04/30/SpringBoot%E6%80%A7%E8%83%BD%E5%A4%AA%E5%B7%AE,%E6%95%99%E4%BD%A0%E5%87%A0%E6%8B%9B%E8%BD%BB%E6%9D%BE%E6%90%9E%E5%AE%9A/"
           data-tag="SpringBoot"
           data-author="" >
            <span class="post-title" title="SpringBoot性能太差,教你几招轻松搞定">SpringBoot性能太差,教你几招轻松搞定</span>
            <span class="post-date" title="2022-04-30 00:00:00">2022/04/30</span>
        </a>
        
        <a  class="全部文章 API网关 "
           href="/2022/04/30/API%E7%BD%91%E5%85%B3%E7%9A%84%E5%8A%9F%E8%83%BD%E7%94%A8%E9%80%94%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"
           data-tag="API网关"
           data-author="" >
            <span class="post-title" title="API网关的功能用途及实现方式">API网关的功能用途及实现方式</span>
            <span class="post-date" title="2022-04-30 00:00:00">2022/04/30</span>
        </a>
        
        <a  class="全部文章 PaaS "
           href="/2022/04/30/%E5%9F%BA%E4%BA%8E%E5%AE%B9%E5%99%A8%E7%9A%84PaaS%E6%B7%B7%E5%90%88%E4%BA%91%E7%9A%84%E5%87%A0%E7%A7%8D%E5%BD%A2%E5%BC%8F/"
           data-tag="PaaS"
           data-author="" >
            <span class="post-title" title="基于容器的PaaS混合云的几种形式">基于容器的PaaS混合云的几种形式</span>
            <span class="post-date" title="2022-04-30 00:00:00">2022/04/30</span>
        </a>
        
        <a  class="全部文章 k8s "
           href="/2022/04/30/%E6%89%93%E7%A0%B4Dockershim%E7%A7%BB%E9%99%A4%E7%84%A6%E8%99%91,%E4%B8%94%E7%9C%8BRancher%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9/"
           data-tag="k8s"
           data-author="" >
            <span class="post-title" title="打破Dockershim移除焦虑,且看Rancher如何应对">打破Dockershim移除焦虑,且看Rancher如何应对</span>
            <span class="post-date" title="2022-04-30 00:00:00">2022/04/30</span>
        </a>
        
        <a  class="全部文章 API网关 "
           href="/2022/04/30/API%E7%BD%91%E5%85%B3%E4%B8%BAK8s%E5%AE%B9%E5%99%A8%E5%BA%94%E7%94%A8%E9%9B%86%E7%BE%A4%E6%8F%90%E4%BE%9B%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%8E%A5%E5%85%A5%E8%83%BD%E5%8A%9B/"
           data-tag="API网关"
           data-author="" >
            <span class="post-title" title="API网关为K8s容器应用集群提供强大的接入能力">API网关为K8s容器应用集群提供强大的接入能力</span>
            <span class="post-date" title="2022-04-30 00:00:00">2022/04/30</span>
        </a>
        
        <a  class="全部文章 日志 "
           href="/2022/04/30/%E4%BA%91%E5%8E%9F%E7%94%9F%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86-%E5%AD%98%E5%82%A8-%E5%88%86%E6%9E%90%E5%AE%9E%E8%B7%B5/"
           data-tag="日志"
           data-author="" >
            <span class="post-title" title="云原生环境下的日志采集、存储、分析实践">云原生环境下的日志采集、存储、分析实践</span>
            <span class="post-date" title="2022-04-30 00:00:00">2022/04/30</span>
        </a>
        
        <a  class="全部文章 公有云 "
           href="/2022/04/30/%E5%85%AC%E6%9C%89%E4%BA%91%E9%99%8D%E6%9C%AC%E5%A2%9E%E6%95%88%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"
           data-tag="公有云"
           data-author="" >
            <span class="post-title" title="公有云降本增效最佳实践">公有云降本增效最佳实践</span>
            <span class="post-date" title="2022-04-30 00:00:00">2022/04/30</span>
        </a>
        
        <a  class="全部文章 我假装讲，你假装看 "
           href="/2022/04/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E4%B8%80%E8%BE%B9%E5%A4%A7%E8%A7%84%E6%A8%A1%E8%A3%81%E5%91%98%E5%8F%88%E4%B8%80%E8%BE%B9%E6%8B%9B%E8%81%98/"
           data-tag="我假装讲，你假装看"
           data-author="" >
            <span class="post-title" title="为什么互联网大厂一边大规模裁员又一边招聘">为什么互联网大厂一边大规模裁员又一边招聘</span>
            <span class="post-date" title="2022-04-23 00:00:00">2022/04/23</span>
        </a>
        
        <a  class="全部文章 linux "
           href="/2022/04/23/Linux%E7%9A%84CPU%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8/"
           data-tag="linux"
           data-author="" >
            <span class="post-title" title="Linux的CPU上下文切换深入探讨">Linux的CPU上下文切换深入探讨</span>
            <span class="post-date" title="2022-04-23 00:00:00">2022/04/23</span>
        </a>
        
        <a  class="全部文章 架构 "
           href="/2022/04/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
           data-tag="架构"
           data-author="" >
            <span class="post-title" title="微服务架构及设计模式">微服务架构及设计模式</span>
            <span class="post-date" title="2022-04-23 00:00:00">2022/04/23</span>
        </a>
        
        <a  class="全部文章 监控 "
           href="/2022/04/23/%E6%89%93%E9%80%A0%E4%B8%80%E5%A5%97%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8A%9F%E8%83%BD%E6%9C%80%E5%85%A8%E7%9A%84APM%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/"
           data-tag="监控"
           data-author="" >
            <span class="post-title" title="打造一套客户端功能最全的APM监控系统">打造一套客户端功能最全的APM监控系统</span>
            <span class="post-date" title="2022-04-23 00:00:00">2022/04/23</span>
        </a>
        
        <a  class="全部文章 架构 "
           href="/2022/04/23/%E4%BC%81%E4%B8%9A%E5%AE%8C%E6%88%90%E4%BA%91%E8%BD%AC%E5%9E%8B%E7%9A%84%E6%88%90%E5%8A%9F%E4%B9%8B%E9%81%93-%E4%BA%91%E6%88%90%E6%9C%AC%E4%BC%98%E5%8C%96%E7%AE%A1%E7%90%86/"
           data-tag="架构"
           data-author="" >
            <span class="post-title" title="企业完成云转型的成功之道：云成本优化管理">企业完成云转型的成功之道：云成本优化管理</span>
            <span class="post-date" title="2022-04-23 00:00:00">2022/04/23</span>
        </a>
        
        <a  class="全部文章 优化 "
           href="/2022/04/12/%E8%B0%88%E8%B0%88%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%A5%BD%E7%BD%91%E7%AB%99%E7%9A%84URL/"
           data-tag="优化"
           data-author="" >
            <span class="post-title" title="谈谈如何设计好网站的URL">谈谈如何设计好网站的URL</span>
            <span class="post-date" title="2022-04-12 00:00:00">2022/04/12</span>
        </a>
        
        <a  class="全部文章 Scrum "
           href="/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC01%E8%AF%BE-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%92%8CScrumMaster%E5%9F%BA%E6%9C%AC%E5%8A%9F%E5%9B%9B%E9%83%A8%E6%9B%B2/"
           data-tag="Scrum"
           data-author="" >
            <span class="post-title" title="敏捷教练第01课-敏捷教练和ScrumMaster基本功四部曲">敏捷教练第01课-敏捷教练和ScrumMaster基本功四部曲</span>
            <span class="post-date" title="2022-04-12 00:00:00">2022/04/12</span>
        </a>
        
        <a  class="全部文章 Scrum "
           href="/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC02%E8%AF%BE-%E5%82%A8%E5%A4%87-Scrum%E7%B2%BE%E8%A6%81/"
           data-tag="Scrum"
           data-author="" >
            <span class="post-title" title="敏捷教练第02课-储备-Scrum精要">敏捷教练第02课-储备-Scrum精要</span>
            <span class="post-date" title="2022-04-12 00:00:00">2022/04/12</span>
        </a>
        
        <a  class="全部文章 Scrum "
           href="/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC03%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E7%B2%BE%E8%A6%81/"
           data-tag="Scrum"
           data-author="" >
            <span class="post-title" title="敏捷教练第03课-储备-用户故事精要">敏捷教练第03课-储备-用户故事精要</span>
            <span class="post-date" title="2022-04-12 00:00:00">2022/04/12</span>
        </a>
        
        <a  class="全部文章 Scrum "
           href="/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC04%E8%AF%BE-%E5%82%A8%E5%A4%87-scrum%E7%9A%8420%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%BC%8F/"
           data-tag="Scrum"
           data-author="" >
            <span class="post-title" title="敏捷教练第04课-储备-scrum的20个子模式">敏捷教练第04课-储备-scrum的20个子模式</span>
            <span class="post-date" title="2022-04-12 00:00:00">2022/04/12</span>
        </a>
        
        <a  class="全部文章 Scrum "
           href="/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC05%E8%AF%BE-%E5%82%A8%E5%A4%87-%E7%B2%BE%E7%9B%8A%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81/"
           data-tag="Scrum"
           data-author="" >
            <span class="post-title" title="敏捷教练第05课-储备-精益体系精要">敏捷教练第05课-储备-精益体系精要</span>
            <span class="post-date" title="2022-04-12 00:00:00">2022/04/12</span>
        </a>
        
        <a  class="全部文章 Scrum "
           href="/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC08%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8B%EF%BC%89/"
           data-tag="Scrum"
           data-author="" >
            <span class="post-title" title="敏捷教练第08课-技巧-敏捷教练的六脉神剑（下）">敏捷教练第08课-技巧-敏捷教练的六脉神剑（下）</span>
            <span class="post-date" title="2022-04-12 00:00:00">2022/04/12</span>
        </a>
        
        <a  class="全部文章 Scrum "
           href="/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC09%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%89%E5%BC%8F/"
           data-tag="Scrum"
           data-author="" >
            <span class="post-title" title="敏捷教练第09课-技巧-敏捷教练的提升三式">敏捷教练第09课-技巧-敏捷教练的提升三式</span>
            <span class="post-date" title="2022-04-12 00:00:00">2022/04/12</span>
        </a>
        
        <a  class="全部文章 Scrum "
           href="/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC10%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%8C%81%E7%BB%AD%E6%94%B9%E5%96%84%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E6%96%B9%E6%B3%95/"
           data-tag="Scrum"
           data-author="" >
            <span class="post-title" title="敏捷教练第10课-技巧-持续改善和系统思考方法">敏捷教练第10课-技巧-持续改善和系统思考方法</span>
            <span class="post-date" title="2022-04-12 00:00:00">2022/04/12</span>
        </a>
        
        <a  class="全部文章 Scrum "
           href="/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC11%E8%AF%BE-%E5%AE%9E%E6%88%98-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E5%AE%9E%E6%88%98%E5%91%A8%E6%9C%9FV%E5%BD%A2%E5%85%AD%E6%AD%A5%E6%B3%95/"
           data-tag="Scrum"
           data-author="" >
            <span class="post-title" title="敏捷教练第11课-实战-敏捷教练实战周期V形六步法">敏捷教练第11课-实战-敏捷教练实战周期V形六步法</span>
            <span class="post-date" title="2022-04-12 00:00:00">2022/04/12</span>
        </a>
        
        <a  class="全部文章 Scrum "
           href="/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC06%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BF%83%E6%B3%95/"
           data-tag="Scrum"
           data-author="" >
            <span class="post-title" title="敏捷教练第06课-技巧-敏捷教练的四种心法">敏捷教练第06课-技巧-敏捷教练的四种心法</span>
            <span class="post-date" title="2022-04-12 00:00:00">2022/04/12</span>
        </a>
        
        <a  class="全部文章 Scrum "
           href="/2022/04/12/%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%AC%AC07%E8%AF%BE-%E6%8A%80%E5%B7%A7-%E6%95%8F%E6%8D%B7%E6%95%99%E7%BB%83%E7%9A%84%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91%EF%BC%88%E4%B8%8A%EF%BC%89/"
           data-tag="Scrum"
           data-author="" >
            <span class="post-title" title="敏捷教练第07课-技巧-敏捷教练的六脉神剑（上）">敏捷教练第07课-技巧-敏捷教练的六脉神剑（上）</span>
            <span class="post-date" title="2022-04-12 00:00:00">2022/04/12</span>
        </a>
        
        <a  class="全部文章 公有云 "
           href="/2022/03/08/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8ECS%E9%80%89%E8%B4%AD%E6%8C%87%E5%8D%97%E5%8F%8A%E7%9C%81%E9%92%B1%E6%B3%95%E5%AE%9D/"
           data-tag="公有云"
           data-author="" >
            <span class="post-title" title="云服务器ECS选购指南及省钱法宝">云服务器ECS选购指南及省钱法宝</span>
            <span class="post-date" title="2022-03-08 00:00:00">2022/03/08</span>
        </a>
        
        <a  class="全部文章 SRE "
           href="/2022/03/08/%E9%98%BF%E9%87%8C%E4%BA%91%E5%BC%B9%E6%80%A7%E8%AE%A1%E7%AE%97%E7%A0%94%E5%8F%91%E5%9B%A2%E9%98%9F%E5%A6%82%E4%BD%95%E4%BB%8E0%E5%88%B01%E8%87%AA%E5%BB%BASRE%E4%BD%93%E7%B3%BB/"
           data-tag="SRE"
           data-author="" >
            <span class="post-title" title="阿里云弹性计算研发团队如何从0到1自建SRE体系">阿里云弹性计算研发团队如何从0到1自建SRE体系</span>
            <span class="post-date" title="2022-03-08 00:00:00">2022/03/08</span>
        </a>
        
        <a  class="全部文章 SRE "
           href="/2022/03/08/%E4%BA%91%E4%B8%8A%E8%B5%84%E6%BA%90%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E6%96%B0%E6%A8%A1%E5%BC%8F/"
           data-tag="SRE"
           data-author="" >
            <span class="post-title" title="云上资源自动化部署新模式">云上资源自动化部署新模式</span>
            <span class="post-date" title="2022-03-08 00:00:00">2022/03/08</span>
        </a>
        
        <a  class="全部文章 Kubernetes "
           href="/2021/05/31/cotainer-init/"
           data-tag="Kubernetes"
           data-author="" >
            <span class="post-title" title="开启shareProcessNamespace后容器异常">开启shareProcessNamespace后容器异常</span>
            <span class="post-date" title="2021-05-31 00:00:00">2021/05/31</span>
        </a>
        
        <a  class="全部文章 Kubernetes "
           href="/2021/05/31/docker-shell-signal/"
           data-tag="Kubernetes"
           data-author="" >
            <span class="post-title" title="k8s中shell脚本启动如何传递信号">k8s中shell脚本启动如何传递信号</span>
            <span class="post-date" title="2021-05-31 00:00:00">2021/05/31</span>
        </a>
        
        <a  class="全部文章 Kubernetes "
           href="/2021/05/31/enforce-audit-policy-in-k8s/"
           data-tag="Kubernetes"
           data-author="" >
            <span class="post-title" title="在Kubernetes中实施审计策略">在Kubernetes中实施审计策略</span>
            <span class="post-date" title="2021-05-31 00:00:00">2021/05/31</span>
        </a>
        
        <a  class="全部文章 Kubernetes "
           href="/2021/05/26/Cilium-Network-Overview/"
           data-tag="Cilium"
           data-author="" >
            <span class="post-title" title="Cilium网络概述">Cilium网络概述</span>
            <span class="post-date" title="2021-05-26 00:00:00">2021/05/26</span>
        </a>
        
        <a  class="全部文章 Kubernetes "
           href="/2021/05/19/generating-yaml-for-k8s/"
           data-tag="Kubernetes"
           data-author="" >
            <span class="post-title" title="快速生成k8s的yaml配置的4种方法">快速生成k8s的yaml配置的4种方法</span>
            <span class="post-date" title="2021-05-19 00:00:00">2021/05/19</span>
        </a>
        
        <a  class="全部文章 日志 "
           href="/2021/04/28/fklek-to-k8s-log/"
           data-tag="日志"
           data-author="" >
            <span class="post-title" title="使用fklek搭建Kubernetes日志收集工具栈">使用fklek搭建Kubernetes日志收集工具栈</span>
            <span class="post-date" title="2021-04-28 00:00:00">2021/04/28</span>
        </a>
        
        <a  class="全部文章 我假装讲，你假装看 "
           href="/2021/04/27/%E5%8F%AA%E6%9C%89%E9%BB%91%E8%AF%9D%E6%89%8D%E8%83%BD%E6%8B%AF%E6%95%91%E4%BA%92%E8%81%94%E7%BD%91%E4%BA%BA/"
           data-tag="我假装讲，你假装看"
           data-author="" >
            <span class="post-title" title="只有黑话，才能拯救互联网人">只有黑话，才能拯救互联网人</span>
            <span class="post-date" title="2021-04-27 00:00:00">2021/04/27</span>
        </a>
        
        <a  class="全部文章 我假装讲，你假装看 "
           href="/2021/04/27/%E6%BC%AB%E7%94%BB%E4%B8%80%E4%B8%AANB%E4%BA%92%E8%81%94%E7%BD%91%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%8A%E7%BA%BF%E8%BF%87%E7%A8%8B/"
           data-tag="我假装讲，你假装看"
           data-author="" >
            <span class="post-title" title="漫画一个NB互联网项目的上线过程">漫画一个NB互联网项目的上线过程</span>
            <span class="post-date" title="2021-04-27 00:00:00">2021/04/27</span>
        </a>
        
        <a  class="全部文章 消息系统 "
           href="/2021/04/24/comparing-pulsar-and-kafka-from-a-ctos-point-of-view/"
           data-tag="Pulsar"
           data-author="" >
            <span class="post-title" title="Pulsar vs Kafka，CTO 如何抉择">Pulsar vs Kafka，CTO 如何抉择</span>
            <span class="post-date" title="2021-04-24 00:00:00">2021/04/24</span>
        </a>
        
        <a  class="全部文章 Kubernetes "
           href="/2021/04/21/kubernetes-best-practices-in-production/"
           data-tag="Kubernetes"
           data-author="" >
            <span class="post-title" title="生产环境中的Kubernetes最佳实践">生产环境中的Kubernetes最佳实践</span>
            <span class="post-date" title="2021-04-21 00:00:00">2021/04/21</span>
        </a>
        
        <a  class="全部文章 职业发展 "
           href="/2021/04/19/jishuchengzhang/"
           data-tag="职业发展"
           data-author="" >
            <span class="post-title" title="你的技术成长战略是什么">你的技术成长战略是什么</span>
            <span class="post-date" title="2021-04-19 00:00:00">2021/04/19</span>
        </a>
        
        <a  class="全部文章 containerd "
           href="/2021/04/12/nerdctl-to-containerd/"
           data-tag="containerd"
           data-author="" >
            <span class="post-title" title="使用nerdctl玩转containerd">使用nerdctl玩转containerd</span>
            <span class="post-date" title="2021-04-12 00:00:00">2021/04/12</span>
        </a>
        
        <a  class="全部文章 Kubernetes "
           href="/2021/04/09/Kubernetes-network/"
           data-tag="Kubernetes"
           data-author="" >
            <span class="post-title" title="Kubernetes网络和云厂商实践浅析">Kubernetes网络和云厂商实践浅析</span>
            <span class="post-date" title="2021-04-09 00:00:00">2021/04/09</span>
        </a>
        
        <a  class="全部文章 Ingress "
           href="/2021/04/08/Technical-selection-of-Kubernetes-Ingress-controller/"
           data-tag="Ingress"
           data-author="" >
            <span class="post-title" title="Kubernetes Ingress 控制器的技术选型技巧">Kubernetes Ingress 控制器的技术选型技巧</span>
            <span class="post-date" title="2021-04-08 00:00:00">2021/04/08</span>
        </a>
        
        <a  class="全部文章 Kubernetes "
           href="/2021/04/08/Kubernetes-remen/"
           data-tag="Kubernetes"
           data-author="" >
            <span class="post-title" title="Kubernetes入门-进阶实战">Kubernetes入门-进阶实战</span>
            <span class="post-date" title="2021-04-08 00:00:00">2021/04/08</span>
        </a>
        
        <a  class="全部文章 Kubernetes "
           href="/2021/03/24/Flannel-Calico/"
           data-tag="flannel"
           data-author="" >
            <span class="post-title" title="Flannel-Calico怎么选择">Flannel-Calico怎么选择</span>
            <span class="post-date" title="2021-03-24 00:00:00">2021/03/24</span>
        </a>
        
        <a  class="全部文章 nginx "
           href="/2021/03/15/nginx-knowledge-graph/"
           data-tag="nginx"
           data-author="" >
            <span class="post-title" title="nginx核心知识100讲知识图谱">nginx核心知识100讲知识图谱</span>
            <span class="post-date" title="2021-03-15 00:00:00">2021/03/15</span>
        </a>
        
        <a  class="全部文章 优化 "
           href="/2021/03/15/performance-optimize-your-program/"
           data-tag="性能"
           data-author="" >
            <span class="post-title" title="性能之癫-优化你的程序">性能之癫-优化你的程序</span>
            <span class="post-date" title="2021-03-15 00:00:00">2021/03/15</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-打造一套客户端功能最全的APM监控系统" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">打造一套客户端功能最全的APM监控系统</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="监控">监控</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color3">监控</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2022-04-23 22:24:50'>2022-04-23 00:00</time>
        
    </div>
    <div class="article-meta">
        
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%93%E9%80%A0%E4%B8%80%E5%A5%97%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8A%9F%E8%83%BD%E6%9C%80%E5%85%A8%E7%9A%84-APM-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F"><span class="toc-text">打造一套客户端功能最全的 APM 监控系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%8D%A1%E9%A1%BF%E7%9B%91%E6%8E%A7"><span class="toc-text">一、卡顿监控</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%B1%8F%E5%B9%95%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-text">1. 屏幕绘制原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8D%A1%E9%A1%BF%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">2. 卡顿产生的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-APM-%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7%E5%8D%A1%E9%A1%BF%E5%B9%B6%E4%B8%8A%E6%8A%A5"><span class="toc-text">3. APM 如何监控卡顿并上报</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-RunLoop-%E7%8A%B6%E6%80%81%E7%9B%91%E5%90%AC%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">3.1 RunLoop 状态监听的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%AD%90%E7%BA%BF%E7%A8%8B-ping-%E4%B8%BB%E7%BA%BF%E7%A8%8B%E7%9B%91%E5%90%AC%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">3.2 子线程 ping 主线程监听的方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A0%86%E6%A0%88-dump"><span class="toc-text">4. 堆栈 dump</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Mach-Task-%E7%9F%A5%E8%AF%86"><span class="toc-text">5. Mach Task 知识</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-App-%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4%E7%9B%91%E6%8E%A7"><span class="toc-text">二、 App 启动时间监控</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-App-%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4%E7%9A%84%E7%9B%91%E6%8E%A7"><span class="toc-text">1. App 启动时间的监控</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BA%BF%E4%B8%8A%E7%9B%91%E6%8E%A7%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4%E5%B0%B1%E5%A5%BD%EF%BC%8C%E4%BD%86%E6%98%AF%E5%9C%A8%E5%BC%80%E5%8F%91%E9%98%B6%E6%AE%B5%E9%9C%80%E8%A6%81%E5%AF%B9%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4%E5%81%9A%E4%BC%98%E5%8C%96%E3%80%82"><span class="toc-text">2. 线上监控启动时间就好，但是在开发阶段需要对启动时间做优化。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%8A%A0%E8%BD%BD-Dylib"><span class="toc-text">2.1 加载 Dylib</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-Rebase-amp-amp-Binding"><span class="toc-text">2.2 Rebase &amp;&amp; Binding</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-Initializers"><span class="toc-text">2.3 Initializers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-pre-main-%E9%98%B6%E6%AE%B5%E5%BD%B1%E5%93%8D%E5%9B%A0%E7%B4%A0"><span class="toc-text">2.4 pre-main 阶段影响因素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-main-%E9%98%B6%E6%AE%B5%E4%BC%98%E5%8C%96"><span class="toc-text">2.5 main 阶段优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4%E5%8A%A0%E9%80%9F"><span class="toc-text">3. 启动时间加速</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81-CPU-%E4%BD%BF%E7%94%A8%E7%8E%87%E7%9B%91%E6%8E%A7"><span class="toc-text">三、 CPU 使用率监控</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-CPU-%E6%9E%B6%E6%9E%84"><span class="toc-text">1. CPU 架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E4%BF%A1%E6%81%AF"><span class="toc-text">2. 获取线程信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81-OOM-%E9%97%AE%E9%A2%98"><span class="toc-text">四、 OOM 问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%87%86%E5%A4%87"><span class="toc-text">1. 基础知识准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-iOS-%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86"><span class="toc-text">2. iOS 内存知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%8E%B7%E5%8F%96%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF"><span class="toc-text">3. 获取内存信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E9%80%9A%E8%BF%87-JetsamEvent-%E6%97%A5%E5%BF%97%E8%AE%A1%E7%AE%97%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6%E5%80%BC"><span class="toc-text">3.1 通过 JetsamEvent 日志计算内存限制值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%BC%80%E5%8F%91%E8%80%85%E4%BB%AC%E6%95%B4%E7%90%86%E6%89%80%E5%BE%97"><span class="toc-text">3.2 开发者们整理所得</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E8%A7%A6%E5%8F%91%E5%BD%93%E5%89%8D-App-%E7%9A%84-high-water-mark"><span class="toc-text">3.3 触发当前 App 的 high water mark</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E9%80%82%E7%94%A8%E4%BA%8E-iOS13-%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F"><span class="toc-text">3.4 适用于 iOS13 系统的获取方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E9%80%9A%E8%BF%87-XNU-%E8%8E%B7%E5%8F%96%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6%E5%80%BC"><span class="toc-text">3.5 通过 XNU 获取内存限制值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E5%88%A4%E5%AE%9A%E5%8F%91%E7%94%9F%E4%BA%86-OOM"><span class="toc-text">4. 如何判定发生了 OOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86"><span class="toc-text">5. 内存信息收集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%BC%80%E5%8F%91%E9%98%B6%E6%AE%B5%E9%92%88%E5%AF%B9%E5%86%85%E5%AD%98%E6%88%91%E4%BB%AC%E8%83%BD%E5%81%9A%E4%BA%9B%E4%BB%80%E4%B9%88"><span class="toc-text">6. 开发阶段针对内存我们能做些什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%8E%B0%E7%8A%B6%E5%8F%8A%E5%85%B6%E6%94%B9%E8%BF%9B"><span class="toc-text">7. 现状及其改进</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81-App-%E7%BD%91%E7%BB%9C%E7%9B%91%E6%8E%A7"><span class="toc-text">五、 App 网络监控</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-App-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B"><span class="toc-text">1. App 网络请求过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%9B%91%E6%8E%A7%E5%8E%9F%E7%90%86"><span class="toc-text">2. 监控原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%96%B9%E6%A1%88%E4%B8%80%EF%BC%9ANSURLProtocol-%E7%9B%91%E6%8E%A7-App-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82"><span class="toc-text">2.1 方案一：NSURLProtocol 监控 App 网络请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%96%B9%E6%A1%88%E4%BA%8C%EF%BC%9ANSURLProtocol-%E7%9B%91%E6%8E%A7-App-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E4%B9%8B%E9%BB%91%E9%AD%94%E6%B3%95%E7%AF%87"><span class="toc-text">2.2 方案二：NSURLProtocol 监控 App 网络请求之黑魔法篇</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E6%96%B9%E6%A1%88%E4%B8%89%EF%BC%9AHook"><span class="toc-text">2.3 方案三：Hook</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-1-%E6%96%B9%E6%B3%95%E4%B8%80"><span class="toc-text">2.3.1 方法一</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-2-%E6%96%B9%E6%B3%95%E4%BA%8C"><span class="toc-text">2.3.2 方法二</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E6%96%B9%E6%A1%88%E5%9B%9B%EF%BC%9A%E7%9B%91%E6%8E%A7-App-%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82"><span class="toc-text">2.4 方案四：监控 App 常见网络请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-iOS-%E6%B5%81%E9%87%8F%E7%9B%91%E6%8E%A7"><span class="toc-text">2.5 iOS 流量监控</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-1-HTTP-%E8%AF%B7%E6%B1%82%E3%80%81%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">2.5.1 HTTP 请求、响应数据结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-2-%E9%97%AE%E9%A2%98"><span class="toc-text">2.5.2 问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-3-%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.5.3 技术实现</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#2-5-3-1-Request-%E9%83%A8%E5%88%86"><span class="toc-text">2.5.3.1 Request 部分</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-5-3-2-Resquest-%E9%83%A8%E5%88%86"><span class="toc-text">2.5.3.2 Resquest 部分</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81-%E7%94%B5%E9%87%8F%E6%B6%88%E8%80%97"><span class="toc-text">六、 电量消耗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E7%94%B5%E9%87%8F"><span class="toc-text">1. 如何获取电量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98"><span class="toc-text">2. 定位问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BC%80%E5%8F%91%E9%98%B6%E6%AE%B5%E9%92%88%E5%AF%B9%E7%94%B5%E9%87%8F%E6%B6%88%E8%80%97%E6%88%91%E4%BB%AC%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-text">3. 开发阶段针对电量消耗我们能做什么</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81-Crash-%E7%9B%91%E6%8E%A7"><span class="toc-text">七、 Crash 监控</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%82%E5%B8%B8%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE"><span class="toc-text">1. 异常相关知识回顾</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-Mach-%E5%B1%82%E5%AF%B9%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">1.1 Mach 层对异常的处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-BSD-%E5%B1%82%E5%AF%B9%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">1.2 BSD 层对异常的处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Crash-%E6%94%B6%E9%9B%86%E6%96%B9%E5%BC%8F"><span class="toc-text">2. Crash 收集方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-Mach-%E5%B1%82%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">2.1. Mach 层异常处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-Signal-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">2.2. Signal 异常处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-C-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">2.3. C++ 异常处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-Objective-C-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">2.4. Objective-C 异常处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-%E4%B8%BB%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="toc-text">2.5. 主线程死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-Crash-%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E4%BF%9D%E5%AD%98"><span class="toc-text">2.6 Crash 的生成与保存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-1-Crash-%E6%97%A5%E5%BF%97%E7%9A%84%E7%94%9F%E6%88%90%E9%80%BB%E8%BE%91"><span class="toc-text">2.6.1 Crash 日志的生成逻辑</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-2-Crash-%E6%97%A5%E5%BF%97%E7%9A%84%E8%AF%BB%E5%8F%96%E9%80%BB%E8%BE%91"><span class="toc-text">2.6.2 Crash 日志的读取逻辑</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-%E5%89%8D%E7%AB%AF-js-%E7%9B%B8%E5%85%B3%E7%9A%84-Crash-%E7%9A%84%E7%9B%91%E6%8E%A7"><span class="toc-text">2.7 前端 js 相关的 Crash 的监控</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-7-1-JavascriptCore-%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7"><span class="toc-text">2.7.1 JavascriptCore 异常监控</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-7-2-h5-%E9%A1%B5%E9%9D%A2%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7"><span class="toc-text">2.7.2 h5 页面异常监控</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-7-3-React-Native-%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7"><span class="toc-text">2.7.3 React Native 异常监控</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#2-7-3-1-js-%E9%80%BB%E8%BE%91%E9%94%99%E8%AF%AF"><span class="toc-text">2.7.3.1 js 逻辑错误</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-7-3-2-%E7%BB%84%E4%BB%B6%E9%97%AE%E9%A2%98"><span class="toc-text">2.7.3.2 组件问题</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-7-4-RN-Crash-%E8%BF%98%E5%8E%9F"><span class="toc-text">2.7.4 RN Crash 还原</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-7-5-SourceMap-%E8%A7%A3%E6%9E%90%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1"><span class="toc-text">2.7.5 SourceMap 解析系统设计</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-KSCrash-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8C%85%E8%A3%85"><span class="toc-text">3. KSCrash 的使用包装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%AC%A6%E5%8F%B7%E5%8C%96"><span class="toc-text">4. 符号化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-DSYM-%E6%96%87%E4%BB%B6"><span class="toc-text">4.1 .DSYM 文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-DWARF-%E6%96%87%E4%BB%B6"><span class="toc-text">4.2 DWARF 文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-symbols"><span class="toc-text">4.3 symbols</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%9C%B0%E5%9D%80%EF%BC%9F"><span class="toc-text">4.4 如何获取地址？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-UUID"><span class="toc-text">4.5 UUID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-%E7%AC%A6%E5%8F%B7%E5%8C%96%EF%BC%88%E8%A7%A3%E6%9E%90-Crash-%E6%97%A5%E5%BF%97%EF%BC%89"><span class="toc-text">4.6 符号化（解析 Crash 日志）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-%E7%B3%BB%E7%BB%9F%E5%BA%93%E7%AC%A6%E5%8F%B7%E5%8C%96%E8%A7%A3%E6%9E%90"><span class="toc-text">4.7 系统库符号化解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A4%84%E7%90%86"><span class="toc-text">5. 服务端处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-ELK-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F"><span class="toc-text">5.1 ELK 日志系统</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-%E6%9C%8D%E5%8A%A1%E4%BE%A7"><span class="toc-text">5.2 服务侧</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81-APM-%E5%B0%8F%E7%BB%93"><span class="toc-text">八、 APM 小结</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<h1 id="打造一套客户端功能最全的-APM-监控系统"><a href="#打造一套客户端功能最全的-APM-监控系统" class="headerlink" title="打造一套客户端功能最全的 APM 监控系统"></a><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000040277799">打造一套客户端功能最全的 APM 监控系统</a></h1><p> <strong>杭城小刘</strong> 发布于 2021-07-02</p>
<blockquote>
<p>APM 是 Application Performance Monitoring 的缩写，监视和管理软件应用程序的性能和可用性。应用性能管理对一个应用的持续稳定运行至关重要。所以这篇文章就从一个 iOS App 的性能管理的纬度谈谈如何精确监控以及数据如何上报等技术点</p>
</blockquote>
<p>App 的性能问题是影响用户体验的重要因素之一。性能问题主要包含：Crash、网络请求错误或者超时、UI 响应速度慢、主线程卡顿、CPU 和内存使用率高、耗电量大等等。大多数的问题原因在于开发者错误地使用了线程锁、系统函数、编程规范问题、数据结构等等。解决问题的关键在于尽早的发现和定位问题。</p>
<p>本篇文章着重总结了 APM 的原因以及如何收集数据。APM 数据收集后结合数据上报机制，按照一定策略上传数据到服务端。服务端消费这些信息并产出报告。请结合<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=3WWrfendOrHHUYaFUFmEWQ==.gXyR2KjStFj13n8ud2G51sMBu7j/K1MBzaJfRUnJZV1p11+6W2vj1HjCb0fDrYc3Kao0BOufcvbrp+SvLAUkl0nxS4839kyL6sa8Y1fPC9gGbVJXVBqa4xwWlJl+Gmla">姊妹篇</a>， 总结了如何打造一款灵活可配置、功能强大的数据上报组件。</p>
<h2 id="一、卡顿监控"><a href="#一、卡顿监控" class="headerlink" title="一、卡顿监控"></a>一、卡顿监控</h2><p>卡顿问题，就是在主线程上无法响应用户交互的问题。影响着用户的直接体验，所以针对 App 的卡顿监控是 APM 里面重要的一环。</p>
<p>FPS（frame per second）每秒钟的帧刷新次数，iPhone 手机以 60 为最佳，iPad 某些型号是 120，也是作为卡顿监控的一项参考参数，为什么说是参考参数？因为它不准确。先说说怎么获取到 FPS。CADisplayLink 是一个系统定时器，会以帧刷新频率一样的速率来刷新视图。 <code>[CADisplayLink displayLinkWithTarget:self selector:@selector(###:)]</code>。至于为什么不准我们来看看下面的示例代码</p>
<p>_displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(p_displayLinkTick:)];<br>[_displayLink setPaused:YES];<br>[_displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];</p>
<p>代码所示，CADisplayLink 对象是被添加到指定的 RunLoop 的某个 Mode 下。所以还是 CPU 层面的操作，卡顿的体验是整个图像渲染的结果：CPU + GPU。请继续往下看</p>
<h3 id="1-屏幕绘制原理"><a href="#1-屏幕绘制原理" class="headerlink" title="1. 屏幕绘制原理"></a>1. 屏幕绘制原理</h3><p><img src="https://segmentfault.com/img/bVbIOee"></p>
<p>讲讲老式的 CRT 显示器的原理。 CRT 电子枪按照上面方式，从上到下一行行扫描，扫面完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用硬件时钟产生一系列的定时信号。当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 HSync；当一帧画面绘制完成后，电子枪恢复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（Vertical synchronization），简称 VSync。显示器通常以固定的频率进行刷新，这个固定的刷新频率就是 VSync 信号产生的频率。虽然现在的显示器基本都是液晶显示屏，但是原理保持不变。</p>
<p><img src="https://segmentfault.com/img/bVbIOej"></p>
<p>通常，屏幕上一张画面的显示是由 CPU、GPU 和显示器是按照上图的方式协同工作的。CPU 根据工程师写的代码计算好需要现实的内容（比如视图创建、布局计算、图片解码、文本绘制等），然后把计算结果提交到 GPU，GPU 负责图层合成、纹理渲染，随后 GPU 将渲染结果提交到帧缓冲区。随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过数模转换传递给显示器显示。</p>
<p>在帧缓冲区只有一个的情况下，帧缓冲区的读取和刷新都存在效率问题，为了解决效率问题，显示系统会引入2个缓冲区，即双缓冲机制。在这种情况下，GPU 会预先渲染好一帧放入帧缓冲区，让视频控制器来读取，当下一帧渲染好后，GPU 直接把视频控制器的指针指向第二个缓冲区。提升了效率。</p>
<p>目前来看，双缓冲区提高了效率，但是带来了新的问题：当视频控制器还未读取完成时，即屏幕内容显示了部分，GPU 将新渲染好的一帧提交到另一个帧缓冲区并把视频控制器的指针指向新的帧缓冲区，视频控制器就会把新的一帧数据的下半段显示到屏幕上，造成画面撕裂的情况。</p>
<p>为了解决这个问题，GPU 通常有一个机制叫垂直同步信号（V-Sync），当开启垂直同步信号后，GPU 会等到视频控制器发送 V-Sync 信号后，才进行新的一帧的渲染和帧缓冲区的更新。这样的几个机制解决了画面撕裂的情况，也增加了画面流畅度。但需要更多的计算资源</p>
<p><img src="https://segmentfault.com/img/bVbIOes"></p>
<p>答疑</p>
<p>可能有些人会看到「当开启垂直同步信号后，GPU 会等到视频控制器发送 V-Sync 信号后，才进行新的一帧的渲染和帧缓冲区的更新」这里会想，GPU 收到 V-Sync 才进行新的一帧渲染和帧缓冲区的更新，那是不是双缓冲区就失去意义了？</p>
<p>设想一个显示器显示第一帧图像和第二帧图像的过程。首先在双缓冲区的情况下，GPU 首先渲染好一帧图像存入到帧缓冲区，然后让视频控制器的指针直接直接这个缓冲区，显示第一帧图像。第一帧图像的内容显示完成后，视频控制器发送 V-Sync 信号，GPU 收到 V-Sync 信号后渲染第二帧图像并将视频控制器的指针指向第二个帧缓冲区。</p>
<p><strong>看上去第二帧图像是在等第一帧显示后的视频控制器发送 V-Sync 信号。是吗？真是这样的吗？ 😭 想啥呢，当然不是。 🐷 不然双缓冲区就没有存在的意义了</strong></p>
<p>揭秘。请看下图</p>
<p><img src="https://segmentfault.com/img/bVbIOeK"></p>
<p>当第一次 V-Sync 信号到来时，先渲染好一帧图像放到帧缓冲区，但是不展示，当收到第二个 V-Sync 信号后读取第一次渲染好的结果（视频控制器的指针指向第一个帧缓冲区），并同时渲染新的一帧图像并将结果存入第二个帧缓冲区，等收到第三个 V-Sync 信号后，读取第二个帧缓冲区的内容（视频控制器的指针指向第二个帧缓冲区），并开始第三帧图像的渲染并送入第一个帧缓冲区，依次不断循环往复。</p>
<p>请查看资料，需要梯子：<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=n8yMZ8IDSwKEkHK7UX9mew==.rwyqrHqcabnVtvC7qgQO21Sfn3W4WPZ1Y6CbA1wv6wtXtqZAywcg1uD9Y1SmX4ad3KutIqneRAmcP4CSbb1NbQ==">Multiple buffering</a></p>
<h3 id="2-卡顿产生的原因"><a href="#2-卡顿产生的原因" class="headerlink" title="2. 卡顿产生的原因"></a>2. 卡顿产生的原因</h3><p><img src="https://segmentfault.com/img/bVbIOeO"></p>
<p>VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容（视图创建、布局计算、图片解码、文本绘制等）。然后将计算的内容提交到 GPU，GPU 经过图层的变换、合成、渲染，随后 GPU 把渲染结果提交到帧缓冲区，等待下一次 VSync 信号到来再显示之前渲染好的结果。在垂直同步机制的情况下，如果在一个 VSync 时间周期内，CPU 或者 GPU 没有完成内容的提交，就会造成该帧的丢弃，等待下一次机会再显示，这时候屏幕上还是之前渲染的图像，所以这就是 CPU、GPU 层面界面卡顿的原因。</p>
<p>目前 iOS 设备有双缓存机制，也有三缓冲机制，Android 现在主流是三缓冲机制，在早期是单缓冲机制。<br><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=yWtB/pBzC6C53LUBI/MRaA==.dtIZUu+rgO4kc9Kz1OM6fhoRFMNyKY+BUURmK4zHfeQpy9fES4w1t64pP1D3wATKgkkXQunwc71gQBONJgOH45koMcsMRQ5sc8dxbSdg81kFE0AkmutjrwopIhyMnJxE">iOS 三缓冲机制例子</a></p>
<p>CPU 和 GPU 资源消耗原因很多，比如对象的频繁创建、属性调整、文件读取、视图层级的调整、布局的计算（AutoLayout 视图个数多了就是线性方程求解难度变大）、图片解码（大图的读取优化）、图像绘制、文本渲染、数据库读取（多读还是多写乐观锁、悲观锁的场景）、锁的使用（举例：自旋锁使用不当会浪费 CPU）等方面。开发者根据自身经验寻找最优解（这里不是本文重点）。</p>
<h3 id="3-APM-如何监控卡顿并上报"><a href="#3-APM-如何监控卡顿并上报" class="headerlink" title="3. APM 如何监控卡顿并上报"></a>3. APM 如何监控卡顿并上报</h3><p>CADisplayLink 肯定不用了，这个 FPS 仅作为参考。一般来讲，卡顿的监测有2种方案：<strong>监听 RunLoop 状态回调、子线程 ping 主线程</strong></p>
<h4 id="3-1-RunLoop-状态监听的方式"><a href="#3-1-RunLoop-状态监听的方式" class="headerlink" title="3.1 RunLoop 状态监听的方式"></a>3.1 RunLoop 状态监听的方式</h4><p>RunLoop 负责监听输入源进行调度处理。比如网络、输入设备、周期性或者延迟事件、异步回调等。RunLoop 会接收2种类型的输入源：一种是来自另一个线程或者来自不同应用的异步消息（source0事件）、另一种是来自预定或者重复间隔的事件。</p>
<p>RunLoop 状态如下图<br><img src="https://segmentfault.com/img/bVbIOe3"></p>
<p>第一步：通知 Observers，RunLoop 要开始进入 loop，紧接着进入 loop</p>
<p>if (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry )<br>    // 通知 Observers: RunLoop 即将进入 loop<br>    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);<br>// 进入loop<br>result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</p>
<p>第二步：开启 do while 循环保活线程，通知 Observers，RunLoop 触发 Timer 回调、Source0 回调，接着执行被加入的 block</p>
<p> if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers)<br>    //  通知 Observers: RunLoop 即将触发 Timer 回调<br>    __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);<br>if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources)<br>    //  通知 Observers: RunLoop 即将触发 Source 回调<br>    __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);<br>// 执行被加入的block<br>__CFRunLoopDoBlocks(rl, rlm);</p>
<p>第三步：RunLoop 在触发 Source0 回调后，如果 Source1 是 ready 状态，就会跳转到 handle_msg 去处理消息。</p>
<p>//  如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息<br>if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) {<br>#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI<br>    msg = (mach_msg_header_t *)msg_buffer;</p>
<pre><code>if (\_\_CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg\_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123;
    goto handle\_msg;
&#125;</code></pre>
<p>#elif DEPLOYMENT_TARGET_WINDOWS<br>    if (__CFRunLoopWaitForMultipleObjects(NULL, &amp;dispatchPort, 0, 0, &amp;livePort, NULL)) {<br>        goto handle_msg;<br>    }<br>#endif<br>}</p>
<p>第四步：回调触发后，通知 Observers 即将进入休眠状态</p>
<p>Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);<br>// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)<br>if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);<br>    __CFRunLoopSetSleeping(rl);</p>
<p>第五步：进入休眠后，会等待 mach_port 消息，以便再次唤醒。只有以下4种情况才可以被再次唤醒。</p>
<ul>
<li><p>  基于 port 的 source 事件</p>
</li>
<li><p>  Timer 时间到</p>
</li>
<li><p>  RunLoop 超时</p>
</li>
<li><p>被调用者唤醒</p>
<p>  do {</p>
<pre><code>if (kCFUseCollectableAllocator) &#123;
    // objc\_clear\_stack(0);
    // &lt;rdar://problem/16393959&gt;
    memset(msg\_buffer, 0, sizeof(msg\_buffer));
&#125;
msg = (mach\_msg\_header\_t \*)msg\_buffer;

\_\_CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg\_buffer), &amp;livePort, poll ? 0 : TIMEOUT\_INFINITY, &amp;voucherState, &amp;voucherCopy);

if (modeQueuePort != MACH\_PORT\_NULL &amp;&amp; livePort == modeQueuePort) &#123;
    // Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.
    while (\_dispatch\_runloop\_root\_queue\_perform\_4CF(rlm-&gt;\_queue));
    if (rlm-&gt;\_timerFired) &#123;
        // Leave livePort as the queue port, and service timers below
        rlm-&gt;\_timerFired = false;
        break;
    &#125; else &#123;
        if (msg &amp;&amp; msg != (mach\_msg\_header\_t \*)msg\_buffer) free(msg);
    &#125;
&#125; else &#123;
    // Go ahead and leave the inner loop.
    break;
&#125;</code></pre>
<p>  } while (1);</p>
</li>
</ul>
<p>第六步：唤醒时通知 Observer，RunLoop 的线程刚刚被唤醒了</p>
<p>// 通知 Observers: RunLoop 的线程刚刚被唤醒了<br>if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);<br>    // 处理消息<br>    handle_msg:;<br>    __CFRunLoopSetIgnoreWakeUps(rl);</p>
<p>第七步：RunLoop 唤醒后，处理唤醒时收到的消息</p>
<ul>
<li><p>  如果是 Timer 时间到，则触发 Timer 的回调</p>
</li>
<li><p>  如果是 dispatch，则执行 block</p>
</li>
<li><p>如果是 source1 事件，则处理这个事件</p>
<p>  #if USE_MK_TIMER_TOO</p>
<pre><code>    // 如果一个 Timer 到时间了，触发这个Timer的回调
    else if (rlm-&gt;\_timerPort != MACH\_PORT\_NULL &amp;&amp; livePort == rlm-&gt;\_timerPort) &#123;
        CFRUNLOOP\_WAKEUP\_FOR\_TIMER();
        // On Windows, we have observed an issue where the timer port is set before the time which we requested it to be set. For example, we set the fire time to be TSR 167646765860, but it is actually observed firing at TSR 167646764145, which is 1715 ticks early. The result is that, when \_\_CFRunLoopDoTimers checks to see if any of the run loop timers should be firing, it appears to be &#39;too early&#39; for the next timer, and no timers are handled.
        // In this case, the timer port has been automatically reset (since it was returned from MsgWaitForMultipleObjectsEx), and if we do not re-arm it, then no timers will ever be serviced again unless something adjusts the timer list (e.g. adding or removing timers). The fix for the issue is to reset the timer here if CFRunLoopDoTimers did not handle a timer itself. 9308754
        if (!\_\_CFRunLoopDoTimers(rl, rlm, mach\_absolute\_time())) &#123;
            // Re-arm the next timer
            \_\_CFArmNextTimerInMode(rlm, rl);
        &#125;
    &#125;</code></pre>
<p>  #endif</p>
<pre><code>    //  如果有dispatch到main\_queue的block，执行block
    else if (livePort == dispatchPort) &#123;
        CFRUNLOOP\_WAKEUP\_FOR\_DISPATCH();
        \_\_CFRunLoopModeUnlock(rlm);
        \_\_CFRunLoopUnlock(rl);
        \_CFSetTSD(\_\_CFTSDKeyIsInGCDMainQ, (void \*)6, NULL);</code></pre>
<p>  #if DEPLOYMENT_TARGET_WINDOWS</p>
<pre><code>        void \*msg = 0;</code></pre>
<p>  #endif</p>
<pre><code>        \_\_CFRUNLOOP\_IS\_SERVICING\_THE\_MAIN\_DISPATCH\_QUEUE\_\_(msg);
        \_CFSetTSD(\_\_CFTSDKeyIsInGCDMainQ, (void \*)0, NULL);
        \_\_CFRunLoopLock(rl);
        \_\_CFRunLoopModeLock(rlm);
        sourceHandledThisLoop = true;
        didDispatchPortLastTime = true;
    &#125;
    // 如果一个 Source1 (基于port) 发出事件了，处理这个事件
    else &#123;
        CFRUNLOOP\_WAKEUP\_FOR\_SOURCE();

        // If we received a voucher from this mach\_msg, then put a copy of the new voucher into TSD. CFMachPortBoost will look in the TSD for the voucher. By using the value in the TSD we tie the CFMachPortBoost to this received mach\_msg explicitly without a chance for anything in between the two pieces of code to set the voucher again.
        voucher\_t previousVoucher = \_CFSetTSD(\_\_CFTSDKeyMachMessageHasVoucher, (void \*)voucherCopy, os\_release);

        CFRunLoopSourceRef rls = \_\_CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);
        if (rls) &#123;</code></pre>
<p>  #if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</p>
<pre><code>    mach\_msg\_header\_t \*reply = NULL;
    sourceHandledThisLoop = \_\_CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh\_size, &amp;reply) || sourceHandledThisLoop;
    if (NULL != reply) &#123;
        (void)mach\_msg(reply, MACH\_SEND\_MSG, reply-&gt;msgh\_size, 0, MACH\_PORT\_NULL, 0, MACH\_PORT\_NULL);
        CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);
    &#125;</code></pre>
<p>  #elif DEPLOYMENT_TARGET_WINDOWS</p>
<pre><code>            sourceHandledThisLoop = \_\_CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop;</code></pre>
<p>  #endif</p>
</li>
</ul>
<p>第八步：根据当前 RunLoop 状态判断是否需要进入下一个 loop。当被外部强制停止或者 loop 超时，就不继续下一个 loop，否则进入下一个 loop</p>
<p>if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) {<br>    // 进入loop时参数说处理完事件就返回<br>    retVal = kCFRunLoopRunHandledSource;<br>    } else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) {<br>        // 超出传入参数标记的超时时间了<br>        retVal = kCFRunLoopRunTimedOut;<br>} else if (__CFRunLoopIsStopped(rl)) {<br>        __CFRunLoopUnsetStopped(rl);<br>    // 被外部调用者强制停止了<br>    retVal = kCFRunLoopRunStopped;<br>} else if (rlm-&gt;_stopped) {<br>    rlm-&gt;_stopped = false;<br>    retVal = kCFRunLoopRunStopped;<br>} else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) {<br>    // source/timer一个都没有<br>    retVal = kCFRunLoopRunFinished;<br>}</p>
<p>完整且带有注释的 RunLoop 代码见<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=4+ujjBH/lrpIClaiO1sgHw==.4NGPkCBCwzwCUKeUI03OiixGhpRfW7dcVkbAqhHmBXStW2/XOQRmaqukaiDaOHawZC/eLpoax5X2hEwn0gX1hDLwEn+JtBNB6BR5NNWgQt+A+gQ+qPNARMoQOkEZxrc2">此处</a>。 Source1 是 RunLoop 用来处理 Mach port 传来的系统事件的，Source0 是用来处理用户事件的。收到 Source1 的系统事件后本质还是调用 Source0 事件的处理函数。</p>
<p>RunLoop 6个状态</p>
<p>typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {<br>    kCFRunLoopEntry ,           // 进入 loop<br>    kCFRunLoopBeforeTimers ,    // 触发 Timer 回调<br>    kCFRunLoopBeforeSources ,   // 触发 Source0 回调<br>    kCFRunLoopBeforeWaiting ,   // 等待 mach_port 消息<br>    kCFRunLoopAfterWaiting ),   // 接收 mach_port 消息<br>    kCFRunLoopExit ,            // 退出 loop<br>    kCFRunLoopAllActivities     // loop 所有状态改变<br>}</p>
<p>RunLoop 在进入睡眠前的方法执行时间过长而导致无法进入睡眠，或者线程唤醒后接收消息时间过长而无法进入下一步，都会阻塞线程。如果是主线程，则表现为卡顿。</p>
<p>一旦发现进入睡眠前的 KCFRunLoopBeforeSources 状态，或者唤醒后 KCFRunLoopAfterWaiting，在设置的时间阈值内没有变化，则可判断为卡顿，此时 dump 堆栈信息，还原案发现场，进而解决卡顿问题。</p>
<p>开启一个子线程，不断进行循环监测是否卡顿了。在 n 次都超过卡顿阈值后则认为卡顿了。卡顿之后进行堆栈 dump 并上报（具有一定的机制，数据处理在下一 part 讲）。</p>
<p>WatchDog 在不同状态下具有不同的值。</p>
<ul>
<li>  启动（Launch）：20s</li>
<li>  恢复（Resume）：10s</li>
<li>  挂起（Suspend）：10s</li>
<li>  退出（Quit）：6s</li>
<li>  后台（Background）：3min（在 iOS7 之前可以申请 10min；之后改为 3min；可连续申请，最多到 10min）</li>
</ul>
<p>卡顿阈值的设置的依据是 WatchDog 的机制。APM 系统里面的阈值需要小于 WatchDog 的值，所以取值范围在 [1, 6] 之间，业界通常选择3秒。</p>
<p>通过 <code>long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)</code> 方法判断是否阻塞主线程，<code>Returns zero on success, or non-zero if the timeout occurred.</code> 返回非0则代表超时阻塞了主线程。</p>
<p><img src="https://segmentfault.com/img/bVbIOfh"></p>
<p>可能很多人纳闷 RunLoop 状态那么多，为什么选择 KCFRunLoopBeforeSources 和 KCFRunLoopAfterWaiting？因为大部分卡顿都是在 KCFRunLoopBeforeSources 和 KCFRunLoopAfterWaiting 之间。比如 Source0 类型的 App 内部事件等</p>
<p>Runloop 检测卡顿流程图如下：</p>
<p>关键代码如下：</p>
<p>// 设置Runloop observer的运行环境<br>CFRunLoopObserverContext context = {0, (__bridge void *)self, NULL, NULL};<br>// 创建Runloop observer对象<br>_observer = CFRunLoopObserverCreate(kCFAllocatorDefault,<br>                                    kCFRunLoopAllActivities,<br>                                    YES,<br>                                    0,<br>                                    &amp;runLoopObserverCallBack,<br>                                    &amp;context);<br>// 将新建的observer加入到当前thread的runloop<br>CFRunLoopAddObserver(CFRunLoopGetMain(), _observer, kCFRunLoopCommonModes);<br>// 创建信号<br>_semaphore = dispatch_semaphore_create(0);</p>
<p>__weak __typeof(self) weakSelf = self;<br>// 在子线程监控时长<br>dispatch_async(dispatch_get_global_queue(0, 0), ^{<br>    __strong __typeof(weakSelf) strongSelf = weakSelf;<br>    if (!strongSelf) {<br>        return;<br>    }<br>    while (YES) {<br>        if (strongSelf.isCancel) {<br>            return;<br>        }<br>        // N次卡顿超过阈值T记录为一次卡顿<br>        long semaphoreWait = dispatch_semaphore_wait(self-&gt;_semaphore, dispatch_time(DISPATCH_TIME_NOW, strongSelf.limitMillisecond * NSEC_PER_MSEC));<br>        if (semaphoreWait != 0) {<br>            if (self-&gt;_activity == kCFRunLoopBeforeSources || self-&gt;_activity == kCFRunLoopAfterWaiting) {<br>                if (++strongSelf.countTime &lt; strongSelf.standstillCount){<br>                    continue;<br>                }<br>                // 堆栈信息 dump 并结合数据上报机制，按照一定策略上传数据到服务器。堆栈 dump 会在下面讲解。数据上报会在 [打造功能强大、灵活可配置的数据上报组件](<a target="_blank" rel="noopener" href="https://github.com/FantasticLBP/knowledge-kit/blob/master/Chapter1%20-%20iOS/1.80.md">https://github.com/FantasticLBP/knowledge-kit/blob/master/Chapter1%20-%20iOS/1.80.md</a>) 讲<br>            }<br>        }<br>        strongSelf.countTime = 0;<br>    }<br>});</p>
<h4 id="3-2-子线程-ping-主线程监听的方式"><a href="#3-2-子线程-ping-主线程监听的方式" class="headerlink" title="3.2 子线程 ping 主线程监听的方式"></a>3.2 子线程 ping 主线程监听的方式</h4><p>开启一个子线程，创建一个初始值为0的信号量、一个初始值为 YES 的布尔值类型标志位。将设置标志位为 NO 的任务派发到主线程中去，子线程休眠阈值时间，时间到后判断标志位是否被主线程成功（值为 NO），如果没成功则认为主线程发生了卡顿情况，此时 dump 堆栈信息并结合数据上报机制，按照一定策略上传数据到服务器。数据上报会在 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=G+IqmQf5jDS7gdx4HQe5Ew==.OVUGL5Uvtof2GzureH523kZYwMTZz2GbPR81pG19p0mRZXIykiXcGms40cL/DGFT5Omf/h7tJnKxxQjnWD3WYM6I3nn0rGiHbnHLVHJ0CirCtL20e85ritrJms7CsJxL">打造功能强大、灵活可配置的数据上报组件</a> 讲</p>
<p>while (self.isCancelled == NO) {<br>        @autoreleasepool {<br>            __block BOOL isMainThreadNoRespond = YES;<br>            dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</p>
<pre><code>        dispatch\_async(dispatch\_get\_main\_queue(), ^&#123;
            isMainThreadNoRespond = NO;
            dispatch\_semaphore\_signal(semaphore);
        &#125;);

        \[NSThread sleepForTimeInterval:self.threshold\];

        if (isMainThreadNoRespond) &#123;
            if (self.handlerBlock) &#123;
                self.handlerBlock(); // 外部在 block 内部 dump 堆栈（下面会讲），数据上报
            &#125;
        &#125;
        dispatch\_semaphore\_wait(semaphore, DISPATCH\_TIME\_FOREVER);
    &#125;
&#125;</code></pre>
<h3 id="4-堆栈-dump"><a href="#4-堆栈-dump" class="headerlink" title="4. 堆栈 dump"></a>4. 堆栈 dump</h3><p>方法堆栈的获取是一个麻烦事。理一下思路。<code>[NSThread callStackSymbols]</code> 可以获取当前线程的调用栈。但是当监控到卡顿发生，需要拿到主线程的堆栈信息就无能为力了。从任何线程回到主线程这条路走不通。先做个知识回顾。</p>
<p>在计算机科学中，调用堆栈是一种栈类型的数据结构，用于存储有关计算机程序的线程信息。这种栈也叫做执行堆栈、程序堆栈、控制堆栈、运行时堆栈、机器堆栈等。调用堆栈用于跟踪每个活动的子例程在完成执行后应该返回控制的点。</p>
<p>维基百科搜索到 “Call Stack” 的一张图和例子，如下<br><img src="https://segmentfault.com/img/bVbIOfu"><br>上图表示为一个栈。分为若干个栈帧（Frame），每个栈帧对应一个函数调用。下面蓝色部分表示 <code>DrawSquare</code> 函数，它在执行的过程中调用了 <code>DrawLine</code> 函数，用绿色部分表示。</p>
<p>可以看到栈帧由三部分组成：函数参数、返回地址、局部变量。比如在 DrawSquare 内部调用了 DrawLine 函数：第一先把 DrawLine 函数需要的参数入栈；第二把返回地址(控制信息。举例：函数 A 内调用函数 B，调用函数B 的下一行代码的地址就是返回地址)入栈；第三函数内部的局部变量也在该栈中存储。</p>
<p>栈指针 Stack Pointer 表示当前栈的顶部，大多部分操作系统都是栈向下生长，所以栈指针是最小值。帧指针 Frame Pointer 指向的地址中，存储了上一次 Stack Pointer 的值，也就是返回地址。</p>
<p>大多数操作系统中，每个栈帧还保存了上一个栈帧的帧指针。因此知道当前栈帧的 Stack Pointer 和 Frame Pointer 就可以不断回溯，递归获取栈底的帧。</p>
<p>接下来的步骤就是拿到所有线程的 Stack Pointer 和 Frame Pointer。然后不断回溯，还原案发现场。</p>
<h3 id="5-Mach-Task-知识"><a href="#5-Mach-Task-知识" class="headerlink" title="5. Mach Task 知识"></a>5. Mach Task 知识</h3><p><strong>Mach task:</strong></p>
<p>App 在运行的时候，会对应一个 Mach Task，而 Task 下可能有多条线程同时执行任务。《OS X and iOS Kernel Programming》 中描述 Mach Task 为：任务（Task）是一种容器对象，虚拟内存空间和其他资源都是通过这个容器对象管理的，这些资源包括设备和其他句柄。简单概括为：Mack task 是一个机器无关的 thread 的执行环境抽象。</p>
<p>作用： task 可以理解为一个进程，包含它的线程列表。</p>
<p>结构体：task_threads，将 target_task 任务下的所有线程保存在 act_list 数组中，数组个数为 act_listCnt</p>
<p>kern_return_t task_threads<br>(<br>  task_t traget_task,<br>  thread_act_array_t *act_list,                     //线程指针列表<br>  mach_msg_type_number_t *act_listCnt  //线程个数<br>)</p>
<p>thread_info:</p>
<p>kern_return_t thread_info<br>(<br>  thread_act_t target_act,<br>  thread_flavor_t flavor,<br>  thread_info_t thread_info_out,<br>  mach_msg_type_number_t *thread_info_outCnt<br>);</p>
<p>如何获取线程的堆栈数据：</p>
<p>系统方法 <code>kern_return_t task_threads(task_inspect_t target_task, thread_act_array_t *act_list, mach_msg_type_number_t *act_listCnt);</code> 可以获取到所有的线程，不过这种方法获取到的线程信息是最底层的 <strong>mach 线程</strong>。</p>
<p>对于每个线程，可以用 <code>kern_return_t thread_get_state(thread_act_t target_act, thread_state_flavor_t flavor, thread_state_t old_state, mach_msg_type_number_t *old_stateCnt);</code> 方法获取它的所有信息，信息填充在 <code>_STRUCT_MCONTEXT</code> 类型的参数中，这个方法中有2个参数随着 CPU 架构不同而不同。所以需要定义宏屏蔽不同 CPU 之间的区别。</p>
<p><code>_STRUCT_MCONTEXT</code> 结构体中，存储了当前线程的 Stack Pointer 和最顶部栈帧的 Frame pointer，进而回溯整个线程调用堆栈。</p>
<p>但是上述方法拿到的是内核线程，我们需要的信息是 NSThread，所以需要将内核线程转换为 NSThread。</p>
<p>pthread 的 p 是 <strong>POSIX</strong> 的缩写，表示「可移植操作系统接口」（Portable Operating System Interface）。设计初衷是每个系统都有自己独特的线程模型，且不同系统对于线程操作的 API 都不一样。所以 POSIX 的目的就是提供抽象的 pthread 以及相关 API。这些 API 在不同的操作系统中有不同的实现，但是完成的功能一致。</p>
<p>Unix 系统提供的 <code>task_threads</code> 和 <code>thread_get_state</code> 操作的都是内核系统，每个内核线程由 thread_t 类型的 id 唯一标识。pthread 的唯一标识是 pthread_t 类型。其中内核线程和 pthread 的转换（即 thread_t 和 pthread_t）很容易，因为 pthread 设计初衷就是「抽象内核线程」。</p>
<p><code>memorystatus_action_neededpthread_create</code> 方法创建线程的回调函数为 <strong>nsthreadLauncher</strong>。</p>
<p>static void *nsthreadLauncher(void* thread)<br>{<br>    NSThread *t = (NSThread*)thread;<br>    [nc postNotificationName: NSThreadDidStartNotification object:t userInfo: nil];<br>    [t _setName: [t name]];<br>    [t main];<br>    [NSThread exit];<br>    return NULL;<br>}</p>
<p>NSThreadDidStartNotification 其实就是字符串 @”_NSThreadDidStartNotification”。</p>
<p>&lt;NSThread: 0x…&gt;{number = 1, name = main}  </p>
<p>为了 NSThread 和内核线程对应起来，只能通过 name 一一对应。 pthread 的 API <code>pthread_getname_np</code> 也可获取内核线程名字。np 代表 not POSIX，所以不能跨平台使用。</p>
<p>思路概括为：将 NSThread 的原始名字存储起来，再将名字改为某个随机数（时间戳），然后遍历内核线程 pthread 的名字，名字匹配则 NSThread 和内核线程对应了起来。找到后将线程的名字还原成原本的名字。对于主线程，由于不能使用 <code>pthread_getname_np</code>，所以在当前代码的 load 方法中获取到 thread_t，然后匹配名字。</p>
<p>static mach_port_t main_thread_id;  </p>
<ul>
<li>(void)load {<br>  main_thread_id = mach_thread_self();<br>}</li>
</ul>
<h2 id="二、-App-启动时间监控"><a href="#二、-App-启动时间监控" class="headerlink" title="二、 App 启动时间监控"></a>二、 App 启动时间监控</h2><h3 id="1-App-启动时间的监控"><a href="#1-App-启动时间的监控" class="headerlink" title="1. App 启动时间的监控"></a>1. App 启动时间的监控</h3><p>应用启动时间是影响用户体验的重要因素之一，所以我们需要量化去衡量一个 App 的启动速度到底有多快。启动分为冷启动和热启动。<br><img src="https://segmentfault.com/img/bVbIOfD"></p>
<p>冷启动：App 尚未运行，必须加载并构建整个应用。完成应用的初始化。冷启动存在较大优化空间。冷启动时间从 <code>application: didFinishLaunchingWithOptions:</code> 方法开始计算，App 一般在这里进行各种 SDK 和 App 的基础初始化工作。</p>
<p>热启动：应用已经在后台运行（常见场景：比如用户使用 App 过程中点击 Home 键，再打开 App），由于某些事件将应用唤醒到前台，App 会在 <code>applicationWillEnterForeground:</code> 方法接受应用进入前台的事件</p>
<p>思路比较简单。如下</p>
<ul>
<li>  在监控类的 <code>load</code> 方法中先拿到当前的时间值</li>
<li>  监听 App 启动完成后的通知 <code>UIApplicationDidFinishLaunchingNotification</code></li>
<li>  收到通知后拿到当前的时间</li>
<li>  步骤1和3的时间差就是 App 启动时间。</li>
</ul>
<p><code>mach_absolute_time</code> 是一个 CPU/总线依赖函数，返回一个 CPU 时钟周期数。系统休眠时不会增加。是一个纳秒级别的数字。获取前后2个纳秒后需要转换到秒。需要基于系统时间的基准，通过 <code>mach_timebase_info</code> 获得。</p>
<p>mach_timebase_info_data_t g_apmmStartupMonitorTimebaseInfoData = 0;<br>mach_timebase_info(&amp;g_apmmStartupMonitorTimebaseInfoData);<br>uint64_t timelapse = mach_absolute_time() - g_apmmLoadTime;<br>double timeSpan = (timelapse * g_apmmStartupMonitorTimebaseInfoData.numer) / (g_apmmStartupMonitorTimebaseInfoData.denom * 1e9);</p>
<h3 id="2-线上监控启动时间就好，但是在开发阶段需要对启动时间做优化。"><a href="#2-线上监控启动时间就好，但是在开发阶段需要对启动时间做优化。" class="headerlink" title="2. 线上监控启动时间就好，但是在开发阶段需要对启动时间做优化。"></a>2. 线上监控启动时间就好，但是在开发阶段需要对启动时间做优化。</h3><p>要优化启动时间，就先得知道在启动阶段到底做了什么事情，针对现状作出方案。</p>
<p>pre-main 阶段定义为 App 开始启动到系统调用 main 函数这个阶段；main 阶段定义为 main 函数入口到主 UI 框架的 viewDidAppear。</p>
<p>App 启动过程：</p>
<ul>
<li>  解析 Info.plist：加载相关信息例如闪屏；沙盒建立、权限检查；</li>
<li>  Mach-O 加载：如果是胖二进制文件，寻找合适当前 CPU 架构的部分；加载所有依赖的 Mach-O 文件（递归调用 Mach-O 加载的方法）；定义内部、外部指针引用，例如字符串、函数等；加载分类中的方法；c++ 静态对象加载、调用 Objc 的 <code>+load()</code> 函数；执行声明为 __attribute_((constructor)) 的 c 函数；</li>
<li>  程序执行：调用 main()；调用 UIApplicationMain()；调用 applicationWillFinishLaunching()；</li>
</ul>
<p>Pre-Main 阶段<br><img src="https://segmentfault.com/img/bVbIOfI"></p>
<p>Main 阶段<br><img src="https://segmentfault.com/img/bVbIOfP"></p>
<h4 id="2-1-加载-Dylib"><a href="#2-1-加载-Dylib" class="headerlink" title="2.1 加载 Dylib"></a>2.1 加载 Dylib</h4><p>每个动态库的加载，dyld 需要</p>
<ul>
<li>  分析所依赖的动态库</li>
<li>  找到动态库的 Mach-O 文件</li>
<li>  打开文件</li>
<li>  验证文件</li>
<li>  在系统核心注册文件签名</li>
<li>  对动态库的每一个 segment 调用 mmap（）</li>
</ul>
<p>优化：</p>
<ul>
<li>  减少非系统库的依赖</li>
<li>  使用静态库而不是动态库</li>
<li>  合并非系统动态库为一个动态库</li>
</ul>
<h4 id="2-2-Rebase-amp-amp-Binding"><a href="#2-2-Rebase-amp-amp-Binding" class="headerlink" title="2.2 Rebase &amp;&amp; Binding"></a>2.2 Rebase &amp;&amp; Binding</h4><p>优化：</p>
<ul>
<li>  减少 Objc 类数量，减少 selector 数量，把未使用的类和函数都可以删掉</li>
<li>  减少 c++ 虚函数数量</li>
<li>  转而使用 Swift struct（本质就是减少符号的数量）</li>
</ul>
<h4 id="2-3-Initializers"><a href="#2-3-Initializers" class="headerlink" title="2.3 Initializers"></a>2.3 Initializers</h4><p>优化：</p>
<ul>
<li>  使用 <code>+initialize</code> 代替 <code>+load</code></li>
<li>  不要使用过 attribute*((constructor)) 将方法显示标记为初始化器，而是让初始化方法调用时才执行。比如使用 dispatch_one、pthread_once() 或 std::once()。也就是第一次使用时才初始化，推迟了一部分工作耗时也尽量不要使用 c++ 的静态对象</li>
</ul>
<h4 id="2-4-pre-main-阶段影响因素"><a href="#2-4-pre-main-阶段影响因素" class="headerlink" title="2.4 pre-main 阶段影响因素"></a>2.4 pre-main 阶段影响因素</h4><ul>
<li>  动态库加载越多，启动越慢。</li>
<li>  ObjC 类越多，函数越多，启动越慢。</li>
<li>  可执行文件越大启动越慢。</li>
<li>  C 的 constructor 函数越多，启动越慢。</li>
<li>  C++ 静态对象越多，启动越慢。</li>
<li>  ObjC 的 +load 越多，启动越慢。</li>
</ul>
<p>优化手段：</p>
<ul>
<li>  减少依赖不必要的库，不管是动态库还是静态库；如果可以的话，把动态库改造成静态库；如果必须依赖动态库，则把多个非系统的动态库合并成一个动态库</li>
<li>  检查下 framework应当设为optional和required，如果该framework在当前App支持的所有iOS系统版本都存在，那么就设为required，否则就设为optional，因为optional会有些额外的检查</li>
<li>合并或者删减一些OC类和函数。关于清理项目中没用到的类，使用工具AppCode代码检查功能，查到当前项目中没有用到的类（也可以用根据linkmap文件来分析，但是准确度不算很高）<br>  有一个叫做<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=+M8NWNM6ZOB/M1EERBDGkA==.4WCLtil1YWB+tkjAZgL3jaHwEVhfygyzT0Rq6xbaGoM=">FUI</a>的开源项目能很好的分析出不再使用的类，准确率非常高，唯一的问题是它处理不了动态库和静态库里提供的类，也处理不了C++的类模板</li>
<li>  删减一些无用的静态变量</li>
<li>  删减没有被调用到或者已经废弃的方法</li>
<li>  将不必须在 +load 方法中做的事情延迟到 +initialize中，尽量不要用 C++ 虚函数(创建虚函数表有开销)</li>
<li>类和方法名不要太长：iOS每个类和方法名都在 __cstring 段里都存了相应的字符串值，所以类和方法名的长短也是对可执行文件大小是有影响的<br>  因还是 Object-c 的动态特性，因为需要通过类/方法名反射找到这个类/方法进行调用，Object-c 对象模型会把类/方法名字符串都保存下来；</li>
<li>  用 dispatch_once() 代替所有的 attribute((constructor)) 函数、C++ 静态对象初始化、ObjC 的 +load 函数；</li>
<li>在设计师可接受的范围内压缩图片的大小，会有意外收获。<br>  压缩图片为什么能加快启动速度呢？因为启动的时候大大小小的图片加载个十来二十个是很正常的，<br>  图片小了，IO操作量就小了，启动当然就会快了，比较靠谱的压缩算法是 TinyPNG。</li>
</ul>
<h4 id="2-5-main-阶段优化"><a href="#2-5-main-阶段优化" class="headerlink" title="2.5 main 阶段优化"></a>2.5 main 阶段优化</h4><ul>
<li>  减少启动初始化的流程。能懒加载就懒加载，能放后台初始化就放后台初始化，能延迟初始化的就延迟初始化，不要卡主线程的启动时间，已经下线的业务代码直接删除</li>
<li>  优化代码逻辑。去除一些非必要的逻辑和代码，减小每个流程所消耗的时间</li>
<li>  启动阶段使用多线程来进行初始化，把 CPU 性能发挥最大</li>
<li>  使用纯代码而不是 xib 或者 storyboard 来描述 UI，尤其是主 UI 框架，比如 TabBarController。因为 xib 和 storyboard 还是需要解析成代码来渲染页面，多了一步。</li>
</ul>
<h3 id="3-启动时间加速"><a href="#3-启动时间加速" class="headerlink" title="3. 启动时间加速"></a>3. 启动时间加速</h3><p>内存缺页异常？在使用中，访问虚拟内存的一个 page 而对应的物理内存缺不存在（没有被加载到物理内存中），则发生缺页异常。影响耗时，在几毫秒之内。</p>
<p>什么时候发生大量的缺页异常？一个应用程序刚启动的时候。</p>
<p>启动时所需要的代码分布在 VM 的第一页、第二页、第三页…，这样的情况下启动时间会影响较大，所以解决思路就是将应用程序启动刻所需要的代码（二进制优化一下），统一放到某几页，这样就可以避免内存缺页异常，则优化了 App 启动时间。</p>
<p>二进制重排提升 App 启动速度是通过「解决内存缺页异常」（内存缺页会有几毫秒的耗时）来提速的。</p>
<p>一个 App 发生大量「内存缺页」的时机就是 App 刚启动的时候。所以优化手段就是「将影响 App 启动的方法集中处理，放到某一页或者某几页」（虚拟内存中的页）。Xcode 工程允许开发者指定 「Order File」，可以「按照文件中的方法顺序去加载」，可以查看 linkMap 文件（需要在 Xcode 中的 「Buiild Settings」中设置 Order File、Write Link Map Files 参数）。</p>
<p>其实难点是如何拿到启动时刻所调用的所用方法？代码可能是 Swift、block、c、OC，所以hook 肯定不行、fishhook 也不行，用 clang 插桩可以满足需求。</p>
<h2 id="三、-CPU-使用率监控"><a href="#三、-CPU-使用率监控" class="headerlink" title="三、 CPU 使用率监控"></a>三、 CPU 使用率监控</h2><h3 id="1-CPU-架构"><a href="#1-CPU-架构" class="headerlink" title="1. CPU 架构"></a>1. CPU 架构</h3><p>CPU（Central Processing Unit）中央处理器，市场上主流的架构有 ARM（arm64）、Intel（x86）、AMD 等。其中 Intel 使用 CISC（Complex Instruction Set Computer），ARM 使用 RISC（Reduced Instruction Set Computer）。区别在于<strong>不同的 CPU 设计理念和方法</strong>。</p>
<p>早期 CPU 全部是 CISC 架构，设计目的是<strong>用最少的机器语言指令来完成所需的计算任务</strong>。比如对于乘法运算，在 CISC 架构的 CPU 上。一条指令 <code>MUL ADDRA, ADDRB</code> 就可以将内存 ADDRA 和内存 ADDRB 中的数香乘，并将结果存储在 ADDRA 中。做的事情就是：将 ADDRA、ADDRB 中的数据读入到寄存器，相乘的结果写入到内存的操作依赖于 CPU 设计，所以 <strong>CISC 架构会增加 CPU 的复杂性和对 CPU 工艺的要求。</strong></p>
<p>RISC 架构要求软件来指定各个操作步骤。比如上面的乘法，指令实现为 <code>MOVE A, ADDRA; MOVE B, ADDRB; MUL A, B; STR ADDRA, A;</code>。这种架构可以降低 CPU 的复杂性以及允许在同样的工艺水平下生产出功能更加强大的 CPU，但是对于编译器的设计要求更高。</p>
<p>目前市场是大部分的 iPhone 都是基于 arm64 架构的。且 arm 架构能耗低。</p>
<h3 id="2-获取线程信息"><a href="#2-获取线程信息" class="headerlink" title="2. 获取线程信息"></a>2. 获取线程信息</h3><p>讲完了区别来讲下如何做 CPU 使用率的监控</p>
<ul>
<li>  开启定时器，按照设定的周期不断执行下面的逻辑</li>
<li>  获取当前任务 task。从当前 task 中获取所有的线程信息（线程个数、线程数组）</li>
<li>  遍历所有的线程信息，判断是否有线程的 CPU 使用率超过设置的阈值</li>
<li>  假如有线程使用率超过阈值，则 dump 堆栈</li>
<li>  组装数据，上报数据</li>
</ul>
<p>线程信息结构体</p>
<p>struct thread_basic_info {<br>    time_value_t    user_time;      /* user run time（用户运行时长） */<br>    time_value_t    system_time;    /* system run time（系统运行时长） */<br>    integer_t       cpu_usage;      /* scaled cpu usage percentage（CPU使用率，上限1000） */<br>    policy_t        policy;         /* scheduling policy in effect（有效调度策略） */<br>    integer_t       run_state;      /* run state (运行状态，见下) */<br>    integer_t       flags;          /* various flags (各种各样的标记) */<br>    integer_t       suspend_count;  /* suspend count for thread（线程挂起次数） */<br>    integer_t       sleep_time;     /* number of seconds that thread<br>                                     *  has been sleeping（休眠时间） */<br>};</p>
<p>代码在讲堆栈还原的时候讲过，忘记的看一下上面的分析</p>
<p>thread_act_array_t threads;<br>mach_msg_type_number_t threadCount = 0;<br>const task_t thisTask = mach_task_self();<br>kern_return_t kr = task_threads(thisTask, &amp;threads, &amp;threadCount);<br>if (kr != KERN_SUCCESS) {<br>    return ;<br>}<br>for (int i = 0; i &lt; threadCount; i++) {<br>    thread_info_data_t threadInfo;<br>    thread_basic_info_t threadBaseInfo;<br>    mach_msg_type_number_t threadInfoCount;</p>
<pre><code>kern\_return\_t kr = thread\_info((thread\_inspect\_t)threads\[i\], THREAD\_BASIC\_INFO, (thread\_info\_t)threadInfo, &amp;threadInfoCount);

if (kr == KERN\_SUCCESS) &#123;

    threadBaseInfo = (thread\_basic\_info\_t)threadInfo;
    // todo：条件判断，看不明白
    if (!(threadBaseInfo-&gt;flags &amp; TH\_FLAGS\_IDLE)) &#123;
        integer\_t cpuUsage = threadBaseInfo-&gt;cpu\_usage / 10;
        if (cpuUsage &gt; CPUMONITORRATE) &#123;

            NSMutableDictionary \*CPUMetaDictionary = \[NSMutableDictionary dictionary\];
            NSData \*CPUPayloadData = \[NSData data\];

            NSString \*backtraceOfAllThread = \[BacktraceLogger backtraceOfAllThread\];
            // 1. 组装卡顿的 Meta 信息
            CPUMetaDictionary\[@&quot;MONITOR\_TYPE&quot;\] = APMMonitorCPUType;

            // 2. 组装卡顿的 Payload 信息（一个JSON对象，对象的 Key 为约定好的 STACK\_TRACE， value 为 base64 后的堆栈信息）
            NSData \*CPUData = \[SAFE\_STRING(backtraceOfAllThread) dataUsingEncoding:NSUTF8StringEncoding\];
            NSString \*CPUDataBase64String = \[CPUData base64EncodedStringWithOptions:0\];
            NSDictionary \*CPUPayloadDictionary = @&#123;@&quot;STACK\_TRACE&quot;: SAFE\_STRING(CPUDataBase64String)&#125;;

            NSError \*error;
            // NSJSONWritingOptions 参数一定要传0，因为服务端需要根据 \\n 处理逻辑，传递 0 则生成的 json 串不带 \\n
            NSData \*parsedData = \[NSJSONSerialization dataWithJSONObject:CPUPayloadDictionary options:0 error:&amp;error\];
            if (error) &#123;
                APMMLog(@&quot;%@&quot;, error);
                return;
            &#125;
            CPUPayloadData = \[parsedData copy\];

            // 3. 数据上报会在 \[打造功能强大、灵活可配置的数据上报组件\](https://github.com/FantasticLBP/knowledge-kit/blob/master/Chapter1%20-%20iOS/1.80.md) 讲
            \[\[HermesClient sharedInstance\] sendWithType:APMMonitorCPUType meta:CPUMetaDictionary payload:CPUPayloadData\]; 
        &#125;
    &#125;
&#125;</code></pre>
<p>}</p>
<h2 id="四、-OOM-问题"><a href="#四、-OOM-问题" class="headerlink" title="四、 OOM 问题"></a>四、 OOM 问题</h2><h3 id="1-基础知识准备"><a href="#1-基础知识准备" class="headerlink" title="1. 基础知识准备"></a>1. 基础知识准备</h3><p>硬盘：也叫做磁盘，用于存储数据。你存储的歌曲、图片、视频都是在硬盘里。</p>
<p>内存：由于硬盘读取速度较慢，如果 CPU 运行程序期间，所有的数据都直接从硬盘中读取，则非常影响效率。所以 CPU 会将程序运行所需要的数据从硬盘中读取到内存中。然后 CPU 与内存中的数据进行计算、交换。内存是易失性存储器（断电后，数据消失）。内存条区是计算机内部（在主板上）的一些存储器，用来保存 CPU 运算的中间数据和结果。内存是程序与 CPU 之间的桥梁。从硬盘读取出数据或者运行程序提供给 CPU。</p>
<p><strong>虚拟内存</strong> 是计算机系统内存管理的一种技术。它使得程序认为它拥有连续的可用内存，而实际上，它通常被分割成多个物理内存碎片，可能部分暂时存储在外部磁盘（硬盘）存储器上（当需要使用时则用硬盘中数据交换到内存中）。Windows 系统中称为 “虚拟内存”，Linux/Unix 系统中称为 ”交换空间“。</p>
<p>iOS 不支持交换空间？不只是 iOS 不支持交换空间，大多数手机系统都不支持。因为移动设备的大量存储器是<strong>闪存</strong>，它的读写速度远远小电脑所使用的硬盘，也就是说手机即使使用了<strong>交换空间</strong>技术，也因为闪存慢的问题，不能提升性能，所以索性就没有交换空间技术。</p>
<h3 id="2-iOS-内存知识"><a href="#2-iOS-内存知识" class="headerlink" title="2. iOS 内存知识"></a>2. iOS 内存知识</h3><p>内存（RAM）与 CPU 一样都是系统中最稀少的资源，也很容易发生竞争，应用内存与性能直接相关。iOS 没有交换空间作为备选资源，所以内存资源尤为重要。</p>
<p>什么是 OOM？是 out-of-memory 的缩写，字面意思是超过了内存限制。分为 FOOM（Foreground Out Of Memory，应用在前台运行的过程中崩溃。用户在使用的过程中产生的，这样的崩溃会使得活跃用户流失，业务上是非常不愿意看到的）和 BOOM（Background Out Of Memory，应用在后台运行的过程崩溃）。它是由 iOS 的 <code>Jetsam</code> 机制造成的一种非主流 Crash，它不能通过 Signal 这种监控方案所捕获。</p>
<p>什么是 Jetsam 机制？Jetsam 机制可以理解为系统为了控制内存资源过度使用而采用的一种管理机制。Jetsam 机制是运行在一个独立的进程中，每个进程都有一个内存阈值，一旦超过这个内存阈值，Jetsam 会立即杀掉这个进程。</p>
<p>为什么设计 Jetsam 机制？因为设备的内存是有限的，所以内存资源非常重要。系统进程以及其他使用的 App 都会抢占这个资源。由于 iOS 不支持交换空间，一旦触发低内存事件，Jetsam 就会尽可能多的释放 App 所在内存，这样 iOS 系统上出现内存不足时，App 就会被系统杀掉，变现为 crash。</p>
<p>2种情况触发 OOM：系统由于整体内存使用过高，会基于优先级策略杀死优先级较低的 App；当前 App 达到了 “<strong>highg water mark</strong>“ ，系统也会强杀当前 App（超过系统对当前单个 App 的内存限制值）。</p>
<p>读了源码（xnu/bsd/kern/kern_memorystatus.c）会发现内存被杀也有2种机制，如下</p>
<p>highwater 处理 -&gt; 我们的 App 占用内存不能超过单个限制</p>
<ol>
<li> 从优先级列表里循环寻找线程</li>
<li> 判断是否满足 p_memstat_memlimit 的限制条件</li>
<li> DiagonoseActive、FREEZE 过滤</li>
<li> 杀进程，成功则 exit，否则循环</li>
</ol>
<p>memorystatus_act_aggressive 处理 -&gt; 内存占用高，按照优先级杀死</p>
<ol>
<li> 根据 policy 家在 jld_bucket_count，用来判断是否被杀</li>
<li> 从 JETSAM_PRIORITY_ELEVATED_INACTIVE 开始杀</li>
<li> Old_bucket_count 和 memorystatus_jld_eval_period_msecs 判断是否开杀</li>
<li> 根据优先级从低到高开始杀，直到 memorystatus_avail_pages_below_pressure</li>
</ol>
<p>内存过大的几种情况</p>
<ul>
<li>  App 内存消耗较低，同时其他 App 内存管理也很棒，那么即使切换到其他 App，我们自己的 App 依旧是“活着”的，保留了用户状态。体验好</li>
<li>  App 内存消耗较低，但其他 App 内存消耗太大（可能是内存管理糟糕，也可能是本身就耗费资源，比如游戏），那么除了在前台的线程，其他 App 都会被系统杀死，回收内存资源，用来给活跃的进程提供内存。</li>
<li>  App 内存消耗较大，切换到其他 App 后，即使其他 App 向系统申请的内存不大，系统也会因为内存资源紧张，优先把内存消耗大的 App 杀死。表现为用户将 App 退出到后台，过会儿再次打开会发现 App 重新加载启动。</li>
<li>  App 内存消耗非常大，在前台运行时就被系统杀死，造成闪退。</li>
</ul>
<p>App 内存不足时，系统会按照一定策略来腾出更多的空间供使用。比较常见的做法是将一部分优先级低的数据挪到磁盘上，该操作为称为 <strong>page out</strong>。之后再次访问这块数据的时候，系统会负责将它重新搬回到内存中，该操作被称为 <strong>page in</strong>。</p>
<p>Memory page** 是内存管理中的最小单位，是系统分配的，可能一个 page 持有多个对象，也可能一个大的对象跨越多个 page。通常它是 16KB 大小，且有3种类型的 page。</p>
<p><img src="https://segmentfault.com/img/bVbIOf9"></p>
<ul>
<li><p>Clean Memory<br>  Clean memory 包括3类：可以 <code>page out</code> 的内存、内存映射文件、App 使用到的 framework（每个 framework 都有 _DATA_CONST 段，通常都是 clean 状态，但使用 runtime swizling，那么变为 dirty）。</p>
<p>  一开始分配的 page 都是干净的（堆里面的对象分配除外），我们 App 数据写入时候变为 dirty。从硬盘读进内存的文件，也是只读的、clean page。<br>  <img src="https://segmentfault.com/img/bVbIOn9"></p>
</li>
<li><p>Dirty Memory</p>
<p>  Dirty memory 包括4类：被 App 写入过数据的内存、所有堆区分配的对象、图像解码缓冲区、framework（framework 都有 _DATA 段和 _DATA_DIRTY 段，它们的内存都是 dirty）。</p>
<p>  在使用 framework 的过程中会产生 Dirty memory，使用单例或者全局初始化方法有助于帮助减少 Dirty memory（因为单例一旦创建就不销毁，一直在内存中，系统不认为是 Dirty memory）。</p>
<p>  <img src="https://segmentfault.com/img/bVbIOoc"></p>
</li>
<li><p>Compressed Memory</p>
<p>  由于闪存容量和读写限制，iOS 没有交换空间机制，而是在 iOS7 引入了 <strong>memory compressor</strong>。它是在内存紧张时候能够将最近一段时间未使用过的内存对象，内存压缩器会把对象压缩，释放出更多的 page。在需要时内存压缩器对其解压复用。在节省内存的同时提高了响应速度。</p>
<p>  比如 App 使用某 Framework，内部有个 NSDictionary 属性存储数据，使用了 3 pages 内存，在近期未被访问的时候 memory compressor 将其压缩为 1 page，再次使用的时候还原为 3 pages。</p>
</li>
</ul>
<p>App 运行内存 = pageNumbers * pageSize。因为 Compressed Memory 属于 Dirty memory。所以 Memory footprint = dirtySize + CompressedSize</p>
<p>设备不同，内存占用上限不同，App 上限较高，extension 上限较低，超过上限 crash 到 <code>EXC_RESOURCE_EXCEPTION</code>。<br><img src="https://segmentfault.com/img/bVbIOgi"></p>
<p>接下来谈一下如何获取内存上限，以及如何监控 App 因为占用内存过大而被强杀。</p>
<h3 id="3-获取内存信息"><a href="#3-获取内存信息" class="headerlink" title="3. 获取内存信息"></a>3. 获取内存信息</h3><h4 id="3-1-通过-JetsamEvent-日志计算内存限制值"><a href="#3-1-通过-JetsamEvent-日志计算内存限制值" class="headerlink" title="3.1 通过 JetsamEvent 日志计算内存限制值"></a>3.1 通过 JetsamEvent 日志计算内存限制值</h4><p>当 App 被 Jetsam 机制杀死时，手机会生成系统日志。查看路径：Settings-Privacy-Analytics &amp; Improvements- Analytics Data（设置-隐私- 分析与改进-分析数据），可以看到 <code>JetsamEvent-2020-03-14-161828.ips</code> 形式的日志，以 JetsamEvent 开头。这些 JetsamEvent 日志都是 iOS 系统内核强杀掉那些优先级不高（idle、frontmost、suspended）且占用内存超过系统内存限制的 App 留下的。</p>
<p>日志包含了 App 的内存信息。可以查看到 日志最顶部有 <code>pageSize</code> 字段，查找到 per-process-limit，该节点所在结构里的 <code>rpages</code> ，将 rpages * pageSize 即可得到 OOM 的阈值。</p>
<p>日志中 largestProcess 字段代表 App 名称；reason 字段代表内存原因；states 字段代表奔溃时 App 的状态（ idle、suspended、frontmost…）。</p>
<p>为了测试数据的准确性，我将测试2台设备（iPhone 6s plus/13.3.1，iPhone 11 Pro/13.3.1）的所有 App 彻底退出，只跑了一个为了测试内存临界值的 Demo App。 循环申请内存，ViewController 代码如下</p>
<p>- (void)viewDidLoad {<br>    [super viewDidLoad];<br>    NSMutableArray *array = [NSMutableArray array];<br>    for (NSInteger index = 0; index &lt; 10000000; index++) {<br>        UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];<br>        UIImage *image = [UIImage imageNamed:@”AppIcon”];<br>        imageView.image = image;<br>        [array addObject:imageView];<br>    }<br>}</p>
<p>iPhone 6s plus/13.3.1 数据如下：</p>
<p>{“bug_type”:”298”,”timestamp”:”2020-03-19 17:23:45.94 +0800”,”os_version”:”iPhone OS 13.3.1 (17D50)”,”incident_id”:”DA8AF66D-24E8-458C-8734-981866942168”}<br>{<br>  “crashReporterKey” : “fc9b659ce486df1ed1b8062d5c7c977a7eb8c851”,<br>  “kernel” : “Darwin Kernel Version 19.3.0: Thu Jan  9 21:10:44 PST 2020; root:xnu-6153.82.3~1\/RELEASE_ARM64_S8000”,<br>  “product” : “iPhone8,2”,<br>  “incident” : “DA8AF66D-24E8-458C-8734-981866942168”,<br>  “date” : “2020-03-19 17:23:45.93 +0800”,<br>  “build” : “iPhone OS 13.3.1 (17D50)”,<br>  “timeDelta” : 332,<br>  “memoryStatus” : {<br>  “compressorSize” : 48499,<br>  “compressions” : 7458651,<br>  “decompressions” : 5190200,<br>  “zoneMapCap” : 744407040,<br>  “largestZone” : “APFS_4K_OBJS”,<br>  “largestZoneSize” : 41402368,<br>  “pageSize” : 16384,<br>  “uncompressed” : 104065,<br>  “zoneMapSize” : 141606912,<br>  “memoryPages” : {<br>    “active” : 26214,<br>    “throttled” : 0,<br>    “fileBacked” : 14903,<br>    “wired” : 20019,<br>    “anonymous” : 37140,<br>    “purgeable” : 142,<br>    “inactive” : 23669,<br>    “free” : 2967,<br>    “speculative” : 2160<br>  }<br>},<br>  “largestProcess” : “Test”,<br>  “genCounter” : 0,<br>  “processes” : [<br>  {<br>    “uuid” : “39c5738b-b321-3865-a731-68064c4f7a6f”,<br>    “states” : [<br>      “daemon”,<br>      “idle”<br>    ],<br>    “lifetimeMax” : 188,<br>    “age” : 948223699030,<br>    “purgeable” : 0,<br>    “fds” : 25,<br>    “coalition” : 422,<br>    “rpages” : 177,<br>    “pid” : 282,<br>    “idleDelta” : 824711280,<br>    “name” : “com.apple.Safari.SafeBrowsing.Se”,<br>    “cpuTime” : 10.275422000000001<br>  },<br>  // …<br>  {<br>    “uuid” : “83dbf121-7c0c-3ab5-9b66-77ee926e1561”,<br>    “states” : [<br>      “frontmost”<br>    ],<br>    “killDelta” : 2592,<br>    “genCount” : 0,<br>    “age” : 1531004794,<br>    “purgeable” : 0,<br>    “fds” : 50,<br>    “coalition” : 1047,<br>    “rpages” : 92806,<br>    “reason” : “per-process-limit”,<br>    “pid” : 2384,<br>    “cpuTime” : 59.464373999999999,<br>    “name” : “Test”,<br>    “lifetimeMax” : 92806<br>  },<br>  // …<br> ]<br>}</p>
<p>iPhone 6s plus/13.3.1 手机 OOM 临界值为：(16384*92806)/(1024*1024)=1450.09375M</p>
<p>iPhone 11 Pro/13.3.1 数据如下：</p>
<p>{“bug_type”:”298”,”timestamp”:”2020-03-19 17:30:28.39 +0800”,”os_version”:”iPhone OS 13.3.1 (17D50)”,”incident_id”:”7F111601-BC7A-4BD7-A468-CE3370053057”}<br>{<br>  “crashReporterKey” : “bc2445adc164c399b330f812a48248e029e26276”,<br>  “kernel” : “Darwin Kernel Version 19.3.0: Thu Jan  9 21:11:10 PST 2020; root:xnu-6153.82.3~1\/RELEASE_ARM64_T8030”,<br>  “product” : “iPhone12,3”,<br>  “incident” : “7F111601-BC7A-4BD7-A468-CE3370053057”,<br>  “date” : “2020-03-19 17:30:28.39 +0800”,<br>  “build” : “iPhone OS 13.3.1 (17D50)”,<br>  “timeDelta” : 189,<br>  “memoryStatus” : {<br>  “compressorSize” : 66443,<br>  “compressions” : 25498129,<br>  “decompressions” : 15532621,<br>  “zoneMapCap” : 1395015680,<br>  “largestZone” : “APFS_4K_OBJS”,<br>  “largestZoneSize” : 41222144,<br>  “pageSize” : 16384,<br>  “uncompressed” : 127027,<br>  “zoneMapSize” : 169639936,<br>  “memoryPages” : {<br>    “active” : 58652,<br>    “throttled” : 0,<br>    “fileBacked” : 20291,<br>    “wired” : 45838,<br>    “anonymous” : 96445,<br>    “purgeable” : 4,<br>    “inactive” : 54368,<br>    “free” : 5461,<br>    “speculative” : 3716<br>  }<br>},<br>  “largestProcess” : “杭城小刘”,<br>  “genCounter” : 0,<br>  “processes” : [<br>  {<br>    “uuid” : “2dd5eb1e-fd31-36c2-99d9-bcbff44efbb7”,<br>    “states” : [<br>      “daemon”,<br>      “idle”<br>    ],<br>    “lifetimeMax” : 171,<br>    “age” : 5151034269954,<br>    “purgeable” : 0,<br>    “fds” : 50,<br>    “coalition” : 66,<br>    “rpages” : 164,<br>    “pid” : 11276,<br>    “idleDelta” : 3801132318,<br>    “name” : “wcd”,<br>    “cpuTime” : 3.430787<br>  },<br>  // …<br>  {<br>    “uuid” : “63158edc-915f-3a2b-975c-0e0ac4ed44c0”,<br>    “states” : [<br>      “frontmost”<br>    ],<br>    “killDelta” : 4345,<br>    “genCount” : 0,<br>    “age” : 654480778,<br>    “purgeable” : 0,<br>    “fds” : 50,<br>    “coalition” : 1718,<br>    “rpages” : 134278,<br>    “reason” : “per-process-limit”,<br>    “pid” : 14206,<br>    “cpuTime” : 23.955463999999999,<br>    “name” : “杭城小刘”,<br>    “lifetimeMax” : 134278<br>  },<br>  // …<br> ]<br>}</p>
<p>iPhone 11 Pro/13.3.1 手机 OOM 临界值为：(16384*134278)/(1024*1024)=2098.09375M</p>
<p><strong>iOS 系统如何发现 Jetsam ？</strong></p>
<p>MacOS/iOS 是一个 BSD 衍生而来的系统，其内核是 Mach，但是对于上层暴露的接口一般是基于 BSD 层对 Mach 的包装后的。Mach 是一个微内核的架构，真正的虚拟内存管理也是在其中进行的，BSD 对内存管理提供了上层接口。Jetsam 事件也是由 BSD 产生的。<code>bsd_init</code> 函数是入口，其中基本都是在初始化各个子系统，比如虚拟内存管理等。</p>
<p>// 1. Initialize the kernel memory allocator, 初始化 BSD 内存 Zone，这个 Zone 是基于 Mach 内核的zone 构建<br>kmeminit();</p>
<p>// 2. Initialise background freezing, iOS 上独有的特性，内存和进程的休眠的常驻监控线程<br>#if CONFIG_FREEZE<br>#ifndef CONFIG_MEMORYSTATUS<br>    #error “CONFIG_FREEZE defined without matching CONFIG_MEMORYSTATUS”<br>#endif<br>    /* Initialise background freezing */<br>    bsd_init_kprintf(“calling memorystatus_freeze_init\n”);<br>    memorystatus_freeze_init();<br>#endif&gt;</p>
<p>// 3. iOS 独有，JetSAM（即低内存事件的常驻监控线程）<br>#if CONFIG_MEMORYSTATUS<br>    /* Initialize kernel memory status notifications */<br>    bsd_init_kprintf(“calling memorystatus_init\n”);<br>    memorystatus_init();<br>#endif /* CONFIG_MEMORYSTATUS */</p>
<p><strong>主要作用就是开启了2个优先级最高的线程，来监控整个系统的内存情况。</strong></p>
<p>CONFIG_FREEZE 开启时，内核对进程进行冷冻而不是杀死。冷冻功能是由内核中启动一个 <code>memorystatus_freeze_thread</code> 进行，这个进程在收到信号后调用 <code>memorystatus_freeze_top_process</code> 进行冷冻。</p>
<p>iOS 系统会开启优先级最高的线程 <code>vm_pressure_monitor</code> 来监控系统的内存压力情况，并通过一个堆栈来维护所有 App 进程。iOS 系统还会维护一个内存快照表，用于保存每个进程内存页的消耗情况。有关 Jetsam 也就是 memorystatus 相关的逻辑，可以在 XNU 项目中的 <strong>kern_memorystatus.h</strong> 和 <strong>kern_memorystatus.c</strong> 源码中查看。</p>
<p>iOS 系统因内存占用过高会强杀 App 前，至少有 6秒钟可以用来做优先级判断，JetsamEvent 日志也是在这6秒内生成的。</p>
<p>上文提到了 iOS 系统没有交换空间，于是引入了 <strong>MemoryStatus 机制（也称为 Jetsam）</strong>。也就是说在 iOS 系统上释放尽可能多的内存供当前 App 使用。这个机制表现在优先级上，就是先强杀后台应用；如果内存还是不够多，就强杀掉当前应用。在 MacOS 中，MemoryStatus 只会强杀掉标记为空闲退出的进程。</p>
<p>MemoryStatus 机制会开启一个 memorystatus_jetsam_thread 的线程，它负责强杀 App 和记录日志，不会发送消息，所以内存压力检测线程无法获取到强杀 App 的消息。</p>
<p>当监控线程发现某 App 有内存压力时，就发出通知，此时有内存的 App 就去执行 <code>didReceiveMemoryWarning</code> 代理方法。在这个时机，我们还有机会做一些内存资源释放的逻辑，也许会避免 App 被系统杀死。</p>
<p><strong>源码角度查看问题</strong></p>
<p>iOS 系统内核有一个数组，专门维护线程的优先级。数组的每一项是一个包含进程链表的结构体。结构体如下：</p>
<p>#define MEMSTAT_BUCKET_COUNT (JETSAM_PRIORITY_MAX + 1)</p>
<p>typedef struct memstat_bucket {<br>    TAILQ_HEAD(, proc) list;<br>    int count;<br>} memstat_bucket_t;</p>
<p>memstat_bucket_t memstat_bucket[MEMSTAT_BUCKET_COUNT];</p>
<p>在 kern_memorystatus.h 中可以看到进行优先级信息</p>
<p>#define JETSAM_PRIORITY_IDLE_HEAD                -2<br>/* The value -1 is an alias to JETSAM_PRIORITY_DEFAULT */<br>#define JETSAM_PRIORITY_IDLE                      0<br>#define JETSAM_PRIORITY_IDLE_DEFERRED          1 /* Keeping this around till all xnu_quick_tests can be moved away from it.*/<br>#define JETSAM_PRIORITY_AGING_BAND1          JETSAM_PRIORITY_IDLE_DEFERRED<br>#define JETSAM_PRIORITY_BACKGROUND_OPPORTUNISTIC  2<br>#define JETSAM_PRIORITY_AGING_BAND2          JETSAM_PRIORITY_BACKGROUND_OPPORTUNISTIC<br>#define JETSAM_PRIORITY_BACKGROUND                3<br>#define JETSAM_PRIORITY_ELEVATED_INACTIVE      JETSAM_PRIORITY_BACKGROUND<br>#define JETSAM_PRIORITY_MAIL                      4<br>#define JETSAM_PRIORITY_PHONE                     5<br>#define JETSAM_PRIORITY_UI_SUPPORT                8<br>#define JETSAM_PRIORITY_FOREGROUND_SUPPORT        9<br>#define JETSAM_PRIORITY_FOREGROUND               10<br>#define JETSAM_PRIORITY_AUDIO_AND_ACCESSORY      12<br>#define JETSAM_PRIORITY_CONDUCTOR                13<br>#define JETSAM_PRIORITY_HOME                     16<br>#define JETSAM_PRIORITY_EXECUTIVE                17<br>#define JETSAM_PRIORITY_IMPORTANT                18<br>#define JETSAM_PRIORITY_CRITICAL                 19</p>
<p>#define JETSAM_PRIORITY_MAX                      21</p>
<p>可以明显的看到，后台 App 优先级 JETSAM_PRIORITY_BACKGROUND 为3，前台 App 优先级 JETSAM_PRIORITY_FOREGROUND 为10。</p>
<p>优先级规则是：内核线程优先级 &gt; 操作系统优先级 &gt; App 优先级。且前台 App 优先级高于后台运行的 App；当线程的优先级相同时， CPU 占用多的线程的优先级会被降低。</p>
<p>在 kern_memorystatus.c 中可以看到 OOM 可能的原因：</p>
<p>/* For logging clarity */<br>static const char *memorystatus_kill_cause_name[] = {<br>    “”                                ,        /* kMemorystatusInvalid                            */<br>    “jettisoned”                    ,        /* kMemorystatusKilled                            */<br>    “highwater”                        ,        /* kMemorystatusKilledHiwat                        */<br>    “vnode-limit”                    ,        /* kMemorystatusKilledVnodes                    */<br>    “vm-pageshortage”                ,        /* kMemorystatusKilledVMPageShortage            */<br>    “proc-thrashing”                ,        /* kMemorystatusKilledProcThrashing                */<br>    “fc-thrashing”                    ,        /* kMemorystatusKilledFCThrashing                */<br>    “per-process-limit”                ,        /* kMemorystatusKilledPerProcessLimit            */<br>    “disk-space-shortage”            ,        /* kMemorystatusKilledDiskSpaceShortage            */<br>    “idle-exit”                        ,        /* kMemorystatusKilledIdleExit                    */<br>    “zone-map-exhaustion”            ,        /* kMemorystatusKilledZoneMapExhaustion            */<br>    “vm-compressor-thrashing”        ,        /* kMemorystatusKilledVMCompressorThrashing        */<br>    “vm-compressor-space-shortage”    ,        /* kMemorystatusKilledVMCompressorSpaceShortage    */<br>};</p>
<p>查看 memorystatus_init 这个函数中初始化 Jetsam 线程的关键代码</p>
<p>__private_extern__ void<br>memorystatus_init(void) {<br>    // …<br>  /* Initialize the jetsam_threads state array */<br>    jetsam_threads = kalloc(sizeof(struct jetsam_thread_state) * max_jetsam_threads);</p>
<pre><code>/\* Initialize all the jetsam threads \*/
for (i = 0; i &lt; max\_jetsam\_threads; i++) &#123;

    result = kernel\_thread\_start\_priority(memorystatus\_thread, NULL, 95 /\* MAXPRI\_KERNEL \*/, &amp;jetsam\_threads\[i\].thread);
    if (result == KERN\_SUCCESS) &#123;
        jetsam\_threads\[i\].inited = FALSE;
        jetsam\_threads\[i\].index = i;
        thread\_deallocate(jetsam\_threads\[i\].thread);
    &#125; else &#123;
        panic(&quot;Could not create memorystatus\_thread %d&quot;, i);
    &#125;
&#125;</code></pre>
<p>}</p>
<p>/*<br> *    High-level priority assignments<br> *<br> *************************************************************************<br> * 127        Reserved (real-time)<br> *                A<br> *                +<br> *            (32 levels)<br> *                +<br> *                V<br> * 96        Reserved (real-time)<br> * 95        Kernel mode only<br> *                A<br> *                +<br> *            (16 levels)<br> *                +<br> *                V<br> * 80        Kernel mode only<br> * 79        System high priority<br> *                A<br> *                +<br> *            (16 levels)<br> *                +<br> *                V<br> * 64        System high priority<br> * 63        Elevated priorities<br> *                A<br> *                +<br> *            (12 levels)<br> *                +<br> *                V<br> * 52        Elevated priorities<br> * 51        Elevated priorities (incl. BSD +nice)<br> *                A<br> *                +<br> *            (20 levels)<br> *                +<br> *                V<br> * 32        Elevated priorities (incl. BSD +nice)<br> * 31        Default (default base for threads)<br> * 30        Lowered priorities (incl. BSD -nice)<br> *                A<br> *                +<br> *            (20 levels)<br> *                +<br> *                V<br> * 11        Lowered priorities (incl. BSD -nice)<br> * 10        Lowered priorities (aged pri’s)<br> *                A<br> *                +<br> *            (11 levels)<br> *                +<br> *                V<br> * 0        Lowered priorities (aged pri’s / idle)<br> *************************************************************************<br> */</p>
<p>可以看出：用户态的应用程序的线程不可能高于操作系统和内核。而且，用户态的应用程序间的线程优先级分配也有区别，比如处于前台的应用程序优先级高于处于后台的应用程序优先级。iOS 上应用程序优先级最高的是 SpringBoard；此外线程的优先级不是一成不变的。Mach 会根据线程的利用率和系统整体负载动态调整线程优先级。如果耗费 CPU 太多就降低线程优先级，如果线程过度挨饿，则会提升线程优先级。但是无论怎么变，程序都不能超过其所在线程的优先级区间范围。</p>
<p>可以看出，系统会根据内核启动参数和设备性能，开启 max_jetsam_threads 个（一般情况为1，特殊情况下可能为3）jetsam 线程，且这些线程的优先级为 95，也就是 MAXPRI_KERNEL（注意这里的 95 是线程的优先级，XNU 的线程优先级区间为：0～127。上文的宏定义是进程优先级，区间为：-2~19）。</p>
<p>紧接着，分析下 memorystatus_thread 函数，主要负责线程启动的初始化</p>
<p>static void<br>memorystatus_thread(void *param __unused, wait_result_t wr __unused) {<br>  //…<br>  while (memorystatus_action_needed()) {<br>        boolean_t killed;<br>        int32_t priority;<br>        uint32_t cause;<br>        uint64_t jetsam_reason_code = JETSAM_REASON_INVALID;<br>        os_reason_t jetsam_reason = OS_REASON_NULL;</p>
<pre><code>    cause = kill\_under\_pressure\_cause;
    switch (cause) &#123;
        case kMemorystatusKilledFCThrashing:
            jetsam\_reason\_code = JETSAM\_REASON\_MEMORY\_FCTHRASHING;
            break;
        case kMemorystatusKilledVMCompressorThrashing:
            jetsam\_reason\_code = JETSAM\_REASON\_MEMORY\_VMCOMPRESSOR\_THRASHING;
            break;
        case kMemorystatusKilledVMCompressorSpaceShortage:
            jetsam\_reason\_code = JETSAM\_REASON\_MEMORY\_VMCOMPRESSOR\_SPACE\_SHORTAGE;
            break;
        case kMemorystatusKilledZoneMapExhaustion:
            jetsam\_reason\_code = JETSAM\_REASON\_ZONE\_MAP\_EXHAUSTION;
            break;
        case kMemorystatusKilledVMPageShortage:
            /\* falls through \*/
        default:
            jetsam\_reason\_code = JETSAM\_REASON\_MEMORY\_VMPAGESHORTAGE;
            cause = kMemorystatusKilledVMPageShortage;
            break;
    &#125;

    /\* Highwater \*/
    boolean\_t is\_critical = TRUE;
    if (memorystatus\_act\_on\_hiwat\_processes(&amp;errors, &amp;hwm\_kill, &amp;post\_snapshot, &amp;is\_critical)) &#123;
        if (is\_critical == FALSE) &#123;
            /\*
             \* For now, don&#39;t kill any other processes.
             \*/
            break;
        &#125; else &#123;
            goto done;
        &#125;
    &#125;

    jetsam\_reason = os\_reason\_create(OS\_REASON\_JETSAM, jetsam\_reason\_code);
    if (jetsam\_reason == OS\_REASON\_NULL) &#123;
        printf(&quot;memorystatus\_thread: failed to allocate jetsam reason\\n&quot;);
    &#125;

    if (memorystatus\_act\_aggressive(cause, jetsam\_reason, &amp;jld\_idle\_kills, &amp;corpse\_list\_purged, &amp;post\_snapshot)) &#123;
        goto done;
    &#125;

    /\*
     \* memorystatus\_kill\_top\_process() drops a reference,
     \* so take another one so we can continue to use this exit reason
     \* even after it returns
     \*/
    os\_reason\_ref(jetsam\_reason);

    /\* LRU \*/
    killed = memorystatus\_kill\_top\_process(TRUE, sort\_flag, cause, jetsam\_reason, &amp;priority, &amp;errors);
    sort\_flag = FALSE;

    if (killed) &#123;
        if (memorystatus\_post\_snapshot(priority, cause) == TRUE) &#123;

                post\_snapshot = TRUE;
        &#125;

        /\* Jetsam Loop Detection \*/
        if (memorystatus\_jld\_enabled == TRUE) &#123;
            if ((priority == JETSAM\_PRIORITY\_IDLE) || (priority == system\_procs\_aging\_band) || (priority == applications\_aging\_band)) &#123;
                jld\_idle\_kills++;
            &#125; else &#123;
                /\*
                 \* We&#39;ve reached into bands beyond idle deferred.
                 \* We make no attempt to monitor them
                 \*/
            &#125;
        &#125;

        if ((priority &gt;= JETSAM\_PRIORITY\_UI\_SUPPORT) &amp;&amp; (total\_corpses\_count() &gt; 0) &amp;&amp; (corpse\_list\_purged == FALSE)) &#123;
            /\*
             \* If we have jetsammed a process in or above JETSAM\_PRIORITY\_UI\_SUPPORT
             \* then we attempt to relieve pressure by purging corpse memory.
             \*/
            task\_purge\_all\_corpses();
            corpse\_list\_purged = TRUE;
        &#125;
        goto done;
    &#125;

    if (memorystatus\_avail\_pages\_below\_critical()) &#123;
        /\*
         \* Still under pressure and unable to kill a process - purge corpse memory
         \*/
        if (total\_corpses\_count() &gt; 0) &#123;
            task\_purge\_all\_corpses();
            corpse\_list\_purged = TRUE;
        &#125;

        if (memorystatus\_avail\_pages\_below\_critical()) &#123;
            /\*
             \* Still under pressure and unable to kill a process - panic
             \*/
            panic(&quot;memorystatus\_jetsam\_thread: no victim! available pages:%llu\\n&quot;, (uint64\_t)memorystatus\_available\_pages);
        &#125;
    &#125;</code></pre>
<p>done:    </p>
<p>}</p>
<p>可以看到它开启了一个 循环，memorystatus_action_needed() 来作为循环条件，持续释放内存。</p>
<p>static boolean_t<br>memorystatus_action_needed(void) {<br>#if CONFIG_EMBEDDED<br>    return (is_reason_thrashing(kill_under_pressure_cause) ||<br>            is_reason_zone_map_exhaustion(kill_under_pressure_cause) ||<br>           memorystatus_available_pages &lt;= memorystatus_available_pages_pressure);<br>#else /* CONFIG_EMBEDDED */<br>    return (is_reason_thrashing(kill_under_pressure_cause) ||<br>            is_reason_zone_map_exhaustion(kill_under_pressure_cause));<br>#endif /* CONFIG_EMBEDDED */<br>}</p>
<p>它通过 vm_pagepout 发送的内存压力来判断当前内存资源是否紧张。几种情况：频繁的页面换出换进 is_reason_thrashing, Mach Zone 耗尽了 is_reason_zone_map_exhaustion、以及可用的页低于了 memory status_available_pages 这个门槛。</p>
<p>继续看 memorystatus_thread，会发现内存紧张时，将先触发 High-water 类型的 OOM，也就是说假如某个进程使用过程中超过了其使用内存的最高限制 hight water mark 时会发生 OOM。在 memorystatus_act_on_hiwat_processes() 中，通过 memorystatus_kill_hiwat_proc() 在优先级数组 memstat_bucket 中查找优先级最低的进程，如果进程的内存小于阈值（footprint_in_bytes &lt;= memlimit_in_bytes）则继续寻找次优先级较低的进程，直到找到占用内存超过阈值的进程并杀死。</p>
<p>通常来说单个 App 很难触碰到 high water mark，如果不能结束任何进程，最终走到 memorystatus_act_aggressive，也就是大多数 OOM 发生的地方。</p>
<p>static boolean_t<br>memorystatus_act_aggressive(uint32_t cause, os_reason_t jetsam_reason, int *jld_idle_kills, boolean_t *corpse_list_purged, boolean_t *post_snapshot) {<br>    // …<br>  if ( (jld_bucket_count == 0) ||<br>             (jld_now_msecs &gt; (jld_timestamp_msecs + memorystatus_jld_eval_period_msecs))) {</p>
<pre><code>        /\* 
         \* Refresh evaluation parameters 
         \*/
        jld\_timestamp\_msecs     = jld\_now\_msecs;
        jld\_idle\_kill\_candidates = jld\_bucket\_count;
        \*jld\_idle\_kills         = 0;
        jld\_eval\_aggressive\_count = 0;
        jld\_priority\_band\_max    = JETSAM\_PRIORITY\_UI\_SUPPORT;
    &#125;</code></pre>
<p>  //…<br>}</p>
<p>上述代码看到，判断要不要真正执行 kill 是根据一定的时间间判断的，条件是 <code>jld_now_msecs &gt; (jld_timestamp_msecs + memorystatus_jld_eval_period_msecs</code>。 也就是在 memorystatus_jld_eval_period_msecs 后才发生条件里面的 kill。</p>
<p>/* Jetsam Loop Detection */<br>if (max_mem &lt;= (512 * 1024 * 1024)) {<br>    /* 512 MB devices */<br>memorystatus_jld_eval_period_msecs = 8000;    /* 8000 msecs == 8 second window */<br>} else {<br>    /* 1GB and larger devices */<br>memorystatus_jld_eval_period_msecs = 6000;    /* 6000 msecs == 6 second window */<br>}</p>
<p>其中 memorystatus_jld_eval_period_msecs 取值最小6秒。所以我们可以在6秒内做些处理。</p>
<h4 id="3-2-开发者们整理所得"><a href="#3-2-开发者们整理所得" class="headerlink" title="3.2 开发者们整理所得"></a>3.2 开发者们整理所得</h4><p><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=jXqAlw4S4FOsD7u5160uFA==.Ap2qdKjaM0Mrxz+exry6MgJXIb+6daIX0Uf70MPabekPiXVP9YTyapT4vtBNYne6LbUktczVdsrs9D8E/M5QzaYa1fLm/DrkWOTFgNx1OySq+DkvKpj6QxzOJBIyhLmx">stackoverflow</a> 上有一份数据，整理了各种设备的 OOM 临界值</p>
<p>device</p>
<p>crash amount:MB</p>
<p>total amount:MB</p>
<p>percentage of total</p>
<p>iPad1</p>
<p>127</p>
<p>256</p>
<p>49%</p>
<p>iPad2</p>
<p>275</p>
<p>512</p>
<p>53%</p>
<p>iPad3</p>
<p>645</p>
<p>1024</p>
<p>62%</p>
<p>iPad4(iOS 8.1)</p>
<p>585</p>
<p>1024</p>
<p>57%</p>
<p>Pad Mini 1st Generation</p>
<p>297</p>
<p>512</p>
<p>58%</p>
<p>iPad Mini retina(iOS 7.1)</p>
<p>696</p>
<p>1024</p>
<p>68%</p>
<p>iPad Air</p>
<p>697</p>
<p>1024</p>
<p>68%</p>
<p>iPad Air 2(iOS 10.2.1)</p>
<p>1383</p>
<p>2048</p>
<p>68%</p>
<p>iPad Pro 9.7”(iOS 10.0.2 (14A456))</p>
<p>1395</p>
<p>1971</p>
<p>71%</p>
<p>iPad Pro 10.5”(iOS 11 beta4)</p>
<p>3057</p>
<p>4000</p>
<p>76%</p>
<p>iPad Pro 12.9” (2015)(iOS 11.2.1)</p>
<p>3058</p>
<p>3999</p>
<p>76%</p>
<p>iPad 10.2(iOS 13.2.3)</p>
<p>1844</p>
<p>2998</p>
<p>62%</p>
<p>iPod touch 4th gen(iOS 6.1.1)</p>
<p>130</p>
<p>256</p>
<p>51%</p>
<p>iPod touch 5th gen</p>
<p>286</p>
<p>512</p>
<p>56%</p>
<p>iPhone4</p>
<p>325</p>
<p>512</p>
<p>63%</p>
<p>iPhone4s</p>
<p>286</p>
<p>512</p>
<p>56%</p>
<p>iPhone5</p>
<p>645</p>
<p>1024</p>
<p>62%</p>
<p>iPhone5s</p>
<p>646</p>
<p>1024</p>
<p>63%</p>
<p>iPhone6(iOS 8.x)</p>
<p>645</p>
<p>1024</p>
<p>62%</p>
<p>iPhone6 Plus(iOS 8.x)</p>
<p>645</p>
<p>1024</p>
<p>62%</p>
<p>iPhone6s(iOS 9.2)</p>
<p>1396</p>
<p>2048</p>
<p>68%</p>
<p>iPhone6s Plus(iOS 10.2.1)</p>
<p>1396</p>
<p>2048</p>
<p>68%</p>
<p>iPhoneSE(iOS 9.3)</p>
<p>1395</p>
<p>2048</p>
<p>68%</p>
<p>iPhone7(iOS 10.2)</p>
<p>1395</p>
<p>2048</p>
<p>68%</p>
<p>iPhone7 Plus(iOS 10.2.1)</p>
<p>2040</p>
<p>3072</p>
<p>66%</p>
<p>iPhone8(iOS 12.1)</p>
<p>1364</p>
<p>1990</p>
<p>70%</p>
<p>iPhoneX(iOS 11.2.1)</p>
<p>1392</p>
<p>2785</p>
<p>50%</p>
<p>iPhoneXS(iOS 12.1)</p>
<p>2040</p>
<p>3754</p>
<p>54%</p>
<p>iPhoneXS Max(iOS 12.1)</p>
<p>2039</p>
<p>3735</p>
<p>55%</p>
<p>iPhoneXR(iOS 12.1)</p>
<p>1792</p>
<p>2813</p>
<p>63%</p>
<p>iPhone11(iOS 13.1.3)</p>
<p>2068</p>
<p>3844</p>
<p>54%</p>
<p>iPhone11 Pro Max(iOS 13.2.3)</p>
<p>2067</p>
<p>3740</p>
<p>55%</p>
<h4 id="3-3-触发当前-App-的-high-water-mark"><a href="#3-3-触发当前-App-的-high-water-mark" class="headerlink" title="3.3 触发当前 App 的 high water mark"></a>3.3 触发当前 App 的 high water mark</h4><p>我们可以写定时器，不断的申请内存，之后再通过 <code>phys_footprint</code> 打印当前占用内存，按道理来说不断申请内存即可触发 Jetsam 机制，强杀 App，那么<strong>最后一次打印的内存占用也就是当前设备的内存上限值</strong>。</p>
<p>timer = [NSTimer scheduledTimerWithTimeInterval:0.01 target:self selector:@selector(allocateMemory) userInfo:nil repeats:YES];</p>
<ul>
<li><p>(void)allocateMemory {<br>  UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];<br>  UIImage *image = [UIImage imageNamed:@”AppIcon”];<br>  imageView.image = image;<br>  [array addObject:imageView];</p>
<p>  memoryLimitSizeMB = [self usedSizeOfMemory];<br>  if (memoryWarningSizeMB &amp;&amp; memoryLimitSizeMB) {</p>
<pre><code>  NSLog(@&quot;----- memory warnning:%dMB, memory limit:%dMB&quot;, memoryWarningSizeMB, memoryLimitSizeMB);</code></pre>
<p>  }<br>}</p>
</li>
<li><p>(int)usedSizeOfMemory {<br>  task_vm_info_data_t taskInfo;<br>  mach_msg_type_number_t infoCount = TASK_VM_INFO_COUNT;<br>  kern_return_t kernReturn = task_info(mach_task_self(), TASK_VM_INFO, (task_info_t)&amp;taskInfo, &amp;infoCount);</p>
<p>  if (kernReturn != KERN_SUCCESS) {</p>
<pre><code>  return 0;</code></pre>
<p>  }<br>  return (int)(taskInfo.phys_footprint/1024.0/1024.0);<br>}</p>
</li>
</ul>
<h4 id="3-4-适用于-iOS13-系统的获取方式"><a href="#3-4-适用于-iOS13-系统的获取方式" class="headerlink" title="3.4 适用于 iOS13 系统的获取方式"></a>3.4 适用于 iOS13 系统的获取方式</h4><p>iOS13 开始 &lt;os/proc.h&gt; 中 <code>size_t os_proc_available_memory(void);</code> 可以查看当前可用内存。</p>
<blockquote>
<p>Return Value</p>
<p>The number of bytes that the app may allocate before it hits its memory limit. If the calling process isn’t an app, or if the process has already exceeded its memory limit, this function returns <code>0</code>.</p>
<p>Discussion</p>
<p>Call this function to determine the amount of memory available to your app. The returned value corresponds to the current memory limit minus the memory footprint of your app at the time of the function call. Your app’s memory footprint consists of the data that you allocated in RAM, and that must stay in RAM (or the equivalent) at all times. Memory limits can change during the app life cycle and don’t necessarily correspond to the amount of physical memory available on the device.</p>
<p>Use the returned value as advisory information only and don’t cache it. The precise value changes when your app does any work that affects memory, which can happen frequently.</p>
<p>Although this function lets you determine the amount of memory your app may safely consume, don’t use it to maximize your app’s memory usage. Significant memory use, even when under the current memory limit, affects system performance. For example, when your app consumes all of its available memory, the system may need to terminate other apps and system processes to accommodate your app’s requests. Instead, always consume the smallest amount of memory you need to be responsive to the user’s needs.</p>
<p>If you need more detailed information about the available memory resources, you can call <code>task_info</code>. However, be aware that <code>task_info</code> is an expensive call, whereas this function is much more efficient.</p>
</blockquote>
<p>if (@available(iOS 13.0, *)) {<br>    return os_proc_available_memory() / 1024.0 / 1024.0;<br>}</p>
<p>App 内存信息的 API 可以在 Mach 层找到，<code>mach_task_basic_info</code> 结构体存储了 Mach task 的内存使用信息，其中 phys_footprint 就是应用使用的物理内存大小，virtual_size 是虚拟内存大小。</p>
<p>#define MACH_TASK_BASIC_INFO     20         /* always 64-bit basic info */<br>struct mach_task_basic_info {<br>    mach_vm_size_t  virtual_size;       /* virtual memory size (bytes) */<br>    mach_vm_size_t  resident_size;      /* resident memory size (bytes) */<br>    mach_vm_size_t  resident_size_max;  /* maximum resident memory size (bytes) */<br>    time_value_t    user_time;          /* total user run time for<br>                                            terminated threads */<br>    time_value_t    system_time;        /* total system run time for<br>                                            terminated threads */<br>    policy_t        policy;             /* default policy for new threads */<br>    integer_t       suspend_count;      /* suspend count for task */<br>};</p>
<p>所以获取代码为</p>
<p>task_vm_info_data_t vmInfo;<br>mach_msg_type_number_t count = TASK_VM_INFO_COUNT;<br>kern_return_t kr = task_info(mach_task_self(), TASK_VM_INFO, (task_info_t)&amp;vmInfo, &amp;count);</p>
<p>if (kr != KERN_SUCCESS) {<br>    return ;<br>}<br>CGFloat memoryUsed = (CGFloat)(vmInfo.phys_footprint/1024.0/1024.0);</p>
<p>可能有人好奇不应该是 <code>resident_size</code> 这个字段获取内存的使用情况吗？一开始测试后发现 resident_size 和 Xcode 测量结果差距较大。而使用 phys_footprint 则接近于 Xcode 给出的结果。且可以从 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=JnwZOCCjfSuM+5Ot/DLidg==.cYB5AHuFJs5/6Be4sEnT/CDIRxgf1D0geQbZ5W2vvtXQxvYEPRKMVYgeJt8rGaYhaU+rrfaezYhQI3h+pGMETDhUijv+K1JrciXQb9ArAJQfyT545MlJlPC6OLcyu6GtxVj+tlQVIxC1wNk9sbg6C5Dynbwf7TCURqKmnF39nIk=">WebKit 源码</a>中得到印证。</p>
<p>所以在 iOS13 上，我们可以通过 <code>os_proc_available_memory</code> 获取到当前可以用内存，通过 <code>phys_footprint</code> 获取到当前 App 占用内存，2者的和也就是当前设备的内存上限，超过即触发 Jetsam 机制。</p>
<p>- (CGFloat)limitSizeOfMemory {<br>    if (@available(iOS 13.0, *)) {<br>        task_vm_info_data_t taskInfo;<br>        mach_msg_type_number_t infoCount = TASK_VM_INFO_COUNT;<br>        kern_return_t kernReturn = task_info(mach_task_self(), TASK_VM_INFO, (task_info_t)&amp;taskInfo, &amp;infoCount);</p>
<pre><code>    if (kernReturn != KERN\_SUCCESS) &#123;
        return 0;
    &#125;
    return (CGFloat)((taskInfo.phys\_footprint + os\_proc\_available\_memory()) / (1024.0 \* 1024.0);
&#125;
return 0;</code></pre>
<p>}</p>
<p>当前可以使用内存：1435.936752MB；当前 App 已占用内存：14.5MB，临界值：1435.936752MB + 14.5MB= 1450.436MB， 和 3.1 方法中获取到的内存临界值一样「iPhone 6s plus/13.3.1 手机 OOM 临界值为：(16384*92806)/(1024*1024)=1450.09375M」。</p>
<h4 id="3-5-通过-XNU-获取内存限制值"><a href="#3-5-通过-XNU-获取内存限制值" class="headerlink" title="3.5 通过 XNU 获取内存限制值"></a>3.5 通过 XNU 获取内存限制值</h4><p>在 XNU 中，有专门用于获取内存上限值的函数和宏，可以通过 <code>memorystatus_priority_entry</code> 这个结构体得到所有进程的优先级和内存限制值。</p>
<p>typedef struct memorystatus_priority_entry {<br>  pid_t pid;<br>  int32_t priority;<br>  uint64_t user_data;<br>  int32_t limit;<br>  uint32_t state;<br>} memorystatus_priority_entry_t;</p>
<p>其中，priority 代表进程优先级，limit 代表进程的内存限制值。但是这种方式需要 root 权限，由于没有越狱设备，我没有尝试过。</p>
<p>相关代码可查阅 <code>kern_memorystatus.h</code> 文件。需要用到函数 <code>int memorystatus_control(uint32_t command, int32_t pid, uint32_t flags, void *buffer, size_t buffersize);</code></p>
<p>/* Commands */<br>#define MEMORYSTATUS_CMD_GET_PRIORITY_LIST            1<br>#define MEMORYSTATUS_CMD_SET_PRIORITY_PROPERTIES      2<br>#define MEMORYSTATUS_CMD_GET_JETSAM_SNAPSHOT          3<br>#define MEMORYSTATUS_CMD_GET_PRESSURE_STATUS          4<br>#define MEMORYSTATUS_CMD_SET_JETSAM_HIGH_WATER_MARK   5    /* Set active memory limit = inactive memory limit, both non-fatal    */<br>#define MEMORYSTATUS_CMD_SET_JETSAM_TASK_LIMIT          6    /* Set active memory limit = inactive memory limit, both fatal    */<br>#define MEMORYSTATUS_CMD_SET_MEMLIMIT_PROPERTIES      7    /* Set memory limits plus attributes independently            */<br>#define MEMORYSTATUS_CMD_GET_MEMLIMIT_PROPERTIES      8    /* Get memory limits plus attributes                    */<br>#define MEMORYSTATUS_CMD_PRIVILEGED_LISTENER_ENABLE   9    /* Set the task’s status as a privileged listener w.r.t memory notifications  */<br>#define MEMORYSTATUS_CMD_PRIVILEGED_LISTENER_DISABLE  10   /* Reset the task’s status as a privileged listener w.r.t memory notifications  */<br>#define MEMORYSTATUS_CMD_AGGRESSIVE_JETSAM_LENIENT_MODE_ENABLE  11   /* Enable the ‘lenient’ mode for aggressive jetsam. See comments in kern_memorystatus.c near the top. */<br>#define MEMORYSTATUS_CMD_AGGRESSIVE_JETSAM_LENIENT_MODE_DISABLE 12   /* Disable the ‘lenient’ mode for aggressive jetsam. */<br>#define MEMORYSTATUS_CMD_GET_MEMLIMIT_EXCESS          13   /* Compute how much a process’s phys_footprint exceeds inactive memory limit */<br>#define MEMORYSTATUS_CMD_ELEVATED_INACTIVEJETSAMPRIORITY_ENABLE     14 /* Set the inactive jetsam band for a process to JETSAM_PRIORITY_ELEVATED_INACTIVE */<br>#define MEMORYSTATUS_CMD_ELEVATED_INACTIVEJETSAMPRIORITY_DISABLE     15 /* Reset the inactive jetsam band for a process to the default band (0)*/<br>#define MEMORYSTATUS_CMD_SET_PROCESS_IS_MANAGED       16   /* (Re-)Set state on a process that marks it as (un-)managed by a system entity e.g. assertiond */<br>#define MEMORYSTATUS_CMD_GET_PROCESS_IS_MANAGED       17   /* Return the ‘managed’ status of a process */<br>#define MEMORYSTATUS_CMD_SET_PROCESS_IS_FREEZABLE     18   /* Is the process eligible for freezing? Apps and extensions can pass in FALSE to opt out of freezing, i.e.,</p>
<p>伪代码</p>
<p>struct memorystatus_priority_entry memStatus[NUM_ENTRIES];<br>size_t count = sizeof(struct memorystatus_priority_entry) * NUM_ENTRIES;<br>int kernResult = memorystatus_control(MEMORYSTATUS_CMD_GET_PRIORITY_LIST, 0, 0, memStatus, count);<br>if (rc &lt; 0) {<br>  NSLog(@”memorystatus_control”);<br>    return ;<br>}</p>
<p>int entry = 0;<br>for (; rc &gt; 0; rc -= sizeof(struct memorystatus_priority_entry)){<br>  printf (“PID: %5d\tPriority:%2d\tUser Data: %llx\tLimit:%2d\tState:%s\n”,<br>          memstatus[entry].pid,<br>          memstatus[entry].priority,<br>          memstatus[entry].user_data,<br>          memstatus[entry].limit,<br>          state_to_text(memstatus[entry].state));<br>  entry++;<br>}</p>
<p>for 循环打印出每个进程（也就是 App）的 pid、Priority、User Data、Limit、State 信息。从 log 中找出优先级为10的进程，即我们前台运行的 App。为什么是10？ 因为 <code>#define JETSAM_PRIORITY_FOREGROUND 10</code> 我们的目的就是获取前台 App 的内存上限值。</p>
<h3 id="4-如何判定发生了-OOM"><a href="#4-如何判定发生了-OOM" class="headerlink" title="4. 如何判定发生了 OOM"></a>4. 如何判定发生了 OOM</h3><p>OOM 导致 crash 前，app 一定会收到低内存警告吗？</p>
<p>做2组对比实验：</p>
<p>// 实验1<br>NSMutableArray *array = [NSMutableArray array];<br>for (NSInteger index = 0; index &lt; 10000000; index++) {<br>  NSString *filePath = [[NSBundle mainBundle] pathForResource:@”Info” ofType:@”plist”];<br>  NSData *data = [NSData dataWithContentsOfFile:filePath];<br>  [array addObject:data];<br>}</p>
<p>// 实验2<br>// ViewController.m</p>
<ul>
<li>(void)viewDidLoad {<br>  [super viewDidLoad];<br>  dispatch_async(dispatch_get_global_queue(0, 0), ^{<pre><code>  NSMutableArray \*array = \[NSMutableArray array\];
  for (NSInteger index = 0; index &lt; 10000000; index++) &#123;
      NSString \*filePath = \[\[NSBundle mainBundle\] pathForResource:@&quot;Info&quot; ofType:@&quot;plist&quot;\];
      NSData \*data = \[NSData dataWithContentsOfFile:filePath\];
      \[array addObject:data\];
  &#125;</code></pre>
  });<br>}</li>
<li>(void)didReceiveMemoryWarning<br>{<br>  NSLog(@”2”);<br>}</li>
</ul>
<p>// AppDelegate.m</p>
<ul>
<li>(void)applicationDidReceiveMemoryWarning:(UIApplication *)application<br>{<br>  NSLog(@”1”);<br>}</li>
</ul>
<p>现象：</p>
<ol>
<li> 在 viewDidLoad 也就是主线程中内存消耗过大，系统并不会发出低内存警告，直接 Crash。因为内存增长过快，主线程很忙。</li>
<li> 多线程的情况下，App 因内存增长过快，会收到低内存警告，AppDelegate 中的<code>applicationDidReceiveMemoryWarning</code> 先执行，随后是当前 VC 的 <code>didReceiveMemoryWarning</code>。</li>
</ol>
<p>结论：</p>
<p><strong>收到低内存警告不一定会 Crash，因为有6秒钟的系统判断时间，6秒内内存下降了则不会 crash。发生 OOM 也不一定会收到低内存警告。</strong></p>
<h3 id="5-内存信息收集"><a href="#5-内存信息收集" class="headerlink" title="5. 内存信息收集"></a>5. 内存信息收集</h3><p>要想精确的定位问题，就需要 dump 所有对象及其内存信息。当内存接近系统内存上限的时候，收集并记录所需信息，结合一定的数据上报机制，上传到服务器，分析并修复。</p>
<p>还需要知道每个对象具体是在哪个函数里创建出来的，以便还原“案发现场”。</p>
<p>源代码（libmalloc/malloc），内存分配函数 malloc 和 calloc 等默认使用 nano_zone，nano_zone 是小于 256B 以下的内存分配，大于 256B 则使用 scalable_zone 来分配。</p>
<p>主要针对大内存的分配监控。malloc 函数用的是 malloc_zone_malloc, calloc 用的是 malloc_zone_calloc。</p>
<p>使用 scalable_zone 分配内存的函数都会调用 malloc_logger 函数，因为系统为了有个地方专门统计并管理内存分配情况。这样的设计也满足「收口原则」。</p>
<p>void *<br>malloc(size_t size) {<br>    void *retval;<br>    retval = malloc_zone_malloc(default_zone, size);<br>    if (retval == NULL) {<br>        errno = ENOMEM;<br>    }<br>    return retval;<br>}</p>
<p>void *<br>calloc(size_t num_items, size_t size) {<br>    void *retval;<br>    retval = malloc_zone_calloc(default_zone, num_items, size);<br>    if (retval == NULL) {<br>        errno = ENOMEM;<br>    }<br>    return retval;<br>}</p>
<p>首先来看看这个 <code>default_zone</code> 是什么东西, 代码如下</p>
<p>typedef struct {<br>    malloc_zone_t malloc_zone;<br>    uint8_t pad[PAGE_MAX_SIZE - sizeof(malloc_zone_t)];<br>} virtual_default_zone_t;</p>
<p>static virtual_default_zone_t virtual_default_zone<br>__attribute__((section(“__DATA,__v_zone”)))<br>__attribute__((aligned(PAGE_MAX_SIZE))) = {<br>    NULL,<br>    NULL,<br>    default_zone_size,<br>    default_zone_malloc,<br>    default_zone_calloc,<br>    default_zone_valloc,<br>    default_zone_free,<br>    default_zone_realloc,<br>    default_zone_destroy,<br>    DEFAULT_MALLOC_ZONE_STRING,<br>    default_zone_batch_malloc,<br>    default_zone_batch_free,<br>    &amp;default_zone_introspect,<br>    10,<br>    default_zone_memalign,<br>    default_zone_free_definite_size,<br>    default_zone_pressure_relief,<br>    default_zone_malloc_claimed_address,<br>};</p>
<p>static malloc_zone_t *default_zone = &amp;virtual_default_zone.malloc_zone;</p>
<p>static void *<br>default_zone_malloc(malloc_zone_t *zone, size_t size) {<br>    zone = runtime_default_zone();</p>
<pre><code>return zone-&gt;malloc(zone, size);</code></pre>
<p>}</p>
<p>MALLOC_ALWAYS_INLINE<br>static inline malloc_zone_t *<br>runtime_default_zone() {<br>    return (lite_zone) ? lite_zone : inline_malloc_default_zone();<br>}</p>
<p>可以看到 <code>default_zone</code> 通过这种方式来初始化</p>
<p>static inline malloc_zone_t *<br>inline_malloc_default_zone(void) {<br>    _malloc_initialize_once();<br>    // malloc_report(ASL_LEVEL_INFO, “In inline_malloc_default_zone with %d %d\n”, malloc_num_zones, malloc_has_debug_zone);<br>    return malloc_zones[0];<br>}</p>
<p><strong>随后的调用如下</strong><br><code>_malloc_initialize</code> -&gt; <code>create_scalable_zone</code> -&gt; <code>create_scalable_szone</code> 最终我们创建了 szone_t 类型的对象，通过类型转换，得到了我们的 default_zone。</p>
<p>malloc_zone_t *<br>create_scalable_zone(size_t initial_size, unsigned debug_flags) {<br>    return (malloc_zone_t *) create_scalable_szone(initial_size, debug_flags);<br>}</p>
<p>void *malloc_zone_malloc(malloc_zone_t *zone, size_t size) {<br>  MALLOC_TRACE(TRACE_malloc | DBG_FUNC_START, (uintptr_t)zone, size, 0, 0);<br>  void *ptr;<br>  if (malloc_check_start &amp;&amp; (malloc_check_counter++ &gt;= malloc_check_start)) {<br>    internal_check();<br>  }<br>  if (size &gt; MALLOC_ABSOLUTE_MAX_SIZE) {<br>    return NULL;<br>  }<br>  ptr = zone-&gt;malloc(zone, size);<br>  // 在 zone 分配完内存后就开始使用 malloc_logger 进行进行记录<br>  if (malloc_logger) {<br>    malloc_logger(MALLOC_LOG_TYPE_ALLOCATE | MALLOC_LOG_TYPE_HAS_ZONE, (uintptr_t)zone, (uintptr_t)size, 0, (uintptr_t)ptr, 0);<br>  }<br>  MALLOC_TRACE(TRACE_malloc | DBG_FUNC_END, (uintptr_t)zone, size, (uintptr_t)ptr, 0);<br>  return ptr;<br>}</p>
<p>其分配实现是 <code>zone-&gt;malloc</code> 根据之前的分析，就是szone_t结构体对象中对应的malloc实现。</p>
<p>在创建szone之后，做了一系列如下的初始化操作。</p>
<p>// Initialize the security token.<br>szone-&gt;cookie = (uintptr_t)malloc_entropy[0];</p>
<p>szone-&gt;basic_zone.version = 12;<br>szone-&gt;basic_zone.size = (void *)szone_size;<br>szone-&gt;basic_zone.malloc = (void *)szone_malloc;<br>szone-&gt;basic_zone.calloc = (void *)szone_calloc;<br>szone-&gt;basic_zone.valloc = (void *)szone_valloc;<br>szone-&gt;basic_zone.free = (void *)szone_free;<br>szone-&gt;basic_zone.realloc = (void *)szone_realloc;<br>szone-&gt;basic_zone.destroy = (void *)szone_destroy;<br>szone-&gt;basic_zone.batch_malloc = (void *)szone_batch_malloc;<br>szone-&gt;basic_zone.batch_free = (void *)szone_batch_free;<br>szone-&gt;basic_zone.introspect = (struct malloc_introspection_t *)&amp;szone_introspect;<br>szone-&gt;basic_zone.memalign = (void *)szone_memalign;<br>szone-&gt;basic_zone.free_definite_size = (void *)szone_free_definite_size;<br>szone-&gt;basic_zone.pressure_relief = (void *)szone_pressure_relief;<br>szone-&gt;basic_zone.claimed_address = (void *)szone_claimed_address;</p>
<p>其他使用 scalable_zone 分配内存的函数的方法也类似，所以大内存的分配，不管外部函数如何封装，最终都会调用到 malloc_logger 函数。所以我们可以用 fishhook 去 hook 这个函数，然后记录内存分配情况，结合一定的数据上报机制，上传到服务器，分析并修复。</p>
<p>// For logging VM allocation and deallocation, arg1 here<br>// is the mach_port_name_t of the target task in which the<br>// alloc or dealloc is occurring. For example, for mmap()<br>// that would be mach_task_self(), but for a cross-task-capable<br>// call such as mach_vm_map(), it is the target task.</p>
<p>typedef void (malloc_logger_t)(uint32_t type, uintptr_t arg1, uintptr_t arg2, uintptr_t arg3, uintptr_t result, uint32_t num_hot_frames_to_skip);</p>
<p>extern malloc_logger_t *__syscall_logger;</p>
<p>当 malloc_logger 和 __syscall_logger 函数指针不为空时，malloc/free、vm_allocate/vm_deallocate 等内存分配/释放通过这两个指针通知上层，这也是内存调试工具 malloc stack 的实现原理。有了这两个函数指针，我们很容易记录当前存活对象的内存分配信息（包括分配大小和分配堆栈）。分配堆栈可以用 backtrace 函数捕获，但捕获到的地址是虚拟内存地址，不能从符号表 DSYM 解析符号。所以还要记录每个 image 加载时的偏移 slide，这样 <strong>符号表地址 = 堆栈地址 - slide。</strong></p>
<p>小 tips：</p>
<p>ASLR（Address space layout randomization）：常见称呼为位址空间随机载入、位址空间配置随机化、位址空间布局随机化，是一种防止内存损坏漏洞被利用的计算机安全技术，通过随机放置进程关键数据区域的定址空间来放置攻击者能可靠地跳转到内存的特定位置来操作函数。现代作业系统一般都具备该机制。</p>
<p>函数地址 add: 函数真实的实现地址;</p>
<p>函数虚拟地址：<code>vm_add</code>;</p>
<p>ASLR: <code>slide</code> 函数虚拟地址加载到进程内存的随机偏移量，每个 mach-o 的 slide 各不相同。<code>vm_add + slide = add</code>。也就是：<code>*(base +offset)= imp</code>。</p>
<p>由于腾讯也开源了自己的 OOM 定位方案- <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=yKbHc3af98aQlln5PiMykQ==.TLNJTvH5g0hkQIcULZcKaEhuB4PrGx64mTZELylFElD2YaHmAbY9Klysfkjwk8a/">OOMDetector</a> ，有了现成的轮子，那么用好就可以了，所以对于内存的监控思路就是找到系统给 App 的内存上限，然后当接近内存上限值的时候，dump 内存情况，组装基础数据信息成一个合格的上报数据，经过一定的数据上报策略到服务端，服务端消费数据，分析产生报表，客户端工程师根据报表分析问题。不同工程的数据以邮件、短信、企业微信等形式通知到该项目的 owner、开发者。（情况严重的会直接电话给开发者，并给主管跟进每一步的处理结果）。<br>问题分析处理后要么发布新版本，要么 hot fix。</p>
<h3 id="6-开发阶段针对内存我们能做些什么"><a href="#6-开发阶段针对内存我们能做些什么" class="headerlink" title="6. 开发阶段针对内存我们能做些什么"></a>6. 开发阶段针对内存我们能做些什么</h3><ol>
<li><p>图片缩放</p>
<p> WWDC 2018 Session 416 - iOS Memory Deep Dive，处理图片缩放的时候直接使用 UIImage 会在解码时读取文件而占用一部分内存，还会生成中间位图 bitmap 消耗大量内存。而 <strong>ImageIO</strong> 不存在上述2种弊端，只会占用最终图片大小的内存</p>
<p> 做了2组对比实验：给 App 显示一张图片</p>
<p> // 方法1: 19.6M<br> UIImage *imageResult = [self scaleImage:[UIImage imageNamed:@”test”]                                                  newSize:CGSizeMake(self.view.frame.size.width, self.view.frame.size.height)];<br> self.imageView.image = imageResult;</p>
<p> // 方法2: 14M<br> NSData *data = UIImagePNGRepresentation([UIImage imageNamed:@”test”]);<br> UIImage *imageResult = [self scaledImageWithData:data                     withSize:CGSizeMake(self.view.frame.size.width, self.view.frame.size.height) scale:3 orientation:UIImageOrientationUp];<br> self.imageView.image = imageResult;</p>
<ul>
<li><p>(UIImage *)scaleImage:(UIImage *)image newSize:(CGSize)newSize<br>{<br>  UIGraphicsBeginImageContextWithOptions(newSize, NO, 0);<br>  [image drawInRect:CGRectMake(0, 0, newSize.width, newSize.height)];<br>  UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();<br>  UIGraphicsEndImageContext();<br>  return newImage;<br>}</p>
</li>
<li><p>(UIImage *)scaledImageWithData:(NSData *)data withSize:(CGSize)size scale:(CGFloat)scale orientation:(UIImageOrientation)orientation<br>{<br>  CGFloat maxPixelSize = MAX(size.width, size.height);<br>  CGImageSourceRef sourceRef = CGImageSourceCreateWithData((__bridge CFDataRef)data, nil);<br>  NSDictionary *options = @{(__bridge id)kCGImageSourceCreateThumbnailFromImageAlways : (__bridge id)kCFBooleanTrue,</p>
<pre><code>                        (\_\_bridge id)kCGImageSourceThumbnailMaxPixelSize : \[NSNumber numberWithFloat:maxPixelSize\]&#125;;</code></pre>
<p>  CGImageRef imageRef = CGImageSourceCreateThumbnailAtIndex(sourceRef, 0, (__bridge CFDictionaryRef)options);<br>  UIImage *resultImage = [UIImage imageWithCGImage:imageRef scale:scale orientation:orientation];<br>  CGImageRelease(imageRef);<br>  CFRelease(sourceRef);<br>  return resultImage;<br>}</p>
</li>
</ul>
</li>
</ol>
<p>可以看出使用 ImageIO 比使用 UIImage 直接缩放占用内存更低。</p>
<ol start="2">
<li><p>合理使用 autoreleasepool</p>
<p> 我们知道 autoreleasepool 对象是在 RunLoop 结束时才释放。在 ARC 下，我们如果在不断申请内存，比如各种循环，那么我们就需要手动添加 autoreleasepool，避免短时间内内存猛涨发生 OOM。</p>
<p> 对比实验</p>
<p> // 实验1<br> NSMutableArray *array = [NSMutableArray array];<br> for (NSInteger index = 0; index &lt; 10000000; index++) {<br>  NSString *indexStrng = [NSString stringWithFormat:@”%zd”, index];<br>  NSString *resultString = [NSString stringWithFormat:@”%zd-%@”, index, indexStrng];<br>  [array addObject:resultString];<br> }</p>
<p> // 实验2<br> NSMutableArray *array = [NSMutableArray array];<br> for (NSInteger index = 0; index &lt; 10000000; index++) {<br>  @autoreleasepool {<br>  NSString *indexStrng = [NSString stringWithFormat:@”%zd”, index];<br>  NSString *resultString = [NSString stringWithFormat:@”%zd-%@”, index, indexStrng];<br>  [array addObject:resultString];<br>  }<br> }</p>
</li>
</ol>
<p>实验1消耗内存 739.6M，实验2消耗内存 587M。</p>
<ol start="3">
<li><p> UIGraphicsBeginImageContext 和 UIGraphicsEndImageContext 必须成双出现，不然会造成 context 泄漏。另外 XCode 的 Analyze 也能扫出这类问题。</p>
</li>
<li><p> 不管是打开网页，还是执行 js，都应该使用 WKWebView。UIWebView 会占用大量内存，从而导致 App 发生 OOM 的几率增加，而 WKWebView 是一个多进程组件，Network Loading 以及 UI Rendering 在其它进程中执行，比 UIWebView 占用更低的内存开销。</p>
</li>
<li><p>在做 SDK 或者 App，如果场景是缓存相关，尽量使用 NSCache 而不是 NSMutableDictionary。它是系统提供的专门处理缓存的类，NSCache 分配的内存是 <code>Purgeable Memory</code>，可以由系统自动释放。NSCache 与 NSPureableData 的结合使用可以让系统根据情况回收内存，也可以在内存清理时移除对象。</p>
<p> 其他的开发习惯就不一一描述了，良好的开发习惯和代码意识是需要平时注意修炼的。</p>
</li>
</ol>
<h3 id="7-现状及其改进"><a href="#7-现状及其改进" class="headerlink" title="7. 现状及其改进"></a>7. 现状及其改进</h3><p>在使用了一波业界优秀的的内存监控工具后发现了一些问题，比如 <code>MLeaksFinder</code>、<code>OOMDetector</code>、<code>FBRetainCycleDetector</code>等都有一些问题。比如 <code>MLeaksFinder</code> 因为单纯通过 VC 的 push、pop 等检测内存泄露的情况，会存在误报的情况。<code>FBRetainCycleDetector</code> 则因为对象深度优先遍历，会有一些性能问题，影响 App 性能。<code>OOMDetector</code> 因为没有合适的触发时机。</p>
<p>思路有2种：</p>
<ul>
<li>  <code>MLeaksFinder</code> + <code>FBRetainCycleDetector</code> 结合提高准确性</li>
<li>  借鉴头条的实现方案：基于内存快照技术的线上方案，我们称之为——线上 Memory Graph。（引用如下）</li>
</ul>
<blockquote>
<ul>
<li>  基于 Objective-C 对象引用关系找循环引用的方案，适用范围比较小，只能处理部分循环引用问题，而内存问题通常是复杂的，类似于内存堆积，Root Leak，C/C++层问题都无法解决。</li>
<li>  基于分配堆栈信息聚类的方案需要常驻运行，对内存、CPU 等资源存在较大消耗，无法针对有内存问题的用户进行监控，只能广撒网，用户体验影响较大。同时，通过某些比较通用的堆栈分配的内存无法定位出实际的内存使用场景，对于循环引用等常见泄漏也无法分析。</li>
</ul>
</blockquote>
<p>核心原理是： 扫描进程中所有的 Dirty 内存，通过内存节点中保存的其他内存节点的地址值，建立起内存节点之间的引用关系的有向图。</p>
<p>全部的讲解可以看这里)。对于 Memory Graph 的实现细节感兴趣的可以看这篇<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=JCBA55CJcQityylTd2V54w==.YaCpcpVk5R35as3/ROYixsLzKFlCP2yFYxf4IsraLh/EQjp7u9kioXChaJGQzACX">文章</a></p>
<h2 id="五、-App-网络监控"><a href="#五、-App-网络监控" class="headerlink" title="五、 App 网络监控"></a>五、 App 网络监控</h2><p>移动网络环境一直很复杂，WIFI、2G、3G、4G、5G 等，用户使用 App 的过程中可能在这几种类型之间切换，这也是移动网络和传统网络间的一个区别，被称为「Connection Migration」。此外还存在 DNS 解析缓慢、失败率高、运营商劫持等问题。用户在使用 App 时因为某些原因导致体验很差，要想针对网络情况进行改善，必须有清晰的监控手段。</p>
<h3 id="1-App-网络请求过程"><a href="#1-App-网络请求过程" class="headerlink" title="1. App 网络请求过程"></a>1. App 网络请求过程</h3><p><img src="https://segmentfault.com/img/bVbIOhA"></p>
<p>App 发送一次网络请求一般会经历下面几个关键步骤：</p>
<ul>
<li><p>DNS 解析</p>
<p>  Domain Name system，网络域名名称系统，本质上就是将<code>域名</code>和<code>IP 地址</code> 相互映射的一个分布式数据库，使人们更方便的访问互联网。首先会查询本地的 DNS 缓存，查找失败就去 DNS 服务器查询，这其中可能会经过非常多的节点，涉及到<strong>递归查询和迭代查询</strong>的过程。运营商可能不干人事：一种情况就是出现运营商劫持的现象，表现为你在 App 内访问某个网页的时候会看到和内容不相关的广告；另一种可能的情况就是把你的请求丢给非常远的基站去做 DNS 解析，导致我们 App 的 DNS 解析时间较长，App 网络效率低。一般做 HTTPDNS 方案去自行解决 DNS 的问题。</p>
</li>
<li><p>TCP 3次握手</p>
<p>  关于 TCP 握手过程中为什么是3次握手而不是2次、4次，可以查看这篇<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=4bf4fIci5+2SfwGhscbC8A==.JejU/qg7VrCdv+zxcQmevbCzhRa1Cmx81mmRYmh1XkWKMZhUAMuy+3VW42U2OI1iy1tkPAqSWzWeVDDOI15+9g==">文章</a>。</p>
</li>
<li><p>TLS 握手</p>
<p>  对于 HTTPS 请求还需要做 TLS 握手，也就是密钥协商的过程。</p>
</li>
<li><p>发送请求</p>
<p>  连接建立好之后就可以发送 request，此时可以记录下 request start 时间</p>
</li>
<li><p>等待回应</p>
<p>  等待服务器返回响应。这个时间主要取决于资源大小，也是网络请求过程中最为耗时的一个阶段。</p>
</li>
<li><p>返回响应</p>
<p>  服务端返回响应给客户端，根据 HTTP header 信息中的状态码判断本次请求是否成功、是否走缓存、是否需要重定向。</p>
</li>
</ul>
<h3 id="2-监控原理"><a href="#2-监控原理" class="headerlink" title="2. 监控原理"></a>2. 监控原理</h3><p>名称</p>
<p>说明</p>
<p>NSURLConnection</p>
<p>已经被废弃。用法简单</p>
<p>NSURLSession</p>
<p>iOS7.0 推出，功能更强大</p>
<p>CFNetwork</p>
<p>NSURL 的底层，纯 C 实现</p>
<p>iOS 网络框架层级关系如下：</p>
<p><img src="https://segmentfault.com/img/bVbIOhF"></p>
<p>iOS 网络现状是由4层组成的：最底层的 BSD Sockets、SecureTransport；次级底层是 CFNetwork、NSURLSession、NSURLConnection、WebView 是用 Objective-C 实现的，且调用 CFNetwork；应用层框架 AFNetworking 基于 NSURLSession、NSURLConnection 实现。</p>
<p>目前业界对于网络监控主要有2种：一种是通过 NSURLProtocol 监控、一种是通过 Hook 来监控。下面介绍几种办法来监控网络请求，各有优缺点。</p>
<h4 id="2-1-方案一：NSURLProtocol-监控-App-网络请求"><a href="#2-1-方案一：NSURLProtocol-监控-App-网络请求" class="headerlink" title="2.1 方案一：NSURLProtocol 监控 App 网络请求"></a>2.1 方案一：NSURLProtocol 监控 App 网络请求</h4><p>NSURLProtocol 作为上层接口，使用较为简单，但 NSURLProtocol 属于 URL Loading System 体系中。应用协议的支持程度有限，支持 FTP、HTTP、HTTPS 等几个应用层协议，对于其他的协议则无法监控，存在一定的局限性。如果监控底层网络库 CFNetwork 则没有这个限制。</p>
<p>对于 NSURLProtocol 的具体做法在<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=32MAqCv5rRh1xG9swBrweQ==.waVikw52hdsc0HH/KXTAhq1AbWxJWzODd9KmUKRpFe0ys3u+yRMdMdKnPLFVrtinIpYrvdbyeC33qKZqTeuJx8TDkWj/hIeStA+z7zej8a/ZVIlwwrLHg+MKzIhLU5BM">这篇文章</a>中讲过，继承抽象类并实现相应的方法，自定义去发起网络请求来实现监控的目的。</p>
<p>iOS 10 之后，NSURLSessionTaskDelegate 中增加了一个新的代理方法：</p>
<p>/*<br> * Sent when complete statistics information has been collected for the task.<br> */</p>
<ul>
<li>(void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didFinishCollectingMetrics:(NSURLSessionTaskMetrics *)metrics API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));</li>
</ul>
<p>可以从 <code>NSURLSessionTaskMetrics</code> 中获取到网络情况的各项指标。各项参数如下</p>
<p>@interface NSURLSessionTaskMetrics : NSObject</p>
<p>/*<br> * transactionMetrics array contains the metrics collected for every request/response transaction created during the task execution.<br> */<br>@property (copy, readonly) NSArray&lt;NSURLSessionTaskTransactionMetrics *&gt; *transactionMetrics;</p>
<p>/*<br> * Interval from the task creation time to the task completion time.<br> * Task creation time is the time when the task was instantiated.<br> * Task completion time is the time when the task is about to change its internal state to completed.<br> */<br>@property (copy, readonly) NSDateInterval *taskInterval;</p>
<p>/*<br> * redirectCount is the number of redirects that were recorded.<br> */<br>@property (assign, readonly) NSUInteger redirectCount;</p>
<ul>
<li>(instancetype)init API_DEPRECATED(“Not supported”, macos(10.12,10.15), ios(10.0,13.0), watchos(3.0,6.0), tvos(10.0,13.0));</li>
</ul>
<ul>
<li>(instancetype)new API_DEPRECATED(“Not supported”, macos(10.12,10.15), ios(10.0,13.0), watchos(3.0,6.0), tvos(10.0,13.0));</li>
</ul>
<p>@end</p>
<p>其中：<code>taskInterval</code> 表示任务从创建到完成话费的总时间，任务的创建时间是任务被实例化时的时间，任务完成时间是任务的内部状态将要变为完成的时间；<code>redirectCount</code> 表示被重定向的次数；<code>transactionMetrics</code> 数组包含了任务执行过程中每个请求/响应事务中收集的指标，各项参数如下：</p>
<pre><code>/*
 * This class defines the performance metrics collected for a request/response transaction during the task execution.
 */
API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0))
@interface NSURLSessionTaskTransactionMetrics : NSObject

/*
 * Represents the transaction request. 请求事务
 */
@property (copy, readonly) NSURLRequest *request;

/*
 * Represents the transaction response. Can be nil if error occurred and no response was generated. 响应事务
 */
@property (nullable, copy, readonly) NSURLResponse *response;

/*
 * For all NSDate metrics below, if that aspect of the task could not be completed, then the corresponding “EndDate” metric will be nil.
 * For example, if a name lookup was started but the name lookup timed out, failed, or the client canceled the task before the name could be resolved -- then while domainLookupStartDate may be set, domainLookupEndDate will be nil along with all later metrics.
 */

/*
 * 客户端开始请求的时间，无论是从服务器还是从本地缓存中获取
 * fetchStartDate returns the time when the user agent started fetching the resource, whether or not the resource was retrieved from the server or local resources.
 *
 * The following metrics will be set to nil, if a persistent connection was used or the resource was retrieved from local resources:
 *
 *   domainLookupStartDate
 *   domainLookupEndDate
 *   connectStartDate
 *   connectEndDate
 *   secureConnectionStartDate
 *   secureConnectionEndDate
 */
@property (nullable, copy, readonly) NSDate *fetchStartDate;

/*
 * domainLookupStartDate returns the time immediately before the user agent started the name lookup for the resource. DNS 开始解析的时间
 */
@property (nullable, copy, readonly) NSDate *domainLookupStartDate;

/*
 * domainLookupEndDate returns the time after the name lookup was completed. DNS 解析完成的时间
 */
@property (nullable, copy, readonly) NSDate *domainLookupEndDate;

/*
 * connectStartDate is the time immediately before the user agent started establishing the connection to the server.
 *
 * For example, this would correspond to the time immediately before the user agent started trying to establish the TCP connection. 客户端与服务端开始建立 TCP 连接的时间
 */
@property (nullable, copy, readonly) NSDate *connectStartDate;

/*
 * If an encrypted connection was used, secureConnectionStartDate is the time immediately before the user agent started the security handshake to secure the current connection. HTTPS 的 TLS 握手开始的时间
 *
 * For example, this would correspond to the time immediately before the user agent started the TLS handshake. 
 *
 * If an encrypted connection was not used, this attribute is set to nil.
 */
@property (nullable, copy, readonly) NSDate *secureConnectionStartDate;

/*
 * If an encrypted connection was used, secureConnectionEndDate is the time immediately after the security handshake completed. HTTPS 的 TLS 握手结束的时间
 *
 * If an encrypted connection was not used, this attribute is set to nil.
 */
@property (nullable, copy, readonly) NSDate *secureConnectionEndDate;

/*
 * connectEndDate is the time immediately after the user agent finished establishing the connection to the server, including completion of security-related and other handshakes. 客户端与服务器建立 TCP 连接完成的时间，包括 TLS 握手时间
 */
@property (nullable, copy, readonly) NSDate *connectEndDate;

/*
 * requestStartDate is the time immediately before the user agent started requesting the source, regardless of whether the resource was retrieved from the server or local resources.
 客户端请求开始的时间，可以理解为开始传输 HTTP 请求的 header 的第一个字节时间
 *
 * For example, this would correspond to the time immediately before the user agent sent an HTTP GET request.
 */
@property (nullable, copy, readonly) NSDate *requestStartDate;

/*
 * requestEndDate is the time immediately after the user agent finished requesting the source, regardless of whether the resource was retrieved from the server or local resources.
 客户端请求结束的时间，可以理解为 HTTP 请求的最后一个字节传输完成的时间
 *
 * For example, this would correspond to the time immediately after the user agent finished sending the last byte of the request.
 */
@property (nullable, copy, readonly) NSDate *requestEndDate;

/*
 * responseStartDate is the time immediately after the user agent received the first byte of the response from the server or from local resources.
 客户端从服务端接收响应的第一个字节的时间
 *
 * For example, this would correspond to the time immediately after the user agent received the first byte of an HTTP response.
 */
@property (nullable, copy, readonly) NSDate *responseStartDate;

/*
 * responseEndDate is the time immediately after the user agent received the last byte of the resource. 客户端从服务端接收到最后一个请求的时间
 */
@property (nullable, copy, readonly) NSDate *responseEndDate;

/*
 * The network protocol used to fetch the resource, as identified by the ALPN Protocol ID Identification Sequence [RFC7301].
 * E.g., h2, http/1.1, spdy/3.1.
 网络协议名，比如 http/1.1, spdy/3.1
 *
 * When a proxy is configured AND a tunnel connection is established, then this attribute returns the value for the tunneled protocol.
 *
 * For example:
 * If no proxy were used, and HTTP/2 was negotiated, then h2 would be returned.
 * If HTTP/1.1 were used to the proxy, and the tunneled connection was HTTP/2, then h2 would be returned.
 * If HTTP/1.1 were used to the proxy, and there were no tunnel, then http/1.1 would be returned.
 *
 */
@property (nullable, copy, readonly) NSString *networkProtocolName;

/*
 * This property is set to YES if a proxy connection was used to fetch the resource.
    该连接是否使用了代理
 */
@property (assign, readonly, getter=isProxyConnection) BOOL proxyConnection;

/*
 * This property is set to YES if a persistent connection was used to fetch the resource.
 是否复用了现有连接
 */
@property (assign, readonly, getter=isReusedConnection) BOOL reusedConnection;

/*
 * Indicates whether the resource was loaded, pushed or retrieved from the local cache.
 获取资源来源
 */
@property (assign, readonly) NSURLSessionTaskMetricsResourceFetchType resourceFetchType;

/*
 * countOfRequestHeaderBytesSent is the number of bytes transferred for request header.
 请求头的字节数
 */
@property (readonly) int64_t countOfRequestHeaderBytesSent API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));

/*
 * countOfRequestBodyBytesSent is the number of bytes transferred for request body.
 请求体的字节数
 * It includes protocol-specific framing, transfer encoding, and content encoding.
 */
@property (readonly) int64_t countOfRequestBodyBytesSent API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));

/*
 * countOfRequestBodyBytesBeforeEncoding is the size of upload body data, file, or stream.
 上传体数据、文件、流的大小
 */
@property (readonly) int64_t countOfRequestBodyBytesBeforeEncoding API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));

/*
 * countOfResponseHeaderBytesReceived is the number of bytes transferred for response header.
 响应头的字节数
 */
@property (readonly) int64_t countOfResponseHeaderBytesReceived API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));

/*
 * countOfResponseBodyBytesReceived is the number of bytes transferred for response body.
 响应体的字节数
 * It includes protocol-specific framing, transfer encoding, and content encoding.
 */
@property (readonly) int64_t countOfResponseBodyBytesReceived API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));

/*
 * countOfResponseBodyBytesAfterDecoding is the size of data delivered to your delegate or completion handler.
给代理方法或者完成后处理的回调的数据大小

 */
@property (readonly) int64_t countOfResponseBodyBytesAfterDecoding API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));

/*
 * localAddress is the IP address string of the local interface for the connection.
  当前连接下的本地接口 IP 地址
 *
 * For multipath protocols, this is the local address of the initial flow.
 *
 * If a connection was not used, this attribute is set to nil.
 */
@property (nullable, copy, readonly) NSString *localAddress API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));

/*
 * localPort is the port number of the local interface for the connection.
 当前连接下的本地端口号

 *
 * For multipath protocols, this is the local port of the initial flow.
 *
 * If a connection was not used, this attribute is set to nil.
 */
@property (nullable, copy, readonly) NSNumber *localPort API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));

/*
 * remoteAddress is the IP address string of the remote interface for the connection.
 当前连接下的远端 IP 地址
 *
 * For multipath protocols, this is the remote address of the initial flow.
 *
 * If a connection was not used, this attribute is set to nil.
 */
@property (nullable, copy, readonly) NSString *remoteAddress API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));

/*
 * remotePort is the port number of the remote interface for the connection.
  当前连接下的远端端口号
 *
 * For multipath protocols, this is the remote port of the initial flow.
 *
 * If a connection was not used, this attribute is set to nil.
 */
@property (nullable, copy, readonly) NSNumber *remotePort API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));

/*
 * negotiatedTLSProtocolVersion is the TLS protocol version negotiated for the connection.
  连接协商用的 TLS 协议版本号
 * It is a 2-byte sequence in host byte order.
 *
 * Please refer to tls_protocol_version_t enum in Security/SecProtocolTypes.h
 *
 * If an encrypted connection was not used, this attribute is set to nil.
 */
@property (nullable, copy, readonly) NSNumber *negotiatedTLSProtocolVersion API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));

/*
 * negotiatedTLSCipherSuite is the TLS cipher suite negotiated for the connection.
 连接协商用的 TLS 密码套件
 * It is a 2-byte sequence in host byte order.
 *
 * Please refer to tls_ciphersuite_t enum in Security/SecProtocolTypes.h
 *
 * If an encrypted connection was not used, this attribute is set to nil.
 */
@property (nullable, copy, readonly) NSNumber *negotiatedTLSCipherSuite API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));

/*
 * Whether the connection is established over a cellular interface.
 是否是通过蜂窝网络建立的连接
 */
@property (readonly, getter=isCellular) BOOL cellular API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));

/*
 * Whether the connection is established over an expensive interface.
 是否通过昂贵的接口建立的连接
 */
@property (readonly, getter=isExpensive) BOOL expensive API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));

/*
 * Whether the connection is established over a constrained interface.
 是否通过受限接口建立的连接
 */
@property (readonly, getter=isConstrained) BOOL constrained API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));

/*
 * Whether a multipath protocol is successfully negotiated for the connection.
 是否为了连接成功协商了多路径协议
 */
@property (readonly, getter=isMultipath) BOOL multipath API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));


- (instancetype)init API_DEPRECATED(&quot;Not supported&quot;, macos(10.12,10.15), ios(10.0,13.0), watchos(3.0,6.0), tvos(10.0,13.0));
+ (instancetype)new API_DEPRECATED(&quot;Not supported&quot;, macos(10.12,10.15), ios(10.0,13.0), watchos(3.0,6.0), tvos(10.0,13.0));

@end</code></pre>
<p>网络监控简单代码</p>
<p>// 监控基础信息<br>@interface  NetworkMonitorBaseDataModel : NSObject<br>// 请求的 URL 地址<br>@property (nonatomic, strong) NSString *requestUrl;<br>//请求头<br>@property (nonatomic, strong) NSArray *requestHeaders;<br>//响应头<br>@property (nonatomic, strong) NSArray *responseHeaders;<br>//GET方法 的请求参数<br>@property (nonatomic, strong) NSString *getRequestParams;<br>//HTTP 方法, 比如 POST<br>@property (nonatomic, strong) NSString *httpMethod;<br>//协议名，如http1.0 / http1.1 / http2.0<br>@property (nonatomic, strong) NSString *httpProtocol;<br>//是否使用代理<br>@property (nonatomic, assign) BOOL useProxy;<br>//DNS解析后的 IP 地址<br>@property (nonatomic, strong) NSString *ip;<br>@end</p>
<p>// 监控信息模型<br>@interface  NetworkMonitorDataModel : NetworkMonitorBaseDataModel<br>//客户端发起请求的时间<br>@property (nonatomic, assign) UInt64 requestDate;<br>//客户端开始请求到开始dns解析的等待时间,单位ms<br>@property (nonatomic, assign) int waitDNSTime;<br>//DNS 解析耗时<br>@property (nonatomic, assign) int dnsLookupTime;<br>//tcp 三次握手耗时,单位ms<br>@property (nonatomic, assign) int tcpTime;<br>//ssl 握手耗时<br>@property (nonatomic, assign) int sslTime;<br>//一个完整请求的耗时,单位ms<br>@property (nonatomic, assign) int requestTime;<br>//http 响应码<br>@property (nonatomic, assign) NSUInteger httpCode;<br>//发送的字节数<br>@property (nonatomic, assign) UInt64 sendBytes;<br>//接收的字节数<br>@property (nonatomic, assign) UInt64 receiveBytes;</p>
<p>// 错误信息模型<br>@interface  NetworkMonitorErrorModel : NetworkMonitorBaseDataModel<br>//错误码<br>@property (nonatomic, assign) NSInteger errorCode;<br>//错误次数<br>@property (nonatomic, assign) NSUInteger errCount;<br>//异常名<br>@property (nonatomic, strong) NSString *exceptionName;<br>//异常详情<br>@property (nonatomic, strong) NSString *exceptionDetail;<br>//异常堆栈<br>@property (nonatomic, strong) NSString *stackTrace;<br>@end</p>
<p>// 继承自 NSURLProtocol 抽象类，实现响应方法，代理网络请求<br>@interface CustomURLProtocol () &lt;NSURLSessionTaskDelegate&gt;</p>
<p>@property (nonatomic, strong) NSURLSessionDataTask *dataTask;<br>@property (nonatomic, strong) NSOperationQueue *sessionDelegateQueue;<br>@property (nonatomic, strong) NetworkMonitorDataModel *dataModel;<br>@property (nonatomic, strong) NetworkMonitorErrorModel *errModel;</p>
<p>@end</p>
<p>//使用NSURLSessionDataTask请求网络</p>
<ul>
<li>(void)startLoading {<br>  NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];<pre><code>NSURLSession \*session = \[NSURLSession sessionWithConfiguration:configuration
                                                    delegate:self
                                               delegateQueue:nil\];</code></pre>
  NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration delegate:self delegateQueue:nil];<pre><code>self.sessionDelegateQueue = \[\[NSOperationQueue alloc\] init\];</code></pre>
  self.sessionDelegateQueue.maxConcurrentOperationCount = 1;<br>  self.sessionDelegateQueue.name = @”com.networkMonitor.session.queue”;<br>  self.dataTask = [session dataTaskWithRequest:self.request];<br>  [self.dataTask resume];<br>}</li>
</ul>
<p>#pragma mark - NSURLSessionTaskDelegate</p>
<ul>
<li>(void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error {<br>  if (error) {<pre><code>  \[self.client URLProtocol:self didFailWithError:error\];</code></pre>
  } else {<pre><code>  \[self.client URLProtocolDidFinishLoading:self\];</code></pre>
  }<br>  if (error) {<pre><code>  NSURLRequest \*request = task.currentRequest;
  if (request) &#123;
      self.errModel.requestUrl  = request.URL.absoluteString;        
      self.errModel.httpMethod = request.HTTPMethod;
      self.errModel.requestParams = request.URL.query;
  &#125;
  self.errModel.errorCode = error.code;
  self.errModel.exceptionName = error.domain;
  self.errModel.exceptionDetail = error.description;
// 上传 Network 数据到数据上报组件，数据上报会在 \[打造功能强大、灵活可配置的数据上报组件\](https://github.com/FantasticLBP/knowledge-kit/blob/master/Chapter1%20-%20iOS/1.80.md) 讲</code></pre>
  }<br>  self.dataTask = nil;<br>}</li>
</ul>
<ul>
<li><p>(void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didFinishCollectingMetrics:(NSURLSessionTaskMetrics *)metrics {</p>
<pre><code> if (@available(iOS 10.0, \*) &amp;&amp; \[metrics.transactionMetrics count\] &gt; 0) &#123;
  \[metrics.transactionMetrics enumerateObjectsUsingBlock:^(NSURLSessionTaskTransactionMetrics \*\_Nonnull obj, NSUInteger idx, BOOL \*\_Nonnull stop) &#123;
      if (obj.resourceFetchType == NSURLSessionTaskMetricsResourceFetchTypeNetworkLoad) &#123;
          if (obj.fetchStartDate) &#123;
              self.dataModel.requestDate = \[obj.fetchStartDate timeIntervalSince1970\] \* 1000;
          &#125;
          if (obj.domainLookupStartDate &amp;&amp; obj.domainLookupEndDate) &#123;
              self.dataModel. waitDNSTime = ceil(\[obj.domainLookupStartDate timeIntervalSinceDate:obj.fetchStartDate\] \* 1000);
              self.dataModel. dnsLookupTime = ceil(\[obj.domainLookupEndDate timeIntervalSinceDate:obj.domainLookupStartDate\] \* 1000);
          &#125;
          if (obj.connectStartDate) &#123;
              if (obj.secureConnectionStartDate) &#123;
                  self.dataModel. waitDNSTime = ceil(\[obj.secureConnectionStartDate timeIntervalSinceDate:obj.connectStartDate\] \* 1000);
              &#125; else if (obj.connectEndDate) &#123;
                  self.dataModel.tcpTime = ceil(\[obj.connectEndDate timeIntervalSinceDate:obj.connectStartDate\] \* 1000);
              &#125;
          &#125;
          if (obj.secureConnectionEndDate &amp;&amp; obj.secureConnectionStartDate) &#123;
              self.dataModel.sslTime = ceil(\[obj.secureConnectionEndDate timeIntervalSinceDate:obj.secureConnectionStartDate\] \* 1000);
          &#125;

          if (obj.fetchStartDate &amp;&amp; obj.responseEndDate) &#123;
              self.dataModel.requestTime = ceil(\[obj.responseEndDate timeIntervalSinceDate:obj.fetchStartDate\] \* 1000);
          &#125;

          self.dataModel.httpProtocol = obj.networkProtocolName;

          NSHTTPURLResponse \*response = (NSHTTPURLResponse \*)obj.response;
          if (\[response isKindOfClass:NSHTTPURLResponse.class\]) &#123;
              self.dataModel.receiveBytes = response.expectedContentLength;
          &#125;

          if (\[obj respondsToSelector:@selector(\_remoteAddressAndPort)\]) &#123;
              self.dataModel.ip = \[obj valueForKey:@&quot;\_remoteAddressAndPort&quot;\];
          &#125;

          if (\[obj respondsToSelector:@selector(\_requestHeaderBytesSent)\]) &#123;
              self.dataModel.sendBytes = \[\[obj valueForKey:@&quot;\_requestHeaderBytesSent&quot;\] unsignedIntegerValue\];
          &#125;
          if (\[obj respondsToSelector:@selector(\_responseHeaderBytesReceived)\]) &#123;
              self.dataModel.receiveBytes = \[\[obj valueForKey:@&quot;\_responseHeaderBytesReceived&quot;\] unsignedIntegerValue\];
          &#125;

         self.dataModel.requestUrl = \[obj.request.URL absoluteString\];
          self.dataModel.httpMethod = obj.request.HTTPMethod;
          self.dataModel.useProxy = obj.isProxyConnection;
      &#125;
  &#125;\];
          // 上传 Network 数据到数据上报组件，数据上报会在 \[打造功能强大、灵活可配置的数据上报组件\](https://github.com/FantasticLBP/knowledge-kit/blob/master/Chapter1%20-%20iOS/1.80.md) 讲</code></pre>
<p>  }<br>}</p>
</li>
</ul>
<h4 id="2-2-方案二：NSURLProtocol-监控-App-网络请求之黑魔法篇"><a href="#2-2-方案二：NSURLProtocol-监控-App-网络请求之黑魔法篇" class="headerlink" title="2.2 方案二：NSURLProtocol 监控 App 网络请求之黑魔法篇"></a>2.2 方案二：NSURLProtocol 监控 App 网络请求之黑魔法篇</h4><p>文章上面 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000040277799#network-2.1">2.1</a> 分析到了 NSURLSessionTaskMetrics 由于兼容性问题，对于网络监控来说似乎不太完美，但是自后在搜资料的时候看到了一篇<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=lyjF2l1sjWlNLh2nKf0mXw==.2JdFSv7uYQ9qWxE26VJkv7dXHcec4rUBP6BpC/FCKNN/5qdXhE9jLJ3RU0x8KzGA">文章</a>。文章在分析 WebView 的网络监控的时候分析 Webkit 源码的时候发现了下面代码</p>
<p>#if !HAVE(TIMINGDATAOPTIONS)<br>void setCollectsTimingData()<br>{<br>    static dispatch_once_t onceToken;<br>    dispatch_once(&amp;onceToken, ^{<br>        [NSURLConnection _setCollectsTimingData:YES];<br>        …<br>    });<br>}<br>#endif</p>
<p>也就是说明 NSURLConnection 本身有一套 <code>TimingData</code> 的收集 API，只是没有暴露给开发者，苹果自己在用而已。在 runtime header 中找到了 NSURLConnection 的 <code>_setCollectsTimingData:</code> 、<code>_timingData</code> 2个 api（iOS8 以后可以使用）。</p>
<p>NSURLSession 在 iOS9 之前使用 <code>_setCollectsTimingData:</code> 就可以使用 TimingData 了。</p>
<p>注意：</p>
<ul>
<li>  因为是私有 API，所以在使用的时候注意混淆。比如 <code>[[@&quot;_setC&quot; stringByAppendingString:@&quot;ollectsT&quot;] stringByAppendingString:@&quot;imingData:&quot;]</code>。</li>
<li>  不推荐私有 API，一般做 APM 的属于公共团队，你想想看虽然你做的 SDK 达到网络监控的目的了，但是万一给业务线的 App 上架造成了问题，那就得不偿失了。一般这种投机取巧，不是百分百确定的事情可以在玩具阶段使用。</li>
</ul>
<p>@interface _NSURLConnectionProxy : DelegateProxy</p>
<p>@end</p>
<p>@implementation _NSURLConnectionProxy</p>
<ul>
<li><p>(BOOL)respondsToSelector:(SEL)aSelector<br>{<br>  if ([NSStringFromSelector(aSelector) isEqualToString:@”connectionDidFinishLoading:”]) {</p>
<pre><code>  return YES;</code></pre>
<p>  }<br>  return [self.target respondsToSelector:aSelector];<br>}</p>
</li>
<li><p>(void)forwardInvocation:(NSInvocation *)invocation<br>{<br>  [super forwardInvocation:invocation];<br>  if ([NSStringFromSelector(invocation.selector) isEqualToString:@”connectionDidFinishLoading:”]) {</p>
<pre><code>  \_\_unsafe\_unretained NSURLConnection \*conn;
  \[invocation getArgument:&amp;conn atIndex:2\];
  SEL selector = NSSelectorFromString(\[@&quot;\_timin&quot; stringByAppendingString:@&quot;gData&quot;\]);
  NSDictionary \*timingData = \[conn performSelector:selector\];
  \[\[NTDataKeeper shareInstance\] trackTimingData:timingData request:conn.currentRequest\];</code></pre>
<p>  }<br>}</p>
</li>
</ul>
<p>@end</p>
<p>@implementation NSURLConnection(tracker)</p>
<ul>
<li><p>(void)load<br>{<br>  static dispatch_once_t onceToken;<br>  dispatch_once(&amp;onceToken, ^{</p>
<pre><code>  Class class = \[self class\];

  SEL originalSelector = @selector(initWithRequest:delegate:);
  SEL swizzledSelector = @selector(swizzledInitWithRequest:delegate:);

  Method originalMethod = class\_getInstanceMethod(class, originalSelector);
  Method swizzledMethod = class\_getInstanceMethod(class, swizzledSelector);
  method\_exchangeImplementations(originalMethod, swizzledMethod);

  NSString \*selectorName = \[\[@&quot;\_setC&quot; stringByAppendingString:@&quot;ollectsT&quot;\] stringByAppendingString:@&quot;imingData:&quot;\];
  SEL selector = NSSelectorFromString(selectorName);
  \[NSURLConnection performSelector:selector withObject:@(YES)\];</code></pre>
<p>  });<br>}</p>
</li>
</ul>
<ul>
<li>(instancetype)swizzledInitWithRequest:(NSURLRequest *)request delegate:(id&lt;NSURLConnectionDelegate&gt;)delegate<br>{<br>  if (delegate) {<pre><code>  \_NSURLConnectionProxy \*proxy = \[\[\_NSURLConnectionProxy alloc\] initWithTarget:delegate\];
  objc\_setAssociatedObject(delegate ,@&quot;\_NSURLConnectionProxy&quot; ,proxy, OBJC\_ASSOCIATION\_RETAIN\_NONATOMIC);
  return \[self swizzledInitWithRequest:request delegate:(id&lt;NSURLConnectionDelegate\&gt;)proxy\];</code></pre>
  }else{<pre><code>  return \[self swizzledInitWithRequest:request delegate:delegate\];</code></pre>
  }<br>}</li>
</ul>
<p>@end</p>
<h4 id="2-3-方案三：Hook"><a href="#2-3-方案三：Hook" class="headerlink" title="2.3 方案三：Hook"></a>2.3 方案三：Hook</h4><p>iOS 中 hook 技术有2类，一种是 NSProxy，一种是 method swizzling（isa swizzling）</p>
<h5 id="2-3-1-方法一"><a href="#2-3-1-方法一" class="headerlink" title="2.3.1 方法一"></a>2.3.1 方法一</h5><p>写 SDK 肯定不可能手动侵入业务代码（你没那个权限提交到线上代码 😂），所以不管是 APM 还是无痕埋点都是通过 Hook 的方式。</p>
<p>面向切面程序设计（Aspect-oriented Programming，AOP）是计算机科学中的一种程序设计范型，将<strong>横切关注点</strong>与业务主体进一步分离，以提高程序代码的模块化程度。在不修改源代码的情况下给程序动态增加功能。其核心思想是将业务逻辑（核心关注点，系统主要功能）与公共功能（横切关注点，比如日志系统）进行分离，降低复杂性，保持系统模块化程度、可维护性、可重用性。常被用在日志系统、性能统计、安全控制、事务处理、异常处理等场景下。</p>
<p>在 iOS 中 AOP 的实现是基于 Runtime 机制，目前由3种方式：Method Swizzling、NSProxy、FishHook（主要用用于 hook c 代码）。</p>
<p>文章上面 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000040277799#network-2.1">2.1</a> 讨论了满足大多数的需求的场景，NSURLProtocol 监控了 NSURLConnection、NSURLSession 的网络请求，自身代理后可以发起网络请求并得到诸如请求开始时间、请求结束时间、header 信息等，但是无法得到非常详细的网络性能数据，比如 DNS 开始解析时间、DNS 解析用了多久、reponse 开始返回的时间、返回了多久等。 iOS10 之后 NSURLSessionTaskDelegate 增加了一个代理方法 <code>- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didFinishCollectingMetrics:(NSURLSessionTaskMetrics *)metrics API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));</code>，可以获取到精确的各项网络数据。但是具有兼容性。文章上面 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000040277799#network-2.2">2.2</a> 讨论了从 Webkit 源码中得到的信息，通过私有方法 <code>_setCollectsTimingData:</code> 、<code>_timingData</code> 可以获取到 TimingData。</p>
<p>但是如果需要监全部的网络请求就不能满足需求了，查阅资料后发现了阿里百川有 APM 的解决方案，于是有了方案3，对于网络监控需要做如下的处理</p>
<p><img src="https://segmentfault.com/img/bVbIOh5"></p>
<p>可能对于 CFNetwork 比较陌生，可以看一下 CFNetwork 的层级和简单用法<br><img src="https://segmentfault.com/img/bVbIOiA"></p>
<p>CFNetwork 的基础是 CFSocket 和 CFStream。</p>
<p>CFSocket：Socket 是网络通信的底层基础，可以让2个 socket 端口互发数据，iOS 中最常用的 socket 抽象是 BSD socket。而 CFSocket 是 BSD socket 的 OC 包装，几乎实现了所有的 BSD 功能，此外加入了 RunLoop。</p>
<p>CFStream：提供了与设备无关的读写数据方法，使用它可以为内存、文件、网络（使用 socket）的数据建立流，使用 stream 可以不必将所有数据写入到内存中。CFStream 提供 API 对2种 CFType 对象提供抽象：CFReadStream、CFWriteStream。同时也是 CFHTTP、CFFTP 的基础。</p>
<p>简单 Demo</p>
<p>- (void)testCFNetwork<br>{<br>    CFURLRef urlRef = CFURLCreateWithString(kCFAllocatorDefault, CFSTR(“<a target="_blank" rel="noopener" href="https://httpbin.org/get&quot;">https://httpbin.org/get&quot;</a>), NULL);<br>    CFHTTPMessageRef httpMessageRef = CFHTTPMessageCreateRequest(kCFAllocatorDefault, CFSTR(“GET”), urlRef, kCFHTTPVersion1_1);<br>    CFRelease(urlRef);</p>
<pre><code>CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, httpMessageRef);
CFRelease(httpMessageRef);

CFReadStreamScheduleWithRunLoop(readStream, CFRunLoopGetCurrent(), kCFRunLoopCommonModes);

CFOptionFlags eventFlags = (kCFStreamEventHasBytesAvailable | kCFStreamEventErrorOccurred | kCFStreamEventEndEncountered);
CFStreamClientContext context = &#123;
    0,
    NULL,
    NULL,
    NULL,
   NULL
&#125; ;
// Assigns a client to a stream, which receives callbacks when certain events occur.
CFReadStreamSetClient(readStream, eventFlags, CFNetworkRequestCallback, &amp;context);
// Opens a stream for reading.
CFReadStreamOpen(readStream);</code></pre>
<p>}<br>// callback<br>void CFNetworkRequestCallback (CFReadStreamRef _Null_unspecified stream, CFStreamEventType type, void * _Null_unspecified clientCallBackInfo) {<br>    CFMutableDataRef responseBytes = CFDataCreateMutable(kCFAllocatorDefault, 0);<br>    CFIndex numberOfBytesRead = 0;<br>    do {<br>        UInt8 buffer[2014];<br>        numberOfBytesRead = CFReadStreamRead(stream, buffer, sizeof(buffer));<br>        if (numberOfBytesRead &gt; 0) {<br>            CFDataAppendBytes(responseBytes, buffer, numberOfBytesRead);<br>        }<br>    } while (numberOfBytesRead &gt; 0);</p>
<pre><code>CFHTTPMessageRef response = (CFHTTPMessageRef)CFReadStreamCopyProperty(stream, kCFStreamPropertyHTTPResponseHeader);
if (responseBytes) &#123;
    if (response) &#123;
        CFHTTPMessageSetBody(response, responseBytes);
    &#125;
    CFRelease(responseBytes);
&#125;

// close and cleanup
CFReadStreamClose(stream);
CFReadStreamUnscheduleFromRunLoop(stream, CFRunLoopGetCurrent(), kCFRunLoopCommonModes);
CFRelease(stream);

// print response
if (response) &#123;
    CFDataRef reponseBodyData = CFHTTPMessageCopyBody(response);
    CFRelease(response);

    printResponseData(reponseBodyData);
    CFRelease(reponseBodyData);
&#125;</code></pre>
<p>}</p>
<p>void printResponseData (CFDataRef responseData) {<br>    CFIndex dataLength = CFDataGetLength(responseData);<br>    UInt8 *bytes = (UInt8 *)malloc(dataLength);<br>    CFDataGetBytes(responseData, CFRangeMake(0, CFDataGetLength(responseData)), bytes);<br>    CFStringRef responseString = CFStringCreateWithBytes(kCFAllocatorDefault, bytes, dataLength, kCFStringEncodingUTF8, TRUE);<br>    CFShow(responseString);<br>    CFRelease(responseString);<br>    free(bytes);<br>}<br>// console<br>{<br>  “args”: {},<br>  “headers”: {<br>    “Host”: “httpbin.org”,<br>    “User-Agent”: “Test/1 CFNetwork/1125.2 Darwin/19.3.0”,<br>    “X-Amzn-Trace-Id”: “Root=1-5e8980d0-581f3f44724c7140614c2564”<br>  },<br>  “origin”: “183.159.122.102”,<br>  “url”: “<a target="_blank" rel="noopener" href="https://httpbin.org/get&quot;">https://httpbin.org/get&quot;</a><br>}</p>
<p>我们知道 NSURLSession、NSURLConnection、CFNetwork 的使用都需要调用一堆方法进行设置然后需要设置代理对象，实现代理方法。所以针对这种情况进行监控首先想到的是使用 runtime hook 掉方法层级。但是针对设置的代理对象的代理方法没办法 hook，因为不知道代理对象是哪个类。所以想办法可以 hook 设置代理对象这个步骤，将代理对象替换成我们设计好的某个类，然后让这个类去实现 NSURLConnection、NSURLSession、CFNetwork 相关的代理方法。然后在这些方法的内部都去调用一下原代理对象的方法实现。所以我们的需求得以满足，我们在相应的方法里面可以拿到监控数据，比如请求开始时间、结束时间、状态码、内容大小等。</p>
<p>NSURLSession、NSURLConnection hook 如下。</p>
<p><img src="https://segmentfault.com/img/bVbIOiI"></p>
<p><img src="https://segmentfault.com/img/bVbIOiT"></p>
<p>业界有 APM 针对 CFNetwork 的方案，整理描述下：</p>
<p>CFNetwork 是 c 语言实现的，要对 c 代码进行 hook 需要使用 Dynamic Loader Hook 库 - <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=tcKJVyEvs7dexHInMoDCyw==.U6nR6eU3JMfqS5fGvu0zKDtIo2B6MLKTgyx0LvekE3gw4lJm88QrCDo9LH1aCMnC">fishhook</a>。</p>
<blockquote>
<p><strong>Dynamic Loader</strong>（dyld）通过更新 <strong>Mach-O</strong> 文件中保存的指针的方法来绑定符号。借用它可以在 <strong>Runtime</strong> 修改 <strong>C</strong> 函数调用的函数指针。<strong>fishhook</strong> 的实现原理：遍历 <code>__DATA segment</code> 里面 <code>__nl_symbol_ptr</code> 、<code>__la_symbol_ptr</code> 两个 section 里面的符号，通过 Indirect Symbol Table、Symbol Table 和 String Table 的配合，找到自己要替换的函数，达到 hook 的目的。</p>
<p>/* Returns the number of bytes read, or -1 if an error occurs preventing any</p>
<p>bytes from being read, or 0 if the stream’s end was encountered.</p>
<p>It is an error to try and read from a stream that hasn’t been opened first.</p>
<p>This call will block until at least one byte is available; it will NOT block</p>
<p>until the entire buffer can be filled. To avoid blocking, either poll using</p>
<p>CFReadStreamHasBytesAvailable() or use the run loop and listen for the</p>
<p>kCFStreamEventHasBytesAvailable event for notification of data available. */</p>
<p>CF_EXPORT</p>
<p>CFIndex CFReadStreamRead(CFReadStreamRef <strong>_Null_unspecified</strong> stream, UInt8 * <strong>_Null_unspecified</strong> buffer, CFIndex bufferLength);</p>
</blockquote>
<p>CFNetwork 使用 CFReadStreamRef 来传递数据，使用回调函数的形式来接受服务器的响应。当回调函数受到</p>
<p>具体步骤及其关键代码如下，以 NSURLConnection 举例</p>
<ul>
<li><p>因为要 Hook 挺多地方，所以写一个 method swizzling 的工具类</p>
<p>  #import &lt;Foundation/Foundation.h&gt;</p>
<p>  NS_ASSUME_NONNULL_BEGIN</p>
<p>  @interface NSObject (hook)</p>
<p>  /**<br>   hook对象方法</p>
<p>   @param originalSelector 需要hook的原始对象方法<br>   @param swizzledSelector 需要替换的对象方法<br>   */</p>
<ul>
<li><p>(void)apm_swizzleMethod:(SEL)originalSelector swizzledSelector:(SEL)swizzledSelector;</p>
<p>/**<br>hook类方法</p>
<p>@param originalSelector 需要hook的原始类方法<br>@param swizzledSelector 需要替换的类方法<br>*/</p>
</li>
<li><p>(void)apm_swizzleClassMethod:(SEL)originalSelector swizzledSelector:(SEL)swizzledSelector;</p>
<p>@end</p>
<p>NS_ASSUME_NONNULL_END</p>
</li>
<li><p>(void)apm_swizzleMethod:(SEL)originalSelector swizzledSelector:(SEL)swizzledSelector<br>{<br>  class_swizzleInstanceMethod(self, originalSelector, swizzledSelector);<br>}</p>
</li>
<li><p>(void)apm_swizzleClassMethod:(SEL)originalSelector swizzledSelector:(SEL)swizzledSelector<br>{<br>  //类方法实际上是储存在类对象的类(即元类)中，即类方法相当于元类的实例方法,所以只需要把元类传入，其他逻辑和交互实例方法一样。<br>  Class class2 = object_getClass(self);<br>  class_swizzleInstanceMethod(class2, originalSelector, swizzledSelector);<br>}</p>
<p>void class_swizzleInstanceMethod(Class class, SEL originalSEL, SEL replacementSEL)<br>{<br>  Method originMethod = class_getInstanceMethod(class, originalSEL);<br>  Method replaceMethod = class_getInstanceMethod(class, replacementSEL);</p>
<p>  if(class_addMethod(class, originalSEL, method_getImplementation(replaceMethod),method_getTypeEncoding(replaceMethod)))<br>  {</p>
<pre><code>  class\_replaceMethod(class,replacementSEL, method\_getImplementation(originMethod), method\_getTypeEncoding(originMethod));</code></pre>
<p>  }else {</p>
<pre><code>  method\_exchangeImplementations(originMethod, replaceMethod);</code></pre>
<p>  }<br>}</p>
</li>
</ul>
</li>
<li><p>建立一个继承自 NSProxy 抽象类的类，实现相应方法。</p>
<p>  #import &lt;Foundation/Foundation.h&gt;</p>
<p>  NS_ASSUME_NONNULL_BEGIN</p>
<p>  // 为 NSURLConnection、NSURLSession、CFNetwork 代理设置代理转发<br>  @interface NetworkDelegateProxy : NSProxy</p>
<ul>
<li><p>(instancetype)setProxyForObject:(id)originalTarget withNewDelegate:(id)newDelegate;</p>
<p>@end</p>
<p>NS_ASSUME_NONNULL_END</p>
<p>// .m<br>@interface NetworkDelegateProxy () {<br>  id _originalTarget;<br>  id _NewDelegate;<br>}</p>
<p>@end</p>
<p>@implementation NetworkDelegateProxy</p>
<p>#pragma mark - life cycle</p>
</li>
<li><p>(instancetype)sharedInstance {<br>  static NetworkDelegateProxy *_sharedInstance = nil;</p>
<p>  static dispatch_once_t onceToken;</p>
<p>  dispatch_once(&amp;onceToken, ^{</p>
<pre><code>  \_sharedInstance = \[NetworkDelegateProxy alloc\];</code></pre>
<p>  });</p>
<p>  return _sharedInstance;<br>}</p>
<p>#pragma mark - public Method</p>
</li>
<li><p>(instancetype)setProxyForObject:(id)originalTarget withNewDelegate:(id)newDelegate<br>{<br>  NetworkDelegateProxy *instance = [NetworkDelegateProxy sharedInstance];<br>  instance-&gt;_originalTarget = originalTarget;<br>  instance-&gt;_NewDelegate = newDelegate;<br>  return instance;<br>}</p>
</li>
</ul>
<ul>
<li><p>(void)forwardInvocation:(NSInvocation *)invocation<br>{<br>  if ([_originalTarget respondsToSelector:invocation.selector]) {</p>
<pre><code>  \[invocation invokeWithTarget:\_originalTarget\];
  \[((NSURLSessionAndConnectionImplementor \*)\_NewDelegate) invoke:invocation\];</code></pre>
<p>  }<br>}</p>
</li>
<li><p>(nullable NSMethodSignature *)methodSignatureForSelector:(SEL)sel<br>{<br>  return [_originalTarget methodSignatureForSelector:sel];<br>}</p>
<p>@end</p>
</li>
</ul>
</li>
<li><p>创建一个对象，实现 NSURLConnection、NSURLSession、NSIuputStream 代理方法</p>
<p>  // NetworkImplementor.m</p>
<p>  #pragma mark-NSURLConnectionDelegate</p>
<ul>
<li><p>(void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error {<br>  NSLog(@”%s”, __func__);<br>}</p>
</li>
<li><p>(nullable NSURLRequest *)connection:(NSURLConnection *)connection willSendRequest:(NSURLRequest *)request redirectResponse:(nullable NSURLResponse *)response {<br>  NSLog(@”%s”, __func__);<br>  return request;<br>}</p>
<p>#pragma mark-NSURLConnectionDataDelegate</p>
</li>
<li><p>(void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response {<br>  NSLog(@”%s”, __func__);<br>}</p>
</li>
<li><p>(void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data {<br> NSLog(@”%s”, __func__);<br>}</p>
</li>
<li><p>(void)connection:(NSURLConnection *)connection   didSendBodyData:(NSInteger)bytesWritten<br>totalBytesWritten:(NSInteger)totalBytesWritten<br>totalBytesExpectedToWrite:(NSInteger)totalBytesExpectedToWrite {<br>  NSLog(@”%s”, __func__);<br>}</p>
</li>
<li><p>(void)connectionDidFinishLoading:(NSURLConnection *)connection {<br>  NSLog(@”%s”, __func__);<br>}</p>
<p>#pragma mark-NSURLConnectionDownloadDelegate</p>
</li>
<li><p>(void)connection:(NSURLConnection *)connection didWriteData:(long long)bytesWritten totalBytesWritten:(long long)totalBytesWritten expectedTotalBytes:(long long) expectedTotalBytes {<br>  NSLog(@”%s”, __func__);<br>}</p>
</li>
<li><p>(void)connectionDidResumeDownloading:(NSURLConnection *)connection totalBytesWritten:(long long)totalBytesWritten expectedTotalBytes:(long long) expectedTotalBytes {<br>  NSLog(@”%s”, __func__);<br>}</p>
</li>
<li><p>(void)connectionDidFinishDownloading:(NSURLConnection *)connection destinationURL:(NSURL *) destinationURL {<br>  NSLog(@”%s”, __func__);<br>}<br>// 根据需求自己去写需要监控的数据项</p>
</li>
</ul>
</li>
<li><p>给 NSURLConnection 添加 Category，专门设置 hook 代理对象、hook NSURLConnection 对象方法</p>
<p>  // NSURLConnection+Monitor.m<br>  @implementation NSURLConnection (Monitor)</p>
<ul>
<li>(void)load<br>{<br>  static dispatch_once_t onceToken;<br>  dispatch_once(&amp;onceToken, ^{<pre><code>  @autoreleasepool &#123;
      \[\[self class\] apm\_swizzleMethod:@selector(apm\_initWithRequest:delegate:) swizzledSelector:@selector(initWithRequest: delegate:)\];
  &#125;</code></pre>
  });<br>}</li>
</ul>
<ul>
<li><p>(_Nonnull instancetype)apm_initWithRequest:(NSURLRequest *)request delegate:(nullable id)delegate<br>{<br>  /*</p>
<ol>
<li><p>在设置 Delegate 的时候替换 delegate。</p>
</li>
<li><p>因为要在每个代理方法里面，监控数据，所以需要将代理方法都 hook 下</p>
</li>
<li><p>在原代理方法执行的时候，让新的代理对象里面，去执行方法的转发，<br>*/<br>NSString *traceId = @”traceId”;<br>NSMutableURLRequest *rq = [request mutableCopy];<br>NSString *preTraceId = [request.allHTTPHeaderFields valueForKey:@”head_key_traceid”];<br>if (preTraceId) {<br>// 调用 hook 之前的初始化方法，返回 NSURLConnection<br>return [self apm_initWithRequest:rq delegate:delegate];<br>} else {<br>[rq setValue:traceId forHTTPHeaderField:@”head_key_traceid”];</p>
<p>NSURLSessionAndConnectionImplementor *mockDelegate = [NSURLSessionAndConnectionImplementor new];<br>[self registerDelegateMethod:@”connection:didFailWithError:” originalDelegate:delegate newDelegate:mockDelegate flag:”v@:@@”];</p>
<p>[self registerDelegateMethod:@”connection:didReceiveResponse:” originalDelegate:delegate newDelegate:mockDelegate flag:”v@:@@”];<br>[self registerDelegateMethod:@”connection:didReceiveData:” originalDelegate:delegate newDelegate:mockDelegate flag:”v@:@@”];<br>[self registerDelegateMethod:@”connection:didFailWithError:” originalDelegate:delegate newDelegate:mockDelegate flag:”v@:@@”];</p>
<p>[self registerDelegateMethod:@”connectionDidFinishLoading:” originalDelegate:delegate newDelegate:mockDelegate flag:”v@:@”];<br>[self registerDelegateMethod:@”connection:willSendRequest:redirectResponse:” originalDelegate:delegate newDelegate:mockDelegate flag:”@@:@@”];<br>delegate = [NetworkDelegateProxy setProxyForObject:delegate withNewDelegate:mockDelegate];</p>
<p>// 调用 hook 之前的初始化方法，返回 NSURLConnection<br>return [self apm_initWithRequest:rq delegate:delegate];<br>}<br>}</p>
</li>
</ol>
</li>
<li><p>(void)registerDelegateMethod:(NSString *)methodName originalDelegate:(id&lt;NSURLConnectionDelegate&gt;)originalDelegate newDelegate:(NSURLSessionAndConnectionImplementor *)newDelegate flag:(const char *)flag<br>{<br>  if ([originalDelegate respondsToSelector:NSSelectorFromString(methodName)]) {</p>
<pre><code>  IMP originalMethodImp = class\_getMethodImplementation(\[originalDelegate class\], NSSelectorFromString(methodName));
  IMP newMethodImp = class\_getMethodImplementation(\[newDelegate class\], NSSelectorFromString(methodName));
  if (originalMethodImp != newMethodImp) &#123;
      \[newDelegate registerSelector: methodName\];
      NSLog(@&quot;&quot;);
  &#125;</code></pre>
<p>  } else {</p>
<pre><code>  class\_addMethod(\[originalDelegate class\], NSSelectorFromString(methodName), class\_getMethodImplementation(\[newDelegate class\], NSSelectorFromString(methodName)), flag);</code></pre>
<p>  }<br>}</p>
<p>@end</p>
</li>
</ul>
</li>
</ul>
<p>这样下来就是可以监控到网络信息了，然后将数据交给数据上报 SDK，按照下发的数据上报策略去上报数据。</p>
<h5 id="2-3-2-方法二"><a href="#2-3-2-方法二" class="headerlink" title="2.3.2 方法二"></a>2.3.2 方法二</h5><p>其实，针对上述的需求还有另一种方法一样可以达到目的，那就是 <strong>isa swizzling</strong>。</p>
<p>顺道说一句，上面针对 NSURLConnection、NSURLSession、NSInputStream 代理对象的 hook 之后，利用 NSProxy 实现代理对象方法的转发，有另一种方法可以实现，那就是 <strong>isa swizzling</strong>。</p>
<ul>
<li><p>Method swizzling 原理</p>
<p>  struct old_method {</p>
<pre><code>  SEL method\_name;
  char \*method\_types;
  IMP method\_imp;</code></pre>
<p>  };</p>
</li>
</ul>
<p><img src="https://segmentfault.com/img/bVbIOi3"></p>
<p>method swizzling 改进版如下</p>
<p>Method originalMethod = class_getInstanceMethod(aClass, aSEL);<br>IMP originalIMP = method_getImplementation(originalMethod);<br>char *cd = method_getTypeEncoding(originalMethod);<br>IMP newIMP = imp_implementationWithBlock(^(id self) {<br>  void (*tmp)(id self, SEL _cmd) = originalIMP;<br>  tmp(self, aSEL);<br>});<br>class_replaceMethod(aClass, aSEL, newIMP, cd);</p>
<ul>
<li><p>isa swizzling</p>
<p>  /// Represents an instance of a class.<br>  struct objc_object {</p>
<pre><code>  Class \_Nonnull isa  OBJC\_ISA\_AVAILABILITY;</code></pre>
<p>  };</p>
<p>  /// A pointer to an instance of a class.<br>  typedef struct objc_object *id;</p>
</li>
</ul>
<p><img src="https://segmentfault.com/img/bVbIOjh"></p>
<p>我们来分析一下为什么修改 <code>isa</code> 可以实现目的呢？</p>
<ol>
<li> 写 APM 监控的人没办法确定业务代码</li>
<li> 不可能为了方便监控 APM，写某些类，让业务线开发者别使用系统 NSURLSession、NSURLConnection 类</li>
</ol>
<p>想想 KVO 的实现原理？结合上面的图</p>
<ul>
<li>  创建监控对象子类</li>
<li>  重写子类中属性的 getter、seeter</li>
<li>  将监控对象的 isa 指针指向新创建的子类</li>
<li>  在子类的 getter、setter 中拦截值的变化，通知监控对象值的变化</li>
<li>  监控完之后将监控对象的 isa 还原回去</li>
</ul>
<p>按照这个思路，我们也可以对 NSURLConnection、NSURLSession 的 load 方法中动态创建子类，在子类中重写方法，比如 <code>- (**nullable** **instancetype**)initWithRequest:(NSURLRequest *)request delegate:(**nullable** **id**)delegate startImmediately:(**BOOL**)startImmediately;</code> ，然后将 NSURLSession、NSURLConnection 的 isa 指向动态创建的子类。在这些方法处理完之后还原本身的 isa 指针。</p>
<p>不过 isa swizzling 针对的还是 method swizzling，代理对象不确定，还是需要 NSProxy 进行动态处理。</p>
<p>至于如何修改 isa，我写一个简单的 Demo 来模拟 KVO</p>
<p>- (void)lbpKVO_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context {<br>    //生成自定义的名称<br>    NSString *className = NSStringFromClass(self.class);<br>    NSString *currentClassName = [@”LBPKVONotifying_“ stringByAppendingString:className];<br>    //1. runtime 生成类<br>    Class myclass = objc_allocateClassPair(self.class, [currentClassName UTF8String], 0);<br>    // 生成后不能马上使用，必须先注册<br>    objc_registerClassPair(myclass);</p>
<pre><code>//2. 重写 setter 方法
class\_addMethod(myclass,@selector(say) , (IMP)say, &quot;v@:@&quot;);</code></pre>
<p>//    class_addMethod(myclass,@selector(setName:) , (IMP)setName, “v@:@”);<br>    //3. 修改 isa<br>    object_setClass(self, myclass);</p>
<pre><code>//4. 将观察者保存到当前对象里面
objc\_setAssociatedObject(self, &quot;observer&quot;, observer, OBJC\_ASSOCIATION\_ASSIGN);

//5. 将传递的上下文绑定到当前对象里面
objc\_setAssociatedObject(self, &quot;context&quot;, (\_\_bridge id \_Nullable)(context), OBJC\_ASSOCIATION\_RETAIN);</code></pre>
<p>}</p>
<p>void say(id self, SEL _cmd)<br>{<br>   // 调用父类方法一<br>    struct objc_super superclass = {self, [self superclass]};<br>    ((void(*)(struct objc_super *,SEL))objc_msgSendSuper)(&amp;superclass,@selector(say));<br>    NSLog(@”%s”, __func__);<br>// 调用父类方法二<br>//    Class class = [self class];<br>//    object_setClass(self, class_getSuperclass(class));<br>//    objc_msgSend(self, @selector(say));<br>}</p>
<p>void setName (id self, SEL _cmd, NSString *name) {<br>    NSLog(@”come here”);<br>    //先切换到当前类的父类，然后发送消息 setName，然后切换当前子类<br>    //1. 切换到父类<br>    Class class = [self class];<br>    object_setClass(self, class_getSuperclass(class));<br>    //2. 调用父类的 setName 方法<br>    objc_msgSend(self, @selector(setName:), name);</p>
<pre><code>//3. 调用观察
id observer = objc\_getAssociatedObject(self, &quot;observer&quot;);
id context = objc\_getAssociatedObject(self, &quot;context&quot;);
if (observer) &#123;
    objc\_msgSend(observer, @selector(observeValueForKeyPath:ofObject:change:context:), @&quot;name&quot;, self, @&#123;@&quot;new&quot;: name, @&quot;kind&quot;: @1 &#125; , context);
&#125;
//4. 改回子类
object\_setClass(self, class);</code></pre>
<p>}</p>
<p>@end</p>
<h4 id="2-4-方案四：监控-App-常见网络请求"><a href="#2-4-方案四：监控-App-常见网络请求" class="headerlink" title="2.4 方案四：监控 App 常见网络请求"></a>2.4 方案四：监控 App 常见网络请求</h4><p>本着成本的原因，由于现在大多数的项目的网络能力都是通过 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=MYj1ggNH/meF+oxXiYJbZg==.IYz8wJ/KSEXObkRzTOxLYjdN5RNFlQyunNtJO1Se9wGa3x76x0tMSjB/U+kVQy7b">AFNetworking</a> 完成的，所以本文的网络监控可以快速完成。</p>
<p>AFNetworking 在发起网络的时候会有相应的通知。<code>AFNetworkingTaskDidResumeNotification</code> 和 <code>AFNetworkingTaskDidCompleteNotification</code>。通过监听通知携带的参数获取网络情况信息。</p>
<p> self.didResumeObserver = [[NSNotificationCenter defaultCenter] addObserverForName:AFNetworkingTaskDidResumeNotification object:nil queue:self.queue usingBlock:^(NSNotification * _Nonnull note) {<br>    // 开始<br>    __strong __typeof(weakSelf)strongSelf = weakSelf;<br>    NSURLSessionTask *task = note.object;<br>    NSString *requestId = [[NSUUID UUID] UUIDString];<br>    task.apm_requestId = requestId;<br>    [strongSelf.networkRecoder recordStartRequestWithRequestID:requestId task:task];<br>}];</p>
<p>self.didCompleteObserver = [[NSNotificationCenter defaultCenter] addObserverForName:AFNetworkingTaskDidCompleteNotification object:nil queue:self.queue usingBlock:^(NSNotification * _Nonnull note) {</p>
<pre><code>\_\_strong \_\_typeof(weakSelf)strongSelf = weakSelf;

NSError \*error = note.userInfo\[AFNetworkingTaskDidCompleteErrorKey\];
NSURLSessionTask \*task = note.object;
if (!error) &#123;
    // 成功
    \[strongSelf.networkRecoder recordFinishRequestWithRequestID:task.apmn\_requestId task:task\];
&#125; else &#123;
    // 失败
    \[strongSelf.networkRecoder recordResponseErrorWithRequestID:task.apmn\_requestId task:task error:error\];
&#125;</code></pre>
<p>}];</p>
<p>在 networkRecoder 的方法里面去组装数据，交给数据上报组件，等到合适的时机策略去上报。</p>
<p>因为网络是一个异步的过程，所以当网络请求开始的时候需要为每个网络设置唯一标识，等到网络请求完成后再根据每个请求的标识，判断该网络耗时多久、是否成功等。所以措施是为 <strong>NSURLSessionTask</strong> 添加分类，通过 runtime 增加一个属性，也就是唯一标识。</p>
<p>这里插一嘴，为 Category 命名、以及内部的属性和方法命名的时候需要注意下。假如不注意会怎么样呢？假如你要为 NSString 类增加身份证号码中间位数隐藏的功能，那么写代码久了的老司机 A，为 NSString 增加了一个方法名，叫做 getMaskedIdCardNumber，但是他的需求是从 [9, 12] 这4位字符串隐藏掉。过了几天同事 B 也遇到了类似的需求，他也是一位老司机，为 NSString 增加了一个也叫 getMaskedIdCardNumber 的方法，但是他的需求是从 [8, 11] 这4位字符串隐藏，但是他引入工程后发现输出并不符合预期，为该方法写的单测没通过，他以为自己写错了截取方法，检查了几遍才发现工程引入了另一个 NSString 分类，里面的方法同名 😂 真坑。</p>
<p>下面的例子是 SDK，但是日常开发也是一样。</p>
<ul>
<li>  Category 类名：建议按照当前 SDK 名称的简写作为前缀，再加下划线，再加当前分类的功能，也就是<code>类名+SDK名称简写_功能名称</code>。比如当前 SDK 叫 JuhuaSuanAPM，那么该 NSURLSessionTask Category 名称就叫做 <code>NSURLSessionTask+JuHuaSuanAPM_NetworkMonitor.h</code></li>
<li>  Category 属性名：建议按照当前 SDK 名称的简写作为前缀，再加下划线，再加属性名，也就是<code>SDK名称简写_属性名称</code>。比如 JuhuaSuanAPM_requestId`</li>
<li>  Category 方法名：建议按照当前 SDK 名称的简写作为前缀，再加下划线，再加方法名，也就是<code>SDK名称简写_方法名称</code>。比如 <code>-(BOOL)JuhuaSuanAPM__isGzippedData</code></li>
</ul>
<p>例子如下：</p>
<p>#import &lt;Foundation/Foundation.h&gt;</p>
<p>@interface NSURLSessionTask (JuhuaSuanAPM_NetworkMonitor)</p>
<p>@property (nonatomic, copy) NSString* JuhuaSuanAPM_requestId;</p>
<p>@end</p>
<p>#import “NSURLSessionTask+JuHuaSuanAPM_NetworkMonitor.h”<br>#import &lt;objc/runtime.h&gt;</p>
<p>@implementation NSURLSessionTask (JuHuaSuanAPM_NetworkMonitor)</p>
<ul>
<li><p>(NSString*)JuhuaSuanAPM_requestId<br>{<br>  return objc_getAssociatedObject(self, _cmd);<br>}</p>
</li>
<li><p>(void)setJuhuaSuanAPM_requestId:(NSString*)requestId<br>{<br>  objc_setAssociatedObject(self, @selector(JuhuaSuanAPM_requestId), requestId, OBJC_ASSOCIATION_COPY_NONATOMIC);<br>}<br>@end</p>
</li>
</ul>
<h4 id="2-5-iOS-流量监控"><a href="#2-5-iOS-流量监控" class="headerlink" title="2.5 iOS 流量监控"></a>2.5 iOS 流量监控</h4><h5 id="2-5-1-HTTP-请求、响应数据结构"><a href="#2-5-1-HTTP-请求、响应数据结构" class="headerlink" title="2.5.1 HTTP 请求、响应数据结构"></a>2.5.1 HTTP 请求、响应数据结构</h5><p>HTTP 请求报文结构</p>
<p><img src="https://segmentfault.com/img/bVbIOjv"></p>
<p>响应报文的结构<br><img src="https://segmentfault.com/img/bVbIOjA"></p>
<ol>
<li> HTTP 报文是格式化的数据块，每条报文由三部分组成：对报文进行描述的起始行、包含属性的首部块、以及可选的包含数据的主体部分。</li>
<li> 起始行和手部就是由行分隔符的 ASCII 文本，每行都以一个由2个字符组成的行终止序列作为结束（包括一个回车符、一个换行符）</li>
<li> 实体的主体或者报文的主体是一个可选的数据块。与起始行和首部不同的是，主体中可以包含文本或者二进制数据，也可以为空。</li>
<li> HTTP 首部（也就是 Headers）总是应该以一个空行结束，即使没有实体部分。浏览器发送了一个空白行来通知服务器，它已经结束了该头信息的发送。</li>
</ol>
<p>请求报文的格式</p>
<p>&lt;method&gt; &lt;request-URI&gt; &lt;version&gt;<br>&lt;headers&gt;</p>
<p>&lt;entity-body&gt;</p>
<p>响应报文的格式</p>
<p><version> <status> <reason-phrase><br><headers></p>
<entity-body>

<p>下图是打开 Chrome 查看极课时间网页的请求信息。包括响应行、响应头、响应体等信息。</p>
<p><img src="https://segmentfault.com/img/bVbIOjS"></p>
<p>下图是在终端使用 <code>curl</code> 查看一个完整的请求和响应数据<br><img src="https://segmentfault.com/img/bVbIOj9"></p>
<p>我们都知道在 HTTP 通信中，响应数据会使用 gzip 或其他压缩方式压缩，用 NSURLProtocol 等方案监听，用 NSData 类型去计算分析流量等会造成数据的不精确，因为正常一个 HTTP 响应体的内容是使用 gzip 或其他压缩方式压缩的，所以使用 NSData 会偏大。</p>
<h5 id="2-5-2-问题"><a href="#2-5-2-问题" class="headerlink" title="2.5.2 问题"></a>2.5.2 问题</h5><ol>
<li><p>Request 和 Response 不一定成对存在</p>
<p> 比如网络断开、App 突然 Crash 等，所以 Request 和 Response 监控后不应该记录在一条记录里</p>
</li>
<li><p>请求流量计算方式不精确</p>
<p> 主要原因有：</p>
<ul>
<li>  监控技术方案忽略了请求头和请求行部分的数据大小</li>
<li>  监控技术方案忽略了 Cookie 部分的数据大小</li>
<li>  监控技术方案在对请求体大小计算的时候直接使用 <code>HTTPBody.length</code>，导致不够精确</li>
</ul>
</li>
<li><p>响应流量计算方式不精确</p>
<p> 主要原因有：</p>
<ul>
<li>  监控技术方案忽略了响应头和响应行部分的数据大小</li>
<li>  监控技术方案在对 body 部分的字节大小计算，因采用 <code>exceptedContentLength</code> 导致不够准确</li>
<li>  监控技术方案忽略了响应体使用 gzip 压缩。真正的网络通信过程中，客户端在发起请求的请求头中 <code>Accept-Encoding</code> 字段代表客户端支持的数据压缩方式（表明客户端可以正常使用数据时支持的压缩方法），同样服务端根据客户端想要的压缩方式、服务端当前支持的压缩方式，最后处理数据，在响应头中<code>Content-Encoding</code> 字段表示当前服务器采用了什么压缩方式。</li>
</ul>
</li>
</ol>
<h5 id="2-5-3-技术实现"><a href="#2-5-3-技术实现" class="headerlink" title="2.5.3 技术实现"></a>2.5.3 技术实现</h5><p>第五部分讲了网络拦截的各种原理和技术方案，这里拿 NSURLProtocol 来说实现流量监控（Hook 的方式）。从上述知道了我们需要什么样的，那么就逐步实现吧。</p>
<h6 id="2-5-3-1-Request-部分"><a href="#2-5-3-1-Request-部分" class="headerlink" title="2.5.3.1 Request 部分"></a>2.5.3.1 Request 部分</h6><ol>
<li><p> 先利用网络监控方案将 NSURLProtocol 管理 App 的各种网络请求</p>
</li>
<li><p>在各个方法内部记录各项所需参数（NSURLProtocol 不能分析请求握手、挥手等数据大小和时间消耗，不过对于正常情况的接口流量分析足够了，最底层需要 Socket 层）</p>
<p> @property(nonatomic, strong) NSURLConnection *internalConnection;<br> @property(nonatomic, strong) NSURLResponse *internalResponse;<br> @property(nonatomic, strong) NSMutableData *responseData;<br> @property (nonatomic, strong) NSURLRequest *internalRequest;</p>
</li>
</ol>
<p>- (void)startLoading<br>{<br>    NSMutableURLRequest *mutableRequest = [[self request] mutableCopy];<br>    self.internalConnection = [[NSURLConnection alloc] initWithRequest:mutableRequest delegate:self];<br>    self.internalRequest = self.request;<br>}</p>
<ul>
<li><p>(void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response<br>{<br>  [self.client URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageNotAllowed];<br>  self.internalResponse = response;<br>}</p>
</li>
<li><p>(void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data<br>{<br>  [self.responseData appendData:data];<br>  [self.client URLProtocol:self didLoadData:data];<br>}</p>
</li>
</ul>
<ol start="3">
<li><p>Status Line 部分</p>
<p> NSURLResponse 没有 Status Line 等属性或者接口，HTTP Version 信息也没有，所以要想获取 Status Line 想办法转换到 CFNetwork 层试试看。发现有私有 API 可以实现。</p>
<p> <strong>思路：将 NSURLResponse 通过 <code>_CFURLResponse</code> 转换为 <code>CFTypeRef</code>，然后再将 <code>CFTypeRef</code> 转换为 <code>CFHTTPMessageRef</code>，再通过 <code>CFHTTPMessageCopyResponseStatusLine</code> 获取 <code>CFHTTPMessageRef</code> 的 Status Line 信息。</strong></p>
<p> 将读取 Status Line 的功能添加一个 NSURLResponse 的分类。</p>
<p> // NSURLResponse+apm_FetchStatusLineFromCFNetwork.h<br> #import &lt;Foundation/Foundation.h&gt;</p>
<p> NS_ASSUME_NONNULL_BEGIN</p>
<p> @interface NSURLResponse (apm_FetchStatusLineFromCFNetwork)</p>
<ul>
<li><p>(NSString *)apm_fetchStatusLineFromCFNetwork;</p>
<p>@end</p>
<p>NS_ASSUME_NONNULL_END</p>
<p>// NSURLResponse+apm_FetchStatusLineFromCFNetwork.m<br>#import “NSURLResponse+apm_FetchStatusLineFromCFNetwork.h”<br>#import &lt;dlfcn.h&gt;</p>
<p>#define SuppressPerformSelectorLeakWarning(Stuff) \<br>do { \<br>_Pragma(“clang diagnostic push”) \<br>_Pragma(“clang diagnostic ignored \“-Warc-performSelector-leaks\“”) \<br>Stuff; \<br>_Pragma(“clang diagnostic pop”) \<br>} while (0)</p>
<p>typedef CFHTTPMessageRef (*APMURLResponseFetchHTTPResponse)(CFURLRef response);</p>
<p>@implementation NSURLResponse (apm_FetchStatusLineFromCFNetwork)</p>
</li>
<li><p>(NSString *)apm_fetchStatusLineFromCFNetwork<br>{<br>NSString *statusLine = @””;<br>NSString *funcName = @”CFURLResponseGetHTTPResponse”;<br>APMURLResponseFetchHTTPResponse originalURLResponseFetchHTTPResponse = dlsym(RTLD_DEFAULT, [funcName UTF8String]);</p>
<p>SEL getSelector = NSSelectorFromString(@”_CFURLResponse”);<br>if ([self respondsToSelector:getSelector] &amp;&amp; NULL != originalURLResponseFetchHTTPResponse) {<br>  CFTypeRef cfResponse;<br>  SuppressPerformSelectorLeakWarning(</p>
<pre><code>  cfResponse = CFBridgingRetain(\[self performSelector:getSelector\]);</code></pre>
<p>  );<br>  if (NULL != cfResponse) {</p>
<pre><code>  CFHTTPMessageRef messageRef = originalURLResponseFetchHTTPResponse(cfResponse);
  statusLine = (\_\_bridge\_transfer NSString \*)CFHTTPMessageCopyResponseStatusLine(messageRef);
  CFRelease(cfResponse);</code></pre>
<p>  }<br>}<br>return statusLine;<br>}</p>
<p>@end</p>
</li>
</ul>
</li>
<li><p>将获取到的 Status Line 转换为 NSData，再计算大小</p>
<p> - (NSUInteger)apm_getLineLength {<br> NSString *statusLineString = @””;<br> if ([self isKindOfClass:[NSHTTPURLResponse class]]) {</p>
<pre><code> NSHTTPURLResponse \*httpResponse = (NSHTTPURLResponse \*)self;
 statusLineString = \[self apm\_fetchStatusLineFromCFNetwork\];</code></pre>
<p> }<br> NSData *lineData = [statusLineString dataUsingEncoding:NSUTF8StringEncoding];<br> return lineData.length;<br> }</p>
</li>
<li><p>Header 部分</p>
<p> <code>allHeaderFields</code> 获取到 NSDictionary，然后按照 <code>key: value</code> 拼接成字符串，然后转换成 NSData 计算大小</p>
<p> 注意：<code>key: value</code> key 后是有空格的，curl 或者 chrome Network 面板可以查看印证下。</p>
<p> - (NSUInteger)apm_getHeadersLength<br> {<br> NSUInteger headersLength = 0;<br> if ([self isKindOfClass:[NSHTTPURLResponse class]]) {</p>
<pre><code> NSHTTPURLResponse \*httpResponse = (NSHTTPURLResponse \*)self;
 NSDictionary \*headerFields = httpResponse.allHeaderFields;
 NSString \*headerString = @&quot;&quot;;
 for (NSString \*key in headerFields.allKeys) &#123;
     headerString = \[headerStr stringByAppendingString:key\];
     headheaderStringerStr = \[headerString stringByAppendingString:@&quot;: &quot;\];
     if (\[headerFields objectForKey:key\]) &#123;
         headerString = \[headerString stringByAppendingString:headerFields\[key\]\];
     &#125;
     headerString = \[headerString stringByAppendingString:@&quot;\\n&quot;\];
 &#125;
 NSData \*headerData = \[headerString dataUsingEncoding:NSUTF8StringEncoding\];
 headersLength = headerData.length;</code></pre>
<p> }<br> return headersLength;<br> }</p>
</li>
<li><p>Body 部分</p>
<p> Body 大小的计算不能直接使用 excepectedContentLength，官方文档说明了其不准确性，只可以作为参考。或者 <code>allHeaderFields</code> 中的 <code>Content-Length</code> 值也是不够准确的。</p>
<blockquote>
<p>/*!</p>
<p><strong>@abstract</strong> Returns the expected content length of the receiver.</p>
<p><strong>@discussion</strong> Some protocol implementations report a content length</p>
<p>as part of delivering load metadata, but not all protocols</p>
<p>guarantee the amount of data that will be delivered in actuality.</p>
<p>Hence, this method returns an expected amount. Clients should use</p>
<p>this value as an advisory, and should be prepared to deal with</p>
<p>either more or less data.</p>
<p><strong>@result</strong> The expected content length of the receiver, or -1 if</p>
<p>there is no expectation that can be arrived at regarding expected</p>
<p>content length.</p>
<p>*/</p>
<p><strong>@property</strong> (<strong>readonly</strong>) <strong>long</strong> <strong>long</strong> expectedContentLength;</p>
</blockquote>
<ul>
<li><p>  HTTP 1.1 版本规定，如果存在 <code>Transfer-Encoding: chunked</code>，则在 header 中不能有 <code>Content-Length</code>，有也会被忽视。</p>
</li>
<li><p>  在 HTTP 1.0及之前版本中，<code>content-length</code> 字段可有可无</p>
</li>
<li><p>在 HTTP 1.1及之后版本。如果是 <code>keep alive</code>，则 <code>Content-Length</code> 和 <code>chunked</code> 必然是二选一。若是非<code>keep alive</code>，则和 HTTP 1.0一样。<code>Content-Length</code> 可有可无。</p>
<p>什么是 <code>Transfer-Encoding: chunked</code></p>
<p>数据以一系列分块的形式进行发送 <code>Content-Length</code> 首部在这种情况下不被发送. 在每一个分块的开头需要添加当前分块的长度, 以十六进制的形式表示，后面紧跟着 <code>\r\n</code> , 之后是分块本身, 后面也是 <code>\r\n</code> ，终止块是一个常规的分块, 不同之处在于其长度为0.</p>
<p>我们之前拿 NSMutableData 记录了数据，所以我们可以在 <code>stopLoading</code> 方法中计算出 Body 大小。步骤如下：</p>
</li>
<li><p>在 <code>didReceiveData</code> 中不断添加 data</p>
<p>- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data<br>{<br>  [self.responseData appendData:data];<br>  [self.client URLProtocol:self didLoadData:data];<br>}</p>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>在 <code>stopLoading</code> 方法中拿到 <code>allHeaderFields</code> 字典，获取 <code>Content-Encoding</code> key 的值，如果是 <strong>gzip</strong>，则在 <code>stopLoading</code> 中将 NSData 处理为 gzip 压缩后的数据，再计算大小。（gzip 相关功能可以使用这个<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=wIhdNGkCq9yrL31VzIBqyA==.zCMe4OPXbL0XTEsiuqivL7za/Z0ccjxY3A8kt2LI7OCHkRWiBCvTwvl+50VVeo6Q">工具</a>）</p>
<p>  需要额外计算一个空白行的长度</p>
<p>  - (void)stopLoadi<br>  {</p>
<pre><code>  \[self.internalConnection cancel\];

  HCTNetworkTrafficModel \*model = \[\[HCTNetworkTrafficModel alloc\] init\];
  model.path = self.request.URL.path;
  model.host = self.request.URL.host;
  model.type = DMNetworkTrafficDataTypeResponse;
  model.lineLength = \[self.internalResponse apm\_getStatusLineLength\];
  model.headerLength = \[self.internalResponse apm\_getHeadersLength\];
  model.emptyLineLength = \[self.internalResponse apm\_getEmptyLineLength\];
  if (\[self.dm\_response isKindOfClass:\[NSHTTPURLResponse class\]\]) &#123;
      NSHTTPURLResponse \*httpResponse = (NSHTTPURLResponse \*)self.dm\_response;
      NSData \*data = self.dm\_data;
      if (\[\[httpResponse.allHeaderFields objectForKey:@&quot;Content-Encoding&quot;\] isEqualToString:@&quot;gzip&quot;\]) &#123;
          data = \[self.dm\_data gzippedData\];
      &#125;
      model.bodyLength = data.length;
  &#125;
  model.length = model.lineLength + model.headerLength + model.bodyLength + model.emptyLineLength;
  NSDictionary \*networkTrafficDictionary = \[model convertToDictionary\];
  \[\[HermesClient sharedInstance\] sendWithType:APMMonitorNetworkTrafficType meta:networkTrafficDictionary payload:nil\];</code></pre>
<p>  }</p>
</li>
</ul>
<h6 id="2-5-3-2-Resquest-部分"><a href="#2-5-3-2-Resquest-部分" class="headerlink" title="2.5.3.2 Resquest 部分"></a>2.5.3.2 Resquest 部分</h6><ol>
<li><p> 先利用网络监控方案将 NSURLProtocol 管理 App 的各种网络请求</p>
</li>
<li><p>在各个方法内部记录各项所需参数（NSURLProtocol 不能分析请求握手、挥手等数据大小和时间消耗，不过对于正常情况的接口流量分析足够了，最底层需要 Socket 层）</p>
<p> @property(nonatomic, strong) NSURLConnection *internalConnection;<br> @property(nonatomic, strong) NSURLResponse *internalResponse;<br> @property(nonatomic, strong) NSMutableData *responseData;<br> @property (nonatomic, strong) NSURLRequest *internalRequest;</p>
</li>
</ol>
<p>- (void)startLoading<br>{<br>    NSMutableURLRequest *mutableRequest = [[self request] mutableCopy];<br>    self.internalConnection = [[NSURLConnection alloc] initWithRequest:mutableRequest delegate:self];<br>    self.internalRequest = self.request;<br>}</p>
<ul>
<li><p>(void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response<br>{<br>  [self.client URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageNotAllowed];<br>  self.internalResponse = response;<br>}</p>
</li>
<li><p>(void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data<br>{<br>  [self.responseData appendData:data];<br>  [self.client URLProtocol:self didLoadData:data];<br>}</p>
</li>
</ul>
<ol start="3">
<li><p>Status Line 部分</p>
<p> 对于 NSURLRequest 没有像 NSURLResponse 一样的方法找到 StatusLine。所以兜底方案是自己根据 Status Line 的结构，自己手动构造一个。结构为：<code>协议版本号+空格+状态码+空格+状态文本+换行</code></p>
<p> 为 NSURLRequest 添加一个专门获取 Status Line 的分类。</p>
<p> // NSURLResquest+apm_FetchStatusLineFromCFNetwork.m</p>
<ul>
<li>(NSUInteger)apm_fetchStatusLineLength<br>{<br>NSString *statusLineString = [NSString stringWithFormat:@”%@ %@ %@\n”, self.HTTPMethod, self.URL.path, @”HTTP/1.1”];<br>NSData *statusLineData = [statusLineString dataUsingEncoding:NSUTF8StringEncoding];<br>return statusLineData.length;<br>}</li>
</ul>
</li>
<li><p>Header 部分</p>
<p> 一个 HTTP 请求会先构建判断是否存在缓存，然后进行 DNS 域名解析以获取请求域名的服务器 IP 地址。如果请求协议是 HTTPS，那么还需要建立 TLS 连接。接下来就是利用 IP 地址和服务器建立 TCP 连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。</p>
<p> 所以一个网络监控不考虑 cookie 😂，借用王多鱼的一句话「那不完犊子了吗」。</p>
<p> 看过一些文章说 NSURLRequest 不能完整获取到请求头信息。其实问题不大， 几个信息获取不完全也没办法。衡量监控方案本身就是看接口在不同版本或者某些情况下数据消耗是否异常，WebView 资源请求是否过大，类似于控制变量法的思想。</p>
<p> 所以获取到 NSURLRequest 的 <code>allHeaderFields</code> 后，加上 cookie 信息，计算完整的 Header 大小</p>
<p> // NSURLResquest+apm_FetchHeaderWithCookies.m</p>
<ul>
<li><p>(NSUInteger)apm_fetchHeaderLengthWithCookie<br>{<br>  NSDictionary *headerFields = self.allHTTPHeaderFields;<br>  NSDictionary *cookiesHeader = [self apm_fetchCookies];</p>
<p>  if (cookiesHeader.count) {</p>
<pre><code>  NSMutableDictionary \*headerDictionaryWithCookies = \[NSMutableDictionary dictionaryWithDictionary:headerFields\];
  \[headerDictionaryWithCookies addEntriesFromDictionary:cookiesHeader\];
  headerFields = \[headerDictionaryWithCookies copy\];</code></pre>
<p>  }</p>
<p>  NSString *headerString = @””;</p>
<p>  for (NSString *key in headerFields.allKeys) {</p>
<pre><code>  headerString = \[headerString stringByAppendingString:key\];
  headerString = \[headerString stringByAppendingString:@&quot;: &quot;\];
  if (\[headerFields objectForKey:key\]) &#123;
      headerString = \[headerString stringByAppendingString:headerFields\[key\]\];
  &#125;
  headerString = \[headerString stringByAppendingString:@&quot;\\n&quot;\];</code></pre>
<p>  }<br>  NSData *headerData = [headerString dataUsingEncoding:NSUTF8StringEncoding];<br>  headersLength = headerData.length;<br>  return headerString;<br>}</p>
</li>
<li><p>(NSDictionary *)apm_fetchCookies<br>{<br>  NSDictionary *cookiesHeaderDictionary;<br>  NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];<br>  NSArray&lt;NSHTTPCookie *&gt; *cookies = [cookieStorage cookiesForURL:self.URL];<br>  if (cookies.count) {</p>
<pre><code>  cookiesHeaderDictionary = \[NSHTTPCookie requestHeaderFieldsWithCookies:cookies\];</code></pre>
<p>  }<br>  return cookiesHeaderDictionary;<br>}</p>
</li>
</ul>
</li>
<li><p>Body 部分</p>
<p> NSURLConnection 的 <code>HTTPBody</code> 有可能获取不到，问题类似于 WebView 上 ajax 等情况。所以可以通过 <code>HTTPBodyStream</code> 读取 stream 来计算 body 大小.</p>
<p> - (NSUInteger)apm_fetchRequestBody<br> {</p>
<pre><code> NSDictionary \*headerFields = self.allHTTPHeaderFields;
 NSUInteger bodyLength = \[self.HTTPBody length\];

 if (\[headerFields objectForKey:@&quot;Content-Encoding&quot;\]) &#123;
     NSData \*bodyData;
     if (self.HTTPBody == nil) &#123;
         uint8\_t d\[1024\] = &#123;0&#125;;
         NSInputStream \*stream = self.HTTPBodyStream;
         NSMutableData \*data = \[\[NSMutableData alloc\] init\];
         \[stream open\];
         while (\[stream hasBytesAvailable\]) &#123;
             NSInteger len = \[stream read:d maxLength:1024\];
             if (len &gt; 0 &amp;&amp; stream.streamError == nil) &#123;
                 \[data appendBytes:(void \*)d length:len\];
             &#125;
         &#125;
         bodyData = \[data copy\];
         \[stream close\];
     &#125; else &#123;
         bodyData = self.HTTPBody;
     &#125;
     bodyLength = \[\[bodyData gzippedData\] length\];
 &#125;
 return bodyLength;</code></pre>
<p> }</p>
</li>
<li><p>在 <code>- (NSURLRequest *)connection:(NSURLConnection *)connection willSendRequest:(NSURLRequest *)request redirectResponse:(NSURLResponse *)response</code> 方法中将数据上报会在 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=eA1igiLRIyzxo5vMT8tLmQ==.AHKgASs3qLXjTEPL9wX33oDkOMD1zeDvkG6R9Jp1OXq1zlKsABF2yM0xNspPp96Eq/t1yL+R/k/H7p1hkZh50wttauZx5eHaAgCWyi7opMUOqkwqVl5SGWY4PwJtG5Ys">打造功能强大、灵活可配置的数据上报组件</a> 讲</p>
<p> -(NSURLRequest *)connection:(NSURLConnection *)connection willSendRequest:(NSURLRequest *)request redirectResponse:(NSURLResponse *)response<br> {</p>
<pre><code> if (response != nil) &#123;
     self.internalResponse = response;
     \[self.client URLProtocol:self wasRedirectedToRequest:request redirectResponse:response\];
 &#125;

 HCTNetworkTrafficModel \*model = \[\[HCTNetworkTrafficModel alloc\] init\];
 model.path = request.URL.path;
 model.host = request.URL.host;
 model.type = DMNetworkTrafficDataTypeRequest;
 model.lineLength = \[connection.currentRequest dgm\_getLineLength\];
 model.headerLength = \[connection.currentRequest dgm\_getHeadersLengthWithCookie\];
 model.bodyLength = \[connection.currentRequest dgm\_getBodyLength\];
 model.emptyLineLength = \[self.internalResponse apm\_getEmptyLineLength\];
 model.length = model.lineLength + model.headerLength + model.bodyLength + model.emptyLineLength;

 NSDictionary \*networkTrafficDictionary = \[model convertToDictionary\];
 \[\[HermesClient sharedInstance\] sendWithType:APMMonitorNetworkTrafficType meta:networkTrafficDictionary payload:nil\];
 return request;</code></pre>
<p> }</p>
</li>
</ol>
<h2 id="六、-电量消耗"><a href="#六、-电量消耗" class="headerlink" title="六、 电量消耗"></a>六、 电量消耗</h2><p>移动设备上电量一直是比较敏感的问题，如果用户在某款 App 的时候发现耗电量严重、手机发热严重，那么用户很大可能会马上卸载这款 App。所以需要在开发阶段关心耗电量问题。</p>
<p>一般来说遇到耗电量较大，我们立马会想到是不是使用了定位、是不是使用了频繁网络请求、是不是不断循环做某件事情？</p>
<p>开发阶段基本没啥问题，我们可以结合 <code>Instrucments</code> 里的 <code>Energy Log</code> 工具来定位问题。但是线上问题就需要代码去监控耗电量，可以作为 APM 的能力之一。</p>
<h3 id="1-如何获取电量"><a href="#1-如何获取电量" class="headerlink" title="1. 如何获取电量"></a>1. 如何获取电量</h3><p>在 iOS 中，<code>IOKit</code> 是一个私有框架，用来获取硬件和设备的详细信息，也是硬件和内核服务通信的底层框架。所以我们可以通过 <code>IOKit</code> 来获取硬件信息，从而获取到电量信息。步骤如下：</p>
<ul>
<li>  首先在苹果开放源代码 opensource 中找到 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=b/6fURTOumUTAheQuqpyxw==.dtXSUx10pYnebLQ48O8hnlF0B3mu1BzrOerkThTmYrlnpOwSNKQFCRC847ewVPpe5IgUj5QgS085FsKXyfzn74H35iPkjiQ8aT/fwMuVVp+QOBpakYTdYuZvMsZbG59F/gB5bS8STsX272y03dvAJQ==">IOPowerSources.h</a>、<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=JL4sd8PzpJH1P4eo4y6QNQ==.XAH/9UR0Dplko4Zt/s1ZHcsZZOWvPu7K/KAe1o+BdDFcemfyCycdcPwe2G5Hpw9JmvBGhliBSx6fFM5u4ruadbsuWy6Ev0CWwoeUoMTa4EBFjwqYkIdPoZIZkaaNm8gU">IOPSKeys.h</a>。在 Xcode 的 <code>Package Contents</code> 里面找到 <code>IOKit.framework</code>。 路径为 <code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/System/Library/Frameworks/IOKit.framework</code></li>
<li>  然后将 IOPowerSources.h、IOPSKeys.h、IOKit.framework 导入项目工程</li>
<li>  设置 UIDevice 的 batteryMonitoringEnabled 为 true</li>
<li>  获取到的耗电量精确度为 1%</li>
</ul>
<h3 id="2-定位问题"><a href="#2-定位问题" class="headerlink" title="2. 定位问题"></a>2. 定位问题</h3><p>通常我们通过 Instrucments 里的 Energy Log 解决了很多问题后，App 上线了，线上的耗电量解决就需要使用 APM 来解决了。耗电地方可能是二方库、三方库，也可能是某个同事的代码。</p>
<p>思路是：在检测到耗电后，先找到有问题的线程，然后堆栈 dump，还原案发现场。</p>
<p>在上面部分我们知道了线程信息的结构， <code>thread_basic_info</code> 中有个记录 CPU 使用率百分比的字段 <code>cpu_usage</code>。所以我们可以通过遍历当前线程，判断哪个线程的 CPU 使用率较高，从而找出有问题的线程。然后再 dump 堆栈，从而定位到发生耗电量的代码。详细请看 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000040277799#threadInfo">3.2</a> 部分。</p>
<p>- (double)fetchBatteryCostUsage<br>{<br>  // returns a blob of power source information in an opaque CFTypeRef<br>    CFTypeRef blob = IOPSCopyPowerSourcesInfo();<br>    // returns a CFArray of power source handles, each of type CFTypeRef<br>    CFArrayRef sources = IOPSCopyPowerSourcesList(blob);<br>    CFDictionaryRef pSource = NULL;<br>    const void *psValue;<br>    // returns the number of values currently in an array<br>    int numOfSources = CFArrayGetCount(sources);<br>    // error in CFArrayGetCount<br>    if (numOfSources == 0) {<br>        NSLog(@”Error in CFArrayGetCount”);<br>        return -1.0f;<br>    }</p>
<pre><code>// calculating the remaining energy
for (int i=0; i&lt;numOfSources; i++) &#123;
    // returns a CFDictionary with readable information about the specific power source
    pSource = IOPSGetPowerSourceDescription(blob, CFArrayGetValueAtIndex(sources, i));
    if (!pSource) &#123;
        NSLog(@&quot;Error in IOPSGetPowerSourceDescription&quot;);
        return \-1.0f;
    &#125;
    psValue = (CFStringRef) CFDictionaryGetValue(pSource, CFSTR(kIOPSNameKey));

    int curCapacity = 0;
    int maxCapacity = 0;
    double percentage;

    psValue = CFDictionaryGetValue(pSource, CFSTR(kIOPSCurrentCapacityKey));
    CFNumberGetValue((CFNumberRef)psValue, kCFNumberSInt32Type, &amp;curCapacity);

    psValue = CFDictionaryGetValue(pSource, CFSTR(kIOPSMaxCapacityKey));
    CFNumberGetValue((CFNumberRef)psValue, kCFNumberSInt32Type, &amp;maxCapacity);

    percentage = ((double) curCapacity / (double) maxCapacity \* 100.0f);
    NSLog(@&quot;curCapacity : %d / maxCapacity: %d , percentage: %.1f &quot;, curCapacity, maxCapacity, percentage);
    return percentage;
&#125;
return \-1.0f;</code></pre>
<p>}</p>
<h3 id="3-开发阶段针对电量消耗我们能做什么"><a href="#3-开发阶段针对电量消耗我们能做什么" class="headerlink" title="3. 开发阶段针对电量消耗我们能做什么"></a>3. 开发阶段针对电量消耗我们能做什么</h3><p>CPU 密集运算是耗电量主要原因。所以我们对 CPU 的使用需要精打细算。尽量避免让 CPU 做无用功。对于大量数据的复杂运算，可以借助服务器的能力、GPU 的能力。如果方案设计必须是在 CPU 上完成数据的运算，则可以利用 GCD 技术，使用 <code>dispatch_block_create_with_qos_class(&lt;#dispatch_block_flags_t flags#&gt;, dispatch_qos_class_t qos_class, &lt;#int relative_priority#&gt;, &lt;#^(void)block#&gt;)()</code> 并指定 队列的 qos 为 <code>QOS_CLASS_UTILITY</code>。将任务提交到这个队列的 block 中，在 QOS_CLASS_UTILITY 模式下，系统针对大量数据的计算，做了电量优化</p>
<p>除了 CPU 大量运算，I/O 操作也是耗电主要原因。业界常见方案都是将「碎片化的数据写入磁盘存储」这个操作延后，先在内存中聚合吗，然后再进行磁盘存储。碎片化数据先聚合，在内存中进行存储的机制，iOS 提供 <code>NSCache</code> 这个对象。</p>
<p>NSCache 是线程安全的，NSCache 会在达到达预设的缓存空间的条件时清理缓存，此时会触发 <code>- (**void**)cache:(NSCache *)cache willEvictObject:(**id**)obj;</code> 方法回调，在该方法内部对数据进行 I/O 操作，达到将聚合的数据 I/O 延后的目的。I/O 次数少了，对电量的消耗也就减少了。</p>
<p>NSCache 的使用可以查看 SDWebImage 这个图片加载框架。在图片读取缓存处理时，没直接读取硬盘文件（I/O），而是使用系统的 NSCache。</p>
<p>- (nullable UIImage *)imageFromMemoryCacheForKey:(nullable NSString *)key {<br>    return [self.memoryCache objectForKey:key];<br>}</p>
<ul>
<li><p>(nullable UIImage *)imageFromDiskCacheForKey:(nullable NSString *)key {<br>  UIImage *diskImage = [self diskImageForKey:key];<br>  if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) {</p>
<pre><code>  NSUInteger cost = diskImage.sd\_memoryCost;
  \[self.memoryCache setObject:diskImage forKey:key cost:cost\];</code></pre>
<p>  }</p>
<p>  return diskImage;<br>}</p>
</li>
</ul>
<p>可以看到主要逻辑是先从磁盘中读取图片，如果配置允许开启内存缓存，则将图片保存到 NSCache 中，使用的时候也是从 NSCache 中读取图片。NSCache 的 <code>totalCostLimit、countLimit</code> 属性，</p>
<p><code>- (void)setObject:(ObjectType)obj forKey:(KeyType)key cost:(NSUInteger)g;</code> 方法用来设置缓存条件。所以我们写磁盘、内存的文件操作时可以借鉴该策略，以优化耗电量。</p>
<h2 id="七、-Crash-监控"><a href="#七、-Crash-监控" class="headerlink" title="七、 Crash 监控"></a>七、 Crash 监控</h2><h3 id="1-异常相关知识回顾"><a href="#1-异常相关知识回顾" class="headerlink" title="1. 异常相关知识回顾"></a>1. 异常相关知识回顾</h3><h4 id="1-1-Mach-层对异常的处理"><a href="#1-1-Mach-层对异常的处理" class="headerlink" title="1.1 Mach 层对异常的处理"></a>1.1 Mach 层对异常的处理</h4><p>Mach 在消息传递基础上实现了一套独特的异常处理方法。Mach 异常处理在设计时考虑到：</p>
<ul>
<li>  带有一致的语义的单一异常处理设施：Mach 只提供一个异常处理机制用于处理所有类型的异常（包括用户定义的异常、平台无关的异常以及平台特定的异常）。根据异常类型进行分组，具体的平台可以定义具体的子类型。</li>
<li>  清晰和简洁：异常处理的接口依赖于 Mach 已有的具有良好定义的消息和端口架构，因此非常优雅（不会影响效率）。这就允许调试器和外部处理程序的拓展-甚至在理论上还支持拓展基于网络的异常处理。</li>
</ul>
<p>在 Mach 中，异常是通过内核中的基础设施-消息传递机制处理的。一个异常并不比一条消息复杂多少，异常由出错的线程或者任务（通过 msg_send()） 抛出，然后由一个处理程序通过 msg_recv()）捕捉。处理程序可以处理异常，也可以清楚异常（将异常标记为已完成并继续），还可以决定终止线程。</p>
<p>Mach 的异常处理模型和其他的异常处理模型不同，其他模型的异常处理程序运行在出错的线程上下文中，而 Mach 的异常处理程序在不同的上下文中运行异常处理程序，出错的线程向预先指定好的异常端口发送消息，然后等待应答。每一个任务都可以注册一个异常处理端口，这个异常处理端口会对该任务中的所有线程生效。此外，每个线程都可以通过 <code>thread_set_exception_ports(&lt;#thread_act_t thread#&gt;, &lt;#exception_mask_t exception_mask#&gt;, &lt;#mach_port_t new_port#&gt;, &lt;#exception_behavior_t behavior#&gt;, &lt;#thread_state_flavor_t new_flavor#&gt;)</code> 注册自己的异常处理端口。通常情况下，任务和线程的异常端口都是 NULL，也就是异常不会被处理，而一旦创建异常端口，这些端口就像系统中的其他端口一样，可以转交给其他任务或者其他主机。（有了端口，就可以使用 UDP 协议，通过网络能力让其他的主机上应用程序处理异常）。</p>
<p>发生异常时，首先尝试将异常抛给线程的异常端口，然后尝试抛给任务的异常端口，最后再抛给主机的异常端口（即主机注册的默认端口）。如果没有一个端口返回 <code>KERN_SUCCESS</code>，那么整个任务将被终止。也就是 Mach 不提供异常处理逻辑，只提供传递异常通知的框架。</p>
<p>异常首先是由处理器陷阱引发的。为了处理陷阱，每一个现代的内核都会安插陷阱处理程序。这些底层函数是由内核的汇编部分安插的。</p>
<h4 id="1-2-BSD-层对异常的处理"><a href="#1-2-BSD-层对异常的处理" class="headerlink" title="1.2 BSD 层对异常的处理"></a>1.2 BSD 层对异常的处理</h4><p>BSD 层是用户态主要使用的 XUN 接口，这一层展示了一个符合 POSIX 标准的接口。开发者可以使用 UNIX 系统的一切功能，但不需要了解 Mach 层的细节实现。</p>
<p>Mach 已经通过异常机制提供了底层的陷进处理，而 BSD 则在异常机制之上构建了信号处理机制。硬件产生的信号被 Mach 层捕捉，然后转换为对应的 UNIX 信号，为了维护一个统一的机制，操作系统和用户产生的信号首先被转换为 Mach 异常，然后再转换为信号。</p>
<p>Mach 异常都在 host 层被 <code>ux_exception</code> 转换为相应的 unix 信号，并通过 <code>threadsignal</code> 将信号投递到出错的线程。</p>
<p><img src="https://segmentfault.com/img/bVbIOko"></p>
<h3 id="2-Crash-收集方式"><a href="#2-Crash-收集方式" class="headerlink" title="2. Crash 收集方式"></a>2. Crash 收集方式</h3><p>iOS 系统自带的 Apples`s Crash Reporter 在设置中记录 Crash 日志，我们先观察下 Crash 日志</p>
<p>Incident Identifier: 7FA6736D-09E8-47A1-95EC-76C4522BDE1A<br>CrashReporter Key:   4e2d36419259f14413c3229e8b7235bcc74847f3<br>Hardware Model:      iPhone7,1<br>Process:         APMMonitorExample [3608]<br>Path:            /var/containers/Bundle/Application/9518A4F4-59B7-44E9-BDDA-9FBEE8CA18E5/APMMonitorExample.app/APMMonitorExample<br>Identifier:      com.Wacai.APMMonitorExample<br>Version:         1.0 (1)<br>Code Type:       ARM-64<br>Parent Process:  ? [1]</p>
<p>Date/Time:       2017-01-03 11:43:03.000 +0800<br>OS Version:      iOS 10.2 (14C92)<br>Report Version:  104</p>
<p>Exception Type:  EXC_CRASH (SIGABRT)<br>Exception Codes: 0x00000000 at 0x0000000000000000<br>Crashed Thread:  0</p>
<p>Application Specific Information:<br>*** Terminating app due to uncaught exception ‘NSInvalidArgumentException’, reason: ‘-[__NSSingleObjectArrayI objectForKey:]: unrecognized selector sent to instance 0x174015060’</p>
<p>Thread 0 Crashed:<br>0   CoreFoundation                  0x0000000188f291b8 0x188df9000 + 1245624 (<redacted> + 124)<br>1   libobjc.A.dylib                 0x000000018796055c 0x187958000 + 34140 (objc_exception_throw + 56)<br>2   CoreFoundation                  0x0000000188f30268 0x188df9000 + 1274472 (<redacted> + 140)<br>3   CoreFoundation                  0x0000000188f2d270 0x188df9000 + 1262192 (<redacted> + 916)<br>4   CoreFoundation                  0x0000000188e2680c 0x188df9000 + 186380 (_CF_forwarding_prep_0 + 92)<br>5   APMMonitorExample                0x000000010004c618 0x100044000 + 34328 (-[MakeCrashHandler throwUncaughtNSException] + 80)</p>
<p>会发现，Crash 日志中 <code>Exception Type</code> 项由2部分组成：Mach 异常 + Unix 信号。</p>
<p>所以 <code>Exception Type: EXC_CRASH (SIGABRT)</code> 表示：Mach 层发生了 <code>EXC_CRASH</code> 异常，在 host 层被转换为 <code>SIGABRT</code> 信号投递到出错的线程。</p>
<p><strong>问题：</strong> 捕获 Mach 层异常、注册 Unix 信号处理都可以捕获 Crash，这两种方式如何选择？</p>
<p><strong>答：</strong> 优选 Mach 层异常拦截。根据上面 1.2 中的描述我们知道 Mach 层异常处理时机更早些，假如 Mach 层异常处理程序让进程退出，这样 Unix 信号永远不会发生了。</p>
<p>业界关于崩溃日志的收集开源项目很多，著名的有： KSCrash、plcrashreporter，提供一条龙服务的 Bugly、友盟等。我们一般使用开源项目在此基础上开发成符合公司内部需求的 bug 收集工具。一番对比后选择 KSCrash。为什么选择 KSCrash 不在本文重点。</p>
<p>KSCrash 功能齐全，可以捕获如下类型的 Crash</p>
<ul>
<li>  Mach kernel exceptions</li>
<li>  Fatal signals</li>
<li>  C++ exceptions</li>
<li>  Objective-C exceptions</li>
<li>  Main thread deadlock (experimental)</li>
<li>  Custom crashes (e.g. from scripting languages)</li>
</ul>
<p>所以分析 iOS 端的 Crash 收集方案也就是分析 KSCrash 的 Crash 监控实现原理。</p>
<h4 id="2-1-Mach-层异常处理"><a href="#2-1-Mach-层异常处理" class="headerlink" title="2.1. Mach 层异常处理"></a>2.1. Mach 层异常处理</h4><p>大体思路是：先创建一个异常处理端口，为该端口申请权限，再设置异常端口、新建一个内核线程，在该线程内循环等待异常。但是为了防止自己注册的 Mach 层异常处理抢占了其他 SDK、或者业务线开发者设置的逻辑，我们需要在最开始保存其他的异常处理端口，等逻辑执行完后将异常处理交给其他的端口内的逻辑处理。收集到 Crash 信息后组装数据，写入 json 文件。</p>
<p>流程图如下：</p>
<p><img src="https://segmentfault.com/img/bVbIOku"></p>
<p>对于 Mach 异常捕获，可以注册一个异常端口，该端口负责对当前任务的所有线程进行监听。</p>
<p>下面来看看关键代码:</p>
<p>注册 Mach 层异常监听代码</p>
<p>static bool installExceptionHandler()<br>{<br>    KSLOG_DEBUG(“Installing mach exception handler.”);</p>
<pre><code>bool attributes\_created = false;
pthread\_attr\_t attr;

kern\_return\_t kr;
int error;
// 拿到当前进程
const task\_t thisTask = mach\_task\_self();
exception\_mask\_t mask = EXC\_MASK\_BAD\_ACCESS |
EXC\_MASK\_BAD\_INSTRUCTION |
EXC\_MASK\_ARITHMETIC |
EXC\_MASK\_SOFTWARE |
EXC\_MASK\_BREAKPOINT;

KSLOG\_DEBUG(&quot;Backing up original exception ports.&quot;);
// 获取该 Task 上的注册好的异常端口
kr = task\_get\_exception\_ports(thisTask,
                              mask,
                              g\_previousExceptionPorts.masks,
                              &amp;g\_previousExceptionPorts.count,
                              g\_previousExceptionPorts.ports,
                              g\_previousExceptionPorts.behaviors,
                              g\_previousExceptionPorts.flavors);
// 获取失败走 failed 逻辑
if(kr != KERN\_SUCCESS)
&#123;
    KSLOG\_ERROR(&quot;task\_get\_exception\_ports: %s&quot;, mach\_error\_string(kr));
    goto failed;
&#125;
// KSCrash 的异常为空则走执行逻辑
if(g\_exceptionPort == MACH\_PORT\_NULL)
&#123;
    KSLOG\_DEBUG(&quot;Allocating new port with receive rights.&quot;);
    // 申请异常处理端口
    kr = mach\_port\_allocate(thisTask,
                            MACH\_PORT\_RIGHT\_RECEIVE,
                            &amp;g\_exceptionPort);
    if(kr != KERN\_SUCCESS)
    &#123;
        KSLOG\_ERROR(&quot;mach\_port\_allocate: %s&quot;, mach\_error\_string(kr));
        goto failed;
    &#125;

    KSLOG\_DEBUG(&quot;Adding send rights to port.&quot;);
    // 为异常处理端口申请权限：MACH\_MSG\_TYPE\_MAKE\_SEND
    kr = mach\_port\_insert\_right(thisTask,
                                g\_exceptionPort,
                                g\_exceptionPort,
                                MACH\_MSG\_TYPE\_MAKE\_SEND);
    if(kr != KERN\_SUCCESS)
    &#123;
        KSLOG\_ERROR(&quot;mach\_port\_insert\_right: %s&quot;, mach\_error\_string(kr));
        goto failed;
    &#125;
&#125;

KSLOG\_DEBUG(&quot;Installing port as exception handler.&quot;);
// 为该 Task 设置异常处理端口
kr = task\_set\_exception\_ports(thisTask,
                              mask,
                              g\_exceptionPort,
                              EXCEPTION\_DEFAULT,
                              THREAD\_STATE\_NONE);
if(kr != KERN\_SUCCESS)
&#123;
    KSLOG\_ERROR(&quot;task\_set\_exception\_ports: %s&quot;, mach\_error\_string(kr));
    goto failed;
&#125;

KSLOG\_DEBUG(&quot;Creating secondary exception thread (suspended).&quot;);
pthread\_attr\_init(&amp;attr);
attributes\_created = true;
pthread\_attr\_setdetachstate(&amp;attr, PTHREAD\_CREATE\_DETACHED);
// 设置监控线程
error = pthread\_create(&amp;g\_secondaryPThread,
                       &amp;attr,
                       &amp;handleExceptions,
                       kThreadSecondary);
if(error != 0)
&#123;
    KSLOG\_ERROR(&quot;pthread\_create\_suspended\_np: %s&quot;, strerror(error));
    goto failed;
&#125;
// 转换为 Mach 内核线程
g\_secondaryMachThread = pthread\_mach\_thread\_np(g\_secondaryPThread);
ksmc\_addReservedThread(g\_secondaryMachThread);

KSLOG\_DEBUG(&quot;Creating primary exception thread.&quot;);
error = pthread\_create(&amp;g\_primaryPThread,
                       &amp;attr,
                       &amp;handleExceptions,
                       kThreadPrimary);
if(error != 0)
&#123;
    KSLOG\_ERROR(&quot;pthread\_create: %s&quot;, strerror(error));
    goto failed;
&#125;
pthread\_attr\_destroy(&amp;attr);
g\_primaryMachThread = pthread\_mach\_thread\_np(g\_primaryPThread);
ksmc\_addReservedThread(g\_primaryMachThread);

KSLOG\_DEBUG(&quot;Mach exception handler installed.&quot;);
return true;</code></pre>
<p>failed:<br>    KSLOG_DEBUG(“Failed to install mach exception handler.”);<br>    if(attributes_created)<br>    {<br>        pthread_attr_destroy(&amp;attr);<br>    }<br>    // 还原之前的异常注册端口，将控制权还原<br>    uninstallExceptionHandler();<br>    return false;<br>}</p>
<p>处理异常的逻辑、组装崩溃信息</p>
<p>/** Our exception handler thread routine.<br> * Wait for an exception message, uninstall our exception port, record the<br> * exception information, and write a report.<br> */<br>static void* handleExceptions(void* const userData)<br>{<br>    MachExceptionMessage exceptionMessage = 0;<br>    MachReplyMessage replyMessage = 0;<br>    char* eventID = g_primaryEventID;</p>
<pre><code>const char\* threadName = (const char\*) userData;
pthread\_setname\_np(threadName);
if(threadName == kThreadSecondary)
&#123;
    KSLOG\_DEBUG(&quot;This is the secondary thread. Suspending.&quot;);
    thread\_suspend((thread\_t)ksthread\_self());
    eventID = g\_secondaryEventID;
&#125;
// 循环读取注册好的异常端口信息
for(;;)
&#123;
    KSLOG\_DEBUG(&quot;Waiting for mach exception&quot;);

    // Wait for a message.
    kern\_return\_t kr = mach\_msg(&amp;exceptionMessage.header,
                                MACH\_RCV\_MSG,
                                0,
                                sizeof(exceptionMessage),
                                g\_exceptionPort,
                                MACH\_MSG\_TIMEOUT\_NONE,
                                MACH\_PORT\_NULL);
    // 获取到信息后则代表发生了 Mach 层异常，跳出 for 循环，组装数据
    if(kr == KERN\_SUCCESS)
    &#123;
        break;
    &#125;

    // Loop and try again on failure.
    KSLOG\_ERROR(&quot;mach\_msg: %s&quot;, mach\_error\_string(kr));
&#125;

KSLOG\_DEBUG(&quot;Trapped mach exception code 0x%x, subcode 0x%x&quot;,
            exceptionMessage.code\[0\], exceptionMessage.code\[1\]);
if(g\_isEnabled)
&#123;
    // 挂起所有线程
    ksmc\_suspendEnvironment();
    g\_isHandlingCrash = true;
    // 通知发生了异常
    kscm\_notifyFatalExceptionCaptured(true);

    KSLOG\_DEBUG(&quot;Exception handler is installed. Continuing exception handling.&quot;);


    // Switch to the secondary thread if necessary, or uninstall the handler
    // to avoid a death loop.
    if(ksthread\_self() == g\_primaryMachThread)
    &#123;
        KSLOG\_DEBUG(&quot;This is the primary exception thread. Activating secondary thread.&quot;);</code></pre>
<p>// TODO: This was put here to avoid a freeze. Does secondary thread ever fire?<br>            restoreExceptionPorts();<br>            if(thread_resume(g_secondaryMachThread) != KERN_SUCCESS)<br>            {<br>                KSLOG_DEBUG(“Could not activate secondary thread. Restoring original exception ports.”);<br>            }<br>        }<br>        else<br>        {<br>            KSLOG_DEBUG(“This is the secondary exception thread. Restoring original exception ports.”);<br>//            restoreExceptionPorts();<br>        }</p>
<pre><code>    // Fill out crash information
    // 组装异常所需要的方案现场信息
    KSLOG\_DEBUG(&quot;Fetching machine state.&quot;);
    KSMC\_NEW\_CONTEXT(machineContext);
    KSCrash\_MonitorContext\* crashContext = &amp;g\_monitorContext;
    crashContext-&gt;offendingMachineContext = machineContext;
    kssc\_initCursor(&amp;g\_stackCursor, NULL, NULL);
    if(ksmc\_getContextForThread(exceptionMessage.thread.name, machineContext, true))
    &#123;
        kssc\_initWithMachineContext(&amp;g\_stackCursor, 100, machineContext);
        KSLOG\_TRACE(&quot;Fault address 0x%x, instruction address 0x%x&quot;, kscpu\_faultAddress(machineContext), kscpu\_instructionAddress(machineContext));
        if(exceptionMessage.exception == EXC\_BAD\_ACCESS)
        &#123;
            crashContext-&gt;faultAddress = kscpu\_faultAddress(machineContext);
        &#125;
        else
        &#123;
            crashContext-&gt;faultAddress = kscpu\_instructionAddress(machineContext);
        &#125;
    &#125;

    KSLOG\_DEBUG(&quot;Filling out context.&quot;);
    crashContext-&gt;crashType = KSCrashMonitorTypeMachException;
    crashContext-&gt;eventID = eventID;
    crashContext-&gt;registersAreValid = true;
    crashContext-&gt;mach.type = exceptionMessage.exception;
    crashContext-&gt;mach.code = exceptionMessage.code\[0\];
    crashContext-&gt;mach.subcode = exceptionMessage.code\[1\];
    if(crashContext-&gt;mach.code == KERN\_PROTECTION\_FAILURE &amp;&amp; crashContext-&gt;isStackOverflow)
    &#123;
        // A stack overflow should return KERN\_INVALID\_ADDRESS, but
        // when a stack blasts through the guard pages at the top of the stack,
        // it generates KERN\_PROTECTION\_FAILURE. Correct for this.
        crashContext-&gt;mach.code = KERN\_INVALID\_ADDRESS;
    &#125;
    crashContext-&gt;signal.signum = signalForMachException(crashContext-&gt;mach.type, crashContext-&gt;mach.code);
    crashContext-&gt;stackCursor = &amp;g\_stackCursor;

    kscm\_handleException(crashContext);

    KSLOG\_DEBUG(&quot;Crash handling complete. Restoring original handlers.&quot;);
    g\_isHandlingCrash = false;
    ksmc\_resumeEnvironment();
&#125;

KSLOG\_DEBUG(&quot;Replying to mach exception message.&quot;);
// Send a reply saying &quot;I didn&#39;t handle this exception&quot;.
replyMessage.header = exceptionMessage.header;
replyMessage.NDR = exceptionMessage.NDR;
replyMessage.returnCode = KERN\_FAILURE;

mach\_msg(&amp;replyMessage.header,
         MACH\_SEND\_MSG,
         sizeof(replyMessage),
         0,
         MACH\_PORT\_NULL,
         MACH\_MSG\_TIMEOUT\_NONE,
         MACH\_PORT\_NULL);

return NULL;</code></pre>
<p>}</p>
<p>还原异常处理端口，转移控制权</p>
<p>/** Restore the original mach exception ports.<br> */<br>static void restoreExceptionPorts(void)<br>{<br>    KSLOG_DEBUG(“Restoring original exception ports.”);<br>    if(g_previousExceptionPorts.count == 0)<br>    {<br>        KSLOG_DEBUG(“Original exception ports were already restored.”);<br>        return;<br>    }</p>
<pre><code>const task\_t thisTask = mach\_task\_self();
kern\_return\_t kr;

// Reinstall old exception ports.
// for 循环去除保存好的在 KSCrash 之前注册好的异常端口，将每个端口注册回去
for(mach\_msg\_type\_number\_t i = 0; i &lt; g\_previousExceptionPorts.count; i++)
&#123;
    KSLOG\_TRACE(&quot;Restoring port index %d&quot;, i);
    kr = task\_set\_exception\_ports(thisTask,
                                  g\_previousExceptionPorts.masks\[i\],
                                  g\_previousExceptionPorts.ports\[i\],
                                  g\_previousExceptionPorts.behaviors\[i\],
                                  g\_previousExceptionPorts.flavors\[i\]);
    if(kr != KERN\_SUCCESS)
    &#123;
        KSLOG\_ERROR(&quot;task\_set\_exception\_ports: %s&quot;,
                    mach\_error\_string(kr));
    &#125;
&#125;
KSLOG\_DEBUG(&quot;Exception ports restored.&quot;);
g\_previousExceptionPorts.count = 0;</code></pre>
<p>}</p>
<h4 id="2-2-Signal-异常处理"><a href="#2-2-Signal-异常处理" class="headerlink" title="2.2. Signal 异常处理"></a>2.2. Signal 异常处理</h4><p>对于 Mach 异常，操作系统会将其转换为对应的 <code>Unix 信号</code>，所以开发者可以通过注册 <code>signanHandler</code> 的方式来处理。</p>
<p>KSCrash 在这里的处理逻辑如下图：</p>
<p><img src="https://segmentfault.com/img/bVbIOkv"><br>看一下关键代码:</p>
<p>设置信号处理函数</p>
<p>static bool installSignalHandler()<br>{<br>    KSLOG_DEBUG(“Installing signal handler.”);</p>
<p>#if KSCRASH_HAS_SIGNAL_STACK<br>    // 在堆上分配一块内存，<br>    if(g_signalStack.ss_size == 0)<br>    {<br>        KSLOG_DEBUG(“Allocating signal stack area.”);<br>        g_signalStack.ss_size = SIGSTKSZ;<br>        g_signalStack.ss_sp = malloc(g_signalStack.ss_size);<br>    }<br>    // 信号处理函数的栈挪到堆中，而不和进程共用一块栈区<br>    // sigaltstack() 函数，该函数的第 1 个参数 sigstack 是一个 stack_t 结构的指针，该结构存储了一个“可替换信号栈” 的位置及属性信息。第 2 个参数 old_sigstack 也是一个 stack_t 类型指针，它用来返回上一次建立的“可替换信号栈”的信息(如果有的话)<br>    KSLOG_DEBUG(“Setting signal stack area.”);<br>    // sigaltstack 第一个参数为创建的新的可替换信号栈，第二个参数可以设置为NULL，如果不为NULL的话，将会将旧的可替换信号栈的信息保存在里面。函数成功返回0，失败返回-1.<br>    if(sigaltstack(&amp;g_signalStack, NULL) != 0)<br>    {<br>        KSLOG_ERROR(“signalstack: %s”, strerror(errno));<br>        goto failed;<br>    }<br>#endif</p>
<pre><code>const int\* fatalSignals = kssignal\_fatalSignals();
int fatalSignalsCount = kssignal\_numFatalSignals();

if(g\_previousSignalHandlers == NULL)
&#123;
    KSLOG\_DEBUG(&quot;Allocating memory to store previous signal handlers.&quot;);
    g\_previousSignalHandlers = malloc(sizeof(\*g\_previousSignalHandlers)
                                      \* (unsigned)fatalSignalsCount);
&#125;

// 设置信号处理函数 sigaction 的第二个参数，类型为 sigaction 结构体
struct sigaction action = &#123;&#123;0&#125;&#125;;
// sa\_flags 成员设立 SA\_ONSTACK 标志，该标志告诉内核信号处理函数的栈帧就在“可替换信号栈”上建立。
action.sa\_flags = SA\_SIGINFO | SA\_ONSTACK;</code></pre>
<p>#if KSCRASH_HOST_APPLE &amp;&amp; defined(__LP64__)<br>    action.sa_flags |= SA_64REGSET;<br>#endif<br>    sigemptyset(&amp;action.sa_mask);<br>    action.sa_sigaction = &handleSignal;</p>
<pre><code>// 遍历需要处理的信号数组
for(int i = 0; i &lt; fatalSignalsCount; i++)
&#123;
    // 将每个信号的处理函数绑定到上面声明的 action 去，另外用 g\_previousSignalHandlers 保存当前信号的处理函数
    KSLOG\_DEBUG(&quot;Assigning handler for signal %d&quot;, fatalSignals\[i\]);
    if(sigaction(fatalSignals\[i\], &amp;action, &amp;g\_previousSignalHandlers\[i\]) != 0)
    &#123;
        char sigNameBuff\[30\];
        const char\* sigName = kssignal\_signalName(fatalSignals\[i\]);
        if(sigName == NULL)
        &#123;
            snprintf(sigNameBuff, sizeof(sigNameBuff), &quot;%d&quot;, fatalSignals\[i\]);
            sigName = sigNameBuff;
        &#125;
        KSLOG\_ERROR(&quot;sigaction (%s): %s&quot;, sigName, strerror(errno));
        // Try to reverse the damage
        for(i--;i &gt;= 0; i--)
        &#123;
            sigaction(fatalSignals\[i\], &amp;g\_previousSignalHandlers\[i\], NULL);
        &#125;
        goto failed;
    &#125;
&#125;
KSLOG\_DEBUG(&quot;Signal handlers installed.&quot;);
return true;</code></pre>
<p>failed:<br>    KSLOG_DEBUG(“Failed to install signal handlers.”);<br>    return false;<br>}</p>
<p>信号处理时记录线程等上下文信息</p>
<p>static void handleSignal(int sigNum, siginfo_t* signalInfo, void* userContext)<br>{<br>    KSLOG_DEBUG(“Trapped signal %d”, sigNum);<br>    if(g_isEnabled)<br>    {<br>        ksmc_suspendEnvironment();<br>        kscm_notifyFatalExceptionCaptured(false);</p>
<pre><code>    KSLOG\_DEBUG(&quot;Filling out context.&quot;);
    KSMC\_NEW\_CONTEXT(machineContext);
    ksmc\_getContextForSignal(userContext, machineContext);
    kssc\_initWithMachineContext(&amp;g\_stackCursor, 100, machineContext);
    // 记录信号处理时的上下文信息
    KSCrash\_MonitorContext\* crashContext = &amp;g\_monitorContext;
    memset(crashContext, 0, sizeof(\*crashContext));
    crashContext-&gt;crashType = KSCrashMonitorTypeSignal;
    crashContext-&gt;eventID = g\_eventID;
    crashContext-&gt;offendingMachineContext = machineContext;
    crashContext-&gt;registersAreValid = true;
    crashContext-&gt;faultAddress = (uintptr\_t)signalInfo-&gt;si\_addr;
    crashContext-&gt;signal.userContext = userContext;
    crashContext-&gt;signal.signum = signalInfo-&gt;si\_signo;
    crashContext-&gt;signal.sigcode = signalInfo-&gt;si\_code;
    crashContext-&gt;stackCursor = &amp;g\_stackCursor;

    kscm\_handleException(crashContext);
    ksmc\_resumeEnvironment();
&#125;

KSLOG\_DEBUG(&quot;Re-raising signal for regular handlers to catch.&quot;);
// This is technically not allowed, but it works in OSX and iOS.
raise(sigNum);</code></pre>
<p>}</p>
<p>KSCrash 信号处理后还原之前的信号处理权限</p>
<p>static void uninstallSignalHandler(void)<br>{<br>    KSLOG_DEBUG(“Uninstalling signal handlers.”);</p>
<pre><code>const int\* fatalSignals = kssignal\_fatalSignals();
int fatalSignalsCount = kssignal\_numFatalSignals();
// 遍历需要处理信号数组，将之前的信号处理函数还原
for(int i = 0; i &lt; fatalSignalsCount; i++)
&#123;
    KSLOG\_DEBUG(&quot;Restoring original handler for signal %d&quot;, fatalSignals\[i\]);
    sigaction(fatalSignals\[i\], &amp;g\_previousSignalHandlers\[i\], NULL);
&#125;

KSLOG\_DEBUG(&quot;Signal handlers uninstalled.&quot;);</code></pre>
<p>}</p>
<p>说明：</p>
<ol>
<li><p>先从堆上分配一块内存区域，被称为“可替换信号栈”，目的是将信号处理函数的栈干掉，用堆上的内存区域代替，而不和进程共用一块栈区。</p>
<p> 为什么这么做？一个进程可能有 n 个线程，每个线程都有自己的任务，假如某个线程执行出错，这样就会导致整个进程的崩溃。所以为了信号处理函数正常运行，需要为信号处理函数设置单独的运行空间。另一种情况是递归函数将系统默认的栈空间用尽了，但是信号处理函数使用的栈是它实现在堆中分配的空间，而不是系统默认的栈，所以它仍旧可以正常工作。</p>
</li>
<li><p><code>int sigaltstack(const stack_t * __restrict, stack_t * __restrict)</code> 函数的二个参数都是 <code>stack_t</code> 结构的指针，存储了可替换信号栈的信息（栈的起始地址、栈的长度、状态）。第1个参数该结构存储了一个“可替换信号栈” 的位置及属性信息。第 2 个参数用来返回上一次建立的“可替换信号栈”的信息(如果有的话)。</p>
<p> _STRUCT_SIGALTSTACK<br> {</p>
<pre><code> void            \*ss\_sp;         /\* signal stack base \*/
 \_\_darwin\_size\_t ss\_size;        /\* signal stack length \*/
 int             ss\_flags;       /\* SA\_DISABLE and/or SA\_ONSTACK \*/</code></pre>
<p> };<br> typedef _STRUCT_SIGALTSTACK     stack_t; /* [???] signal stack */</p>
</li>
</ol>
<p>新创建的可替换信号栈，<code>ss_flags</code> 必须设置为 0。系统定义了 <code>SIGSTKSZ</code> 常量，可满足绝大多可替换信号栈的需求。</p>
<p>/*<br> * Structure used in sigaltstack call.<br> */</p>
<p>#define SS_ONSTACK      0x0001  /* take signal on signal stack */<br>#define SS_DISABLE      0x0004  /* disable taking signals on alternate stack */<br>#define MINSIGSTKSZ     32768   /* (32K)minimum allowable stack */<br>#define SIGSTKSZ        131072  /* (128K)recommended stack size */</p>
<p><code>sigaltstack</code> 系统调用通知内核“可替换信号栈”已经建立。</p>
<p><code>ss_flags</code> 为 <code>SS_ONSTACK</code> 时，表示进程当前正在“可替换信号栈”中执行，如果此时试图去建立一个新的“可替换信号栈”，那么会遇到 <code>EPERM</code> (禁止该动作) 的错误；为 <code>SS_DISABLE</code> 说明当前没有已建立的“可替换信号栈”，禁止建立“可替换信号栈”。</p>
<ol start="3">
<li><p><code>int sigaction(int, const struct sigaction * __restrict, struct sigaction * __restrict);</code></p>
<p> 第一个函数表示需要处理的信号值，但不能是 <code>SIGKILL</code> 和 <code>SIGSTOP</code> ，这两个信号的处理函数不允许用户重写，因为它们给超级用户提供了终止程序的方法（ <code>SIGKILL</code> and <code>SIGSTOP</code> cannot be caught, blocked, or ignored）；</p>
<p> 第二个和第三个参数是一个 <code>sigaction</code> 结构体。如果第二个参数不为空则代表将其指向信号处理函数，第三个参数不为空，则将之前的信号处理函数保存到该指针中。如果第二个参数为空，第三个参数不为空，则可以获取当前的信号处理函数。</p>
<p> /*<br>  * Signal vector “template” used in sigaction call.<br>  */<br> struct  sigaction {</p>
<pre><code> union \_\_sigaction\_u \_\_sigaction\_u;  /\* signal handler \*/
 sigset\_t sa\_mask;               /\* signal mask to apply \*/
 int     sa\_flags;               /\* see signal options below \*/</code></pre>
<p> };</p>
</li>
</ol>
<p><code>sigaction</code> 函数的 <code>sa_flags</code> 参数需要设置 <code>SA_ONSTACK</code> 标志，告诉内核信号处理函数的栈帧就在“可替换信号栈”上建立。</p>
<h4 id="2-3-C-异常处理"><a href="#2-3-C-异常处理" class="headerlink" title="2.3. C++ 异常处理"></a>2.3. C++ 异常处理</h4><p>c++ 异常处理的实现是依靠了标准库的 <code>std::set_terminate(CPPExceptionTerminate)</code> 函数。</p>
<p>iOS 工程中某些功能的实现可能使用了C、C++等。假如抛出 C++ 异常，如果该异常可以被转换为 NSException，则走 OC 异常捕获机制，如果不能转换，则继续走 C++ 异常流程，也就是 <code>default_terminate_handler</code>。这个 C++ 异常的默认 terminate 函数内部调用 <code>abort_message</code> 函数，最后触发了一个 <code>abort</code> 调用，系统产生一个 <code>SIGABRT</code> 信号。</p>
<p>在系统抛出 C++ 异常后，加一层 <code>try...catch...</code> 来判断该异常是否可以转换为 <code>NSException</code>，再重新抛出的C++异常。此时异常的现场堆栈已经消失，所以上层通过捕获 <code>SIGABRT</code> 信号是无法还原发生异常时的场景，即异常堆栈缺失。</p>
<p>为什么？<code>try...catch...</code> 语句内部会调用 <code>__cxa_rethrow()</code> 抛出异常，<code>__cxa_rethrow()</code> 内部又会调用 <code>unwind</code>，<code>unwind</code> 可以简单理解为函数调用的逆调用，主要用来清理函数调用过程中每个函数生成的局部变量，一直到最外层的 catch 语句所在的函数，并把控制移交给 catch 语句，这就是C++异常的堆栈消失原因。</p>
<p>static void setEnabled(bool isEnabled) {<br>    if(isEnabled != g_isEnabled)<br>    {<br>        g_isEnabled = isEnabled;<br>        if(isEnabled)<br>        {<br>            initialize();</p>
<pre><code>        ksid\_generate(g\_eventID);
        g\_originalTerminateHandler = std::set\_terminate(CPPExceptionTerminate);
    &#125;
    else
    &#123;
        std::set\_terminate(g\_originalTerminateHandler);
    &#125;
    g\_captureNextStackTrace = isEnabled;
&#125;</code></pre>
<p>}</p>
<p>static void initialize() {<br>    static bool isInitialized = false;<br>    if(!isInitialized)<br>    {<br>        isInitialized = true;<br>        kssc_initCursor(&amp;g_stackCursor, NULL, NULL);<br>    }<br>}</p>
<p>void kssc_initCursor(KSStackCursor *cursor,<br>                     void (*resetCursor)(KSStackCursor*),<br>                     bool (*advanceCursor)(KSStackCursor*)) {<br>    cursor-&gt;symbolicate = kssymbolicator_symbolicate;<br>    cursor-&gt;advanceCursor = advanceCursor != NULL ? advanceCursor : g_advanceCursor;<br>    cursor-&gt;resetCursor = resetCursor != NULL ? resetCursor : kssc_resetCursor;<br>    cursor-&gt;resetCursor(cursor);<br>}</p>
<p>static void CPPExceptionTerminate(void) {<br>    ksmc_suspendEnvironment();<br>    KSLOG_DEBUG(“Trapped c++ exception”);<br>    const char* name = NULL;<br>    std::type_info* tinfo = __cxxabiv1::__cxa_current_exception_type();<br>    if(tinfo != NULL)<br>    {<br>        name = tinfo-&gt;name();<br>    }</p>
<pre><code>if(name == NULL || strcmp(name, &quot;NSException&quot;) != 0)
&#123;
    kscm\_notifyFatalExceptionCaptured(false);
    KSCrash\_MonitorContext\* crashContext = &amp;g\_monitorContext;
    memset(crashContext, 0, sizeof(\*crashContext));

    char descriptionBuff\[DESCRIPTION\_BUFFER\_LENGTH\];
    const char\* description = descriptionBuff;
    descriptionBuff\[0\] = 0;

    KSLOG\_DEBUG(&quot;Discovering what kind of exception was thrown.&quot;);
    g\_captureNextStackTrace = false;
    try
    &#123;
        throw;
    &#125;
    catch(std::exception&amp; exc)
    &#123;
        strncpy(descriptionBuff, exc.what(), sizeof(descriptionBuff));
    &#125;</code></pre>
<p>#define CATCH_VALUE(TYPE, PRINTFTYPE) \<br>catch(TYPE value)\<br>{ \<br>    snprintf(descriptionBuff, sizeof(descriptionBuff), “%” #PRINTFTYPE, value); \<br>}<br>        CATCH_VALUE(char,                 d)<br>        CATCH_VALUE(short,                d)<br>        CATCH_VALUE(int,                  d)<br>        CATCH_VALUE(long,                ld)<br>        CATCH_VALUE(long long,          lld)<br>        CATCH_VALUE(unsigned char,        u)<br>        CATCH_VALUE(unsigned short,       u)<br>        CATCH_VALUE(unsigned int,         u)<br>        CATCH_VALUE(unsigned long,       lu)<br>        CATCH_VALUE(unsigned long long, llu)<br>        CATCH_VALUE(float,                f)<br>        CATCH_VALUE(double,               f)<br>        CATCH_VALUE(long double,         Lf)<br>        CATCH_VALUE(char*,                s)<br>        catch(…)<br>        {<br>            description = NULL;<br>        }<br>        g_captureNextStackTrace = g_isEnabled;</p>
<pre><code>    // TODO: Should this be done here? Maybe better in the exception handler?
    KSMC\_NEW\_CONTEXT(machineContext);
    ksmc\_getContextForThread(ksthread\_self(), machineContext, true);

    KSLOG\_DEBUG(&quot;Filling out context.&quot;);
    crashContext-&gt;crashType = KSCrashMonitorTypeCPPException;
    crashContext-&gt;eventID = g\_eventID;
    crashContext-&gt;registersAreValid = false;
    crashContext-&gt;stackCursor = &amp;g\_stackCursor;
    crashContext-&gt;CPPException.name = name;
    crashContext-&gt;exceptionName = name;
    crashContext-&gt;crashReason = description;
    crashContext-&gt;offendingMachineContext = machineContext;

    kscm\_handleException(crashContext);
&#125;
else
&#123;
    KSLOG\_DEBUG(&quot;Detected NSException. Letting the current NSException handler deal with it.&quot;);
&#125;
ksmc\_resumeEnvironment();

KSLOG\_DEBUG(&quot;Calling original terminate handler.&quot;);
g\_originalTerminateHandler();</code></pre>
<p>}</p>
<h4 id="2-4-Objective-C-异常处理"><a href="#2-4-Objective-C-异常处理" class="headerlink" title="2.4. Objective-C 异常处理"></a>2.4. Objective-C 异常处理</h4><p>对于 OC 层面的 NSException 异常处理较为容易，可以通过注册 <code>NSUncaughtExceptionHandler</code> 来捕获异常信息，通过 NSException 参数来做 Crash 信息的收集，交给数据上报组件。</p>
<p>static void setEnabled(bool isEnabled) {<br>    if(isEnabled != g_isEnabled)<br>    {<br>        g_isEnabled = isEnabled;<br>        if(isEnabled)<br>        {<br>            KSLOG_DEBUG(@”Backing up original handler.”);<br>            // 记录之前的 OC 异常处理函数<br>            g_previousUncaughtExceptionHandler = NSGetUncaughtExceptionHandler();</p>
<pre><code>        KSLOG\_DEBUG(@&quot;Setting new handler.&quot;);
        // 设置新的 OC 异常处理函数
        NSSetUncaughtExceptionHandler(&amp;handleException);
        KSCrash.sharedInstance.uncaughtExceptionHandler = &amp;handleException;
    &#125;
    else
    &#123;
        KSLOG\_DEBUG(@&quot;Restoring original handler.&quot;);
        NSSetUncaughtExceptionHandler(g\_previousUncaughtExceptionHandler);
    &#125;
&#125;</code></pre>
<p>}</p>
<h4 id="2-5-主线程死锁"><a href="#2-5-主线程死锁" class="headerlink" title="2.5. 主线程死锁"></a>2.5. 主线程死锁</h4><p>主线程死锁的检测和 ANR 的检测有些类似</p>
<ul>
<li><p>  创建一个线程，在线程运行方法中用 <code>do...while...</code> 循环处理逻辑，加了 autorelease 避免内存过高</p>
</li>
<li><p>有一个 <code>awaitingResponse</code> 属性和 <code>watchdogPulse</code> 方法。watchdogPulse 主要逻辑为设置 <code>awaitingResponse</code> 为 YES，切换到主线程中，设置 <code>awaitingResponse</code> 为 NO，</p>
<p>  - (void) watchdogPulse<br>  {</p>
<pre><code>  \_\_block id blockSelf = self;
  self.awaitingResponse = YES;
  dispatch\_async(dispatch\_get\_main\_queue(), ^
                 &#123;
                     \[blockSelf watchdogAnswer\];
                 &#125;);</code></pre>
<p>  }</p>
</li>
<li><p>线程的执行方法里面不断循环，等待设置的 <code>g_watchdogInterval</code> 后判断 <code>awaitingResponse</code> 的属性值是不是初始状态的值，否则判断为死锁</p>
<p>  - (void) runMonitor<br>  {</p>
<pre><code>  BOOL cancelled = NO;
  do
  &#123;
      // Only do a watchdog check if the watchdog interval is &gt; 0.
      // If the interval is &lt;= 0, just idle until the user changes it.
      @autoreleasepool &#123;
          NSTimeInterval sleepInterval = g\_watchdogInterval;
          BOOL runWatchdogCheck = sleepInterval &gt; 0;
          if(!runWatchdogCheck)
          &#123;
              sleepInterval = kIdleInterval;
          &#125;
          \[NSThread sleepForTimeInterval:sleepInterval\];
          cancelled = self.monitorThread.isCancelled;
          if(!cancelled &amp;&amp; runWatchdogCheck)
          &#123;
              if(self.awaitingResponse)
              &#123;
                  \[self handleDeadlock\];
              &#125;
              else
              &#123;
                  \[self watchdogPulse\];
              &#125;
          &#125;
      &#125;
  &#125; while (!cancelled);</code></pre>
<p>  }</p>
</li>
</ul>
<h4 id="2-6-Crash-的生成与保存"><a href="#2-6-Crash-的生成与保存" class="headerlink" title="2.6 Crash 的生成与保存"></a>2.6 Crash 的生成与保存</h4><h5 id="2-6-1-Crash-日志的生成逻辑"><a href="#2-6-1-Crash-日志的生成逻辑" class="headerlink" title="2.6.1 Crash 日志的生成逻辑"></a>2.6.1 Crash 日志的生成逻辑</h5><p>上面的部分讲过了 iOS 应用开发中的各种 crash 监控逻辑，接下来就应该分析下 crash 捕获后如何将 crash 信息记录下来，也就是保存到应用沙盒中。</p>
<p>拿主线程死锁这种 crash 举例子，看看 KSCrash 是如何记录 crash 信息的。</p>
<p>// KSCrashMonitor_Deadlock.m</p>
<ul>
<li><p>(void) handleDeadlock<br>{<br>  ksmc_suspendEnvironment();<br>  kscm_notifyFatalExceptionCaptured(false);</p>
<p>  KSMC_NEW_CONTEXT(machineContext);<br>  ksmc_getContextForThread(g_mainQueueThread, machineContext, false);<br>  KSStackCursor stackCursor;<br>  kssc_initWithMachineContext(&amp;stackCursor, 100, machineContext);<br>  char eventID[37];<br>  ksid_generate(eventID);</p>
<p>  KSLOG_DEBUG(@”Filling out context.”);<br>  KSCrash_MonitorContext* crashContext = &amp;g_monitorContext;<br>  memset(crashContext, 0, sizeof(*crashContext));<br>  crashContext-&gt;crashType = KSCrashMonitorTypeMainThreadDeadlock;<br>  crashContext-&gt;eventID = eventID;<br>  crashContext-&gt;registersAreValid = false;<br>  crashContext-&gt;offendingMachineContext = machineContext;<br>  crashContext-&gt;stackCursor = &stackCursor;</p>
<p>  kscm_handleException(crashContext);<br>  ksmc_resumeEnvironment();</p>
<p>  KSLOG_DEBUG(@”Calling abort()”);<br>  abort();<br>}</p>
</li>
</ul>
<p>其他几个 crash 也是一样，异常信息经过包装交给 <code>kscm_handleException()</code> 函数处理。可以看到这个函数被其他几种 crash 捕获后所调用。</p>
<p><img src="https://segmentfault.com/img/bVbIOkD"></p>
<p>/** Start general exception processing.<br> *<br> * @oaram context Contextual information about the exception.<br> */<br>void kscm_handleException(struct KSCrash_MonitorContext* context)<br>{<br>    context-&gt;requiresAsyncSafety = g_requiresAsyncSafety;<br>    if(g_crashedDuringExceptionHandling)<br>    {<br>        context-&gt;crashedDuringCrashHandling = true;<br>    }<br>    for(int i = 0; i &lt; g_monitorsCount; i++)<br>    {<br>        Monitor* monitor = &amp;g_monitors[i];<br>        // 判断当前的 crash 监控是开启状态<br>        if(isMonitorEnabled(monitor))<br>        {<br>            // 针对每种 crash 类型做一些额外的补充信息<br>            addContextualInfoToEvent(monitor, context);<br>        }<br>    }<br>    // 真正处理 crash 信息，保存 json 格式的 crash 信息<br>    g_onExceptionEvent(context);</p>
<pre><code>if(g\_handlingFatalException &amp;&amp; !g\_crashedDuringExceptionHandling)
&#123;
    KSLOG\_DEBUG(&quot;Exception is fatal. Restoring original handlers.&quot;);
    kscm\_setActiveMonitors(KSCrashMonitorTypeNone);
&#125;</code></pre>
<p>}</p>
<p><code>g_onExceptionEvent</code> 是一个 block，声明为 <code>static void (*g_onExceptionEvent)(struct KSCrash_MonitorContext* monitorContext);</code> 在 <code>KSCrashMonitor.c</code> 中被赋值</p>
<p>void kscm_setEventCallback(void (*onEvent)(struct KSCrash_MonitorContext* monitorContext))<br>{<br>    g_onExceptionEvent = onEvent;<br>}</p>
<p><code>kscm_setEventCallback()</code> 函数在 <code>KSCrashC.c</code> 文件中被调用</p>
<p>KSCrashMonitorType kscrash_install(const char* appName, const char* const installPath)<br>{<br>    KSLOG_DEBUG(“Installing crash reporter.”);</p>
<pre><code>if(g\_installed)
&#123;
    KSLOG\_DEBUG(&quot;Crash reporter already installed.&quot;);
    return g\_monitoring;
&#125;
g\_installed = 1;

char path\[KSFU\_MAX\_PATH\_LENGTH\];
snprintf(path, sizeof(path), &quot;%s/Reports&quot;, installPath);
ksfu\_makePath(path);
kscrs\_initialize(appName, path);

snprintf(path, sizeof(path), &quot;%s/Data&quot;, installPath);
ksfu\_makePath(path);
snprintf(path, sizeof(path), &quot;%s/Data/CrashState.json&quot;, installPath);
kscrashstate\_initialize(path);

snprintf(g\_consoleLogPath, sizeof(g\_consoleLogPath), &quot;%s/Data/ConsoleLog.txt&quot;, installPath);
if(g\_shouldPrintPreviousLog)
&#123;
    printPreviousLog(g\_consoleLogPath);
&#125;
kslog\_setLogFilename(g\_consoleLogPath, true);

ksccd\_init(60);
// 设置 crash 发生时的 callback 函数
kscm\_setEventCallback(onCrash);
KSCrashMonitorType monitors = kscrash\_setMonitoring(g\_monitoring);

KSLOG\_DEBUG(&quot;Installation complete.&quot;);
return monitors;</code></pre>
<p>}</p>
<p>/** Called when a crash occurs.<br> *<br> * This function gets passed as a callback to a crash handler.<br> */<br>static void onCrash(struct KSCrash_MonitorContext* monitorContext)<br>{<br>    KSLOG_DEBUG(“Updating application state to note crash.”);<br>    kscrashstate_notifyAppCrash();<br>    monitorContext-&gt;consoleLogPath = g_shouldAddConsoleLogToReport ? g_consoleLogPath : NULL;</p>
<pre><code>// 正在处理 crash 的时候，发生了再次 crash
if(monitorContext-&gt;crashedDuringCrashHandling)
&#123;
    kscrashreport\_writeRecrashReport(monitorContext, g\_lastCrashReportFilePath);
&#125;
else
&#123;
    // 1. 先根据当前时间创建新的 crash 的文件路径
    char crashReportFilePath\[KSFU\_MAX\_PATH\_LENGTH\];
    kscrs\_getNextCrashReportPath(crashReportFilePath);
    // 2. 将新生成的文件路径保存到 g\_lastCrashReportFilePath
    strncpy(g\_lastCrashReportFilePath, crashReportFilePath, sizeof(g\_lastCrashReportFilePath));
    // 3. 将新生成的文件路径传入函数进行 crash 写入
    kscrashreport\_writeStandardReport(monitorContext, crashReportFilePath);
&#125;</code></pre>
<p>}</p>
<p>接下来的函数就是具体的日志写入文件的实现。2个函数做的事情相似，都是格式化为 json 形式并写入文件。区别在于 crash 写入时如果再次发生 crash， 则走简易版的写入逻辑 <code>kscrashreport_writeRecrashReport()</code>，否则走标准的写入逻辑 <code>kscrashreport_writeStandardReport()</code>。</p>
<p>bool ksfu_openBufferedWriter(KSBufferedWriter* writer, const char* const path, char* writeBuffer, int writeBufferLength)<br>{<br>    writer-&gt;buffer = writeBuffer;<br>    writer-&gt;bufferLength = writeBufferLength;<br>    writer-&gt;position = 0;<br>    /*<br>     open() 的第二个参数描述的是文件操作的权限<br>     #define O_RDONLY        0x0000         open for reading only<br>     #define O_WRONLY        0x0001         open for writing only<br>     #define O_RDWR          0x0002         open for reading and writing<br>     #define O_ACCMODE       0x0003         mask for above mode</p>
<pre><code> #define O\_CREAT         0x0200         create if nonexistant
 #define O\_TRUNC         0x0400         truncate to zero length
 #define O\_EXCL          0x0800         error if already exists

 0755：即用户具有读/写/执行权限，组用户和其它用户具有读写权限；
 0644：即用户具有读写权限，组用户和其它用户具有只读权限；
 成功则返回文件描述符，若出现则返回 -1
 \*/
writer-&gt;fd = open(path, O\_RDWR | O\_CREAT | O\_EXCL, 0644);
if(writer-&gt;fd &lt; 0)
&#123;
    KSLOG\_ERROR(&quot;Could not open crash report file %s: %s&quot;, path, strerror(errno));
    return false;
&#125;
return true;</code></pre>
<p>}</p>
<p>/**<br> * Write a standard crash report to a file.<br> *<br> *  @param monitorContext Contextual information about the crash and environment.<br> *                      The caller must fill this out before passing it in.<br> *<br> *  @param path The file to write to.<br> */<br>void kscrashreport_writeStandardReport(const struct KSCrash_MonitorContext* const monitorContext,<br>                                       const char* path)<br>{<br>        KSLOG_INFO(“Writing crash report to %s”, path);<br>    char writeBuffer[1024];<br>    KSBufferedWriter bufferedWriter;</p>
<pre><code>if(!ksfu\_openBufferedWriter(&amp;bufferedWriter, path, writeBuffer, sizeof(writeBuffer)))
&#123;
    return;
&#125;

ksccd\_freeze();

KSJSONEncodeContext jsonContext;
jsonContext.userData = &amp;bufferedWriter;
KSCrashReportWriter concreteWriter;
KSCrashReportWriter\* writer = &amp;concreteWriter;
prepareReportWriter(writer, &amp;jsonContext);

ksjson\_beginEncode(getJsonContext(writer), true, addJSONData, &amp;bufferedWriter);

writer-&gt;beginObject(writer, KSCrashField\_Report);
&#123;
    writeReportInfo(writer,
                    KSCrashField\_Report,
                    KSCrashReportType\_Standard,
                    monitorContext-&gt;eventID,
                    monitorContext-&gt;System.processName);
    ksfu\_flushBufferedWriter(&amp;bufferedWriter);

    writeBinaryImages(writer, KSCrashField\_BinaryImages);
    ksfu\_flushBufferedWriter(&amp;bufferedWriter);

    writeProcessState(writer, KSCrashField\_ProcessState, monitorContext);
    ksfu\_flushBufferedWriter(&amp;bufferedWriter);

    writeSystemInfo(writer, KSCrashField\_System, monitorContext);
    ksfu\_flushBufferedWriter(&amp;bufferedWriter);

    writer-&gt;beginObject(writer, KSCrashField\_Crash);
    &#123;
        writeError(writer, KSCrashField\_Error, monitorContext);
        ksfu\_flushBufferedWriter(&amp;bufferedWriter);
        writeAllThreads(writer,
                        KSCrashField\_Threads,
                        monitorContext,
                        g\_introspectionRules.enabled);
        ksfu\_flushBufferedWriter(&amp;bufferedWriter);
    &#125;
    writer-&gt;endContainer(writer);

    if(g\_userInfoJSON != NULL)
    &#123;
        addJSONElement(writer, KSCrashField\_User, g\_userInfoJSON, false);
        ksfu\_flushBufferedWriter(&amp;bufferedWriter);
    &#125;
    else
    &#123;
        writer-&gt;beginObject(writer, KSCrashField\_User);
    &#125;
    if(g\_userSectionWriteCallback != NULL)
    &#123;
        ksfu\_flushBufferedWriter(&amp;bufferedWriter);
        g\_userSectionWriteCallback(writer);
    &#125;
    writer-&gt;endContainer(writer);
    ksfu\_flushBufferedWriter(&amp;bufferedWriter);

    writeDebugInfo(writer, KSCrashField\_Debug, monitorContext);
&#125;
writer-&gt;endContainer(writer);

ksjson\_endEncode(getJsonContext(writer));
ksfu\_closeBufferedWriter(&amp;bufferedWriter);
ksccd\_unfreeze();</code></pre>
<p>}</p>
<p>/** Write a minimal crash report to a file.<br> *<br> * @param monitorContext Contextual information about the crash and environment.<br> *                       The caller must fill this out before passing it in.<br> *<br> * @param path The file to write to.<br> */<br>void kscrashreport_writeRecrashReport(const struct KSCrash_MonitorContext* const monitorContext,<br>                                      const char* path)<br>{<br>  char writeBuffer[1024];<br>    KSBufferedWriter bufferedWriter;<br>    static char tempPath[KSFU_MAX_PATH_LENGTH];<br>    // 将传递过来的上份 crash report 文件名路径（/var/mobile/Containers/Data/Application/******/Library/Caches/KSCrash/Test/Reports/Test-report-******.json）修改为去掉 .json ，加上 .old 成为新的文件路径 /var/mobile/Containers/Data/Application/******/Library/Caches/KSCrash/Test/Reports/Test-report-******.old</p>
<pre><code>strncpy(tempPath, path, sizeof(tempPath) - 10);
strncpy(tempPath + strlen(tempPath) - 5, &quot;.old&quot;, 5);
KSLOG\_INFO(&quot;Writing recrash report to %s&quot;, path);

if(rename(path, tempPath) &lt; 0)
&#123;
    KSLOG\_ERROR(&quot;Could not rename %s to %s: %s&quot;, path, tempPath, strerror(errno));
&#125;
// 根据传入路径来打开内存写入需要的文件
if(!ksfu\_openBufferedWriter(&amp;bufferedWriter, path, writeBuffer, sizeof(writeBuffer)))
&#123;
    return;
&#125;

ksccd\_freeze();
// json 解析的 c 代码
KSJSONEncodeContext jsonContext;
jsonContext.userData = &amp;bufferedWriter;
KSCrashReportWriter concreteWriter;
KSCrashReportWriter\* writer = &amp;concreteWriter;
prepareReportWriter(writer, &amp;jsonContext);

ksjson\_beginEncode(getJsonContext(writer), true, addJSONData, &amp;bufferedWriter);

writer-&gt;beginObject(writer, KSCrashField\_Report);
&#123;
    writeRecrash(writer, KSCrashField\_RecrashReport, tempPath);
    ksfu\_flushBufferedWriter(&amp;bufferedWriter);
    if(remove(tempPath) &lt; 0)
    &#123;
        KSLOG\_ERROR(&quot;Could not remove %s: %s&quot;, tempPath, strerror(errno));
    &#125;
    writeReportInfo(writer,
                    KSCrashField\_Report,
                    KSCrashReportType\_Minimal,
                    monitorContext-&gt;eventID,
                    monitorContext-&gt;System.processName);
    ksfu\_flushBufferedWriter(&amp;bufferedWriter);

    writer-&gt;beginObject(writer, KSCrashField\_Crash);
    &#123;
        writeError(writer, KSCrashField\_Error, monitorContext);
        ksfu\_flushBufferedWriter(&amp;bufferedWriter);
        int threadIndex = ksmc\_indexOfThread(monitorContext-&gt;offendingMachineContext,
                                             ksmc\_getThreadFromContext(monitorContext-&gt;offendingMachineContext));
        writeThread(writer,
                    KSCrashField\_CrashedThread,
                    monitorContext,
                    monitorContext-&gt;offendingMachineContext,
                    threadIndex,
                    false);
        ksfu\_flushBufferedWriter(&amp;bufferedWriter);
    &#125;
    writer-&gt;endContainer(writer);
&#125;
writer-&gt;endContainer(writer);

ksjson\_endEncode(getJsonContext(writer));
ksfu\_closeBufferedWriter(&amp;bufferedWriter);
ksccd\_unfreeze();</code></pre>
<p>}</p>
<h5 id="2-6-2-Crash-日志的读取逻辑"><a href="#2-6-2-Crash-日志的读取逻辑" class="headerlink" title="2.6.2 Crash 日志的读取逻辑"></a>2.6.2 Crash 日志的读取逻辑</h5><p>当前 App 在 Crash 之后，KSCrash 将数据保存到 App 沙盒目录下，App 下次启动后我们读取存储的 crash 文件，然后处理数据并上传。</p>
<p>App 启动后函数调用：</p>
<p><code>[KSCrashInstallation sendAllReportsWithCompletion:]</code> -&gt; <code>[KSCrash sendAllReportsWithCompletion:]</code> -&gt; <code>[KSCrash allReports]</code> -&gt; <code>[KSCrash reportWithIntID:]</code> -&gt;<code>[KSCrash loadCrashReportJSONWithID:]</code> -&gt; <code>kscrs_readReport</code></p>
<p>在 <code>sendAllReportsWithCompletion</code> 里读取沙盒里的Crash 数据。</p>
<p>// 先通过读取文件夹，遍历文件夹内的文件数量来判断 crash 报告的个数<br>static int getReportCount()<br>{<br>    int count = 0;<br>    DIR* dir = opendir(g_reportsPath);<br>    if(dir == NULL)<br>    {<br>        KSLOG_ERROR(“Could not open directory %s”, g_reportsPath);<br>        goto done;<br>    }<br>    struct dirent* ent;<br>    while((ent = readdir(dir)) != NULL)<br>    {<br>        if(getReportIDFromFilename(ent-&gt;d_name) &gt; 0)<br>        {<br>            count++;<br>        }<br>    }</p>
<p>done:<br>    if(dir != NULL)<br>    {<br>        closedir(dir);<br>    }<br>    return count;<br>}</p>
<p>// 通过 crash 文件个数、文件夹信息去遍历，一次获取到文件名（文件名的最后一部分就是 reportID），拿到 reportID 再去读取 crash 报告内的文件内容，写入数组</p>
<ul>
<li><p>(NSArray*) allReports<br>{<br>  int reportCount = kscrash_getReportCount();<br>  int64_t reportIDs[reportCount];<br>  reportCount = kscrash_getReportIDs(reportIDs, reportCount);<br>  NSMutableArray* reports = [NSMutableArray arrayWithCapacity:(NSUInteger)reportCount];<br>  for(int i = 0; i &lt; reportCount; i++)<br>  {</p>
<pre><code>  NSDictionary\* report = \[self reportWithIntID:reportIDs\[i\]\];
  if(report != nil)
  &#123;
      \[reports addObject:report\];
  &#125;</code></pre>
<p>  }</p>
<p>  return reports;<br>}</p>
</li>
</ul>
<p>//  根据 reportID 找到 crash 信息</p>
<ul>
<li><p>(NSDictionary*) reportWithIntID:(int64_t) reportID<br>{<br>  NSData* jsonData = [self loadCrashReportJSONWithID:reportID];<br>  if(jsonData == nil)<br>  {</p>
<pre><code>  return nil;</code></pre>
<p>  }</p>
<p>  NSError* error = nil;<br>  NSMutableDictionary* crashReport = [KSJSONCodec decode:jsonData</p>
<pre><code>                                             options:KSJSONDecodeOptionIgnoreNullInArray |
                                                     KSJSONDecodeOptionIgnoreNullInObject |
                                                     KSJSONDecodeOptionKeepPartialObject
                                               error:&amp;error\];</code></pre>
<p>  if(error != nil)<br>  {</p>
<pre><code>  KSLOG\_ERROR(@&quot;Encountered error loading crash report %&quot; PRIx64 &quot;: %@&quot;, reportID, error);</code></pre>
<p>  }<br>  if(crashReport == nil)<br>  {</p>
<pre><code>  KSLOG\_ERROR(@&quot;Could not load crash report&quot;);
  return nil;</code></pre>
<p>  }<br>  [self doctorReport:crashReport];</p>
<p>  return crashReport;<br>}</p>
</li>
</ul>
<p>//  reportID 读取 crash 内容并转换为 NSData 类型</p>
<ul>
<li>(NSData*) loadCrashReportJSONWithID:(int64_t) reportID<br>{<br>  char* report = kscrash_readReport(reportID);<br>  if(report != NULL)<br>  {<pre><code>  return \[NSData dataWithBytesNoCopy:report length:strlen(report) freeWhenDone:YES\];</code></pre>
  }<br>  return nil;<br>}</li>
</ul>
<p>// reportID 读取 crash 数据到 char 类型<br>char* kscrash_readReport(int64_t reportID)<br>{<br>    if(reportID &lt;= 0)<br>    {<br>        KSLOG_ERROR(“Report ID was %” PRIx64, reportID);<br>        return NULL;<br>    }</p>
<pre><code>char\* rawReport = kscrs\_readReport(reportID);
if(rawReport == NULL)
&#123;
    KSLOG\_ERROR(&quot;Failed to load report ID %&quot; PRIx64, reportID);
    return NULL;
&#125;

char\* fixedReport = kscrf\_fixupCrashReport(rawReport);
if(fixedReport == NULL)
&#123;
    KSLOG\_ERROR(&quot;Failed to fixup report ID %&quot; PRIx64, reportID);
&#125;

free(rawReport);
return fixedReport;</code></pre>
<p>}</p>
<p>// 多线程加锁，通过 reportID 执行 c 函数 getCrashReportPathByID，将路径设置到 path 上。然后执行 ksfu_readEntireFile 读取 crash 信息到 result<br>char* kscrs_readReport(int64_t reportID)<br>{<br>    pthread_mutex_lock(&amp;g_mutex);<br>    char path[KSCRS_MAX_PATH_LENGTH];<br>    getCrashReportPathByID(reportID, path);<br>    char* result;<br>    ksfu_readEntireFile(path, &amp;result, NULL, 2000000);<br>    pthread_mutex_unlock(&amp;g_mutex);<br>    return result;<br>}</p>
<p>int kscrash_getReportIDs(int64_t* reportIDs, int count)<br>{<br>    return kscrs_getReportIDs(reportIDs, count);<br>}</p>
<p>int kscrs_getReportIDs(int64_t* reportIDs, int count)<br>{<br>    pthread_mutex_lock(&amp;g_mutex);<br>    count = getReportIDs(reportIDs, count);<br>    pthread_mutex_unlock(&amp;g_mutex);<br>    return count;<br>}<br>// 循环读取文件夹内容，根据 ent-&gt;d_name 调用 getReportIDFromFilename 函数，来获取 reportID，循环内部填充数组<br>static int getReportIDs(int64_t* reportIDs, int count)<br>{<br>    int index = 0;<br>    DIR* dir = opendir(g_reportsPath);<br>    if(dir == NULL)<br>    {<br>        KSLOG_ERROR(“Could not open directory %s”, g_reportsPath);<br>        goto done;<br>    }</p>
<pre><code>struct dirent\* ent;
while((ent = readdir(dir)) != NULL &amp;&amp; index &lt; count)
&#123;
    int64\_t reportID = getReportIDFromFilename(ent-&gt;d\_name);
    if(reportID &gt; 0)
    &#123;
        reportIDs\[index++\] = reportID;
    &#125;
&#125;

qsort(reportIDs, (unsigned)count, sizeof(reportIDs\[0\]), compareInt64);</code></pre>
<p>done:<br>    if(dir != NULL)<br>    {<br>        closedir(dir);<br>    }<br>    return index;<br>}</p>
<p>// sprintf(参数1， 格式2) 函数将格式2的值返回到参数1上，然后执行 sscanf(参数1， 参数2， 参数3)，函数将字符串参数1的内容，按照参数2的格式，写入到参数3上。crash 文件命名为 “App名称-report-reportID.json”<br>static int64_t getReportIDFromFilename(const char* filename)<br>{<br>    char scanFormat[100];<br>    sprintf(scanFormat, “%s-report-%%” PRIx64 “.json”, g_appName);</p>
<pre><code>int64\_t reportID = 0;
sscanf(filename, scanFormat, &amp;reportID);
return reportID;</code></pre>
<p>}</p>
<p><img src="https://segmentfault.com/img/bVbIOkN"></p>
<h4 id="2-7-前端-js-相关的-Crash-的监控"><a href="#2-7-前端-js-相关的-Crash-的监控" class="headerlink" title="2.7 前端 js 相关的 Crash 的监控"></a>2.7 前端 js 相关的 Crash 的监控</h4><h5 id="2-7-1-JavascriptCore-异常监控"><a href="#2-7-1-JavascriptCore-异常监控" class="headerlink" title="2.7.1 JavascriptCore 异常监控"></a>2.7.1 JavascriptCore 异常监控</h5><p>这部分简单粗暴，直接通过 JSContext 对象的 exceptionHandler 属性来监控，比如下面的代码</p>
<p>jsContext.exceptionHandler = ^(JSContext *context, JSValue *exception) {<br>    // 处理 jscore 相关的异常信息<br>};</p>
<h5 id="2-7-2-h5-页面异常监控"><a href="#2-7-2-h5-页面异常监控" class="headerlink" title="2.7.2 h5 页面异常监控"></a>2.7.2 h5 页面异常监控</h5><p>当 h5 页面内的 Javascript 运行异常时会 window 对象会触发 <code>ErrorEvent</code> 接口的 error 事件，并执行 <code>window.onerror()</code>。</p>
<p>window.onerror = function (msg, url, lineNumber, columnNumber, error) {<br>   // 处理异常信息<br>};</p>
<p><img src="https://segmentfault.com/img/bVbIOkO"></p>
<h5 id="2-7-3-React-Native-异常监控"><a href="#2-7-3-React-Native-异常监控" class="headerlink" title="2.7.3 React Native 异常监控"></a>2.7.3 React Native 异常监控</h5><p>小实验：下图是写了一个 RN Demo 工程，在 Debug Text 控件上加了事件监听代码，内部人为触发 crash</p>
<p>&lt;Text style={styles.sectionTitle} onPress={()=&gt;{1+qw;}}&gt;Debug&lt;/Text&gt;</p>
<p>对比组1：</p>
<p>条件： iOS 项目 debug 模式。在 RN 端增加了异常处理的代码。</p>
<p>模拟器点击 <code>command + d</code> 调出面板，选择 Debug，打开 Chrome 浏览器， Mac 下快捷键 <code>Command + Option + J</code> 打开调试面板，就可以像调试 React 一样调试 RN 代码了。</p>
<p>查看到 crash stack 后点击可以跳转到 sourceMap 的地方。</p>
<p>Tips：RN 项目打 Release 包</p>
<ul>
<li><p>  在项目根目录下创建文件夹（ release_iOS），作为资源的输出文件夹</p>
</li>
<li><p>在终端切换到工程目录，然后执行下面的代码</p>
<p>  react-native bundle –entry-file index.js –platform ios –dev false –bundle-output release_ios/main.jsbundle –assets-dest release_iOS –sourcemap-output release_ios/index.ios.map;</p>
</li>
<li><p>  将 release_iOS 文件夹内的 <code>.jsbundle</code> 和 <code>assets</code> 文件夹内容拖入到 iOS 工程中即可</p>
</li>
</ul>
<p>对比组2：</p>
<p>条件：iOS 项目 release 模式。在 RN 端不增加异常处理代码</p>
<p>操作：运行 iOS 工程，点击按钮模拟 crash</p>
<p>现象：iOS 项目奔溃。截图以及日志如下</p>
<p><img src="https://segmentfault.com/img/bVbIOkX"></p>
<p>2020-06-22 22:26:03.318 [info][tid:main][RCTRootView.m:294] Running application todos ({<br>    initialProps =     {<br>    };<br>    rootTag = 1;<br>})<br>2020-06-22 22:26:03.490 [info][tid:com.facebook.react.JavaScript] Running “todos” with {“rootTag”:1,”initialProps”:{}}<br>2020-06-22 22:27:38.673 [error][tid:com.facebook.react.JavaScript] ReferenceError: Can’t find variable: qw<br>2020-06-22 22:27:38.675 [fatal][tid:com.facebook.react.ExceptionsManagerQueue] Unhandled JS Exception: ReferenceError: Can’t find variable: qw<br>2020-06-22 22:27:38.691300+0800 todos[16790:314161] *** Terminating app due to uncaught exception ‘RCTFatalException: Unhandled JS Exception: ReferenceError: Can’t find variable: qw’, reason: ‘Unhandled JS Exception: ReferenceError: Can’t find variable: qw, stack:<br>onPress@397:1821<br><unknown>@203:3896<br>_performSideEffectsForTransition@210:9689<br>_performSideEffectsForTransition@(null):(null)<br>_receiveSignal@210:8425<br>_receiveSignal@(null):(null)<br>touchableHandleResponderRelease@210:5671<br>touchableHandleResponderRelease@(null):(null)<br>onResponderRelease@203:3006<br>b@97:1125<br>S@97:1268<br>w@97:1322<br>R@97:1617<br>M@97:2401<br>forEach@(null):(null)<br>U@97:2201<br><unknown>@97:13818<br>Pe@97:90199<br>Re@97:13478<br>Ie@97:13664<br>receiveTouches@97:14448<br>value@27:3544<br><unknown>@27:840<br>value@27:2798<br>value@27:812<br>value@(null):(null)<br>‘<br>*** First throw call stack:<br>(<br>    0   CoreFoundation                      0x00007fff23e3cf0e __exceptionPreprocess + 350<br>    1   libobjc.A.dylib                     0x00007fff50ba89b2 objc_exception_throw + 48<br>    2   todos                               0x00000001017b0510 RCTFormatError + 0<br>    3   todos                               0x000000010182d8ca -[RCTExceptionsManager reportFatal:stack:exceptionId:suppressRedBox:] + 503<br>    4   todos                               0x000000010182e34e -[RCTExceptionsManager reportException:] + 1658<br>    5   CoreFoundation                      0x00007fff23e43e8c __invoking___ + 140<br>    6   CoreFoundation                      0x00007fff23e41071 -[NSInvocation invoke] + 321<br>    7   CoreFoundation                      0x00007fff23e41344 -[NSInvocation invokeWithTarget:] + 68<br>    8   todos                               0x00000001017e07fa -[RCTModuleMethod invokeWithBridge:module:arguments:] + 578<br>    9   todos                               0x00000001017e2a84 _ZN8facebook5reactL11invokeInnerEP9RCTBridgeP13RCTModuleDatajRKN5folly7dynamicE + 246<br>    10  todos                               0x00000001017e280c ___ZN8facebook5react15RCTNativeModule6invokeEjON5folly7dynamicEi_block_invoke + 78<br>    11  libdispatch.dylib                   0x00000001025b5f11 _dispatch_call_block_and_release + 12<br>    12  libdispatch.dylib                   0x00000001025b6e8e _dispatch_client_callout + 8<br>    13  libdispatch.dylib                   0x00000001025bd6fd _dispatch_lane_serial_drain + 788<br>    14  libdispatch.dylib                   0x00000001025be28f _dispatch_lane_invoke + 422<br>    15  libdispatch.dylib                   0x00000001025c9b65 _dispatch_workloop_worker_thread + 719<br>    16  libsystem_pthread.dylib             0x00007fff51c08a3d _pthread_wqthread + 290<br>    17  libsystem_pthread.dylib             0x00007fff51c07b77 start_wqthread + 15<br>)<br>libc++abi.dylib: terminating with uncaught exception of type NSException<br>(lldb) </p>
<p>Tips：如何在 RN release 模式下调试（看到 js 侧的 console 信息）</p>
<ul>
<li>  在 <code>AppDelegate.m</code> 中引入 <code>#import &lt;React/RCTLog.h&gt;</code></li>
<li>  在 <code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code> 中加入 <code>RCTSetLogThreshold(RCTLogLevelTrace);</code></li>
</ul>
<p>对比组3：</p>
<p>条件：iOS 项目 release 模式。在 RN 端增加异常处理代码。</p>
<p>global.ErrorUtils.setGlobalHandler((e) =&gt; {<br>  console.log(e);<br>  let message = { name: e.name,<br>                message: e.message,<br>                stack: e.stack<br>  };<br>  axios.get(‘<a target="_blank" rel="noopener" href="http://192.168.1.100:8888/test.php&#39;">http://192.168.1.100:8888/test.php&#39;</a>, {<br>      params: { ‘message’: JSON.stringify(message) }<br>  }).then(function (response) {<br>          console.log(response)<br>  }).catch(function (error) {<br>  console.log(error)<br>  });<br>}, true)</p>
<p>操作：运行 iOS 工程，点击按钮模拟 crash。</p>
<p>现象：iOS 项目不奔溃。日志信息如下，对比 bundle 包中的 js。</p>
<p><img src="https://segmentfault.com/img/bVbIOk9"></p>
<p>结论：</p>
<p>在 RN 项目中，如果发生了 crash 则会在 Native 侧有相应体现。如果 RN 侧写了 crash 捕获的代码，则 Native 侧不会奔溃。如果 RN 侧的 crash 没有捕获，则 Native 直接奔溃。</p>
<p>RN 项目写了 crash 监控，监控后将堆栈信息打印出来发现对应的 js 信息是经过 webpack 处理的，crash 分析难度很大。所以我们针对 RN 的 crash 需要在 RN 侧写监控代码，监控后需要上报，此外针对监控后的信息需要写专门的 crash 信息还原给你，也就是 sourceMap 解析。</p>
<h6 id="2-7-3-1-js-逻辑错误"><a href="#2-7-3-1-js-逻辑错误" class="headerlink" title="2.7.3.1 js 逻辑错误"></a>2.7.3.1 js 逻辑错误</h6><p>写过 RN 的人都知道在 DEBUG 模式下 js 代码有问题则会产生红屏，在 RELEASE 模式下则会白屏或者闪退，为了体验和质量把控需要做异常监控。</p>
<p>在看 RN 源码时候发现了 <code>ErrorUtils</code>，看代码可以设置处理错误信息。</p>
<p>/**<br> * Copyright (c) Facebook, Inc. and its affiliates.<br> *<br> * This source code is licensed under the MIT license found in the<br> * LICENSE file in the root directory of this source tree.<br> *<br> * @format<br> * @flow strict<br> * @polyfill<br> */</p>
<p>let _inGuard = 0;</p>
<p>type ErrorHandler = (error: mixed, isFatal: boolean) =&gt; void;<br>type Fn&lt;Args, Return&gt; = (…Args) =&gt; Return;</p>
<p>/**<br> * This is the error handler that is called when we encounter an exception<br> * when loading a module. This will report any errors encountered before<br> * ExceptionsManager is configured.<br> */<br>let _globalHandler: ErrorHandler = function onError( e: mixed,<br>  isFatal: boolean, ) {<br>  throw e;<br>};</p>
<p>/**<br> * The particular require runtime that we are using looks for a global<br> * `ErrorUtils` object and if it exists, then it requires modules with the<br> * error handler specified via ErrorUtils.setGlobalHandler by calling the<br> * require function with applyWithGuard. Since the require module is loaded<br> * before any of the modules, this ErrorUtils must be defined (and the handler<br> * set) globally before requiring anything.<br> */<br>const ErrorUtils = {<br>  setGlobalHandler(fun: ErrorHandler): void {<br>    _globalHandler = fun;<br>  },<br>  getGlobalHandler(): ErrorHandler {<br>    return _globalHandler;<br>  },<br>  reportError(error: mixed): void {<br>    _globalHandler &amp;&amp; _globalHandler(error, false);<br>  },<br>  reportFatalError(error: mixed): void {<br>    // NOTE: This has an untyped call site in Metro.<br>    _globalHandler &amp;&amp; _globalHandler(error, true);<br>  },<br>  applyWithGuard&lt;TArgs: $ReadOnlyArray<mixed>, TOut&gt;(<br>    fun: Fn&lt;TArgs, TOut&gt;,<br>    context?: ?mixed,<br>    args?: ?TArgs,<br>    // Unused, but some code synced from www sets it to null.<br>    unused_onError?: null,<br>    // Some callers pass a name here, which we ignore.<br>    unused_name?: ?string,<br>  ): ?TOut {<br>    try {<br>      _inGuard++;<br>      // $FlowFixMe: TODO T48204745 (1) apply(context, null) is fine. (2) array -&gt; rest array should work<br>      return fun.apply(context, args);<br>    } catch (e) {<br>      ErrorUtils.reportError(e);<br>    } finally {<br>      _inGuard–;<br>    }<br>    return null;<br>  },<br>  applyWithGuardIfNeeded&lt;TArgs: $ReadOnlyArray<mixed>, TOut&gt;(<br>    fun: Fn&lt;TArgs, TOut&gt;,<br>    context?: ?mixed,<br>    args?: ?TArgs,<br>  ): ?TOut {<br>    if (ErrorUtils.inGuard()) {<br>      // $FlowFixMe: TODO T48204745 (1) apply(context, null) is fine. (2) array -&gt; rest array should work<br>      return fun.apply(context, args);<br>    } else {<br>      ErrorUtils.applyWithGuard(fun, context, args);<br>    }<br>    return null;<br>  },<br>  inGuard(): boolean {<br>    return !!_inGuard;<br>  },<br>  guard&lt;TArgs: $ReadOnlyArray<mixed>, TOut&gt;(<br>    fun: Fn&lt;TArgs, TOut&gt;,<br>    name?: ?string,<br>    context?: ?mixed,<br>  ): ?(…TArgs) =&gt; ?TOut {<br>    // TODO: (moti) T48204753 Make sure this warning is never hit and remove it - types<br>    // should be sufficient.<br>    if (typeof fun !== ‘function’) {<br>      console.warn(‘A function must be passed to ErrorUtils.guard, got ‘, fun);<br>      return null;<br>    }<br>    const guardName = name ?? fun.name ?? ‘<generated guard>‘;<br>    function guarded(…args: TArgs): ?TOut {<br>      return ErrorUtils.applyWithGuard(<br>        fun,<br>        context ?? this,<br>        args,<br>        null,<br>        guardName,<br>      );<br>    }</p>
<pre><code>return guarded;</code></pre>
<p>  },<br>};</p>
<p>global.ErrorUtils = ErrorUtils;</p>
<p>export type ErrorUtilsT = typeof ErrorUtils;</p>
<p>所以 RN 的异常可以使用 <code>global.ErrorUtils</code> 来设置错误处理。举个例子</p>
<p>global.ErrorUtils.setGlobalHandler(e =&gt; {<br>   // e.name e.message e.stack<br>}, true);</p>
<h6 id="2-7-3-2-组件问题"><a href="#2-7-3-2-组件问题" class="headerlink" title="2.7.3.2 组件问题"></a>2.7.3.2 组件问题</h6><p>其实对于 RN 的 crash 处理还有个需要注意的就是 <strong>React Error Boundaries</strong>。<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=pryYiUIXt6rDMGiBW9JdrA==.m0P9N0YFY2i5YfbUeQ3tNbz+v2HXBviSU/EGkeGwkl7Fc1Aj96LYcBtAFcW4WJbnHu/Rjtl+A+CX/DLsjgJCAw==">详细资料</a></p>
<blockquote>
<p>过去，组件内的 JavaScript 错误会导致 React 的内部状态被破坏，并且在下一次渲染时 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=+LL4iGAJU9MD0cUXcZy1VA==.2F/oGJUCX0ff9hXmb2uYfiOBp8YAXVdK2oHwA1wPhCIo/Xas7UOC6IoywXqhn9EG">产生</a> <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=7dOxkzsfnRZKbyVDhQABvw==.3rdyWD6oNR35X8Plfr1hv4kEcLcD9nB7/USWO4ck9QCl2eyv0i5RuSPqmFesUTgV">可能无法追踪的</a> <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=j4GzfPPN8psI9QIBipaswA==.foxVhlbMGnly4jHG/uBHeYEQ/j8DTTnrqzGyzMQJcQeWcBwyuNjZaEOVJU8ylyqv">错误</a>。这些错误基本上是由较早的其他代码（非 React 组件代码）错误引起的，但 React 并没有提供一种在组件中优雅处理这些错误的方式，也无法从错误中恢复。</p>
<p>部分 UI 的 JavaScript 错误不应该导致整个应用崩溃，为了解决这个问题，React 16 引入了一个新的概念 —— 错误边界。</p>
<p>错误边界是一种 React 组件，这种组件<strong>可以捕获并打印发生在其子组件树任何位置的 JavaScript 错误，并且，它会渲染出备用 UI</strong>，而不是渲染那些崩溃了的子组件树。错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误。</p>
</blockquote>
<p>它能捕获子组件生命周期函数中的异常，包括构造函数（constructor）和 render 函数</p>
<p>而不能捕获以下异常：</p>
<ul>
<li>  Event handlers（事件处理函数）</li>
<li>  Asynchronous code（异步代码，如setTimeout、promise等）</li>
<li>  Server side rendering（服务端渲染）</li>
<li>  Errors thrown in the error boundary itself (rather than its children)（异常边界组件本身抛出的异常）</li>
</ul>
<p>所以可以通过异常边界组件捕获组件生命周期内的所有异常然后渲染兜底组件 ，防止 App crash，提高用户体验。也可引导用户反馈问题，方便问题的排查和修复</p>
<p>至此 RN 的 crash 分为2种，分别是 js 逻辑错误、组件 js 错误，都已经被监控处理了。接下来就看看如何从工程化层面解决这些问题</p>
<h5 id="2-7-4-RN-Crash-还原"><a href="#2-7-4-RN-Crash-还原" class="headerlink" title="2.7.4 RN Crash 还原"></a>2.7.4 RN Crash 还原</h5><p>SourceMap 文件对于前端日志的解析至关重要，SourceMap 文件中各个参数和如何计算的步骤都在里面有写，可以查看<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=lqiIX9uf0T1epu78J0gMgw==.pFeUKkKaFchytJc+k6N9CiVIXf+Zzdo/IXobGvd9lG9/BsxgN/VLg2E8JDIHq5RaxvB9mG4FtsbHKdGuvlcx5aHf52FIeYmsLA0QJeBQG3WdAjdo8ozUy257Y33FfaDk">这篇文章</a>。</p>
<p>有了 SourceMap 文件，借助于 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=xxCynZ245I7o4l2TUjBHjA==.6aGTndpktKHB4Vx3d8dlszqp+ujJC8og3LAhDdL0c7s=">mozilla</a> 的 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=+gvuXOyReT1RLpCGgzsiqQ==.GgVByZjqibYalVB7iwMXK5MHsJbVAU/d+GeQlMviGFlM1ytvmQeMtU2G0EcmEC+E">source-map</a> 项目，可以很好的还原 RN 的 crash 日志。</p>
<p>我写了个 NodeJS 脚本，代码如下</p>
<p>var fs = require(‘fs’);<br>var sourceMap = require(‘source-map’);<br>var arguments = process.argv.splice(2);</p>
<p>function parseJSError(aLine, aColumn) {<br>    fs.readFile(‘./index.ios.map’, ‘utf8’, function (err, data) {<br>        const whatever =  sourceMap.SourceMapConsumer.with(data, null, consumer =&gt; {<br>            // 读取 crash 日志的行号、列号<br>            let parseData = consumer.originalPositionFor({<br>                line: parseInt(aLine),<br>                column: parseInt(aColumn)<br>            });<br>            // 输出到控制台<br>            console.log(parseData);<br>            // 输出到文件中<br>            fs.writeFileSync(‘./parsed.txt’, JSON.stringify(parseData) + ‘\n’, ‘utf8’, function(err) {<br>                if(err) {<br>                    console.log(err);<br>                }<br>            });<br>        });<br>    });<br>}</p>
<p>var line = arguments[0];<br>var column = arguments[1];<br>parseJSError(line, column);</p>
<p>接下来做个实验，还是上述的 todos 项目。</p>
<ol>
<li><p>在 Text 的点击事件上模拟 crash</p>
<p> &lt;Text style={styles.sectionTitle} onPress={()=&gt;{1+qw;}}&gt;Debug&lt;/Text&gt;</p>
</li>
<li><p>将 RN 项目打 bundle 包、产出 sourceMap 文件。执行命令,</p>
<p> react-native bundle –entry-file index.js –platform android –dev false –bundle-output release_ios/main.jsbundle –assets-dest release_iOS –sourcemap-output release_ios/index.android.map;</p>
</li>
</ol>
<p>因为高频使用，所以给 iterm2 增加 alias 别名设置，修改 <code>.zshrc</code> 文件</p>
<p>alias RNRelease=’react-native bundle –entry-file index.js –platform ios –dev false –bundle-output release_ios/main.jsbundle –assets-dest release_iOS –sourcemap-output release_ios/index.ios.map;’ # RN 打 Release 包</p>
<ol start="3">
<li><p> 将 js bundle 和图片资源拷贝到 Xcode 工程中</p>
</li>
<li><p>点击模拟 crash，将日志下面的行号和列号拷贝，在 Node 项目下，执行下面命令</p>
<p> node index.js 397 1822</p>
</li>
<li><p> 拿脚本解析好的行号、列号、文件信息去和源代码文件比较，结果很正确。</p>
</li>
</ol>
<p><img src="https://segmentfault.com/img/bVbIOlg"></p>
<h5 id="2-7-5-SourceMap-解析系统设计"><a href="#2-7-5-SourceMap-解析系统设计" class="headerlink" title="2.7.5 SourceMap 解析系统设计"></a>2.7.5 SourceMap 解析系统设计</h5><p>目的：通过平台可以将 RN 项目线上 crash 可以还原到具体的文件、代码行数、代码列数。可以看到具体的代码，可以看到 RN stack trace、提供源文件下载功能。</p>
<ol>
<li><p>打包系统下管理的服务器：</p>
<ul>
<li>  生产环境下打包才生成 source map 文件</li>
<li>  存储打包前的所有文件（install）</li>
</ul>
</li>
<li><p> 开发产品侧 RN 分析界面。点击收集到的 RN crash，在详情页可以看到具体的文件、代码行数、代码列数。可以看到具体的代码，可以看到 RN stack trace、Native stack trace。（具体技术实现上面讲过了）</p>
</li>
<li><p> 由于 souece map 文件较大，RN 解析过长虽然不久，但是是对计算资源的消耗，所以需要设计高效读取方式</p>
</li>
<li><p> SourceMap 在 iOS、Android 模式下不一样，所以 SoureceMap 存储需要区分 os。</p>
</li>
</ol>
<h3 id="3-KSCrash-的使用包装"><a href="#3-KSCrash-的使用包装" class="headerlink" title="3. KSCrash 的使用包装"></a>3. KSCrash 的使用包装</h3><p>然后再封装自己的 Crash 处理逻辑。比如要做的事情就是：</p>
<ul>
<li><p>继承自 KSCrashInstallation 这个抽象类，设置初始化工作（抽象类比如 NSURLProtocol 必须继承后使用），实现抽象类中的 <code>sink</code> 方法。</p>
<p>  /**<br>   * Crash system installation which handles backend-specific details.<br>   *<br>   * Only one installation can be installed at a time.<br>   *<br>   * This is an abstract class.<br>   */<br>  @interface KSCrashInstallation : NSObject</p>
</li>
</ul>
<p>#import “APMCrashInstallation.h”<br>#import &lt;KSCrash/KSCrashInstallation+Private.h&gt;<br>#import “APMCrashReporterSink.h”</p>
<p>@implementation APMCrashInstallation</p>
<ul>
<li>(instancetype)sharedInstance {<br>  static APMCrashInstallation *sharedInstance = nil;<br>  static dispatch_once_t onceToken;<br>  dispatch_once(&amp;onceToken, ^{<pre><code>  sharedInstance = \[\[APMCrashInstallation alloc\] init\];</code></pre>
  });<br>  return sharedInstance;<br>}</li>
</ul>
<ul>
<li><p>(id)init {<br>  return [super initWithRequiredProperties: nil];<br>}</p>
</li>
<li><p>(id<KSCrashReportFilter>)sink {<br>  APMCrashReporterSink *sink = [[APMCrashReporterSink alloc] init];<br>  return [sink defaultCrashReportFilterSetAppleFmt];<br>}</p>
</li>
</ul>
<p>@end</p>
<ul>
<li><p><code>sink</code> 方法内部的 <code>APMCrashReporterSink</code> 类，遵循了 <strong>KSCrashReportFilter</strong> 协议，声明了公有方法 <code>defaultCrashReportFilterSetAppleFmt</code></p>
<p>  // .h<br>  #import &lt;Foundation/Foundation.h&gt;<br>  #import &lt;KSCrash/KSCrashReportFilter.h&gt;</p>
<p>  @interface APMCrashReporterSink : NSObject&lt;KSCrashReportFilter&gt;</p>
<ul>
<li><p>(id <KSCrashReportFilter>) defaultCrashReportFilterSetAppleFmt;</p>
<p>@end</p>
<p>// .m<br>#pragma mark - public Method</p>
</li>
<li><p>(id <KSCrashReportFilter>) defaultCrashReportFilterSetAppleFmt<br>{<br>  return [KSCrashReportFilterPipeline filterWithFilters:</p>
<pre><code>      \[APMCrashReportFilterAppleFmt filterWithReportStyle:KSAppleReportStyleSymbolicatedSideBySide\],
      self,
      nil\];</code></pre>
<p>}</p>
</li>
</ul>
</li>
</ul>
<p>其中 <code>defaultCrashReportFilterSetAppleFmt</code> 方法内部返回了一个 <code>KSCrashReportFilterPipeline</code> 类方法 <code>filterWithFilters</code> 的结果。</p>
<p><code>APMCrashReportFilterAppleFmt</code> 是一个继承自 <code>KSCrashReportFilterAppleFmt</code> 的类，遵循了 <code>KSCrashReportFilter</code> 协议。协议方法允许开发者处理 Crash 的数据格式。</p>
<p>/** Filter the specified reports.<br> *<br> * @param reports The reports to process.<br> * @param onCompletion Block to call when processing is complete.<br> */</p>
<ul>
<li>(void) filterReports:(NSArray*) reports<pre><code>    onCompletion:(KSCrashReportFilterCompletion) onCompletion;</code></pre>
</li>
</ul>
<p>#import &lt;KSCrash/KSCrashReportFilterAppleFmt.h&gt;</p>
<p>@interface APMCrashReportFilterAppleFmt : KSCrashReportFilterAppleFmt&lt;KSCrashReportFilter&gt;</p>
<p>@end</p>
<p>// .m</p>
<ul>
<li>(void) filterReports:(NSArray*)reports onCompletion:(KSCrashReportFilterCompletion)onCompletion<br>{<br>  NSMutableArray* filteredReports = [NSMutableArray arrayWithCapacity:[reports count]];<br>  for(NSDictionary *report in reports){<pre><code>if(\[self majorVersion:report\] == kExpectedMajorVersion)&#123;
  id monitorInfo = \[self generateMonitorInfoFromCrashReport:report\];
  if(monitorInfo != nil)&#123;
    \[filteredReports addObject:monitorInfo\];
  &#125;
&#125;</code></pre>
  }<br>  kscrash_callCompletion(onCompletion, filteredReports, YES, nil);<br>}</li>
</ul>
<p>/**<br> @brief 获取Crash JSON中的crash时间、mach name、signal name和apple report<br> */</p>
<ul>
<li><p>(NSDictionary *)generateMonitorInfoFromCrashReport:(NSDictionary *)crashReport<br>{<br>  NSDictionary *infoReport = [crashReport objectForKey:@”report”];<br>  // …<br>  id appleReport = [self toAppleFormat:crashReport];</p>
<p>  NSMutableDictionary *info = [NSMutableDictionary dictionary];<br>  [info setValue:crashTime forKey:@”crashTime”];<br>  [info setValue:appleReport forKey:@”appleReport”];<br>  [info setValue:userException forKey:@”userException”];<br>  [info setValue:userInfo forKey:@”custom”];</p>
<p>  return [info copy];<br>}</p>
</li>
</ul>
<p>/**<br> * A pipeline of filters. Reports get passed through each subfilter in order.<br> *<br> * Input: Depends on what’s in the pipeline.<br> * Output: Depends on what’s in the pipeline.<br> */<br>@interface KSCrashReportFilterPipeline : NSObject &lt;KSCrashReportFilter&gt;</p>
<ul>
<li><p>APM 能力中为 Crash 模块设置一个启动器。启动器内部设置 KSCrash 的初始化工作，以及触发 Crash 时候监控所需数据的组装。比如：SESSION_ID、App 启动时间、App 名称、崩溃时间、App 版本号、当前页面信息等基础信息。</p>
<p>  /** C Function to call during a crash report to give the callee an opportunity to<br>   * add to the report. NULL = ignore.<br>   *<br>   * WARNING: Only call async-safe functions from this function! DO NOT call<br>   * Objective-C methods!!!<br>   */<br>  @property(atomic,readwrite,assign) KSReportWriteCallback onCrash;</p>
</li>
</ul>
<p>+ (instancetype)sharedInstance<br>{<br>    static APMCrashMonitor *_sharedManager = nil;<br>    static dispatch_once_t onceToken;<br>    dispatch_once(&amp;onceToken, ^{<br>        _sharedManager = [[APMCrashMonitor alloc] init];<br>    });<br>    return _sharedManager;<br>}</p>
<p>#pragma mark - public Method</p>
<ul>
<li>(void)startMonitor<br>{<br>  APMMLog(@”crash monitor started”);</li>
</ul>
<p>#ifdef DEBUG<br>    BOOL _trackingCrashOnDebug = [APMMonitorConfig sharedInstance].trackingCrashOnDebug;<br>    if (_trackingCrashOnDebug) {<br>        [self installKSCrash];<br>    }<br>#else<br>    [self installKSCrash];<br>#endif<br>}</p>
<p>#pragma mark - private method</p>
<p>static void onCrash(const KSCrashReportWriter* writer)<br>{<br>    NSString *sessionId = [NSString stringWithFormat:@”\“%@\“”, ***]];<br>    writer-&gt;addJSONElement(writer, “SESSION_ID”, [sessionId UTF8String], true);</p>
<pre><code>NSString \*appLaunchTime = \*\*\*;
writer-&gt;addJSONElement(writer, &quot;USER\_APP\_START\_DATE&quot;, \[\[NSString stringWithFormat:@&quot;\\&quot;%@\\&quot;&quot;, appLaunchTime\] UTF8String\], true);
// ...</code></pre>
<p>}</p>
<ul>
<li>(void)installKSCrash<br>{<br>  [[APMCrashInstallation sharedInstance] install];<br>  [[APMCrashInstallation sharedInstance] sendAllReportsWithCompletion:nil];<br>  [APMCrashInstallation sharedInstance].onCrash = onCrash;<br>  dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.f * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{<pre><code>  \_isCanAddCrashCount = NO;</code></pre>
  });<br>}</li>
</ul>
<p>在 <code>installKSCrash</code> 方法中调用了 <code>[[APMCrashInstallation sharedInstance] sendAllReportsWithCompletion: nil]</code>，内部实现如下</p>
<p>- (void) sendAllReportsWithCompletion:(KSCrashReportFilterCompletion) onCompletion<br>{<br>    NSError* error = [self validateProperties];<br>    if(error != nil)<br>    {<br>        if(onCompletion != nil)<br>        {<br>            onCompletion(nil, NO, error);<br>        }<br>        return;<br>    }</p>
<pre><code>id&lt;KSCrashReportFilter&gt; sink = \[self sink\];
if(sink == nil)
&#123;
    onCompletion(nil, NO, \[NSError errorWithDomain:\[\[self class\] description\]
                                              code:0
                                       description:@&quot;Sink was nil (subclasses must implement method \\&quot;sink\\&quot;)&quot;\]);
    return;
&#125;

sink = \[KSCrashReportFilterPipeline filterWithFilters:self.prependedFilters, sink, nil\];

KSCrash\* handler = \[KSCrash sharedInstance\];
handler.sink = sink;
\[handler sendAllReportsWithCompletion:onCompletion\];</code></pre>
<p>}</p>
<p>方法内部将 <code>KSCrashInstallation</code> 的 <code>sink</code> 赋值给 <code>KSCrash</code> 对象。 内部还是调用了 <code>KSCrash</code> 的 <code>sendAllReportsWithCompletion</code> 方法，实现如下</p>
<p>- (void) sendAllReportsWithCompletion:(KSCrashReportFilterCompletion) onCompletion<br>{<br>    NSArray* reports = [self allReports];</p>
<pre><code>KSLOG\_INFO(@&quot;Sending %d crash reports&quot;, \[reports count\]);

\[self sendReports:reports
     onCompletion:^(NSArray\* filteredReports, BOOL completed, NSError\* error)
 &#123;
     KSLOG\_DEBUG(@&quot;Process finished with completion: %d&quot;, completed);
     if(error != nil)
     &#123;
         KSLOG\_ERROR(@&quot;Failed to send reports: %@&quot;, error);
     &#125;
     if((self.deleteBehaviorAfterSendAll == KSCDeleteOnSucess &amp;&amp; completed) ||
        self.deleteBehaviorAfterSendAll == KSCDeleteAlways)
     &#123;
         kscrash\_deleteAllReports();
     &#125;
     kscrash\_callCompletion(onCompletion, filteredReports, completed, error);
 &#125;\];</code></pre>
<p>}</p>
<p>该方法内部调用了对象方法 <code>sendReports: onCompletion:</code>，如下所示</p>
<p>- (void) sendReports:(NSArray*) reports onCompletion:(KSCrashReportFilterCompletion) onCompletion<br>{<br>    if([reports count] == 0)<br>    {<br>        kscrash_callCompletion(onCompletion, reports, YES, nil);<br>        return;<br>    }</p>
<pre><code>if(self.sink == nil)
&#123;
    kscrash\_callCompletion(onCompletion, reports, NO,
                             \[NSError errorWithDomain:\[\[self class\] description\]
                                                 code:0
                                          description:@&quot;No sink set. Crash reports not sent.&quot;\]);
    return;
&#125;

\[self.sink filterReports:reports
            onCompletion:^(NSArray\* filteredReports, BOOL completed, NSError\* error)
 &#123;
     kscrash\_callCompletion(onCompletion, filteredReports, completed, error);
 &#125;\];</code></pre>
<p>}</p>
<p>方法内部的 <code>[self.sink filterReports: onCompletion: ]</code> 实现其实就是 <code>APMCrashInstallation</code> 中设置的 <code>sink</code> getter 方法，内部返回了 <code>APMCrashReporterSink</code> 对象的 <code>defaultCrashReportFilterSetAppleFmt</code> 方法的返回值。内部实现如下</p>
<p>- (id <KSCrashReportFilter>) defaultCrashReportFilterSetAppleFmt<br>{<br>    return [KSCrashReportFilterPipeline filterWithFilters:<br>            [APMCrashReportFilterAppleFmt filterWithReportStyle:KSAppleReportStyleSymbolicatedSideBySide],<br>            self,<br>            nil];<br>}</p>
<p>可以看到这个函数内部设置了多个 <strong>filters</strong>，其中一个就是 <strong>self</strong>，也就是 <code>APMCrashReporterSink</code> 对象，所以上面的 <code>[self.sink filterReports: onCompletion:]</code> ，也就是调用 <code>APMCrashReporterSink</code> 内的数据处理方法。完了之后通过 <code>kscrash_callCompletion(onCompletion, reports, YES, nil);</code> 告诉 <code>KSCrash</code> 本地保存的 Crash 日志已经处理完毕，可以删除了。</p>
<p>- (void)filterReports:(NSArray *)reports onCompletion:(KSCrashReportFilterCompletion)onCompletion<br>{<br>    for (NSDictionary *report in reports) {<br>        // 处理 Crash 数据，将数据交给统一的数据上报组件处理…<br>    }<br>    kscrash_callCompletion(onCompletion, reports, YES, nil);<br>}</p>
<p>至此，概括下 KSCrash 做的事情，提供各种 crash 的监控能力，在 crash 后将进程信息、基本信息、异常信息、线程信息等用 c 高效转换为 json 写入文件，App 下次启动后读取本地的 crash 文件夹中的 crash 日志，让开发者可以自定义 key、value 然后去上报日志到 APM 系统，然后删除本地 crash 文件夹中的日志。</p>
<h3 id="4-符号化"><a href="#4-符号化" class="headerlink" title="4. 符号化"></a>4. 符号化</h3><p>应用 crash 之后，系统会生成一份崩溃日志，存储在设置中，应用的运行状态、调用堆栈、所处线程等信息会记录在日志中。但是这些日志是地址，并不可读，所以需要进行符号化还原。</p>
<h4 id="4-1-DSYM-文件"><a href="#4-1-DSYM-文件" class="headerlink" title="4.1 .DSYM 文件"></a>4.1 .DSYM 文件</h4><p><code>.DSYM</code> （debugging symbol）文件是保存十六进制函数地址映射信息的中转文件，调试信息（symbols）都包含在该文件中。Xcode 工程每次编译运行都会生成新的 <code>.DSYM</code> 文���。默认情况下 debug 模式时不生成 <code>.DSYM</code> ，可以在 Build Settings -&gt; Build Options -&gt; Debug Information Format 后将值 <code>DWARF</code> 修改为 <code>DWARF with DSYM File</code>，这样再次编译运行就可以生成 <code>.DSYM</code> 文件。</p>
<p>所以每次 App 打包的时候都需要保存每个版本的 <code>.DSYM</code> 文件。</p>
<p><code>.DSYM</code> 文件中包含 DWARF 信息，打开文件的包内容 <code>Test.app.DSYM/Contents/Resources/DWARF/Test</code> 保存的就是 <code>DWARF</code> 文件。</p>
<p><code>.DSYM</code> 文件是从 Mach-O 文件中抽取调试信息而得到的文件目录，发布的时候为了安全，会把调试信息存储在单独的文件，<code>.DSYM</code> 其实是一个文件目录，结构如下：</p>
<p><img src="https://segmentfault.com/img/bVbIOlA"></p>
<h4 id="4-2-DWARF-文件"><a href="#4-2-DWARF-文件" class="headerlink" title="4.2 DWARF 文件"></a>4.2 DWARF 文件</h4><blockquote>
<p>DWARF is a debugging file format used by many compilers and debuggers to support source level debugging. It addresses the requirements of a number of procedural languages, such as C, C++, and Fortran, and is designed to be extensible to other languages. DWARF is architecture independent and applicable to any processor or operating system. It is widely used on Unix, Linux and other operating systems, as well as in stand-alone environments.</p>
</blockquote>
<p><strong>DWARF 是一种调试文件格式，它被许多编译器和调试器所广泛使用以支持源代码级别的调试</strong>。它满足许多过程语言（C、C++、Fortran）的需求，它被设计为支持拓展到其他语言。DWARF 是架构独立的，适用于其他任何的处理器和操作系统。被广泛使用在 Unix、Linux 和其他的操作系统上，以及独立环境上。</p>
<p>DWARF 全称是 Debugging With Arbitrary Record Formats，是一种使用属性化记录格式的调试文件。</p>
<p>DWARF 是可执行程序与源代码关系的一个紧凑表示。</p>
<p>大多数现代编程语言都是块结构：每个实体（一个类、一个函数）被包含在另一个实体中。一个 c 程序，每个文件可能包含多个数据定义、多个变量、多个函数，所以 DWARF 遵循这个模型，也是块结构。DWARF 里基本的描述项是调试信息项 DIE（Debugging Information Entry）。一个 DIE 有一个标签，表示这个 DIE 描述了什么以及一个填入了细节并进一步描述该项的属性列表（类比 html、xml 结构）。一个 DIE（除了最顶层的）被一个父 DIE 包含，可能存在兄弟 DIE 或者子 DIE，属性可能包含各种值：常量（比如一个函数名），变量（比如一个函数的起始地址），或对另一个DIE的引用（比如一个函数的返回值类型）。</p>
<p>DWARF 文件中的数据如下：</p>
<p>数据列</p>
<p>信息说明</p>
<p>.debug_loc</p>
<p>在 DW_AT_location 属性中使用的位置列表</p>
<p>.debug_macinfo</p>
<p>宏信息</p>
<p>.debug_pubnames</p>
<p>全局对象和函数的查找表</p>
<p>.debug_pubtypes</p>
<p>全局类型的查找表</p>
<p>.debug_ranges</p>
<p>在 DW_AT_ranges 属性中使用的地址范围</p>
<p>.debug_str</p>
<p>在 .debug_info 中使用的字符串表</p>
<p>.debug_types</p>
<p>类型描述</p>
<p>常用的标记与属性如下：</p>
<p>数据列</p>
<p>信息说明</p>
<p>DW_TAG_class_type</p>
<p>表示类名称和类型信息</p>
<p>DW_TAG_structure_type</p>
<p>表示结构名称和类型信息</p>
<p>DW_TAG_union_type</p>
<p>表示联合名称和类型信息</p>
<p>DW_TAG_enumeration_type</p>
<p>表示枚举名称和类型信息</p>
<p>DW_TAG_typedef</p>
<p>表示 typedef 的名称和类型信息</p>
<p>DW_TAG_array_type</p>
<p>表示数组名称和类型信息</p>
<p>DW_TAG_subrange_type</p>
<p>表示数组的大小信息</p>
<p>DW_TAG_inheritance</p>
<p>表示继承的类名称和类型信息</p>
<p>DW_TAG_member</p>
<p>表示类的成员</p>
<p>DW_TAG_subprogram</p>
<p>表示函数的名称信息</p>
<p>DW_TAG_formal_parameter</p>
<p>表示函数的参数信息</p>
<p>DW_TAG_name</p>
<p>表示名称字符串</p>
<p>DW_TAG_type</p>
<p>表示类型信息</p>
<p>DW_TAG_artifical</p>
<p>在创建时由编译程序设置</p>
<p>DW_TAG_sibling</p>
<p>表示兄弟位置信息</p>
<p>DW_TAG_data_memver_location</p>
<p>表示位置信息</p>
<p>DW_TAG_virtuality</p>
<p>在虚拟时设置</p>
<p>简单看一个 DWARF 的例子：将测试工程的 <code>.DSYM</code> 文件夹下的 DWARF 文件用下面命令解析</p>
<p>dwarfdump -F –debug-info Test.app.DSYM/Contents/Resources/DWARF/Test &gt; debug-info.txt</p>
<p>打开如下</p>
<p>Test.app.DSYM/Contents/Resources/DWARF/Test:    file format Mach-O arm64</p>
<p>.debug_info contents:<br>0x00000000: Compile Unit: length = 0x0000004f version = 0x0004 abbr_offset = 0x0000 addr_size = 0x08 (next unit at 0x00000053)</p>
<p>0x0000000b: DW_TAG_compile_unit<br>              DW_AT_producer [DW_FORM_strp]    (“Apple clang version 11.0.3 (clang-1103.0.32.62)”)<br>              DW_AT_language [DW_FORM_data2]    (DW_LANG_ObjC)<br>              DW_AT_name [DW_FORM_strp]    (“_Builtin_stddef_max_align_t”)<br>              DW_AT_stmt_list [DW_FORM_sec_offset]    (0x00000000)<br>              DW_AT_comp_dir [DW_FORM_strp]    (“/Users/lbp/Desktop/Test”)<br>              DW_AT_APPLE_major_runtime_vers [DW_FORM_data1]    (0x02)<br>              DW_AT_GNU_dwo_id [DW_FORM_data8]    (0x392b5344d415340c)</p>
<p>0x00000027:   DW_TAG_module<br>                DW_AT_name [DW_FORM_strp]    (“_Builtin_stddef_max_align_t”)<br>                DW_AT_LLVM_config_macros [DW_FORM_strp]    (“\“-DDEBUG=1\“ \“-DOBJC_OLD_DISPATCH_PROTOTYPES=1\“”)<br>                DW_AT_LLVM_include_path [DW_FORM_strp]    (“/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/11.0.3/include”)<br>                DW_AT_LLVM_isysroot [DW_FORM_strp]    (“/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk”)</p>
<p>0x00000038:     DW_TAG_typedef<br>                  DW_AT_type [DW_FORM_ref4]    (0x0000004b “long double”)<br>                  DW_AT_name [DW_FORM_strp]    (“max_align_t”)<br>                  DW_AT_decl_file [DW_FORM_data1]    (“/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/11.0.3/include/__stddef_max_align_t.h”)<br>                  DW_AT_decl_line [DW_FORM_data1]    (16)</p>
<p>0x00000043:     DW_TAG_imported_declaration<br>                  DW_AT_decl_file [DW_FORM_data1]    (“/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/11.0.3/include/__stddef_max_align_t.h”)<br>                  DW_AT_decl_line [DW_FORM_data1]    (27)<br>                  DW_AT_import [DW_FORM_ref_addr]    (0x0000000000000027)</p>
<p>0x0000004a:     NULL</p>
<p>0x0000004b:   DW_TAG_base_type<br>                DW_AT_name [DW_FORM_strp]    (“long double”)<br>                DW_AT_encoding [DW_FORM_data1]    (DW_ATE_float)<br>                DW_AT_byte_size [DW_FORM_data1]    (0x08)</p>
<p>0x00000052:   NULL<br>0x00000053: Compile Unit: length = 0x000183dc version = 0x0004 abbr_offset = 0x0000 addr_size = 0x08 (next unit at 0x00018433)</p>
<p>0x0000005e: DW_TAG_compile_unit<br>              DW_AT_producer [DW_FORM_strp]    (“Apple clang version 11.0.3 (clang-1103.0.32.62)”)<br>              DW_AT_language [DW_FORM_data2]    (DW_LANG_ObjC)<br>              DW_AT_name [DW_FORM_strp]    (“Darwin”)<br>              DW_AT_stmt_list [DW_FORM_sec_offset]    (0x000000a7)<br>              DW_AT_comp_dir [DW_FORM_strp]    (“/Users/lbp/Desktop/Test”)<br>              DW_AT_APPLE_major_runtime_vers [DW_FORM_data1]    (0x02)<br>              DW_AT_GNU_dwo_id [DW_FORM_data8]    (0xa4a1d339379e18a5)</p>
<p>0x0000007a:   DW_TAG_module<br>                DW_AT_name [DW_FORM_strp]    (“Darwin”)<br>                DW_AT_LLVM_config_macros [DW_FORM_strp]    (“\“-DDEBUG=1\“ \“-DOBJC_OLD_DISPATCH_PROTOTYPES=1\“”)<br>                DW_AT_LLVM_include_path [DW_FORM_strp]    (“/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include”)<br>                DW_AT_LLVM_isysroot [DW_FORM_strp]    (“/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk”)</p>
<p>0x0000008b:     DW_TAG_module<br>                  DW_AT_name [DW_FORM_strp]    (“C”)<br>                  DW_AT_LLVM_config_macros [DW_FORM_strp]    (“\“-DDEBUG=1\“ \“-DOBJC_OLD_DISPATCH_PROTOTYPES=1\“”)<br>                  DW_AT_LLVM_include_path [DW_FORM_strp]    (“/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include”)<br>                  DW_AT_LLVM_isysroot [DW_FORM_strp]    (“/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk”)</p>
<p>0x0000009c:       DW_TAG_module<br>                    DW_AT_name [DW_FORM_strp]    (“fenv”)<br>                    DW_AT_LLVM_config_macros [DW_FORM_strp]    (“\“-DDEBUG=1\“ \“-DOBJC_OLD_DISPATCH_PROTOTYPES=1\“”)<br>                    DW_AT_LLVM_include_path [DW_FORM_strp]    (“/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include”)<br>                    DW_AT_LLVM_isysroot [DW_FORM_strp]    (“/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk”)</p>
<p>0x000000ad:         DW_TAG_enumeration_type<br>                      DW_AT_type [DW_FORM_ref4]    (0x00017276 “unsigned int”)<br>                      DW_AT_byte_size [DW_FORM_data1]    (0x04)<br>                      DW_AT_decl_file [DW_FORM_data1]    (“/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/fenv.h”)<br>                      DW_AT_decl_line [DW_FORM_data1]    (154)</p>
<p>0x000000b5:           DW_TAG_enumerator<br>                        DW_AT_name [DW_FORM_strp]    (“__fpcr_trap_invalid”)<br>                        DW_AT_const_value [DW_FORM_udata]    (256)</p>
<p>0x000000bc:           DW_TAG_enumerator<br>                        DW_AT_name [DW_FORM_strp]    (“__fpcr_trap_divbyzero”)<br>                        DW_AT_const_value [DW_FORM_udata]    (512)</p>
<p>0x000000c3:           DW_TAG_enumerator<br>                        DW_AT_name [DW_FORM_strp]    (“__fpcr_trap_overflow”)<br>                        DW_AT_const_value [DW_FORM_udata]    (1024)</p>
<p>0x000000ca:           DW_TAG_enumerator<br>                        DW_AT_name [DW_FORM_strp]    (“__fpcr_trap_underflow”)<br>// ……<br>0x000466ee:   DW_TAG_subprogram<br>                DW_AT_name [DW_FORM_strp]    (“CFBridgingRetain”)<br>                DW_AT_decl_file [DW_FORM_data1]    (“/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/System/Library/Frameworks/Foundation.framework/Headers/NSObject.h”)<br>                DW_AT_decl_line [DW_FORM_data1]    (105)<br>                DW_AT_prototyped [DW_FORM_flag_present]    (true)<br>                DW_AT_type [DW_FORM_ref_addr]    (0x0000000000019155 “CFTypeRef”)<br>                DW_AT_inline [DW_FORM_data1]    (DW_INL_inlined)</p>
<p>0x000466fa:     DW_TAG_formal_parameter<br>                  DW_AT_name [DW_FORM_strp]    (“X”)<br>                  DW_AT_decl_file [DW_FORM_data1]    (“/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/System/Library/Frameworks/Foundation.framework/Headers/NSObject.h”)<br>                  DW_AT_decl_line [DW_FORM_data1]    (105)<br>                  DW_AT_type [DW_FORM_ref4]    (0x00046706 “id”)</p>
<p>0x00046705:     NULL</p>
<p>0x00046706:   DW_TAG_typedef<br>                DW_AT_type [DW_FORM_ref4]    (0x00046711 “objc_object*“)<br>                DW_AT_name [DW_FORM_strp]    (“id”)<br>                DW_AT_decl_file [DW_FORM_data1]    (“/Users/lbp/Desktop/Test/Test/NetworkAPM/NSURLResponse+apm_FetchStatusLineFromCFNetwork.m”)<br>                DW_AT_decl_line [DW_FORM_data1]    (44)</p>
<p>0x00046711:   DW_TAG_pointer_type<br>                DW_AT_type [DW_FORM_ref4]    (0x00046716 “objc_object”)</p>
<p>0x00046716:   DW_TAG_structure_type<br>                DW_AT_name [DW_FORM_strp]    (“objc_object”)<br>                DW_AT_byte_size [DW_FORM_data1]    (0x00)</p>
<p>0x0004671c:     DW_TAG_member<br>                  DW_AT_name [DW_FORM_strp]    (“isa”)<br>                  DW_AT_type [DW_FORM_ref4]    (0x00046727 “objc_class*“)<br>                  DW_AT_data_member_location [DW_FORM_data1]    (0x00)<br>// ……</p>
<p>这里就不粘贴全部内容了（太长了）。可以看到 DIE 包含了函数开始地址、结束地址、函数名、文件名、所在行数，对于给定的地址，找到函数开始地址、结束地址之间包含该地址的 DIE，则可以还原函数名和文件名信息。</p>
<p>debug_line 可以还原文件行数等信息</p>
<p>dwarfdump -F –debug-line Test.app.DSYM/Contents/Resources/DWARF/Test &gt; debug-inline.txt</p>
<p>贴部分信息</p>
<p>Test.app.DSYM/Contents/Resources/DWARF/Test:    file format Mach-O arm64</p>
<p>.debug_line contents:<br>debug_line[0x00000000]<br>Line table prologue:<br>    total_length: 0x000000a3<br>         version: 4<br> prologue_length: 0x0000009a<br> min_inst_length: 1<br>max_ops_per_inst: 1<br> default_is_stmt: 1<br>       line_base: -5<br>      line_range: 14<br>     opcode_base: 13<br>standard_opcode_lengths[DW_LNS_copy] = 0<br>standard_opcode_lengths[DW_LNS_advance_pc] = 1<br>standard_opcode_lengths[DW_LNS_advance_line] = 1<br>standard_opcode_lengths[DW_LNS_set_file] = 1<br>standard_opcode_lengths[DW_LNS_set_column] = 1<br>standard_opcode_lengths[DW_LNS_negate_stmt] = 0<br>standard_opcode_lengths[DW_LNS_set_basic_block] = 0<br>standard_opcode_lengths[DW_LNS_const_add_pc] = 0<br>standard_opcode_lengths[DW_LNS_fixed_advance_pc] = 1<br>standard_opcode_lengths[DW_LNS_set_prologue_end] = 0<br>standard_opcode_lengths[DW_LNS_set_epilogue_begin] = 0<br>standard_opcode_lengths[DW_LNS_set_isa] = 1<br>include_directories[  1] = “/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/11.0.3/include”<br>file_names[  1]:<br>           name: “__stddef_max_align_t.h”<br>      dir_index: 1<br>       mod_time: 0x00000000<br>         length: 0x00000000</p>
<p>Address            Line   Column File   ISA Discriminator Flags</p>
<hr>
<p>0x0000000000000000      1      0      1   0             0  is_stmt end_sequence<br>debug_line[0x000000a7]<br>Line table prologue:<br>    total_length: 0x0000230a<br>         version: 4<br> prologue_length: 0x00002301<br> min_inst_length: 1<br>max_ops_per_inst: 1<br> default_is_stmt: 1<br>       line_base: -5<br>      line_range: 14<br>     opcode_base: 13<br>standard_opcode_lengths[DW_LNS_copy] = 0<br>standard_opcode_lengths[DW_LNS_advance_pc] = 1<br>standard_opcode_lengths[DW_LNS_advance_line] = 1<br>standard_opcode_lengths[DW_LNS_set_file] = 1<br>standard_opcode_lengths[DW_LNS_set_column] = 1<br>standard_opcode_lengths[DW_LNS_negate_stmt] = 0<br>standard_opcode_lengths[DW_LNS_set_basic_block] = 0<br>standard_opcode_lengths[DW_LNS_const_add_pc] = 0<br>standard_opcode_lengths[DW_LNS_fixed_advance_pc] = 1<br>standard_opcode_lengths[DW_LNS_set_prologue_end] = 0<br>standard_opcode_lengths[DW_LNS_set_epilogue_begin] = 0<br>standard_opcode_lengths[DW_LNS_set_isa] = 1<br>include_directories[  1] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include”<br>include_directories[  2] = “/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/11.0.3/include”<br>include_directories[  3] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/sys”<br>include_directories[  4] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/mach”<br>include_directories[  5] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/libkern”<br>include_directories[  6] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/architecture”<br>include_directories[  7] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/sys/_types”<br>include_directories[  8] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/_types”<br>include_directories[  9] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/arm”<br>include_directories[ 10] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/sys/_pthread”<br>include_directories[ 11] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/mach/arm”<br>include_directories[ 12] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/libkern/arm”<br>include_directories[ 13] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/uuid”<br>include_directories[ 14] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/netinet”<br>include_directories[ 15] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/netinet6”<br>include_directories[ 16] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/net”<br>include_directories[ 17] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/pthread”<br>include_directories[ 18] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/mach_debug”<br>include_directories[ 19] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/os”<br>include_directories[ 20] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/malloc”<br>include_directories[ 21] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/bsm”<br>include_directories[ 22] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/machine”<br>include_directories[ 23] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/mach/machine”<br>include_directories[ 24] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/secure”<br>include_directories[ 25] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/xlocale”<br>include_directories[ 26] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/arpa”<br>file_names[  1]:<br>           name: “fenv.h”<br>      dir_index: 1<br>       mod_time: 0x00000000<br>         length: 0x00000000<br>file_names[  2]:<br>           name: “stdatomic.h”<br>      dir_index: 2<br>       mod_time: 0x00000000<br>         length: 0x00000000<br>file_names[  3]:<br>           name: “wait.h”<br>      dir_index: 3<br>       mod_time: 0x00000000<br>         length: 0x00000000<br>// ……<br>Address            Line   Column File   ISA Discriminator Flags</p>
<hr>
<p>0x000000010000b588     14      0      2   0             0  is_stmt<br>0x000000010000b5b4     16      5      2   0             0  is_stmt prologue_end<br>0x000000010000b5d0     17     11      2   0             0  is_stmt<br>0x000000010000b5d4      0      0      2   0             0<br>0x000000010000b5d8     17      5      2   0             0<br>0x000000010000b5dc     17     11      2   0             0<br>0x000000010000b5e8     18      1      2   0             0  is_stmt<br>0x000000010000b608     20      0      2   0             0  is_stmt<br>0x000000010000b61c     22      5      2   0             0  is_stmt prologue_end<br>0x000000010000b628     23      5      2   0             0  is_stmt<br>0x000000010000b644     24      1      2   0             0  is_stmt<br>0x000000010000b650     15      0      1   0             0  is_stmt<br>0x000000010000b65c     15     41      1   0             0  is_stmt prologue_end<br>0x000000010000b66c     11      0      2   0             0  is_stmt<br>0x000000010000b680     11     17      2   0             0  is_stmt prologue_end<br>0x000000010000b6a4     11     17      2   0             0  is_stmt end_sequence<br>debug_line[0x0000def9]<br>Line table prologue:<br>    total_length: 0x0000015a<br>         version: 4<br> prologue_length: 0x000000eb<br> min_inst_length: 1<br>max_ops_per_inst: 1<br> default_is_stmt: 1<br>       line_base: -5<br>      line_range: 14<br>     opcode_base: 13<br>standard_opcode_lengths[DW_LNS_copy] = 0<br>standard_opcode_lengths[DW_LNS_advance_pc] = 1<br>standard_opcode_lengths[DW_LNS_advance_line] = 1<br>standard_opcode_lengths[DW_LNS_set_file] = 1<br>standard_opcode_lengths[DW_LNS_set_column] = 1<br>standard_opcode_lengths[DW_LNS_negate_stmt] = 0<br>standard_opcode_lengths[DW_LNS_set_basic_block] = 0<br>standard_opcode_lengths[DW_LNS_const_add_pc] = 0<br>standard_opcode_lengths[DW_LNS_fixed_advance_pc] = 1<br>standard_opcode_lengths[DW_LNS_set_prologue_end] = 0<br>standard_opcode_lengths[DW_LNS_set_epilogue_begin] = 0<br>standard_opcode_lengths[DW_LNS_set_isa] = 1<br>include_directories[  1] = “Test”<br>include_directories[  2] = “Test/NetworkAPM”<br>include_directories[  3] = “/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk/usr/include/objc”<br>file_names[  1]:<br>           name: “AppDelegate.h”<br>      dir_index: 1<br>       mod_time: 0x00000000<br>         length: 0x00000000<br>file_names[  2]:<br>           name: “JMWebResourceURLProtocol.h”<br>      dir_index: 2<br>       mod_time: 0x00000000<br>         length: 0x00000000<br>file_names[  3]:<br>           name: “AppDelegate.m”<br>      dir_index: 1<br>       mod_time: 0x00000000<br>         length: 0x00000000<br>file_names[  4]:<br>           name: “objc.h”<br>      dir_index: 3<br>       mod_time: 0x00000000<br>         length: 0x00000000<br>// ……</p>
<p>可以看到 debug_line 里包含了每个代码地址对应的行数。上面贴了 AppDelegate 的部分。</p>
<h4 id="4-3-symbols"><a href="#4-3-symbols" class="headerlink" title="4.3 symbols"></a>4.3 symbols</h4><blockquote>
<p>在链接中，我们将函数和变量统称为符合（Symbol），函数名或变量名就是符号名（Symbol Name），我们可以将符号看成是链接中的粘合剂，整个链接过程正是基于符号才能正确完成的。</p>
</blockquote>
<p>上述文字来自《程序员的自我修养》。所以符号就是函数、变量、类的统称。</p>
<p>按照类型划分，符号可以分为三类：</p>
<ul>
<li>  全局符号：目标文件外可见的符号，可以被其他目标文件所引用，或者需要其他目标文件定义</li>
<li>  局部符号：只在目标文件内可见的符号，指只在目标文件内可见的函数和变量</li>
<li>  调试符号：包括行号信息的调试符号信息，行号信息记录了函数和变量对应的文件和文件行号。</li>
</ul>
<p><strong>符号表（Symbol Table）</strong>：是内存地址与函数名、文件名、行号的映射表。每个定义的符号都有一个对应的值得，叫做符号值（Symbol Value），对于变量和函数来说，符号值就是地址，符号表组成如下</p>
<p>&lt;起始地址&gt; &lt;结束地址&gt; &lt;函数&gt; [&lt;文件名：行号&gt;]</p>
<h4 id="4-4-如何获取地址？"><a href="#4-4-如何获取地址？" class="headerlink" title="4.4 如何获取地址？"></a>4.4 <strong>如何获取地址？</strong></h4><p>image 加载的时候会进行相对基地址进行重定位，并且每次加载的基地址都不一样，函数栈 frame 的地址是重定位后的绝对地址，我们要的是重定位前的相对地址。</p>
<p>Binary Images</p>
<p>拿测试工程的 crash 日志举例子，打开贴部分 Binary Images 内容</p>
<p>// …<br>Binary Images:<br>0x102fe0000 - 0x102ff3fff Test arm64  &lt;37eaa57df2523d95969e47a9a1d69ce5&gt; /var/containers/Bundle/Application/643F0DFE-A710-4136-A278-A89D780B7208/Test.app/Test<br>0x1030e0000 - 0x1030ebfff libobjc-trampolines.dylib arm64  &lt;181f3aa866d93165ac54344385ac6e1d&gt; /usr/lib/libobjc-trampolines.dylib<br>0x103204000 - 0x103267fff dyld arm64  &lt;6f1c86b640a3352a8529bca213946dd5&gt; /usr/lib/dyld<br>0x189a78000 - 0x189a8efff libsystem_trace.dylib arm64  <b7477df8f6ab3b2b9275ad23c6cc0b75> /usr/lib/system/libsystem_trace.dylib<br>// …</p>
<p>可以看到 Crash 日志的 Binary Images 包含每个 Image 的加载开始地址、结束地址、image 名称、arm 架构、uuid、image 路径。</p>
<p>crash 日志中的信息</p>
<p>Last Exception Backtrace:<br>// …<br>5   Test                              0x102fe592c -[ViewController testMonitorCrash] + 22828 (ViewController.mm:58)</p>
<p>Binary Images:<br>0x102fe0000 - 0x102ff3fff Test arm64  &lt;37eaa57df2523d95969e47a9a1d69ce5&gt; /var/containers/Bundle/Application/643F0DFE-A710-4136-A278-A89D780B7208/Test.app/Test</p>
<p>所以 frame 5 的相对地址为 <code>0x102fe592c - 0x102fe0000</code> 。再使用 命令可以还原符号信息。</p>
<p>使用 atos 来解析，<code>0x102fe0000</code> 为 image 加载的开始地址，<code>0x102fe592c</code> 为 frame 需要还原的地址。</p>
<p>atos -o Test.app.DSYM/Contents/Resources/DWARF/Test-arch arm64 -l 0x102fe0000 0x102fe592c</p>
<h4 id="4-5-UUID"><a href="#4-5-UUID" class="headerlink" title="4.5 UUID"></a>4.5 UUID</h4><ul>
<li><p>crash 文件的 UUID</p>
<p>  grep –after-context=2 “Binary Images:” *.crash</p>
</li>
</ul>
<p>Test  5-28-20, 7-47 PM.crash:Binary Images:<br>Test  5-28-20, 7-47 PM.crash-0x102fe0000 - 0x102ff3fff Test arm64  &lt;37eaa57df2523d95969e47a9a1d69ce5&gt; /var/containers/Bundle/Application/643F0DFE-A710-4136-A278-A89D780B7208/Test.app/Test<br>Test  5-28-20, 7-47 PM.crash-0x1030e0000 - 0x1030ebfff libobjc-trampolines.dylib arm64  &lt;181f3aa866d93165ac54344385ac6e1d&gt; /usr/lib/libobjc-trampolines.dylib<br>–<br>Test.crash:Binary Images:<br>Test.crash-0x102fe0000 - 0x102ff3fff Test arm64  &lt;37eaa57df2523d95969e47a9a1d69ce5&gt; /var/containers/Bundle/Application/643F0DFE-A710-4136-A278-A89D780B7208/Test.app/Test<br>Test.crash-0x1030e0000 - 0x1030ebfff libobjc-trampolines.dylib arm64  &lt;181f3aa866d93165ac54344385ac6e1d&gt; /usr/lib/libobjc-trampolines.dylib</p>
<p>Test App 的 UUID 为 <code>37eaa57df2523d95969e47a9a1d69ce5</code>.</p>
<ul>
<li><p>.DSYM 文件的 UUID</p>
<p>  dwarfdump –uuid Test.app.DSYM</p>
</li>
</ul>
<p>结果为</p>
<p>UUID: 37EAA57D-F252-3D95-969E-47A9A1D69CE5 (arm64) Test.app.DSYM/Contents/Resources/DWARF/Test</p>
<ul>
<li><p>app 的 UUID</p>
<p>  dwarfdump –uuid Test.app/Test</p>
</li>
</ul>
<p>结果为</p>
<p>UUID: 37EAA57D-F252-3D95-969E-47A9A1D69CE5 (arm64) Test.app/Test</p>
<h4 id="4-6-符号化（解析-Crash-日志）"><a href="#4-6-符号化（解析-Crash-日志）" class="headerlink" title="4.6 符号化（解析 Crash 日志）"></a>4.6 符号化（解析 Crash 日志）</h4><p>上述篇幅分析了如何捕获各种类型的 crash，App 在用户手中我们通过技术手段可以获取 crash 案发现场信息并结合一定的机制去上报，但是这种堆栈是十六进制的地址，无法定位问题，所以需要做符号化处理。</p>
<p>上面也说明了<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000040277799#DSYM">.DSYM 文件</a> 的作用，<strong>通过符号地址结合 DSYM 文件来还原文件名、所在行、函数名，这个过程叫符号化</strong>。但是 .DSYM 文件必须和 crash log 文件的 bundle id、version 严格对应。</p>
<p>获取 Crash 日志可以通过 Xcode -&gt; Window -&gt; Devices and Simulators 选择对应设备，找到 Crash 日志文件，根据时间和 App 名称定位。</p>
<p>app 和 .DSYM 文件可以通过打包的产物得到，路径为 <code>~/Library/Developer/Xcode/Archives</code>。</p>
<p>解析方法一般有2种：</p>
<ul>
<li><p>使用 <strong>symbolicatecrash</strong></p>
<p>  symbolicatecrash 是 Xcode 自带的 crash 日志分析工具，先确定所在路径，在终端执行下面的命令</p>
<p>  find /Applications/Xcode.app -name symbolicatecrash -type f</p>
</li>
</ul>
<p>会返回几个路径，找到 <code>iPhoneSimulator.platform</code> 所在那一行</p>
<p>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/Library/PrivateFrameworks/DVTFoundation.framework/symbolicatecrash</p>
<p>将 symbolicatecrash 拷贝到指定文件夹下（保存了 app、DSYM、crash 文件的文件夹）</p>
<p>执行命令</p>
<p>./symbolicatecrash Test.crash Test.DSYM &gt; Test.crash</p>
<p>第一次做这事儿应该会报错 <code>Error: &quot;DEVELOPER_DIR&quot; is not defined at ./symbolicatecrash line 69.</code>，解决方案：在终端执行下面命令</p>
<p>export DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer</p>
<ul>
<li><p>使用 atos</p>
<p>  区别于 symbolicatecrash，atos 较为灵活，只要 <code>.crash</code> 和 <code>.DSYM</code> 或者 <code>.crash</code> 和 <code>.app</code> 文件对应即可。</p>
<p>  用法如下，-l 最后跟得是符号地址</p>
<p>  xcrun atos -o Test.app.DSYM/Contents/Resources/DWARF/Test -arch armv7 -l 0x1023c592c</p>
</li>
</ul>
<p>也可以解析 .app 文件（不存在 .DSYM 文件），其中xxx为段地址，xx为偏移地址</p>
<p>atos -arch architecture -o binary -l xxx xx</p>
<p>因为我们的 App 可能有很多，每个 App 在用户手中可能是不同的版本，所以在 APM 拦截之后需要符号化的时候需要将 crash 文件和 <code>.DSYM</code> 文件一一对应，才能正确符号化，对应的原则就是 <strong>UUID</strong> 一致。</p>
<h4 id="4-7-系统库符号化解析"><a href="#4-7-系统库符号化解析" class="headerlink" title="4.7 系统库符号化解析"></a>4.7 系统库符号化解析</h4><p>我们每次真机连接 Xcode 运行程序，会提示等待，其实系统为了堆栈解析，都会把当前版本的系统符号库自动导入到 <code>/Users/你自己的用户名/Library/Developer/Xcode/iOS DeviceSupport</code> 目录下安装了一大堆系统库的符号化文件。你可以访问下面目录看看</p>
<p>/Users/你自己的用户名/Library/Developer/Xcode/iOS DeviceSupport/</p>
<p><img src="https://segmentfault.com/img/bVbIOlY"></p>
<h3 id="5-服务端处理"><a href="#5-服务端处理" class="headerlink" title="5. 服务端处理"></a>5. 服务端处理</h3><h5 id="5-1-ELK-日志系统"><a href="#5-1-ELK-日志系统" class="headerlink" title="5.1 ELK 日志系统"></a>5.1 ELK 日志系统</h5><p>业界设计日志监控系统一般会采用基于 ELK 技术。ELK 是 Elasticsearch、Logstash、Kibana 三个开源框架缩写。Elasticsearch 是一个分布式、通过 Restful 方式进行交互的近实时搜索的平台框架。Logstash 是一个中央数据流引擎，用于从不同目标（文件/数据存储/MQ）收集不同格式的数据，经过过滤后支持输出到不同目的地（文件/MQ/Redis/ElasticsSearch/Kafka）。Kibana 可以将 Elasticserarch 的数据通过友好的页面展示出来，提供可视化分析功能。所以 ELK 可以搭建一个高效、企业级的日志分析系统。</p>
<p>早期单体应用时代，几乎应用的所有功能都在一台机器上运行，出了问题，运维人员打开终端输入命令直接查看系统日志，进而定位问题、解决问题。随着系统的功能越来越复杂，用户体量越来越大，单体应用几乎很难满足需求，所以技术架构迭代了，通过水平拓展来支持庞大的用户量，将单体应用进行拆分为多个应用，每个应用采用集群方式部署，负载均衡控制调度，假如某个子模块发生问题，去找这台服务器上终端找日志分析吗？显然台落后，所以日志管理平台便应运而生。通过 Logstash 去收集分析每台服务器的日志文件，然后按照定义的正则模版过滤后传输到 Kafka 或 Redis，然后由另一个 Logstash 从 Kafka 或 Redis 上读取日志存储到 ES 中创建索引，最后通过 Kibana 进行可视化分析。此外可以将收集到的数据进行数据分析，做更进一步的维护和决策。</p>
<p><img src="https://segmentfault.com/img/bVbIOma"></p>
<p>上图展示了一个 ELK 的日志架构图。简单说明下：</p>
<ul>
<li>  Logstash 和 ES 之前存在一个 Kafka 层，因为 Logstash 是架设在数据资源服务器上，将收集到的数据进行实时过滤，过滤需要消耗时间和内存，所以存在 Kafka，起到了数据缓冲存储作用，因为 Kafka 具备非常出色的读写性能。</li>
<li>  再一步就是 Logstash 从 Kafka 里面进行读取数据，将数据过滤、处理，将结果传输到 ES</li>
<li>  这个设计不但性能好、耦合低，还具备可拓展性。比如可以从 n 个不同的 Logstash 上读取传输到 n 个 Kafka 上，再由 n 个 Logstash 过滤处理。日志来源可以是 m 个，比如 App 日志、Tomcat 日志、Nginx 日志等等</li>
</ul>
<p>下图贴一个 Elasticsearch 社区分享的一个 “Elastic APM 动手实战”<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=GlmdPehBhmCplzSNC0/ymQ==.C5++ytucOFOBjcXb+QzqtRBG55cXLxvwvo82vEIrH1aL4Zm4o/dwEaHgQ0LAE6VM">主题</a>的内容截图。</p>
<p><img src="https://segmentfault.com/img/bVbIOmc"></p>
<h5 id="5-2-服务侧"><a href="#5-2-服务侧" class="headerlink" title="5.2 服务侧"></a>5.2 服务侧</h5><p>Crash log 统一入库 Kibana 时是没有符号化的，所以需要符号化处理，以方便定位问题、crash 产生报表和后续处理。</p>
<p><img src="https://segmentfault.com/img/bVbIOmh"></p>
<p>所以整个流程就是：客户端 APM SDK 收集 crash log -&gt; Kafka 存储 -&gt; Mac 机执行定时任务符号化 -&gt; 数据回传 Kafka -&gt; 产品侧（显示端）对数据进行分类、报表、报警等操作。</p>
<p>因为公司的产品线有多条，相应的 App 有多个，用户使用的 App 版本也各不相同，所以 crash 日志分析必须要有正确的 .DSYM 文件，那么多 App 的不同版本，自动化就变得非常重要了。</p>
<p>自动化有2种手段，规模小一点的公司或者图省事，可以在 Xcode中 添加 runScript 脚本代码来自动在 release 模式下上传DSYM）。</p>
<p>因为我们大前端有一套体系，可以同时管理 iOS SDK、iOS App、Android SDK、Android App、Node、React、React Native 工程项目的初始化、依赖管理、构建（持续集成、Unit Test、Lint、统跳检测）、测试、打包、部署、动态能力（热更新、统跳路由下发）等能力于一身。可以基于各个阶段做能力的插入，所以可以在打包系统中，当调用打包后在打包机上传 <code>.DSYM</code> 文件到七牛云存储（规则可以是以 AppName + Version 为 key，value 为 .DSYM 文件）。</p>
<p>现在很多架构设计都是微服务，至于为什么选微服务，不在本文范畴。所以 crash 日志的符号化被设计为一个微服务。架构图如下</p>
<p><img src="https://segmentfault.com/img/bVcKBTl"><br>说明：</p>
<ul>
<li>  Symbolication Service 作为整个监控系统的一个组成部分，是专注于 crash report 符号化的微服务。</li>
<li>  接收来自任务调度框架的包含预处理过的 crash report 和 DSYM index 的请求，从七牛拉取对应的 DSYM，对 crash report 做符号化解析，计算 hash，并将 hash 响应给「数据处理和任务调度框架」。</li>
<li>  接收来自 APM 管理系统的包含原始 crash report 和 DSYM index 的请求，从七牛拉取对应的 DSYM，对crash report 做符号化解析，并将符号化的 crash report 响应给 APM 管理系统。</li>
<li>  脚手架 cli 有个能力就是调用打包系统的打包构建能力，会根据项目的特点，选择合适的打包机（打包平台是维护了多个打包任务，不同任务根据特点被派发到不同的打包机上，任务详情页可以看到依赖的下载、编译、运行过程等，打包好的产物包括二进制包、下载二维码等等）</li>
</ul>
<p>其中符号化服务是大前端背景下大前端团队的产物，所以是 NodeJS 实现的（单线程，所以为了提高机器利用率，就要开启多进程能力）。iOS 的符号化机器是 双核的 Mac mini，这就需要做实验测评到底需要开启几个 worker 进程做符号化服务。结果是双进程处理 crash log，比单进程效率高近一倍，而四进程比双进程效率提升不明显，符合双核 mac mini 的特点。所以开启两个 worker 进程做符号化处理。</p>
<p>下图是完整设计图</p>
<p><img src="https://segmentfault.com/img/bVcKBTm"></p>
<p>简单说明下，符号化流程是一个主从模式，一台 master 机，多个 slave 机，master 机读取 .DSYM 和 crash 结果的 cache。「数据处理和任务调度框架」调度符号化服务（内部2个 symbolocate worker）同时从七牛云上获取 .DSYM 文件。</p>
<p>系统架构图如下<br><img src="https://segmentfault.com/img/bVbIOmt"></p>
<h2 id="八、-APM-小结"><a href="#八、-APM-小结" class="headerlink" title="八、 APM 小结"></a>八、 APM 小结</h2><ol>
<li><p> 通常来说各个端的监控能力是不太一致的，技术实现细节也不统一。所以在技术方案评审的时候需要将监控能力对齐统一。每个能力在各个端的数据字段必须对齐（字段个数、名称、数据类型和精度），因为 APM 本身是一个闭环，监控了之后需符号化解析、数据整理，进行产品化开发、最后需要监控大盘展示等</p>
</li>
<li><p> 一些 crash 或者 ANR 等根据等级需要邮件、短信、企业内容通信工具告知干系人，之后快速发布版本、hot fix 等。</p>
</li>
<li><p> 监控的各个能力需要做成可配置，灵活开启关闭。</p>
</li>
<li><p> 监控数据需要做内存到文件的写入处理，需要注意策略。监控数据需要存储数据库，数据库大小、设计规则等。存入数据库后如何上报，上报机制等会在另一篇文章讲：<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=tHMPJBwKBqGAnYO7hYcQqg==./eOLWZKsqJHhNAhfSn2gbQ2a7WVL9mUUlYeQsXYOSjBISZB2NR17mPajVWwk5TDY5Dn4xXC6MPLu/eK8jzZhnSvMtXciC76PEuTuT2+PpAAYT5v/pm2vmYaTDoGykKi6">打造一个通用、可配置的数据上报 SDK</a></p>
</li>
<li><p>尽量在技术评审后，将各端的技术实现写进文档中，同步给相关人员。比如 ANR 的实现</p>
<p> /*<br> android 端</p>
<p> 根据设备分级，一般超过 300ms 视为一次卡顿<br> hook 系统 loop，在消息处理前后插桩，用以计算每条消息的时长<br> 开启另外线程 dump 堆栈，处理结束后关闭<br> */<br> new ExceptionProcessor().init(this, new Runnable() {</p>
<pre><code>         @Override
         public void run() &#123;
             //监测卡顿
             try &#123;
                 ProxyPrinter proxyPrinter = new ProxyPrinter(PerformanceMonitor.this);
                 Looper.getMainLooper().setMessageLogging(proxyPrinter);
                 mWeakPrinter = new WeakReference&lt;ProxyPrinter&gt;(proxyPrinter);
             &#125; catch (FileNotFoundException e) &#123;
             &#125;
         &#125;
     &#125;)</code></pre>
<p> /*<br> iOS 端</p>
<p> 子线程通过 ping 主线程来确认主线程当前是否卡顿。<br> 卡顿阈值设置为 300ms，超过阈值时认为卡顿。<br> 卡顿时获取主线程的堆栈，并存储上传。<br> */ </p>
<ul>
<li>(void) main() {<br>  while (self.cancle == NO) {<pre><code>  self.isMainThreadBlocked = YES;
  dispatch\_async(dispatch\_get\_main\_queue(), ^&#123;
      self.isMainThreadBlocked = YES;
      \[self.semaphore singal\];
  &#125;);
  \[Thread sleep:300\];
  if (self.isMainThreadBlocked) &#123;
      \[self handleMainThreadBlock\];
  &#125;
  \[self.semaphore wait\];</code></pre>
  }<br>}</li>
</ul>
</li>
<li><p>整个 APM 的架构图如下</p>
<p> <img src="https://segmentfault.com/img/bVbIOnN"></p>
<p> 说明：</p>
<ul>
<li>  埋点 SDK，通过 sessionId 来关联日志数据</li>
</ul>
</li>
<li><p> APM 技术方案本身是随着技术手段、分析需求不断调整升级的。上图的几个结构示意图是早期几个版本的，目前使用的是在此基础上进行了升级和结构调整，提几个关键词：Hermes、Flink SQL、InfluxDB。</p>
</li>
</ol>
</blockquote>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。也可以邮件至 1209453173@qq.com </span>
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    Copyright©2016-至今   张天师
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 572px;
    }
    .nav.fullscreen {
        margin-left: -572px;
    }
    .nav-left {
        width: 150px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 542px;
        }
        .nav.fullscreen {
            margin-left: -542px;
        }
        .nav-left {
            width: 150px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 542px;
            margin-left: -542px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
